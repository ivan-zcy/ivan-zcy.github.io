<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模拟链表</title>
      <link href="/2019/01/30/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/01/30/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/30/模拟链表/title.jpg" alt="title"></p><a id="more"></a><p>​    主要是用C++实现了链表的增删改查以及反转、遍历等功能，具体实现请看代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OK 1</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt; class Point &#123;</span><br><span class="line">public:</span><br><span class="line">    Type data;</span><br><span class="line">    Point&lt;Type&gt; *next;</span><br><span class="line">    Point() &#123;</span><br><span class="line">        this -&gt; next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(Type data) &#123;</span><br><span class="line">        this -&gt; data = data;</span><br><span class="line">        this -&gt; next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt; class Train &#123;</span><br><span class="line">private:</span><br><span class="line">    Point&lt;Type&gt; *head;</span><br><span class="line">    int len;</span><br><span class="line">public:</span><br><span class="line">    Train() &#123;</span><br><span class="line">        head = NULL;</span><br><span class="line">        len = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Train() &#123;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            Point&lt;Type&gt; *old = p;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            free(old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void set(int len) &#123;</span><br><span class="line">        this -&gt; len = len;</span><br><span class="line">    &#125;</span><br><span class="line">    int get() &#123;</span><br><span class="line">        return this -&gt; len;</span><br><span class="line">    &#125;</span><br><span class="line">    bool insert(Point&lt;Type&gt; *t, int inx) &#123;</span><br><span class="line">        if (inx &lt; 0 || inx &gt; this -&gt; len) &#123;</span><br><span class="line">            return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            this -&gt; len ++;</span><br><span class="line">            this -&gt; head = t;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">        if (inx == 0) &#123;</span><br><span class="line">            t -&gt; next = this -&gt; head;</span><br><span class="line">            this -&gt; head = t;</span><br><span class="line">            this -&gt; len ++;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        while(tot &lt; inx - 1) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        t -&gt; next = p -&gt; next;</span><br><span class="line">        p -&gt; next = t;</span><br><span class="line">        this -&gt; len ++;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    int query(Type val) &#123;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            if (p -&gt; data == val) &#123;</span><br><span class="line">                return tot;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    void output() &#123;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            cout &lt;&lt; tot++ &lt;&lt; &quot;:&quot; &lt;&lt; p -&gt; data &lt;&lt; &quot; &quot;;</span><br><span class="line">            p = p -&gt; next; </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bool del(int inx) &#123;</span><br><span class="line">        if (inx &lt; 0 || inx &gt;= this -&gt; len) &#123;</span><br><span class="line">            return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        if (inx == 0) &#123;</span><br><span class="line">            this -&gt; head = this -&gt; head -&gt; next;</span><br><span class="line">            free(p);</span><br><span class="line">            this -&gt; len --;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">        while(tot &lt; inx - 1) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *del = p -&gt; next;</span><br><span class="line">        p -&gt; next = del -&gt; next;</span><br><span class="line">        free(del);</span><br><span class="line">        this -&gt; len --;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    void reverse() &#123;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = head -&gt; next;</span><br><span class="line">        head -&gt; next = NULL;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            Point&lt;Type&gt; *p2 = p -&gt; next;</span><br><span class="line">            p -&gt; next = head;</span><br><span class="line">            head = p;</span><br><span class="line">            p = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Train&lt;int&gt; trian;</span><br><span class="line">    int m, a, b, t;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        switch (t) &#123;</span><br><span class="line">            case 1: &#123;</span><br><span class="line">                cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">                Point &lt;int&gt; *p = (Point &lt;int&gt; *)malloc(sizeof(Point &lt;int&gt;));</span><br><span class="line">                p -&gt; data = b;</span><br><span class="line">                p -&gt; next = NULL;</span><br><span class="line">                if(trian.insert(p, a)) &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 2: &#123;</span><br><span class="line">                trian.output();</span><br><span class="line">                break;</span><br><span class="line">            &#125;  </span><br><span class="line">            case 3:&#123;</span><br><span class="line">                cin &gt;&gt; a;</span><br><span class="line">                if (trian.del(a)) &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 4:&#123;</span><br><span class="line">                cin &gt;&gt; a;</span><br><span class="line">                int inx = trian.query(a);</span><br><span class="line">                if (inx != -1) &#123;</span><br><span class="line">                    cout &lt;&lt; inx &lt;&lt; endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">                trian.reverse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟动态数组</title>
      <link href="/2019/01/30/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2019/01/30/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/30/模拟动态数组/title.jpg" alt="title"></p><a id="more"></a><p>​    大概就是用数组模拟动态数组吧，功能包括插入，查询，删除，遍历。可以进行初始化，动态扩容，以及最后释放掉内存</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OK 1</span><br><span class="line"></span><br><span class="line">typedef struct Vector &#123;</span><br><span class="line">int len, size;</span><br><span class="line">    int *q;</span><br><span class="line">&#125; Vector;</span><br><span class="line"></span><br><span class="line">void init(Vector *a, int size) &#123;</span><br><span class="line">a -&gt; q = (int *)malloc(sizeof(int) * size);</span><br><span class="line">    a -&gt; len = 0;</span><br><span class="line">    a -&gt; size = size;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void expand(Vector *a) &#123;</span><br><span class="line">a -&gt; size *= 2;</span><br><span class="line">    int *old = a -&gt; q;</span><br><span class="line">    a -&gt; q = (int *)malloc(sizeof(int) * a -&gt; size);</span><br><span class="line">    for (int i = 0; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        a -&gt; q[i] = old[i];</span><br><span class="line">    &#125;</span><br><span class="line">    free(old);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int insert(Vector *a, int inx, int val) &#123;</span><br><span class="line">if (inx &lt; 0 || inx &gt; a -&gt; len) return ERROR;</span><br><span class="line">    if (a -&gt; len &gt;= a -&gt; size) &#123;</span><br><span class="line">        expand(a);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = a -&gt; len; i &gt; inx; i--) &#123;</span><br><span class="line">        a -&gt; q[i] = a -&gt; q[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    a -&gt; q[inx] = val;</span><br><span class="line">    a -&gt; len++;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int search(Vector *a, int val) &#123;</span><br><span class="line">for (int i = 0; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        if(a -&gt; q[i] == val) return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete_node(Vector *a, int inx) &#123;</span><br><span class="line">if (inx &lt; 0 || inx &gt;= a -&gt; len) return ERROR;</span><br><span class="line">    for (int i = inx + 1; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        a -&gt; q[i - 1] = a -&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a -&gt; len--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Vector *a) &#123;</span><br><span class="line">for (int i = 0; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, a -&gt; q[i], i == a -&gt; len - 1? &apos;\n&apos;: &apos; &apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear(Vector *a) &#123;</span><br><span class="line">free(a -&gt; q);</span><br><span class="line">    free(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Vector *a = (Vector *)malloc(sizeof(Vector));</span><br><span class="line">    init(a, 20);</span><br><span class="line">int m, t, p, q;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">        switch (t) &#123;</span><br><span class="line">            case 1: </span><br><span class="line">                scanf(&quot;%d%d&quot;, &amp;p, &amp;q);</span><br><span class="line">                if (insert(a, p, q)) &#123;</span><br><span class="line">                    printf(&quot;success\n&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    printf(&quot;failed\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">                if(delete_node(a, p)) &#123;</span><br><span class="line">                    printf(&quot;success\n&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    printf(&quot;failed\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">                if(search(a, p)) &#123;</span><br><span class="line">                    printf(&quot;success\n&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    printf(&quot;failed\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                print(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷3994高速公路</title>
      <link href="/2019/01/29/%E6%B4%9B%E8%B0%B73994%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/"/>
      <url>/2019/01/29/%E6%B4%9B%E8%B0%B73994%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/29/洛谷3994高速公路/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>C国拥有一张四通八达的高速公路<del>网</del>树，其中有n个城市，城市之间由一共n-1条高速公路连接。除了首都1号城市，每个城市都有一家本地的客运公司，可以发车前往全国各地，有若干条高速公路连向其他城市，这是一个树型结构，1号城市（首都）为根。假设有一个人要从i号城市坐车出发前往j号城市，那么他要花费Pi*（i城市到j城市的距离）+Qi元。由于距离首都越远，国家的监管就越松，所以距离首都越远，客运公司的Pi（单位距离价格）越大，形式化的说，如果把高速路网看成一棵以首都为根的有根树，i号城市是j号城市的某个祖先，那么一定存在Pi&lt;=Pj。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>大宁成为了国家统计局的调查人员，他需要对现在的高速路网进行一次调查，了解从其他每一个城市到达首都1号城市所花费的金钱(路径必须是简单路径)。</p><p>因为有非常多转车（或不转车）的抵达首都的方法，所以人工计算这个结果是十分复杂的。大宁非常的懒，所以请你编写一个程序解决它。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第 1 行包含1个非负整数 n,表示城市的个数。</p><p>第 2 到 n 行，每行描述一个<strong>除首都之外</strong>的城市。其中第 i 行包含4 个非负整数 Fi,Si,Pi,Qi，分别表示 i号城市的父亲城市，它到父亲城市高速公路的长度，以及乘车价格的两个参数。</p><p>输出格式：</p><p>输出包含 n-1 行，每行包含一个整数。</p><p>其中第 i 行表示从 i+1号城市 出发，到达首都最少的乘车费用。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 9 3 0</span><br><span class="line">1 17 1 9</span><br><span class="line">1 1 1 6</span><br><span class="line">4 13 2 15</span><br><span class="line">4 9 2 4</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27</span><br><span class="line">26</span><br><span class="line">7</span><br><span class="line">43</span><br><span class="line">24</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于前40%的数据1&lt;=n&lt;=1000。</p><p>对于另外20%的数据 满足从第i（i≠1）个城市出发的高速公路连向第i-1个城市。</p><p>对于所有的数据1&lt;=n&lt;=1000000，0&lt;=Pi，Qi&lt;=2^31-1，保证结果不会大于2^63-1。</p><p>思路：</p><p>​    这道题我们可以设<code>S[i]</code>代表首都到i城市的距离， <code>dp[i]</code>代表第i个城市到首都最少乘车费用，那么我们可以得到递推式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + P[i] * (S[i] - S[j]) + Q[i]) (0 &lt;= j &lt; i)</span><br></pre></td></tr></table></figure><p>​    上面这个式子的时间复杂度为O(n ^ 2)，由于n的范围为1e6，因此我们必须优化为O(n)的做法，我们发现，该式符合斜率优化的特征：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j]为变量，P[i] * S[i]和Q[i]为不变量，而P[i]*S[j]为混合量</span><br></pre></td></tr></table></figure><p>​    我们开始将混合量去掉：</p><p>第一步：由于该题所有城市组成一棵树，1号首都为根结点。我们设j 为 k的子节点（不一定是直接子节点）且对于求<code>dp[i]</code>，j比k优，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] + P[i] * (S[i] - S[j]) + Q[i] &lt; dp[k] + P[i] * (S[i] - S[k]) + Q[i]</span><br><span class="line">dp[j] - P[i] * S[j] &lt; dp[k] - P[i] * S[k]</span><br><span class="line">(dp[j] - dp[k]) / (S[j] - S[k]) &lt; P[i]</span><br></pre></td></tr></table></figure><p>​    其中<code>(dp[j] - dp[k]) / (S[j] - S[k])</code>就为求解的斜率</p><p>第二步</p><p>​    设P(p, q)为点p和点q之间的斜率，那么假设j, p, q都是i的祖宗节点且q是j的祖宗节点，p是q的祖宗节点且P(p, q) &gt; P(q, j)。我们讨论所有的情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) P[i] &lt; P(q, j) &lt; P(p, q)</span><br><span class="line">此时，q优于j，p优于q，因此p是最优解</span><br><span class="line">(2) P(q, j) &lt; P[i] &lt; P(p, q)</span><br><span class="line">此时，j优于q，p优于q，因此j,p中的一个是最优解</span><br><span class="line">(3) P(q, j) &lt; P(p, q) &lt; P[i]</span><br><span class="line">此时，j优于q，q优于p，因此j是最优解</span><br></pre></td></tr></table></figure><p> 我们会发现，在满足该种的情况下，无论如何，q都不是最优解，也就是中间的那个永远不是最优，因此，我们可以用单调队列来维护斜率上升的队列来O(1)的求解<code>dp[i]</code></p><p>第三步：</p><p>​    因为这是一个树，在遍历树的时候，遍历完子节点回溯到父节点的时候需要对队列进行还原，我们发现手动模拟的队列数组q虽然tail，head改变，但是存储的内容只有一个位置发生改变，其余改变的只有head和tail，数组中的东西依旧保存。因此我们只需要维护每次的head，tail和改变的那个值即可，详细请看代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int num=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">inline ll readl() &#123;</span><br><span class="line">    ll num=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int inx;</span><br><span class="line">ll val;</span><br><span class="line">void set(int ninx, ll nval) &#123;</span><br><span class="line">inx = ninx;</span><br><span class="line">val = nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll P[1000005] = &#123;0&#125;, Q[1000005] = &#123;0&#125;, dp[1000005] = &#123;0&#125;, s[1000005] = &#123;0&#125;;</span><br><span class="line">vector&lt;node&gt; v[1000005];</span><br><span class="line">int q[1000005];</span><br><span class="line"></span><br><span class="line">void set(int j, int i) &#123;</span><br><span class="line">dp[i] = dp[j] + P[i] * (s[i] - s[j]) + Q[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getp(int j, int i) &#123;</span><br><span class="line">return 1.0 * (dp[i] - dp[j]) / (s[i] - s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int tail, int head) &#123;</span><br><span class="line">while (head + 2 &lt;= tail &amp;&amp; getp(q[head], q[head + 1]) &lt;= P[inx]) head++;</span><br><span class="line">set(q[head], inx);</span><br><span class="line">while (head + 2 &lt;= tail &amp;&amp; getp(q[tail - 1], inx) &lt;= getp(q[tail - 2], q[tail - 1])) tail--;</span><br><span class="line">int flag = q[tail];</span><br><span class="line">q[tail++] = inx;</span><br><span class="line">for (int i = 0; i &lt; v[inx].size(); i++) &#123;</span><br><span class="line">node t = v[inx][i];</span><br><span class="line">s[t.inx] = s[inx] + t.val;</span><br><span class="line">dfs(t.inx, tail, head);</span><br><span class="line">&#125;</span><br><span class="line">q[tail - 1] = flag;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n, father;</span><br><span class="line">ll x;</span><br><span class="line">node t;</span><br><span class="line">n = read();</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">father = read();</span><br><span class="line">x = readl();</span><br><span class="line">P[i] = readl();</span><br><span class="line">Q[i] = readl();</span><br><span class="line">t.set(i, x);</span><br><span class="line">v[father].push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">q[1] = 1;</span><br><span class="line">dfs(1, 1, 1);</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
            <tag> 斜率优化 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-7</title>
      <link href="/2019/01/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-7/"/>
      <url>/2019/01/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/28/动态规划优化问题-7/title4.jpg" alt="title4"></p><a id="more"></a><p>之前系列讲了动态规划优化的去除冗余状态，重新定义状态，或者单调栈或单调队列优化等关于动态规划的优化问题。</p><p>接下来讲的就比较难了，属于动态规划的斜率优化问题</p><p>具体我们用例题来详细说明</p><p>例题：古老的打印机</p><p>有一台古老的打字机和一篇待打印的文章，文章中有 n 个字符，每个字符会有一个消耗值 Ci, 打字机工作一次会打印若干连续的 k 个字符，同时打字机会有磨损，打字机的单次磨损计算公式为：</p><p>(∑i=1kCi)2+M</p><p>其中 M 是打字机启动一次的固定磨损值，现在给你 n 个字符的消耗值，问你打字机顺序打印出这 n 个字符的最小磨损值为多少？</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行输入两个数字，n,M(1≤n≤106,1≤M≤104) 代表文章中字符数量和打字机单次启动的固定磨损值。</p><p>第二行输入 n 个数字，第 i 个数字代表文章中第 i 个字符的磨损值 Ci(1≤Ci≤100)。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，代表打字机顺序打完 n 个字符的最小磨损值</p><hr><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 40</span><br><span class="line">3 3 6 5 1 2</span><br></pre></td></tr></table></figure><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">256</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    对于这类问题，我们设<code>s[i]</code>为前i个字符的Ci的和， <code>dp[i]</code>代表前i个字符的最小磨损值，那么我们可以得到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (s[i] - s[j])^2 + M) (0 &lt;= j &lt; i)</span><br></pre></td></tr></table></figure><p>​    由上面的递推公式可知，这样的时间复杂度为O(n^2)，而n的范围是1e6，所以肯定1s内跑不完，因此我们需要把它优化为O(n)的时间复杂度</p><p>​    我们展开上面的式子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (s[i] - s[j])^2 + M)</span><br><span class="line">  = min(dp[j] + s[i]^2 + s[j]^2 - 2 * s[i] * s[j] + M)</span><br><span class="line">我们单拿出dp[j] + s[i]^2 + s[j]^2 - 2 * s[i] * s[j] + M来看</span><br><span class="line">其中s[i]^2，M是固定值，dp[j]，s[j]^2是变化值，2 * s[i] * s[j]是两者的混合值</span><br></pre></td></tr></table></figure><p>如果只有固定值和变化值，我们可以通过一个变量维护前i的s[j]^2 + dp[j]的最大值来O(1)的求出dp[i]，可是由于混合值的出现，导致我们无法这样求出</p><p>记住一点：只要看到混合值的出现，就要想办法对其进行斜率优化！！</p><p>具体步骤是</p><p>1.假设j &gt; k且dp[j] + (s[i] - s[j])^2 + M优于dp[k] + (s[i] - s[k])^2 + M，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] + (s[i] - s[j])^2 + M &lt; dp[k] + (s[i] - s[k])^2 + M</span><br><span class="line">等价于：dp[j] + s[j]^2 - 2 * s[j] * s[i] &lt; dp[k] + s[k]^2 - 2 * s[k] * s[i]</span><br><span class="line">等价于：(dp[j] + s[j]^2) - (dp[k] + s[k]^2) &lt; 2 * s[i] * (s[j] - s[k])</span><br><span class="line">等价于：(dp[j] + s[j]^2) - (dp[k] + s[k]^2) / (s[j] - s[k]) &lt; 2 * s[i]</span><br><span class="line">我们假设f(i) = dp[i] * s[i]^2</span><br><span class="line">那么：f(j) - f(k) / (s[j] - s[k]) &lt; 2 * s[i]</span><br></pre></td></tr></table></figure><p>至于为什么叫斜率优化，当我们把s[i]看作x，f(i)看作y，那么f(j) - f(k) / (s[j] - s[k])就是斜率了</p><p>也就是说，只要满足f(j) - f(k) / (s[j] - s[k]) &lt; 2 * s[i]且j &gt; k，那么j就一定优化k</p><p>2.我们设P(x, y)代表点x，y之间的斜率，对i中的p, q, j进行分析（p &lt; q &lt; j &lt; i且P(p, q) &gt; P(q, j)），那么斜率会有三种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 2 * s[i] &lt; P(q, j) &lt; P(p, q)</span><br><span class="line">此时，q优于j，p优于q，因此p是最优解</span><br><span class="line">(2) P(q, j) &lt; 2 * s[i] &lt; P(p, q)</span><br><span class="line">此时，j优于q，p优于q，因此j,p中的一个是最优解</span><br><span class="line">(3) P(q, j) &lt; P(p, q) &lt; 2 * s[i]</span><br><span class="line">此时，j优于q，q优于p，因此j是最优解</span><br></pre></td></tr></table></figure><p>​    我们会发现，在p(p, q) &gt; p(q, j)且 p &lt; q &lt; j &lt; i的情况下，无论如何，q都不是最优解，也就是中间的那个永远不是最优，因此，我们可以用单调队列来维护斜率上升的队列来O(1)的求解<code>dp[i]</code>，具体做法见代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll sum[1000005] = &#123;0&#125;;</span><br><span class="line">ll dp[1000005] = &#123;0&#125;;</span><br><span class="line">int q[1000005] = &#123;0&#125;;</span><br><span class="line">int n, M, a, tail, head;</span><br><span class="line"></span><br><span class="line">void set(int j, int i) &#123;</span><br><span class="line">dp[i] = dp[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getp(int j, int i) &#123;</span><br><span class="line">double p1 = (dp[i] + sum[i] * sum[i]) - (dp[j] + sum[j] * sum[j]);</span><br><span class="line">double p2 = sum[i] - sum[j];</span><br><span class="line">return p1 / p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;M);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">sum[i] = sum[i - 1] + a;</span><br><span class="line">&#125;</span><br><span class="line">head = tail = 1;</span><br><span class="line">set(0, 1);</span><br><span class="line">q[tail++] = 0;</span><br><span class="line">q[tail++] = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">while(head + 2 &lt;= tail &amp;&amp; getp(q[head], q[head + 1]) &lt;= 2 * sum[i]) head++;</span><br><span class="line">set(q[head], i);</span><br><span class="line">while(head + 2 &lt;= tail &amp;&amp; getp(q[tail - 1], i) &lt;= getp(q[tail -2], q[tail - 1])) tail--;</span><br><span class="line">q[tail++] = i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[n]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海贼OJ57有趣的序列</title>
      <link href="/2019/01/27/%E6%B5%B7%E8%B4%BCOJ57%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%8F%E5%88%97/"/>
      <url>/2019/01/27/%E6%B5%B7%E8%B4%BCOJ57%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/海贼OJ57有趣的序列/title5.jpg" alt="title5"></p><a id="more"></a><h2 id="有趣的序列"><a href="#有趣的序列" class="headerlink" title="有趣的序列"></a>有趣的序列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在生成一个包含所有自然数的序列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123456789101112131415...</span><br></pre></td></tr></table></figure><p>其中 d12 是数字 1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入三个数字 x,y,z(1≤x,y,z≤1,000,000)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一个整数，代表<code>dx×dy×dz</code> 的结果</p><p>思路：</p><p>​    因为x，y，z范围是1e6，因此我们可以先预处理出<code>sum[i]</code>代表i位数共占多少位置，并预处理出<code>start[i]</code>代表i位数的起始数组</p><p>​    这样，我们传入位置后，若位置&gt;<code>sum[i]</code>，就用位置-=<code>sum[i]</code>并查找下一位，若等于<code>sum[i]</code>，就返回9（因为每位数的最后一个数字的最后一位都是9），若小于<code>sum[i]</code>，就判断是第该位的哪一个数字的哪一位，并把该数返回即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum[7] = &#123;0, 9, 180, 2700, 36000, 450000, 5400000&#125;;</span><br><span class="line">int start[7] = &#123;0, 1, 10, 100, 1000, 10000, 100000&#125;;</span><br><span class="line"></span><br><span class="line">int quick(int a, int b) &#123;</span><br><span class="line">int ans = 1;</span><br><span class="line">while(b) &#123;</span><br><span class="line">if(b &amp; 1) &#123;</span><br><span class="line">ans *= a;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a *= a;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getinx(int inx) &#123;</span><br><span class="line">for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">if (inx &gt; sum[i]) &#123;</span><br><span class="line">inx -= sum[i];</span><br><span class="line">&#125; else if (inx == sum[i]) &#123;</span><br><span class="line">return 9;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int cs = inx / i;</span><br><span class="line">int ys = inx % i;</span><br><span class="line">if (ys == 0) &#123;</span><br><span class="line">cs = cs + start[i] - 1;</span><br><span class="line">cs %= 10;</span><br><span class="line">return cs;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cs = cs + start[i];</span><br><span class="line">int ttt = quick(10, i - ys);</span><br><span class="line">int kkk = cs / ttt;</span><br><span class="line">kkk %= 10;</span><br><span class="line">return kkk;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">// for (int i = 1; i &lt;= 1000; i++) &#123;</span><br><span class="line">// printf(&quot;%d&quot;, getinx(i));</span><br><span class="line">// &#125;</span><br><span class="line">int xx = getinx(x);</span><br><span class="line">int yy = getinx(y);</span><br><span class="line">int zz = getinx(z);</span><br><span class="line">printf(&quot;%d\n&quot;, xx * yy * zz);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1757通天之分组背包</title>
      <link href="/2019/01/27/%E6%B4%9B%E8%B0%B71757%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/"/>
      <url>/2019/01/27/%E6%B4%9B%E8%B0%B71757%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/洛谷1757通天之分组背包/title3.jpg" alt="title3"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>直达通天路·小A历险记第二篇</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>自01背包问世之后，小A对此深感兴趣。一天，小A去远游，却发现他的背包不同于01背包，他的物品大致可分为k组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>两个数m,n，表示一共有n件物品，总重量为m</p><p>接下来n行，每行3个数ai,bi,ci，表示物品的重量，利用价值，所属组数</p><p>输出格式：</p><p>一个数，最大的利用价值</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">45 3</span><br><span class="line">10 10 1</span><br><span class="line">10 5 1</span><br><span class="line">50 400 2</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1&lt;=m&lt;=1000 1&lt;=n&lt;=1000 组数t&lt;=100</p><p>思路：</p><p>​    分组背包入门题，没啥好说的～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;zcy[1005];</span><br><span class="line">int v[1005], w[1005];</span><br><span class="line">int dp[1050] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int m, n, group;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;w[i], &amp;group);</span><br><span class="line">        zcy[group].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (!zcy[i].size()) break;</span><br><span class="line">        for (int k = m; k &gt;= 0; k--) &#123;</span><br><span class="line">            for (int j = 0; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">                int vv = v[zcy[i][j]];</span><br><span class="line">                int ww = w[zcy[i][j]];</span><br><span class="line">                if (k - vv &lt; 0) continue;</span><br><span class="line">                dp[k] = max(dp[k - vv] + ww, dp[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分组背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1064金明的预算方案</title>
      <link href="/2019/01/27/%E6%B4%9B%E8%B0%B71064%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/"/>
      <url>/2019/01/27/%E6%B4%9B%E8%B0%B71064%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/洛谷1064金明的预算方案/title6.jpg" alt="title6"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N<em>N</em>元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>主件 附件</p><p>电脑 打印机，扫描仪</p><p>书柜 图书</p><p>书桌 台灯，文具</p><p>工作椅 无</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有00个、11个或22个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N<em>N</em>元。于是，他把每件物品规定了一个重要度，分为55等：用整数1−51−5表示，第55等最重要。他还从因特网上查到了每件物品的价格（都是1010元的整数倍）。他希望在不超过N<em>N</em>元（可以等于N<em>N</em>元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第j<em>j</em>件物品的价格为v[j]<em>v</em>[<em>j</em>]，重要度为w[j]<em>w</em>[<em>j</em>]，共选中了k<em>k</em>件物品，编号依次为j1,j2,…,jk<em>j</em>1,<em>j</em>2,…,<em>j**k</em>，则所求的总和为：</p><p>v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]<em>v</em>[<em>j</em>1]×<em>w</em>[<em>j</em>1]+<em>v</em>[<em>j</em>2]×<em>w</em>[<em>j</em>2]+…+<em>v</em>[<em>j**k</em>]×<em>w</em>[<em>j**k</em>]。</p><p>请你帮助金明设计一个满足要求的购物单。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第11行，为两个正整数，用一个空格隔开：</p><p>Nm<em>N**m</em> （其中N(&lt;32000)<em>N</em>(&lt;32000)表示总钱数，m(&lt;60)<em>m</em>(&lt;60)为希望购买物品的个数。） 从第22行到第m+1<em>m</em>+1行，第j<em>j</em>行给出了编号为j−1<em>j</em>−1的物品的基本数据，每行有33个非负整数</p><p>vpq<em>v<strong>p</strong>q</em> （其中v<em>v</em>表示该物品的价格（v&lt;10000<em>v</em>&lt;10000），p表示该物品的重要度（1−51−5），q<em>q</em>表示该物品是主件还是附件。如果q=0<em>q</em>=0，表示该物品为主件，如果q&gt;0<em>q</em>&gt;0，表示该物品为附件，q<em>q</em>是所属主件的编号）</p><p>输出格式：</p><p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大（&lt;200000&lt;200000）。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure><p>解析：因为这道题每个主件可以有0， 1， 2个附件，因此有两种解决方案：</p><p>方案一：我们把有从属关系的一个或多个物品当作一类物品，若只有主件，那么共有2种组合方案（0，主件）。若有一个附件，那么有4种组合方案（0，主件，附件，主见附件），若有两个附件，那么有8种组合方案。我们只要把全部组合方案的价格，重要程度列出来，然后用分组背包的思维就可以做了。</p><p>方案二：因为附件数少，因此我们可以用求全部方案数将其转化为分组背包。若附件多怎么办呢？这时，我们可以设置<code>dp[i][j]</code>代表第i类商品总价不超过j元的最大价值（有所属关系的归位一种），然后每次copy<code>dp[i-1]</code>数组，并对主件商品强制购买，附件商品进行01背包。最后和原<code>dp[i - 1]</code>数组每位比较取较大值，即为<code>dp[i]</code>数组，最后<code>dp[商品种类][最大钱数]</code>即为答案</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;zcy[65];</span><br><span class="line">map&lt;int, int&gt;maps;</span><br><span class="line"></span><br><span class="line">int v[65], w[65];</span><br><span class="line">int dp[32050] = &#123;0&#125;, temp[32050] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int V, m, tot = 0, father;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;V, &amp;m);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;w[i], &amp;father);</span><br><span class="line">        if (father == 0) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            maps[i] = tot;</span><br><span class="line">            zcy[tot].push_back(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            zcy[maps[father]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">        memcpy(temp, dp, sizeof(int) * (V + 5));</span><br><span class="line">        int vv = v[zcy[i][0]];</span><br><span class="line">        int ww = w[zcy[i][0]] * vv;</span><br><span class="line">        for (int j = V; j &gt;= vv; j--) &#123;</span><br><span class="line">            temp[j] = temp[j - vv] + ww;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">            int vvv = v[zcy[i][j]];</span><br><span class="line">            int www = w[zcy[i][j]] * vvv;</span><br><span class="line">            for (int p = V; p &gt;= vv + vvv; p--) &#123;</span><br><span class="line">                temp[p] = max(temp[p - vvv] + www, temp[p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[V]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 特殊背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1858多人背包</title>
      <link href="/2019/01/25/%E6%B4%9B%E8%B0%B71858%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85/"/>
      <url>/2019/01/25/%E6%B4%9B%E8%B0%B71858%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/25/洛谷1858多人背包/title1.jpg" alt="title1"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求01背包前k优解的价值和</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行三个数K、V、N</p><p>接下来每行两个数，表示体积和价值</p><p>输出格式：</p><p>前k优解的价值和</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 10 5</span><br><span class="line">3 12</span><br><span class="line">7 20</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">57</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于100%的数据,K≤50,V≤5000,N≤200</p><p>思路：</p><p>​    这道题本身不算特别难，设置一个二维数组<code>dp[i][j]</code>代表背包容量为i的时候第j优解的价值。V的范围是5000，N的范围是200，如果按照01背包求最优解的话时间复杂度为1e6</p><p>​    可是由于是求第k优，k的范围为1～50，因此我们得在1e6的循环中，用O(k)的复杂度求出前k优，这时候，我们就需要用到归并排序取前50大</p><p>​    这道题太毒瘤了，条件里也没交代说必须正好装满V。。。结果最后答案必须是正好装满V的答案。。。</p><p>​    答案见代码：</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[5005][55] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int K, V, N, v, w;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;K, &amp;V, &amp;N);</span><br><span class="line">    dp[0][0] = 1;//正好装满初始化dp[0][0] = 1, 若是类似01背包可以不必装满的话，就是初始化dp[i][0] = 1 (0 &lt;= i &lt;= V)</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;v, &amp;w);</span><br><span class="line">        for (int j = V; j &gt;= v; j--) &#123;</span><br><span class="line">            int p1 = 1, p2 = 1;</span><br><span class="line">            int c[55] = &#123;0&#125;;</span><br><span class="line">            while(p1 &lt;= dp[j][0] || p2 &lt;= dp[j - v][0]) &#123;</span><br><span class="line">                if (p2 &gt; dp[j - v][0] || (p2 &lt;= dp[j - v][0] &amp;&amp; p1 &lt;= dp[j][0] &amp;&amp; dp[j][p1] &gt;= dp[j - v][p2] + w)) &#123;</span><br><span class="line">                    c[++c[0]] = dp[j][p1];</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c[++c[0]] = dp[j - v][p2] + w;</span><br><span class="line">                    p2++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (c[0] &gt;= K) break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int ppp = 0; ppp &lt;= c[0]; ppp++) &#123;</span><br><span class="line">                dp[j][ppp] = c[ppp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= K; i++) </span><br><span class="line">        ans += dp[V][i];</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包第k优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1541乌龟棋</title>
      <link href="/2019/01/25/%E6%B4%9B%E8%B0%B71541%E4%B9%8C%E9%BE%9F%E6%A3%8B/"/>
      <url>/2019/01/25/%E6%B4%9B%E8%B0%B71541%E4%B9%8C%E9%BE%9F%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/25/洛谷1541乌龟棋/title2.jpg" alt="title2"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>乌龟棋的棋盘是一行N<em>N</em>个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N<em>N</em>格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p><p>乌龟棋中M<em>M</em>张爬行卡片，分成4种不同的类型（M<em>M</em>张卡片中不一定包含所有44种类型的卡片，见样例），每种类型的卡片上分别标有1,2,3,41,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p><p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p><p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p><p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>每行中两个数之间用一个空格隔开。</p><p>第11行22个正整数N,M<em>N</em>,<em>M</em>，分别表示棋盘格子数和爬行卡片数。</p><p>第22行N<em>N</em>个非负整数，a1,a2,…,aN<em>a</em>1,<em>a</em>2,…,<em>a**N</em>，其中ai<em>a**i</em>表示棋盘第i<em>i</em>个格子上的分数。</p><p>第33行M<em>M</em>个整数，b1,b2,…,bM<em>b</em>1,<em>b</em>2,…,<em>b**M</em>，表示M张爬行卡片上的数字。</p><p>输入数据保证到达终点时刚好用光M<em>M</em>张爬行卡片。</p><p>输出格式：</p><p>11个整数，表示小明最多能得到的分数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 5</span><br><span class="line">6 10 14 2 8 8 18 5 17</span><br><span class="line">1 3 1 2 1</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">73</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    刚开始我是设的<code>dp[i][j][p][q][k]</code>代表第一种卡片i个，第二种卡片j个，第三种卡片p个，第四种卡片q个，走到第k个格子的最大得分。后来发现，我既然得到ijpq了，肯定k是固定的。。。然后就灰溜溜的缩减为了四维dp</p><p>​    我们设了<code>dp[i][j][p][q]</code>后，由于题目上说正好把M张卡片用完，因此我们只需要用一个数组c存每种卡片的张数，那么<code>dp[c[1]][c[2]][c[3]][c[4]]</code>极为答案</p><p>​    这个题有个坑点，就是起始位置是1而不是0，自己在这里傻逼了好久～</p><p>​    废话不说，上代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[355];</span><br><span class="line">int c[5] = &#123;0&#125;;</span><br><span class="line">int dp[125][125][125][125] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;b);</span><br><span class="line">        c[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][0][0][0] = a[1];</span><br><span class="line">    for (int i = 0; i &lt;= c[1]; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= c[2]; j++) &#123;</span><br><span class="line">            for (int p = 0; p &lt;= c[3]; p++) &#123;</span><br><span class="line">                for (int q = 0; q &lt;= c[4]; q++) &#123;</span><br><span class="line">                    if (i != 0) dp[i][j][p][q] = max(dp[i - 1][j][p][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                    if (j != 0) dp[i][j][p][q] = max(dp[i][j - 1][p][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                    if (p != 0) dp[i][j][p][q] = max(dp[i][j][p - 1][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                    if (q != 0) dp[i][j][p][q] = max(dp[i][j][p][q - 1] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[c[1]][c[2]][c[3]][c[4]]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1158导弹拦截</title>
      <link href="/2019/01/25/%E6%B4%9B%E8%B0%B7P1158%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/"/>
      <url>/2019/01/25/%E6%B4%9B%E8%B0%B7P1158%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/25/洛谷P1158导弹拦截/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>经过 11年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 0时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。</p><p>某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行包含 4个整数x1、y1、x2、y2，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为(x1,y1)、(x2,y2)。 第二行包含1个整数N，表示有 N颗导弹。接下来N行，每行两个整数 x,y，中间用 一个空格隔开，表示一颗导弹的坐标(x,y)。不同导弹的坐标可能相同。</p><p>输出格式：</p><p>一个整数，即当天的最小使用代价。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 10 0</span><br><span class="line">2</span><br><span class="line">-3 3</span><br><span class="line">10 0</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><p>输入样例#2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 6 0</span><br><span class="line">5</span><br><span class="line">-4 -2</span><br><span class="line">-2 3</span><br><span class="line">4 0</span><br><span class="line">6 -2</span><br><span class="line">9 1</span><br></pre></td></tr></table></figure><p>输出样例#2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p>【数据范围】</p><p>对于10%的数据，N=1</p><p>对于20%的数据，1≤N≤2</p><p>对于40%的数据，1≤N≤100</p><p>对于70%的数据，1≤N≤1000</p><p>对于100%的数据，1≤N≤100000，且所有坐标分量的绝对值都不超过1000。</p><p>题解：</p><p>​    这道题百分之百的数据范围N为1e5，那么说明题目所需的复杂度最大为NlogN，我们可以把所有导弹对第一个拦截系统的距离进行由大到小排序（复杂度为NlogN）</p><p>​    由于已经是按照对第一个拦截系统的距离进行由大到小排序了，我们假设从<code>[i, n]</code>的导弹由第一个拦截，那么第一个拦截系统的最小半径为第i个对于第一个拦截系统 的距离，那么剩下的<code>[1, i - 1]</code>由第二个拦截系统拦截，我们可以在遍历的时候记录一下前i个对于第二个拦截系统的距离的最大值，这样我们只需要求<code>flag + daodan[i].d1</code>的最小值即为正确答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    int j1, j2;</span><br><span class="line">    void set(int x1, int y1, int x2, int y2) &#123;</span><br><span class="line">        j1 = (x - x1) * (x - x1) + (y - y1) * (y - y1);</span><br><span class="line">        j2 = (x - x2) * (x - x2) + (y - y2) * (y - y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;point[100005];</span><br><span class="line"></span><br><span class="line">bool zcy(node A, node B) &#123;</span><br><span class="line">    return A.j1 &gt; B.j1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int x1, y1, x2, y2, n;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">        point[i].set(x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(point, point + n, zcy);</span><br><span class="line">    int ans = 0x3f3f3f3f;</span><br><span class="line">    int k = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ans = min(ans, point[i].j1 + k);</span><br><span class="line">        k = max(point[i].j2, k);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = min(ans, k);</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1028数的计算</title>
      <link href="/2019/01/23/%E6%B4%9B%E8%B0%B71028%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/01/23/%E6%B4%9B%E8%B0%B71028%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/23/洛谷1028数的计算/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们要求找出具有下列性质数的个数(包含输入的自然数n<em>n</em>):</p><p>先输入一个自然数n<em>n</em>(n≤1000<em>n</em>≤1000),然后对此自然数按照如下方法进行处理:</p><ol><li>不作任何处理;</li><li>在它的左边加上一个自然数,但该自然数不能超过原数的一半;</li><li>加上数后,继续按此规则进行处理,直到不能再加自然数为止.</li></ol><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>11个自然数n<em>n</em>(n≤1000<em>n</em>≤1000)</p><p>输出格式：</p><p>11个整数，表示具有该性质数的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>满足条件的数为6，16，26，126，36，136</p><p>思路：</p><p>​    做这个题主要是想用优化的思想来做，这道题我们可以用三层for，两层for，一层for来AC。我把我想到的这三种都说一下，主要是给大家提供更多的思路，毕竟解题的道路是灵活的～</p><p>三层 for：</p><p>​    我们可以设<code>dp[i][j]</code>代表从左边数第i个整数为j的方案数，那么我们就可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化dp[1][j] = 1; (1 &lt;= j &lt;= n)</span><br><span class="line">for (int i = 1; quick(2, i) &lt;= n; i++) &#123;//quick(2, i)为2^i</span><br><span class="line">    int j = quick(2, i);</span><br><span class="line">    for (; j &lt;= n; j++) &#123;</span><br><span class="line">        for (int k = 1; k &lt;= j / 2; k++) &#123;</span><br><span class="line">            dp[i + 1][j] += dp[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这样全部满足条件的dp[i][n]的和即为答案</span><br></pre></td></tr></table></figure><p>两层for：</p><p>​    我们可以设<code>dp[i]</code>代表最右边为数字i有多少种方案，则:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[1] = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">    for (int j = 1; j &lt;= i / 2; j++) &#123;</span><br><span class="line">        dp[i] += dp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//dp[n]即为答案</span><br></pre></td></tr></table></figure><p>一层for：</p><p>​    和上面一样，我们设置<code>dp[i]</code>代表最右边为数字i有多少种方案，并用变量sum来记录和，则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[1] = 1;</span><br><span class="line">sum = 0;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = 1;</span><br><span class="line">    if (!(i &amp; 1)) s += dp[i / 2];</span><br><span class="line">    dp[i] += s;</span><br><span class="line">&#125;</span><br><span class="line">//dp[n]即为答案</span><br></pre></td></tr></table></figure><p>​    大概就是这样，Over</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简单用法(二)</title>
      <link href="/2019/01/21/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%BA%8C/"/>
      <url>/2019/01/21/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/Git简单用法-二/title.jpg" alt="title"></p><a id="more"></a><p>​    明天再补～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++简易实现Linux命令-待完善</title>
      <link href="/2019/01/21/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Linux%E5%91%BD%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84/"/>
      <url>/2019/01/21/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Linux%E5%91%BD%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/简易实现Linux命令-待完善/title7.jpg" alt="title7"></p><a id="more"></a><p>​    两天前老师布置了一个作业，让用C++简易实现linux的ls（包括ls -l，ls -a等）和cd命令，感觉效果不错，挂到了Github上，有时间再继续完善完善其它功能吧～</p><p>​    Github地址：<a href="https://github.com/ivan-zcy/shell" target="_blank" rel="noopener">跳转</a></p><p>​    当然也可以通过主页 -&gt; 项目进行查看：<a href="http://www.ivan-zcy.top/project/">跳转</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简单用法(一)</title>
      <link href="/2019/01/21/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%80/"/>
      <url>/2019/01/21/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/Git简单用法-一/title9.jpg" alt="title9"></p><a id="more"></a><p>[TOC]</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>​    输入下面命令查看git是否已经安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure><p>​    若没有安装，则输入下面命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git -y</span><br><span class="line"></span><br><span class="line">#如果是Mac用户，则：</span><br><span class="line">$ brew install git</span><br><span class="line"></span><br><span class="line">#brew和apt-get都可以看作软件管理工具，Liunx下用apt-get，Mac下用brew，若没有它就先下它</span><br></pre></td></tr></table></figure><h3 id="2-配置用户名与邮箱"><a href="#2-配置用户名与邮箱" class="headerlink" title="2.配置用户名与邮箱"></a>2.配置用户名与邮箱</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##若想设置为全局生效，就添加--global参数</span><br><span class="line">$ git config --global user.name&quot;用户名&quot;</span><br><span class="line">$ git config --global user.email &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure><h3 id="3-基本流程"><a href="#3-基本流程" class="headerlink" title="3.基本流程"></a>3.基本流程</h3><ol><li>初始化新的仓库或远程Clone仓库</li><li>创建或修改文件</li><li>使用<code>git add</code>命令将修改后的文件添加到本地缓存（索引库）</li><li>使用<code>git commit</code>命令提交改动到本地代码库</li><li>使用<code>git push</code>命令推送到远程仓库</li></ol><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><h4 id="4-1克隆远程仓库到本地或者在本地初始化仓库"><a href="#4-1克隆远程仓库到本地或者在本地初始化仓库" class="headerlink" title="4.1克隆远程仓库到本地或者在本地初始化仓库"></a>4.1克隆远程仓库到本地或者在本地初始化仓库</h4><h5 id="4-1-1克隆远程仓库到本地-前提条件是本地已与远程仓库SSH关联"><a href="#4-1-1克隆远程仓库到本地-前提条件是本地已与远程仓库SSH关联" class="headerlink" title="4.1.1克隆远程仓库到本地(前提条件是本地已与远程仓库SSH关联)"></a>4.1.1克隆远程仓库到本地(前提条件是本地已与远程仓库SSH关联)</h5><p>​    在自己远程仓库中（比如自己的Github仓库）点击clone or download，选择Use SSH，然后复制链接。</p><p>​    然后在本地中输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 存储的路径</span><br><span class="line">$ git clone 之前复制的链接</span><br></pre></td></tr></table></figure><h5 id="4-1-2克隆远程仓库到未关联SSH的主机"><a href="#4-1-2克隆远程仓库到未关联SSH的主机" class="headerlink" title="4.1.2克隆远程仓库到未关联SSH的主机"></a>4.1.2克隆远程仓库到未关联SSH的主机</h5><p>​    在远程仓库中点击clone or download，选择Use HTTPS，然后复制链接。</p><p>​    然后在本地中输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 存储的路径</span><br><span class="line">$ git clone 之前复制的链接</span><br></pre></td></tr></table></figure><h5 id="4-1-3本地初始化新仓库"><a href="#4-1-3本地初始化新仓库" class="headerlink" title="4.1.3本地初始化新仓库"></a>4.1.3本地初始化新仓库</h5><p>​    创建代码目录并初始化， 通过<code>git init</code>命令进行初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 想要放置的位置</span><br><span class="line">$ mkdir project</span><br><span class="line">$ cd project</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>​    对于三者的区别，前两者已经同远程仓库建立连接，第一个从本地向远程仓库push更新的时候不用账号密码，第二个需账号密码。而第三个没有同远程仓库建立连接</p><h4 id="4-2查看本地git仓库状态"><a href="#4-2查看本地git仓库状态" class="headerlink" title="4.2查看本地git仓库状态"></a>4.2查看本地git仓库状态</h4><p>​    利用<code>git status</code>命令查看当前本地仓库的状态信息</p><h4 id="4-3添加文件到索引库"><a href="#4-3添加文件到索引库" class="headerlink" title="4.3添加文件到索引库"></a>4.3添加文件到索引库</h4><p>以下操作都需要在克隆到本地的仓库目录下进行：</p><h5 id="4-3-1添加-修改"><a href="#4-3-1添加-修改" class="headerlink" title="4.3.1添加/修改"></a>4.3.1添加/修改</h5><p>​    把一个文件添加或更新内容到本地索引，可以使用<code>git add</code>命令</p><p>​    例如创建一个新的txt文件，并往文件内写入“hello world”，并用<code>git add</code>命令添加到本地索引库中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hello world&quot; &gt; newfile.txt</span><br><span class="line">$ git add newfile.txt</span><br></pre></td></tr></table></figure><h5 id="4-3-2删除"><a href="#4-3-2删除" class="headerlink" title="4.3.2删除"></a>4.3.2删除</h5><p>​    把仓库里的文件删掉，可以使用<code>git rm</code>命令</p><p>​    例如删除新创建的newfile.txt文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm newfile.txt</span><br></pre></td></tr></table></figure><p>​    对于删除文件，需要<code>git commit</code>一下，版本库中文件才可以完全被删除</p><h5 id="4-3-3撤销"><a href="#4-3-3撤销" class="headerlink" title="4.3.3撤销"></a>4.3.3撤销</h5><p>​    把仓库里的改动撤销回到刚克隆下来的状态，可以使用<code>git reset</code>命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#git reset命令有三种方式</span><br><span class="line"></span><br><span class="line">$ git reset -mixed  #git reset默认方式，退回到某个版本，只保留源码，回退commit和index信息</span><br><span class="line">$ git reset -soft #回退到某个版本，只回退commit信息。如果还要提交，直接commit即可</span><br><span class="line">$ git reset -hard#彻底退回某个版本，本地的源码也会变为上一个版本的内容</span><br><span class="line"></span><br><span class="line">#用法为：</span><br><span class="line">#回退所有内容到上一个版本 </span><br><span class="line">$ git reset HEAD^</span><br><span class="line">#回退newfile.txt这个文件的版本到上一个版本 </span><br><span class="line">$ git reset HEAD^ a.py</span><br><span class="line">#向前回退所有内容到第3个版本 </span><br><span class="line">$ git reset HEAD~3</span><br><span class="line">#回退到某个版本 </span><br><span class="line">git reset 版本名</span><br></pre></td></tr></table></figure><h4 id="4-4提交仓库的改动"><a href="#4-4提交仓库的改动" class="headerlink" title="4.4提交仓库的改动"></a>4.4提交仓库的改动</h4><p>​    仓库的每次改动操作后，推送同步到远程仓库前，都需要对这一次或这一批次的操作做提交，命令为<code>git commit</code>，只有完成提交，才可以推送改动到远程仓库</p><p>​    例如提交本次改动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;我的注释&quot;</span><br></pre></td></tr></table></figure><h4 id="4-5推送到远程仓库"><a href="#4-5推送到远程仓库" class="headerlink" title="4.5推送到远程仓库"></a>4.5推送到远程仓库</h4><p>​    提交仓库改动后就可以开始推送改动的内容到远程仓库了，命令为<code>git push</code>，用法是<code>git push -u origin 分支名</code>，其中分支名默认为master。第一次推送可以使用-u参数（会绑定此时的仓库分支名，这样下次推送就无需加分支名了）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="4-6当远程仓库被修改，如何同步到本地"><a href="#4-6当远程仓库被修改，如何同步到本地" class="headerlink" title="4.6当远程仓库被修改，如何同步到本地"></a>4.6当远程仓库被修改，如何同步到本地</h4><h5 id="4-6-1查看仓库改动"><a href="#4-6-1查看仓库改动" class="headerlink" title="4.6.1查看仓库改动"></a>4.6.1查看仓库改动</h5><p>通过<code>git fetch</code>命令查看有哪些新改动，用法为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure><h5 id="4-6-2同步到本地"><a href="#4-6-2同步到本地" class="headerlink" title="4.6.2同步到本地"></a>4.6.2同步到本地</h5><p>通过<code>git pull</code>命令实现同步到本地，具体用法是<code>git pull origin 分支名</code>，分支名默认为master</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现SSH免密登陆</title>
      <link href="/2019/01/21/%E5%AE%9E%E7%8E%B0ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/"/>
      <url>/2019/01/21/%E5%AE%9E%E7%8E%B0ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/实现ssh免密登陆/title6.jpg" alt="title6"></p><a id="more"></a><p>####SSH是什么？</p><p>​    SSH是建立在应用层基础上的安全协议，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。</p><p>​    当数据到达目的地时，SSH自动对加密数据进行解密。整个过程都是透明的，使用OpenSSH工具将会增进系统的安全性</p><p>​    除此之外，SSH传输的数据是经过压缩的，所以可以加快传输的速度。SSH还有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的通道。</p><p>####SSH连接的原理</p><p>​    假设A主机想要连接到B主机：</p><ol><li>A主机向B主机发送连接请求</li><li>B主机向A主机发送公钥</li><li>A主机用公钥将密码信息加密并发送给B</li><li>B主机用私钥解密并验证密码信息，信息合法就建立连接</li></ol><h4 id="免密登录的原理"><a href="#免密登录的原理" class="headerlink" title="免密登录的原理"></a>免密登录的原理</h4><p>​    由于上面的方式A主机必须得输入密码信息发送进行验证，也就是说我们每次进行连接都得需要输入密码，超级麻烦～</p><p>​    因此，我们就可以通过免密登录来实现无密码进行链接。</p><p>​    至于实现的原理是什么？假设A主机想要免密连接到B主机：</p><ol><li>在A主机上生成公钥私钥</li><li><p>将A中的公钥拷贝给到B主机中的authorized_keys（也就相当于把A加入到B的白名单中）</p></li><li><p>A向B发送连接请求</p></li><li>B得到请求后，在authorized_key中查找是否有对应用户名和IP。如果有则随机生成一个字符串并用A的公钥进行加密并发送给A</li><li>A得到B发来的消息后用私钥进行解密，然后将解密后的字符串发送回B。B进行对比，若一致则允许免密登录</li></ol><p>####如何实现免密登录</p><h5 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h5><p>​    A主机若已经生成了公钥私钥，则跳过此步（因此一个主机在同一时间下只能拥有一对公钥私钥，再次随机生成会覆盖掉之前的公钥私钥，但不建议这么做，因为可能在其它主机上存储了A主机之前的公钥，如果A主机再次生成公钥私钥的话会导致之前做过免密登录的主机失效）</p><p>​    若无公钥私钥，则A主机通过<code>$ ssh-keygen -t rsa -P</code> 就可以在家目录下的.ssh文件夹中生成id_rsa(私钥)和id_rsa.pub(公钥)两个文件</p><h5 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h5><p>​    把A中的id_rsa.pub(也就是公钥)中的内容追加到B主机中家目录下的.ssh/authorized_keys中（若B主机没有该路径和文件则先创建），这样就实现了加入白名单</p><p>​    这样，已有A向B发起连接就可以无需输入密码了～</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是佩奇源码</title>
      <link href="/2019/01/20/%E5%95%A5%E6%98%AF%E4%BD%A9%E5%A5%87%E6%BA%90%E7%A0%81/"/>
      <url>/2019/01/20/%E5%95%A5%E6%98%AF%E4%BD%A9%E5%A5%87%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/啥是佩奇源码/title.jpg" alt="title"></p><a id="more"></a><p>​    感谢GIthub上提供的源码，地址：<a href="https://github.com/Monster12138/-" target="_blank" rel="noopener">跳转</a></p><p>​    大家熟悉了Python内置的turtle后可以随意DIY，超棒的Python内置绘制图形库！！</p><p>源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from turtle import*</span><br><span class="line"></span><br><span class="line">def nose(x,y):#鼻子</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-30)</span><br><span class="line">    begin_fill()</span><br><span class="line">    a=0.4</span><br><span class="line">    for i in range(120):</span><br><span class="line">        if 0&lt;=i&lt;30 or 60&lt;=i&lt;90:</span><br><span class="line">            a=a+0.08</span><br><span class="line">            lt(3) #向左转3度</span><br><span class="line">            fd(a) #向前走a的步长</span><br><span class="line">        else:</span><br><span class="line">            a=a-0.08</span><br><span class="line">            lt(3)</span><br><span class="line">            fd(a)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(25)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(10)</span><br><span class="line">    pd()</span><br><span class="line">    pencolor(255,155,192)</span><br><span class="line">    seth(10)</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(5)</span><br><span class="line">    color(160,82,45)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(20)</span><br><span class="line">    pd()</span><br><span class="line">    pencolor(255,155,192)</span><br><span class="line">    seth(10)</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(5)</span><br><span class="line">    color(160,82,45)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def head(x,y):#头</span><br><span class="line">    color((255,155,192),&quot;pink&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    seth(0)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(180)</span><br><span class="line">    circle(300,-30)</span><br><span class="line">    circle(100,-60)</span><br><span class="line">    circle(80,-100)</span><br><span class="line">    circle(150,-20)</span><br><span class="line">    circle(60,-95)</span><br><span class="line">    seth(161)</span><br><span class="line">    circle(-300,15)</span><br><span class="line">    pu()</span><br><span class="line">    goto(-100,100)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-30)</span><br><span class="line">    a=0.4</span><br><span class="line">    for i in range(60):</span><br><span class="line">        if 0&lt;=i&lt;30 or 60&lt;=i&lt;90:</span><br><span class="line">            a=a+0.08</span><br><span class="line">            lt(3) #向左转3度</span><br><span class="line">            fd(a) #向前走a的步长</span><br><span class="line">        else:</span><br><span class="line">            a=a-0.08</span><br><span class="line">            lt(3)</span><br><span class="line">            fd(a)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ears(x,y): #耳朵</span><br><span class="line">    color((255,155,192),&quot;pink&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(100)</span><br><span class="line">    circle(-50,50)</span><br><span class="line">    circle(-10,120)</span><br><span class="line">    circle(-50,54)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(-12)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(30)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(100)</span><br><span class="line">    circle(-50,50)</span><br><span class="line">    circle(-10,120)</span><br><span class="line">    circle(-50,56)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def eyes(x,y):#眼睛</span><br><span class="line">    color((255,155,192),&quot;white&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(-20)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(-95)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(15)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(12)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(-3)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(3)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    color((255,155,192),&quot;white&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(-25)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(40)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(15)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(12)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(-3)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(3)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def cheek(x,y):#腮</span><br><span class="line">    color((255,155,192))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(0)</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(30)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def mouth(x,y): #嘴</span><br><span class="line">    color(239,69,19)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-80)</span><br><span class="line">    circle(30,40)</span><br><span class="line">    circle(40,80)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def body(x,y):#身体</span><br><span class="line">    color(&quot;red&quot;,(255,99,71))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(-130)</span><br><span class="line">    circle(100,10)</span><br><span class="line">    circle(300,30)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(230)</span><br><span class="line">    seth(90)</span><br><span class="line">    circle(300,30)</span><br><span class="line">    circle(100,3)</span><br><span class="line">    color((255,155,192),(255,100,100))</span><br><span class="line">    seth(-135)</span><br><span class="line">    circle(-80,63)</span><br><span class="line">    circle(-150,24)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hands(x,y):#手</span><br><span class="line">    color((255,155,192))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-160)</span><br><span class="line">    circle(300,15)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(15)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(0)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-10)</span><br><span class="line">    circle(-20,90)</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(30)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(237)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-20)</span><br><span class="line">    circle(-300,15)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(20)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(0)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-170)</span><br><span class="line">    circle(20,90)</span><br><span class="line"></span><br><span class="line">def foot(x,y):#脚</span><br><span class="line">    pensize(10)</span><br><span class="line">    color((240,128,128))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-90)</span><br><span class="line">    fd(40)</span><br><span class="line">    seth(-180)</span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pensize(15)</span><br><span class="line">    fd(20)</span><br><span class="line"></span><br><span class="line">    pensize(10)</span><br><span class="line">    color((240,128,128))</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(40)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(90)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-90)</span><br><span class="line">    fd(40)</span><br><span class="line">    seth(-180)</span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pensize(15)</span><br><span class="line">    fd(20)</span><br><span class="line"></span><br><span class="line">def tail(x,y):#尾巴</span><br><span class="line">    pensize(4)</span><br><span class="line">    color((255,155,192))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(0)</span><br><span class="line">    circle(70,20)</span><br><span class="line">    circle(10,330)</span><br><span class="line">    circle(70,30)</span><br><span class="line"></span><br><span class="line">def zcy(x, y):</span><br><span class="line">    pu()</span><br><span class="line">    goto(x, y)</span><br><span class="line">    pendown()</span><br><span class="line">    setheading(0)</span><br><span class="line">    forward(20)</span><br><span class="line">    right(135)</span><br><span class="line">    forward(80)</span><br><span class="line">    left(135)</span><br><span class="line">    forward(55)</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    goto(x + 65, y - 22)</span><br><span class="line">    pendown()</span><br><span class="line">    seth(120)</span><br><span class="line">    a = 0.5</span><br><span class="line">    for i in range(40):</span><br><span class="line">        a = a + 0.07</span><br><span class="line">        if i &gt;= 37:</span><br><span class="line">            lt(20)</span><br><span class="line">        elif i &gt;= 30:</span><br><span class="line">            lt(7)</span><br><span class="line">        else:</span><br><span class="line">            lt(6)</span><br><span class="line">        fd(a)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x + 90, y - 22)</span><br><span class="line">    pendown()</span><br><span class="line">    seth(-65)</span><br><span class="line">    forward(38)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x + 130, y - 22)</span><br><span class="line">    pendown()</span><br><span class="line">    seth(235)</span><br><span class="line">    forward(100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def setting():          #参数设置</span><br><span class="line">    pensize(4)</span><br><span class="line">    hideturtle()</span><br><span class="line">    colormode(255)</span><br><span class="line">    color((255,155,192),&quot;pink&quot;)</span><br><span class="line">    setup(840,500)</span><br><span class="line">    speed(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    setting()           #画布、画笔设置</span><br><span class="line">    nose(-100,100)      #鼻子</span><br><span class="line">    head(-69,167)       #头</span><br><span class="line">    ears(0,160)         #耳朵</span><br><span class="line">    eyes(0,140)         #眼睛</span><br><span class="line">    cheek(80,10)        #腮</span><br><span class="line">    mouth(-20,30)       #嘴</span><br><span class="line">    body(-32,-8)        #身体</span><br><span class="line">    hands(-56,-45)      #手</span><br><span class="line">    foot(2,-177)        #脚</span><br><span class="line">    tail(148,-155)      #尾巴</span><br><span class="line">    #zcy(206, -148)      #牵着尾巴的署名</span><br><span class="line">    done()              #结束</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-6</title>
      <link href="/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-6/"/>
      <url>/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/动态规划优化问题-6/title1.jpg" alt="title1"></p><a id="more"></a><p>例五：矩形问题</p><p>​    在一个n✖️m的黑白相间的矩形中，问有多少个全白色的子矩形（0代表黑色，1代表白）</p><p>​    最暴力的方法就是挨个子矩形都去判断，这样的时间复杂度为O(n^2✖️m^2)，在这里就不说了。</p><p>​    我们可以优化，设<code>dp[i][j]</code>代表以(i, j)为右下角的子矩形的个数，再通过<code>l[i][j]</code>数组记录第i行j列向上有多少个连续的白矩形。这样就可以把题目优化到O(n✖️m^2)，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">    minn = l[i][j];</span><br><span class="line">        for (int k = j; k &gt;= 1; k--) &#123;</span><br><span class="line">            minn = min(minn, l[i][k]);</span><br><span class="line">            if (!minn) break;</span><br><span class="line">            ans += minn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    但是如果n和m的取值范围都是1e3怎么办？这时，我们就可以通过转移优化中的单调栈优化来进一步进行优化</p><p>​    我们创建一个单调栈数组<code>sta[i]</code>代表第i行的单调栈。保持单调栈递增，那么就可以将题目优化到O(n✖️m)了，详情请看代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int num=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx, val, sum;</span><br><span class="line">    node(int x, int y, int z) &#123;</span><br><span class="line">        inx = x;</span><br><span class="line">        val = y;</span><br><span class="line">        sum = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack&lt;node&gt;que[1005];</span><br><span class="line">int l[1005][1005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, a;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            if (a) &#123;</span><br><span class="line">                l[i][j] = l[i - 1][j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!que[i].empty()) &#123;</span><br><span class="line">                if (que[i].top().val &gt;= l[i][j]) &#123;</span><br><span class="line">                    que[i].pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node sta(j, l[i][j], 0);</span><br><span class="line">            if (que[i].empty()) &#123;</span><br><span class="line">                sta.sum = j * l[i][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sta.sum = que[i].top().sum + (j - que[i].top().inx) * l[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            que[i].push(sta);</span><br><span class="line">            ans += sta.sum;</span><br><span class="line">            if (ans &gt;= 100007) &#123;</span><br><span class="line">                ans %= 100007;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-5</title>
      <link href="/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-5/"/>
      <url>/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/动态规划优化问题-5/title4.jpg" alt="title4"></p><a id="more"></a><p>例四：扔鸡蛋问题</p><p>​    定义鸡蛋的硬度为 k，则代表鸡蛋最高从 k 楼扔下来不会碎掉，现在给你 n 个硬度相同的鸡蛋，楼高为 m，问最坏情况下最少测多少次，可以测出鸡蛋的硬度。</p><p>​    我们假设有2个鸡蛋，100层楼。那么我们应该如何扔在最坏情况下测的次数最少呢？</p><p>1.二分法：刚开始我傻傻的以为是二分法，第一个鸡蛋在第50层扔，但是如果一个鸡蛋在第50层碎了，那么第二个鸡蛋只能从第1层扔直到第49层，才能测出鸡蛋的硬度（在最坏情况为49层时），这样最坏情况下需要测50次</p><p>2.平方根法：我们继续优化，我们每10层测一次，第10层若碎了，第二个鸡蛋就从1层测到9层。若没碎继续测第20层…以此类推，最坏情况是第99层时，这时我们需要测10 + 9 = 19次</p><p>3.假设法：方法二一定是最优解吗？我们可以假设一下，设2个鸡蛋100层楼在最坏情况下最多测x次，那么第一个鸡蛋应该放在第x层最合适（如果第一个鸡蛋放在是x + i层，如果碎了最坏情况下最多测x + i次，比x次多；如果第一个鸡蛋放在x - i层，如果没碎的话，由于x - i比x小，所以它剩余测的次数一定 &gt;= x）</p><p>​    因此，我们第一次放在x层（碎了话最多测x次，没碎的话第二次放在2 <em> x - 1层，碎的话最多测x次，没碎的话第三次放在3 </em> x - 3层，碎的话最多测x次，没碎的话第四次放在4 * x - 6层…依次类推），我们只要保证x + (x - 1) + (x - 2) … + 1 &gt;= 100即可，这样解出最优答案为14</p><p>​    好了，以上是推理，我们可以用dp的方法来求出正确的答案。我们可以假设<code>dp[i][j]</code>代表i个鸡蛋j层楼最少测多少次。这样我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">dp[1][j] = k (1 &lt;= j &lt;= m)//一个鸡蛋j层楼最坏情况下最少需要测j次</span><br><span class="line">dp[i][1] = 1 (1 &lt;= i &lt;= n)  //i个鸡蛋1层楼最坏情况下最少需要测1次</span><br><span class="line"></span><br><span class="line">这样我们可以得到dp转移式：</span><br><span class="line">dp[i][m] = min(max(dp[i - 1][j - 1], dp[i][m - j]))  (1 &lt;= j &lt;= m)</span><br></pre></td></tr></table></figure><p>​    那么，当n范围为1e2，m范围为1e9的时候，我们怎么办呢？</p><p>​    数组肯定开不下那么大，而且上面算法的时间复杂度为O(n(m^2))，会直接爆掉的。这时我们就可以进行重新定义状态信息来优化算法。</p><p>​    我们可以假设<code>dp[i][j]</code>代表i个鸡蛋测j次最多能测多少层楼。这样我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//初始化：</span><br><span class="line">dp[1][j] = j//一个鸡蛋测j次最多可以测j层楼</span><br><span class="line">dp[i][1] = 1  //i个鸡蛋测1次最多可以测1层楼</span><br><span class="line"></span><br><span class="line">我们假设第i个鸡蛋测k次最多测n层楼，那么在测n层楼的情况下，第一次需要测的位置应该是i-1个鸡蛋测k - 1次最多测的层数+1(只有满足这个条件，在第m层碎了测的次数最坏情况才为k)</span><br><span class="line">若在第m层没碎，那么往上最多能测的层数应该是i个鸡蛋测k - 1次最多的层数</span><br><span class="line">因此，dp[i][k] = dp[i - 1][k - 1] + dp[i][k - 1] + 1</span><br><span class="line"></span><br><span class="line">我们只要找第一个dp[n][j]大于m的j即是正确答案</span><br></pre></td></tr></table></figure><p>​    最后上AC代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll dp[35][100005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;, m);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 100000; i++) &#123;</span><br><span class="line">            dp[1][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 2; j &lt;= 100000; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= 100000; j++) &#123;</span><br><span class="line">            if (dp[n][j] &gt;= m) &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;, j);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-4</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-4/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-4/title8.jpg" alt="title8"></p><a id="more"></a><p>例三：多重背包</p><p>​    多重背包问题我们经常能碰到，就是给出n种物品，每种物品有<code>a[i]</code>个，占用空间为<code>v[i]</code>，价值为<code>w[i]</code>，背包容量为K，问背包所能装下的物品的最大价值</p><p>方法一：</p><p>​    我们一般的求法就是开一个<code>dp[k]</code>数组代表空间容量为i时的最大价值。然后遍历每种物品的每件，通过递推公式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[k] = max(dp[k], dp[k - v[i]] + w[i]);</span><br></pre></td></tr></table></figure><p>​    这时时间复杂度为<code>O(n * m * K)</code>(其中n为种类数，m为每种物品的数量，K为背包容量)</p><p>​    但是，当m特别大时，我们应该怎么办呢？</p><p>方法二：</p><p>​    我们会发现，每种的物品，它们的<code>v[i]和w[i]</code>是相同的。假如某种物品有15种，我们上面那种方法的做法，由于是遍历该种的每一件物品，因此也就是将{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}任意组合。我们会发现组合会有很多重复，因此我们可以这样进行优化：</p><p>​    对于集合{1, 2, 4, 8}，我们也可以通过这四个数组合成1～15个的任意一个。这样我们只需要求每种物品的n件物品优化成logn种物品，这样时间复杂度就可以优化为<code>O(n * log(m) * K)</code> </p><p>​    注意点！！！！如果一种物品有n件，所选的集合必须只能组成<code>[1, n]</code>，比如13:{1, 2, 4, 6}</p><p>​    这种方法的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[10005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, K, v, w, num;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;K, &amp;n);//K代表背包容量，n代表物品种类数</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;num);//v,w,num分别代表每种物品的体积，价值，数量</span><br><span class="line">        int val = 1;//val为集合所有元素的和，初始化为1</span><br><span class="line">        int j = 1;//j为集合为集合中的元素，初始化为1</span><br><span class="line">        while (val &lt;= num) &#123;</span><br><span class="line">            int vv = v * j;  //此时把j个该种物品看作一个物品进行dp，也就是01背包</span><br><span class="line">            int ww = w * j;</span><br><span class="line">            for (int p = K; p &gt;= vv; p--) &#123;</span><br><span class="line">                dp[p] = max(dp[p], dp[p - vv] + ww);</span><br><span class="line">            &#125;</span><br><span class="line">            j = val + 1;</span><br><span class="line">            val += j;</span><br><span class="line">        &#125;</span><br><span class="line">        val -= j;//该操作保证所求集合确保正好组成[1, num]</span><br><span class="line">        j = num - val;</span><br><span class="line">        if (j &gt; 0) &#123;</span><br><span class="line">            int vv = v * j;</span><br><span class="line">            int ww = w * j;</span><br><span class="line">            for (int p = K; p &gt;= vv; p--) &#123;</span><br><span class="line">                dp[p] = max(dp[p], dp[p - vv] + ww);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[K]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    方法二时间复杂度为<code>O(n * logm * K)</code>，还不可以继续优化呢？答案是可以的，我们可以利用单调队列对多重背包问题进行优化到<code>O(n * K)</code>。大家可以先自己考虑一下如何去做再往下看</p><p>方法三：</p><p>​    方法三看了好多好的题解才搞懂。。只能说自己太笨了Orz～以下是我的理解，希望能对大家有些帮助</p><p>​    我们单拿出一种物品来看，比如体积为5，价值为6，数量为3，再假如K为22。那么我们单拿出全部%5 == 2的容量来看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[2] = dp[2];</span><br><span class="line">dp[7] = max(dp[2], dp[7] - 6) + 6;</span><br><span class="line">dp[12] = max(dp[2], dp[7] - 6, dp[12] - 12) + 12;</span><br><span class="line">dp[17] = max(dp[2], dp[7] - 6, dp[12] - 12, dp[17] - 18) + 18;</span><br><span class="line">dp[22] = max(dp[7] - 6, dp[12] - 12, dp[17] - 18, dp[22] - 24) + 24;</span><br><span class="line"></span><br><span class="line">//这一步没看懂的同学看这里！！</span><br><span class="line">比如dp[22] = max(dp[7] - 6, dp[12] - 12, dp[17] - 18, dp[22] - 24) + 24中，</span><br><span class="line">dp[7] - 6若是最大值，dp[7] - 6 + 24等价于dp[22] = dp[7] + 18，也就是用3个该种物品</span><br><span class="line">dp[12] - 12若是最大值，dp[12] - 12 + 24等价于dp[22] = dp[12] + 12，也就是用2个该种商品</span><br><span class="line">dp[17] - 18若是最大值，dp[17] - 18 + 24等价于dp[22] = dp[17] + 6，也就是用1个该种商品</span><br><span class="line">dp[22] - 24若是最大值，dp[22] - 24 + 24等价于dp[22] = dp[22]，也就是不用该种商品</span><br></pre></td></tr></table></figure><p>​    至于最多选用几个的数量s，它等于s = min(s, K / v)。这样，我们就可以将题目转化为下面的代码形式（伪代码）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (循环遍历每种商品) &#123;</span><br><span class="line">    for (循环遍历全部余数d[0, v)) &#123;</span><br><span class="line">        for (循环遍历K以内全部余数为d的容量k*v+d) &#123;</span><br><span class="line">          for (循环遍历s个上一种物品的状态并更新最大值) &#123;</span><br><span class="line">                </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从伪代码可以看出时间复杂度为<code>O(n * K * s)</code> （第二层和第三层for相乘为K），和上一种方法复杂度差不多甚至在某些情况下还要更高。我们可以用单调队列维护最大值且区间差值小于等于s来优化该算法，此时复杂度为<code>O(n * K)</code></p><p>​    比如说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将dp[2] - 0 * 6加入单调队列并维护最大值，然后用队列最大值 + 0 * 6即为新的dp[2]</span><br><span class="line">将dp[7] - 1 * 6加入单调队列并维护最大值，然后用队列最大值 + 1 * 6即为新的dp[7]</span><br><span class="line">将dp[12] - 2 * 6加入单调队列并维护最大值，然后用队列最大值 + 2 * 6即为新的dp[12]</span><br><span class="line">将dp[17] - 3 * 6加入单调队列并维护最大值，然后用队列最大值 + 3 * 6即为新的dp[17]</span><br><span class="line">将dp[22] - 4 * 6加入单调队列并维护最大值，然后用队列最大值 + 4 * 6即为新的dp[22]</span><br><span class="line"></span><br><span class="line">//注意单调队列的维护需要注意的两点(1.若q[tail] &lt;= val则循环tail--直到满足条件为止 2.若q[tail]与q[head]相差数量大于s则循环head++直到满足条件为止)</span><br></pre></td></tr></table></figure><p>​    下面给出这道题单调队列优化的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//dp[i]存储当前状态下容量为i的最大价值</span><br><span class="line">//q[i]用于模拟优先队列</span><br><span class="line">//inv[i]用于存储优先队列中位置为i的使用该种商品的物品数</span><br><span class="line">int dp[10005] = &#123;0&#125;, inv[10005] = &#123;0&#125;, q[10005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int K, n, v, w, s;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;K, &amp;n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s);</span><br><span class="line">        s = min(K / v, s);    //代表能用的该种物品的最大数量</span><br><span class="line">        for (int mod = 0; mod &lt; v; mod++) &#123;</span><br><span class="line">            int head = 1, tail = 1; //相当于清空队列</span><br><span class="line">            for (int j = 0; j &lt;= (K - mod) / v; j++) &#123;</span><br><span class="line">                int val = dp[j * v + mod] - j * w;</span><br><span class="line">                while (head &lt; tail &amp;&amp; q[tail - 1] &lt;= val) &#123;</span><br><span class="line">                    tail--;         //该操作保证队列单调</span><br><span class="line">                &#125;</span><br><span class="line">                q[tail] = val;</span><br><span class="line">                inv[tail++] = j;</span><br><span class="line">                while (head &lt; tail &amp;&amp; j - inv[head] &gt; s) &#123;</span><br><span class="line">                    head++;         //该操作用于维护数量上限</span><br><span class="line">                &#125;</span><br><span class="line">                //此时队列的头（即最大值）就是我们需要使用该种商品的数量</span><br><span class="line">                dp[j * v + mod] = max(q[head] + j * w, dp[j * v + mod]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[K]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-3</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-3/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-3/title2.jpg" alt="title2"></p><a id="more"></a><p>例2:切割回文串</p><p>​    给出一个字符串s，对字符串最少切几刀，可以使得切完后的每一段字符串都是回文串（单一字符也是回文串）？</p><p>​    这道题我们首先能想到用区间dp来做，设置<code>dp[i][j]</code>代表字符串区间[i, j]最少切多少刀使得每一段字符串都是回文串，这时我们就可以得到递推方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当[i, j]是回文数的时候，dp[i][j] = 0;</span><br><span class="line">//当[i, j]不是回文数的时候，dp[i][j] = min(dp[i][k] + dp[k + 1][j] + 1) //其中i &lt;= k &lt; j</span><br><span class="line">//而对于[i, j]是否为回文数，需要利用bool数组maps[i][j]来记录和预处理</span><br></pre></td></tr></table></figure><p>​    上面方法的空间复杂度是O(n ^ 2)，时间复杂度是O(n ^ 3)，预处理时间复杂度也为O(n^3)，因此当n为1e5左右时直接爆炸。</p><p>​    和上一篇文章一样。大家先在这里停住，考虑一下如何将上面的思路，缩减为空间复杂度为O(n)，时间复杂度为O(nlogn)再继续往下看</p><p>​    对于空间复杂度。我们需要一个数组<code>maps[i][j]</code>用来记录字符串区间[i, j]是否为回文串，对于这个二维数组，我们可以怎么优化呢？对，把它变为一个动态数组<code>maps[i]</code>，用于存储以i结尾的回文串的起始位置。（由于出题人生成的都是随机数据，所以1e5个字符全是相同的那种极限样例根本不可能出现，出现的概率不亚于天天中大乐透～Orz）</p><p>​    这时，maps数组从O(n ^ 2)优化成了O(k)（k为回文串的个数），我们就需要来考虑预处理回文串的时间复杂度优化问题了。由于极限数据根本不可能出现，因此我们可以通过便利中点i，让起点star和终点endd从i向两边扩，若s[star] != s[endd]时即跳出循环，并把全部符合条件的star加入到<code>maps[endd]</code>中，这样预处理的时间复杂度就为O（nlogn）</p><p>​    考虑完预处理，接下来我们开始考虑dp数组的空间优化和状态转移的时间优化～</p><p>​    dp数组上面方法中是二维的，因此我们需要优化成一维数组。用<code>dp[i]</code>来代表前i个字符串最少切的刀数。</p><p>​    优化成一维数组后，我们紧跟着推出递推方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[j] + 1;//[j + 1, i]必须是回文字符串</span><br></pre></td></tr></table></figure><p>​    由于数据是随机的，因此满足条件的j不会特别多。由于<code>maps[i]</code>中存了全部满足条件的j，因此dp的时间复杂度大概也为O(nlogn)。</p><p>​    因此，第二种方法总的空间复杂度为O(nlogn)，时间复杂度为O(nlogn)。这样数据范围就能从1e2提升到1e5了</p><p>​    以上就是这道题动态规划优化的全部思维，下面附上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[500005];</span><br><span class="line">int dp[500005] = &#123;0&#125;;</span><br><span class="line">vector &lt;int&gt; zcy[500005];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">    int n = strlen(s + 1);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        zcy[i].push_back(i);</span><br><span class="line">        if (i + 1 &lt;= n &amp;&amp; s[i + 1] == s[i])</span><br><span class="line">            zcy[i + 1].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int p, q;</span><br><span class="line">        for (p = i + 1, q = i - 1; p &lt;= n &amp;&amp; q &gt;= 1; p++, q--) &#123;</span><br><span class="line">            if (s[p] == s[q]) &#123;</span><br><span class="line">                zcy[p].push_back(q);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[i] == s[i + 1]) &#123;</span><br><span class="line">            for (p = i + 2, q = i - 1; p &lt;= n &amp;&amp; q &gt;= 1; p++, q--) &#123;</span><br><span class="line">                if (s[p] == s[q]) &#123;</span><br><span class="line">                    zcy[p].push_back(q);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dp, 0x3f, sizeof(dp));</span><br><span class="line">    dp[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int j = 0; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">            if (zcy[i][j] == 1) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            dp[i] = 0;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">            dp[i] = min (dp[i], dp[zcy[i][j] - 1] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-2</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-2/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-2/title3.jpg" alt="title3"></p><a id="more"></a><p>例一：墙壁涂色问题：</p><p>​    共有n面墙壁围成一圈，共有k种颜色，相邻墙壁不能涂同一种颜色，问共有多少种涂色方案？</p><p>​    我们可以想到利用<code>dp[i][j]</code>代表第i面墙涂第j种颜色的方案数，初始化<code>dp[1][1] = 1</code>，利用递推公式<code>dp[i][j] += dp[i - 1][k] (其中k != j)</code>，最后<code>ans += dp[n][k] (其中k != 1)</code>，<code>ans *= k</code> 即为答案</p><p>​    按照上面的思路，我们发现它需要开二维数组，空间复杂度为<code>O(n * k)</code>，时间复杂度也为<code>O(n * k)</code></p><p>​    如果题目中<code>n * k</code>的数据范围超过1e7该怎么办呢？</p><p>​    这时，我们就可以通过重新定义状态以去掉那些冗余项来对其进行优化，大家可以先考虑考虑如何进行优化成时间和空间复杂度均为O(n)再接着往下看～</p><p>​    这时，我们可以设<code>dp[i]</code>代表第i面墙与第一面墙成环的方案数，初始化<code>dp[1] = 1, dp[2] = k - 1, dp[3] = (k - 2) * dp[2]</code> 。</p><p>​    我们可以发现，第i面墙与第一面墙成环，那么需要保证第i面墙与第1面颜色不同，也与第i - 1面墙颜色不同。由于<code>dp[i - 1]</code>代表i - 1面墙成环的方案数，因此i - 1面墙与第一面墙颜色不同，所以当第i - 1面墙与第一面墙颜色不同的情况下，<code>dp[i]</code>有<code>dp[i - 1] * (k - 2)</code>种方案。        </p><p>​    除此之外，第i - 1面墙也可以与第一面墙相同。这时假若第i - 1面墙与第一面墙颜色相同，那么前i - 1面墙的方案数为<code>dp[i - 2]</code>，由于第一面和第i - 1面墙颜色相同，因此在该种情况下第i面墙的方案数为<code>dp[i - 2] * (k - 1)</code>。</p><p>​    这两种情况的总和就是<code>dp[i]</code>的方案总数，即当i &gt; 3时：<code>dp[i] = dp[i - 1] * (k - 2) + dp[i - 2] * (k - 1)</code></p><p>​    最终<code>dp[n] *= k</code>即为答案</p><p>​    给出这道题的解题代码（由于数据范围爆longlong因此用大数）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int dp[1005][2005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">    dp[1][0] = dp[2][0] = dp[3][0] = dp[1][1] = 1;</span><br><span class="line">    dp[2][1] = k - 1;</span><br><span class="line">    dp[3][1]= (k - 2) * dp[2][1];</span><br><span class="line">    if (dp[3][1] &gt;= 10) &#123;</span><br><span class="line">        dp[3][0]++;</span><br><span class="line">        dp[3][2] = dp[3][1] / 10;</span><br><span class="line">        dp[3][1] %= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 4; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0];</span><br><span class="line">        for (int j = 1; j &lt;= dp[i][0]; j++) &#123;</span><br><span class="line">            dp[i][j] = (k - 2) * dp[i - 1][j] + (k - 1) * dp[i - 2][j];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= dp[i][0]; j++) &#123;</span><br><span class="line">            if (dp[i][j] &gt;= 10) &#123;</span><br><span class="line">                dp[i][j + 1] += dp[i][j] / 10;</span><br><span class="line">                dp[i][j] %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int j = dp[i][0] + 1;</span><br><span class="line">        while(dp[i][j]) &#123;</span><br><span class="line">            dp[i][0]++;</span><br><span class="line">            if (dp[i][j] &gt;= 10) &#123;</span><br><span class="line">                dp[i][j + 1] = dp[i][j] / 10;</span><br><span class="line">                dp[i][j] %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= dp[n][0]; i++) &#123;</span><br><span class="line">        dp[n][i] *= k;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= dp[n][0]; i++) &#123;</span><br><span class="line">        if(dp[n][i] &gt;= 10) &#123;</span><br><span class="line">            dp[n][i + 1] += dp[n][i] / 10;</span><br><span class="line">            dp[n][i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[n][dp[n][0] + 1]) dp[n][0]++;</span><br><span class="line">    for (int i = dp[n][0]; i &gt; 0; i--) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-1</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-1/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-1/title5.jpg" alt="title5"></p><a id="more"></a><p>​    动态规划的题目，有时可能你推出了递推式，但是由于时间复杂度过高，或者dp数组过大，而导致TLE或MLE。这时，我们就需要用到动态规划优化</p><p>​    优化有两种，分别是状态优化和转移优化</p><p>​    状态优化用于优化空间，有两种方法，一是去除冗余的状态，二是重新定义状态。去除冗余状态最简单的例子比如滚动数组求解，重定义状态最简单的例子就是01背包，dp{i}{j}代表第i个物品在空间大小为j的背包下能装的最大价值，我们可以状态优化为dp{i}代表空间大小为i的背包能装下的最大价值。</p><p>​    而转移优化是用来优化时间，有以下四类题：一是最长上升子序列O(nlogn)求法，二是单调（队列/栈）优化，三是斜率优化，四是四边形不等式</p><p>​    这时候我们就可以根据不同的题目要求，选择相应的方式进行求解。</p><p>​    具体对应例题将在本博客的后续进行详细解答～</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言碎碎念</title>
      <link href="/2019/01/11/C%E8%AF%AD%E8%A8%80%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2019/01/11/C%E8%AF%AD%E8%A8%80%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/11/C语言碎碎念/title4.jpg" alt="title4"></p><a id="more"></a><ol><li><p>对于if判断句，一些情况下可以进行如下简写：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (falg) &#123;</span><br><span class="line">printf(&quot;ok\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//可简写成以下格式：</span><br><span class="line">flag &amp;&amp; printf(&quot;ok\n&quot;);</span><br></pre></td></tr></table></figure></li><li><p>结构体的比较与复制：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">&#125;</span><br><span class="line">node temp1[4];</span><br><span class="line">node temp2[105][15];</span><br><span class="line"></span><br><span class="line">//结构体数组比较</span><br><span class="line">memcmp(temp1, temp2[0], sizeof(temp1));//代表temp1从temp[0]开始，temp2从temp2[0][0]开始，比较它们的前sizeof(temp1)个字节</span><br><span class="line"></span><br><span class="line">//再比如：</span><br><span class="line">memcmp(temp1 + 1, temp2[2] + 2, sizeof(node)); //代表temp1[1]和temp2[2][2]进行比较</span><br><span class="line"></span><br><span class="line">//结构体复制：</span><br><span class="line">memcpy(temp1, temp2[0], sizeof(temp1));//代表将temp2的前sizeof(temp1)个字节复制给temp1</span><br></pre></td></tr></table></figure></li><li><p>函数数组与函数指针的使用</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f (int n) &#123;</span><br><span class="line">    return n * (n + 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int g (int n) &#123;</span><br><span class="line">    return n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数数组</span><br><span class="line">int (*Func[2])(int) = &#123;</span><br><span class="line">    f, g</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数指针作参</span><br><span class="line">int k (int (*t)(int), val) &#123;</span><br><span class="line">    return t(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数数组指针作参</span><br><span class="line">void k (int (*p[2])(int), int val) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, p[i](val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">k (Func, 3);//即可实现调用</span><br></pre></td></tr></table></figure></li><li><p>函数和数组的关系</p><p> 函数就相当于一个映射，而数组<code>a[i] = t</code>也相当于一个映射</p><p> 因此，函数是压缩的数组，数组是展开的函数。</p><p> 函数比数组更省空间，数组相当于记录式函数</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网--服务器搭建</title>
      <link href="/2019/01/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/科学上网-服务器搭建/title1.jpg" alt="title1"></p><a id="more"></a><p>​    平时用个百度查东西总是出来一堆广告，这时候就无比怀念谷歌。</p><p>​    这里是电脑版搭建服务器实现科学上网的方法，感谢亦泽的教程！！不光电脑版，对于手机安卓，亦泽大佬努力帮助我们科学上网，学习交流请加群972084185</p><p>​    以下为pdf文件，仅支持电脑浏览</p><div class="row">    <embed src="科学上网.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件体系风格</title>
      <link href="/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/软件体系风格/title6.jpg" alt="title6"></p><a id="more"></a><ol><li><p>管道/过滤器体系结构风格：构件被称为过滤器，负责对数据进行加工；连接件被称为管道，是输入数据流和输出数据流之间的通路。每个过滤器是一个独立的个体元素，各个过滤器互不相关；每个过滤器独立完成自己的任务，不同过滤器之间不需要交互。数据输出的最终结果与各个过滤器的执行顺序无关。</p><p>   优点：简单性、支持复用、系统具有可扩展性和可进化性、系统并发性、便于系统分析</p><p>   缺点：系统处理过程时采用批处理方式；不适合用来设计交互式应用系统；因为没有通用的数据传输标准，导致每个过滤器都要花费时间进行添加和去除因解析输入数据和合成数据产生的标记，降低了系统性能，增加了过滤器设计的复杂性；难以进行错误处理</p><p>   使用实例：传统的编译器</p></li></ol><ol start="2"><li><p>面向对象体系结构风格：充分体现了软件工程的模块化、信息隐藏、抽象和重用原则。在这种风格中，对象是一种被称为管理器的构件，负责保持资源的完整性。在对象与对象之间，通过函数调用和过程调用来进行交互。对象抽象可以使构件之间通过黑盒方式进行操作。该结构支持信息隐藏。利用封装技术使对象结构和实现方法对外透明，并将属性和方法包装在一起由对象统一管理</p><p>   优点：对象向外界隐藏自己的详细信息，改变一个对象不影响其他部分；</p><p>  低耦合高内聚使系统更容易分解既相互作用又相互独立的对象集合</p><p> 继承和封装方法为对象复用提供了技术支持</p><p>缺点：一个对象的标识发生改变，必须修改所有显示调用该对象的程序语句；</p></li></ol><p>​         会因为一个对象的标识发生改变而产生连锁反应</p><ol start="3"><li><p>事件驱动体系结构风格：基本思想是系统对外部的行为表现可以通过它对事件的处理来实现。在这种体系结构中构件不再调用过程，而是声明事件。触发一个事件会引起其他构件的过程调用。</p><p>   优点：事件声明者不需要知道哪些构件会响应事件；提高了软件复用能力；</p></li></ol><p>​         便于系统升级</p><p>  缺点：构件放弃了对计算的控制权，完全由系统决定；存在数据传输问题；</p><ol start="4"><li><p>解释器体系结构风格：主要用于构建虚拟机，弥合程序语义和计算机硬件之间的缝隙。适用于系统和用户之间的交互非常复杂的情况。解释器结构包括一个执行引擎和三个储存器。即被解释的程序，执行引擎，被解释程序的当前状态和执行引擎的当前状态四部分组成</p><p> 优点：能够提高应用程序的移植能力和编程语言的跨平台移植能力。</p><p>  实际测试工作可能非常复杂，测试代价高，具有风险性</p><p> 缺点：由于使用了特定语言和自定义操作规则，增加了系统运行的开销</p></li></ol><p>​          难以设计和测试</p><p>​    使用实例：java的编译器；专家系统领域的prolog语言；脚本语言；</p><ol start="5"><li><p>客户机/服务器体系结构风格（C/S）</p><p> 优点：客户机构件和服务器构件分别运行在不同的计算机上，利于分布式数据的组织和处理</p><p> 构件之间的位置相互透明，不必考虑对方的实际存储位置</p><p> 客户机侧重数据的显示和分析,服务器则注重数据的管理</p><p> 构件之间彼此独立且隔离,软硬件环境的配置灵活性高</p><p> 系统功能扩展性强</p><p> 将大规模业务逻辑分布给网络连接的低成本计算机以降低系统开销</p><p> 缺点：开发成本较高。 </p><p> 大部分开发工作都集中在客户机程序的设计,增加了设计的复杂度。 </p><p> 信息内容和形式单一 ；维护费用高</p><p> 两层C/S结构都采用单一服务器,以局域网为中心,数据安全性不高。</p></li><li><p>浏览器/服务器体系结构风格：B/S是C/S的一种实现方式，主要包括浏览器、web服务器和数据库服务器。</p><p> 优点：客户端只需要安装测览器,操作简单,能发布动态信息和静态信息</p><p> 运用HTTP标准协议和统一客户端软件,能够实现跨平台通信。</p><p> 开发成本比较低,只需要维护Web服务器程序和中心数据库。</p><p> 缺点：个性化程度比较低,所有客户端程序的功能都是一样的</p><p> 数据提交一般以页面为单位,动态交互性不强,不利于在线事务处理</p><p> B/S体系结构的可扩展性比较差,系统安全性难以保障。</p><p> B/S结构的应用系统查询中心数据库,其速度要远低于C/S体系结构</p><p> 客户端的数据处理能力差,加重了Web服务器的工作负担,影响系统的整体性能</p></li></ol><ol start="7"><li><p>MVC体系结构（模型-视图-控制器）：被广泛的应用于用户交互程序的设计中用于开发具有人机界面的软件系统。</p><p> 模型：应用程序的核心，封装了问题的核心数据、逻辑关系和计算功能。</p><p> 视图：模型的表示，从模型中获取数据并提供交互界面为用户显示模型信息。</p><p> 控制器：负责处理用户与系统之间的交互，为用户提供操作接口。</p><p> 分离模型、视图和控制器，能够提高设计和使用的灵活性</p></li></ol><p>​    优点：多个视图与一个模型相对应。变化一传播机制确保了所有相关视图都能及时的获取模型变化信息，从而使所有视图和控制器同步，便于为维护。</p><p>​    良好的移植性。模型独立于视图，可以方便的实现不同部分的移植</p><p>​    系统被分割为独立的三部分，功能发生变化时，改变任意一部分就能满足要求。</p><p>​    缺点：增加了系统设计和运行的复杂性；</p><p>​    视图与控制器过于紧密，妨碍了两者的独立重用；</p><p>​    视图访问模型效率比较低；</p><ol start="8"><li><p>分层体系结构风格：将系统划分层次结构，每一层都具有高耦合低内聚的性质。上层通过下层的接口使用下层的功能，下层不能使用上层的功能。利用接口隐藏下层实现细节，有助于抽象设计</p><p>   优点：可以通过将系统分解为一个增量的步骤序列来完成复杂的业务逻辑；</p><p> 每一层的交互和功能影响只存在于上下两层，便于系统功能的扩展；</p></li></ol><p>​         可以通过相邻层的相同接口用不同的方法实现每一层，支持软件资源的复用</p><p>   缺点：并非所有系统都能按照层次进行划分；</p><p>​         很难找到一种合适和正确的层次划分方法；</p><p>​         传输数据时需要经过多个层次导致系统性能下降</p><p>​         多层结构难以调试，往往需要通过一系列的跨层次调用来实现</p><p>  使用实例：分层通信协议、计算机网络协议TCP/IP、操作系统和数据库系统</p><ol start="9"><li><p>C2体系结构风格：基于构件和消息的体系结构风格，包括构件和连接件两种元素，构件之间只能通过连接件相连。核心思想是有限可视化，即构件只能使用上层构件提供的服务而不能感知下层构件的存在。消息只能单项传递，这样有利于系统的维护和发展</p><p>   优点：可以使用任何编程语言来开发构件；具有一定的扩展能力；</p></li></ol><p>​         构件不需要共享地址空间，避免了共享全局变量造成的复杂关系；           具有良好的适应性；能够动态的更新系统的框架设计 </p><ol start="10"><li><p>基于层次消息总线的体系结构风格（HMB）：构件之间通过消息总线进行通信，支持构建的分布式存储和并发运行。包括构建件和消息总线两种软件元素。消息总线包括消息登记、消息分派和传递及消息过滤。</p><p>HMB体系风格结构支持运行时的系统演化，体现在动态删除和删除构件；动态改变构件所响应的消息；消息过滤</p></li><li><p>正交体系结构风格：以垂直线索构件为基础的层次化结构，包括组织和线索。基本思想：按照功能的正交相关性，将系统垂直划分为若干个子系统，每个子系统用一条线索表示，每条线索由多个具有不同层次功能和抽象级别的构件组成。</p><p>优点：结构清晰、便于修改与维护、易于重用</p><p>实例：汽修服务管理的设计方案</p></li></ol><ol start="12"><li><p>公共对象请求代理体系结构风格(CORBA)：由对象管理组织提出，是一套完整的对象技术规范，其核心包括标准语言、接口和协议。在异构分布式环境下，可以实现应用程序之间的交互操作</p><p>优点：实现了客户端程序与服务器程序的分离；</p><p>将分布式计算模式与面向对象技术结合起来，提高软件复用率；</p><p>提供了软件总线机制；</p><p>支持各种编程语言和操作系统，在开发时能更好利用已有的开发成果</p></li></ol><ol start="13"><li><p>数据共享体系结构风格(仓库风格):有两种软件元素：一种是中央数据单元(<br> 资源库)，用于表示系统的当前状态；另一种是相互依赖的构建组，用于对中央数据单元实施操作。两者可以进行信息交互。</p><p> 数据共享体系结构可以分为传统的数据库和黑板。</p></li></ol><p>​    黑板是数据共享体系结构的一个特例，用以解决状态冲突并处理可能存在的不确定性知识源，经常被用于信号处理（语音和模式识别），在自然语言处理领域也有广泛应用（机器翻译和句法分析）</p><p>​    一个典型的黑板系统包括三个部分：</p><p>​    知识源：系统设计的关键，主要的信息来源</p><p>​    中央数据单元：黑板系统的运行完全依赖与中央数据单元的状态变化。</p><p>​    控制单元：控制单元是由中央数据单元的状态驱动的</p><p>​    优点：便于多客户共享大量数据</p><p>​    便于将构建作为知识源添加到系统中来</p><p>​    缺点：对共享数据结构，不同知识源要达成一致</p><p>​        需要同步机制和枷锁机制来保证数据的完整性和统一性，增大了系统设计的复杂度。</p><ol start="14"><li><p>反馈控制环体系结构风格：反馈控制环是一种特定的数据流结构，包括过程，数据元素，控制器。过程控制是连续的，可以利用各种构件和相关规则来设计反馈控制系统，实现各种功能</p><p>典型实例：机器学习</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件体系结构复习</title>
      <link href="/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/软件体系结构复习/title5.jpg" alt="title5"></p><a id="more"></a><ol><li>软件复用技术的出发点是在开发应用系统时不再采用一切从零开始的模式，而是以已有工作为基础，充分利用过去应用开发过程中所积累的经验与知识，将开发的重点集中于当前应用的特有部分</li></ol><ol start="2"><li>软件复用根据复用对象的类型不同，分为代码复用、设计复用、分析复用和测试复用 </li></ol><ol start="3"><li>代码复用：分为目标代码复用和源代码复用。<ol><li>目标代码复用级别最低，历史也最久。目前大多数编程语言的运行支持环境都提供了链接和绑定功能来支持这种复用。</li><li>源代码复用的级别略高于目标代码复用，程序员在编程时可以将一些想要复用的代码段复制到自己的程序中，但这样做往往会产生一种新老代码不匹配的现象。因此，大规模的实现源程序复用只能依靠构件库。构件库包含了大量的可复用构件。例如对象链接及嵌入技术(OLE)，OLE既能在源程序级别上定义构件构造新系统，又能使这些构件在目标代码级别上仍然时一些独立的可复用构件，能够在运行时被灵活的组合到不同的应用系统中。</li></ol></li></ol><ol start="4"><li><p>设计复用比源程序复用的级别更高。设计复用受实现环境的影响较小，因此被复用的机会更多，所需的修改也更少。设计复用的途径有三种：</p><p> (1)从现有系统的设计结果中提取一些可复用的设计元素用于新系统的设计过程中</p><p> (2)把现有系统的全部设计文档在新的软、硬件平台上重新实现，即一个设计用于多个具体实现</p><p> (3)独立于任何具体应用，有计划的开发一些可复用的设计元素</p></li></ol><ol start="5"><li><p>分析复用比设计复用的级别更高，可复用的分析成分是针对问题域的某些事物或某些问题所给出的具有普遍意义的解法。分析复用的途径有三种：</p><p> (1)从现有系统的分析结果中提取可复用的分析成分用于分析新系统</p><p> (2)根据完整的分析文档来产生针对不同软硬件平台和其他实现条件的多项设计结果</p><p> (3)独立于具体应用问题，开发专门用于复用的分析成分</p></li></ol><ol start="6"><li>测试复用分为测试用例复用和测试过程复用。测试复用无法和代码复用、设计复用、分析复用进行级别上的比较，但从信息的形态上来看，大体与代码复用的级别相当</li></ol><ol start="7"><li><p>软件复用根据信息复用的方式不同，可以分为黑盒复用和白盒复用。</p><p> 黑盒复用是指对已有软件结构不做任何修改，直接进行复用，是最理想的复用方式</p><p> 白盒复用是指已有软件结构不能完全满足用户要求，需要进行适应性修改后才能使用。是最常用的复用方式</p></li><li><p>软件复用的实现技术一般包括组装和生成两种类型</p><p> 在组装技术中，软件构件是复用的基石。构件在软件开发过程中类似于硬件中的芯片，通过组装可以形成更大的构件。构件是对某一函数、过程、子程序、数据类型及算法等可复用软件成分的抽象。对构件进行描述时应选择即不依赖具体硬件平台也不依赖具体编程语言的抽象描述语言，这样可以避免开发的构件因机器和语言的限制导致复用性降低</p><p> 在生成技术中，由程序生成器完成对软件结构模式的复用。生成器导出的模式相当于种子，从中可生长出新的专用软件构件。生成技术利用可复用模式，通过生成程序产生一个新的程序或程序段，产生的程序即是模式的实例。可复用的模式分为代码模式和规则模式。</p></li></ol><ol start="9"><li><p>基于构件的软件开发</p><p> 基本思想：将用户需求分解为一系列的子功能构建，在开发过程中不必重新设计这些基本功能模块，只需要从现有构件库中寻找合适的构件来组装应用系统</p><p> 优点：(1)大大提高软件的可复用性和开发效率</p><p> (2)使产品在客户需求吻合度、上线时间和质量上领先于同类产品</p><p> (3)使产品的开发与维护变得简单</p><p> (4)客户可以随时应对商业环境和IT技术的变化，以实现快速定制</p><p> 基本目标：以组装的方式生成新应用系统，组装以形式上独立的构件服务为基础进行</p><p> 具备要素：构件组装的应用程序、独立服务、公共构件基础设施和通用服务</p></li></ol><ol start="10"><li><p>软件构件技术的发展历程</p><p>20世纪60年代初：提出了结构化分析与设计方法。意为通过工程化方法，规范开发过程，使软件系统具有良好的结构，即产生可拼装和裁剪的模块化结构。</p><p>20世纪80年代末：出现了面向对象编程技术。其基本思想使使用对象来描述客观事物，对象封装了属性和操作方法。</p><p>20世纪90年代：软件构件技术得到迅速发展。强调开发过程应融入构件化技术和体系结构技术，要求开发的系统具备易理解，自适应，互操作，可扩展和可复用的特点。</p></li></ol><ol start="11"><li>为什么要建立软件体系结构：建立软件体系结构是整个开发过程的关键性步骤，设计一个完整的框架结构和一套构造规则是项目开发成功的关键。软件体系结构的设计对于大型项目开发的成败起着举足轻重的作用。</li></ol><ol start="12"><li><p>软件体系结构研究在整个开发过程中占有重要地位的原因是/为什么要研究软件体系结构</p><p>(1)软件体系结构可以作为项目开发的指导方针</p><p>(2)软件体系结构是设计过程的开端，体现了系统最早期的设计决策，对软件生命周期的影响很大</p><p>(3)软件体系结构具有可复用性</p><p>(4)促进系统的理解</p><p>(5)软件体系结构描述除了提供清晰精确的文档之外，还对文档进行了一致性分析和依赖性分析，暴露其中隐藏的各种问题</p><p>(6)构件复用是建立体系结构良好的软件系统的出发点</p><p>(7)软件体系结构规定了系统演化的方向，提供了系统管理的有效手段</p><p>(8)软件体系结构对系统演化具有重要的意义</p><p>(9)软件体系结构影响着开发组织和维护组织的结构</p></li></ol><ol start="13"><li><p>领域设计</p><p>步骤：(1)将依赖关系从现实中分离，使之容易辨认和修改，以适应新的需求</p></li></ol><p>​         (2)分层框架，使软件资源可以按照特定应用、操作系统及硬件平台的</p><p> 要求分层</p><p>​         (3)在每一层寻找适合领域设计框架的通用软件资源，并以此为基础寻</p><p>​           找其他基础性资源</p><p>   复用元素的选择原则：</p><p>(1)在软件开发和维护过程中，使用最频繁的元素</p><p>​        (2)提供最大利益的元素</p><p>​       (3)用于创建和维护对本公司具有重要意义的策略性软件元素</p><p>​       (4)复用消费者所需要的软件元素</p><ol start="14"><li>软件产品线包括核心资源开发，软件项目开发和技术协调组织管理</li></ol><p>核心资源开发被称为领域工程，利用核心资源的软件项目开发被称为应用工程。核心资源开发的目的是创建软件项目批量生产和大粒度复用的基础设施。核心资源开发的输出包括三点：产品线范围、核心资源、开发计划</p><p>软件项目开发活动依赖于核心资源开发活动的输出结果(产品线范围、核心资源和开发计划)以及各个项目的实际需求。软件项目开发活动的输入包括四点：项目实际需求、产品线范围、用于创建该项目的核心资源、开发计划。</p><p>技术协调和组织管理对于软件产品线的成功至关重要。技术协调负责监视核心资源开发活动和软件项目开发活动。组织管理必须建立合适的组织机构，确保各组织单位得到充足的资源。此外还需要建立一个实时性的调整计划，并对开发活动中涉及的档案进行有效的管理。尤其是开发进度和预算计划</p><p>三者的关系：核心资源开发与软件项目开发之间存在反馈循环，核心资源促进了应用系统的创建，新应用系统的开发又更新了核心资源，从应用系统个性中总结出的共性知识又将丰富产品线的核心资源。核心资源开发和软件项目开发都需要人力财力物理的投入，因此需要持久、强力有远见的组织管理。在产品线开发过程中，三大活动不断进行迭代循环，促进产品线的基础设施不断完善，开发的应用系统的质量不断提高，提高了领域开发的效率。</p><ol start="15"><li>场景：是对于风险承担者与系统进行交互的简短描述。在评估过程中，使用场景可以将那些模糊的、不适用于分析的质量属性需求描述转换为具体的、易于理解的表达形式</li></ol><p>场景分为直接场景和间接场景。直接场景在设计体系结构到系统构造的过程中使用，代表系统的外部视角和观点。间接场景在对现有体系结构进行改变和演化的过程中使用</p><p>​    场景的作用：</p><p>(1)场景可以覆盖系统的若干需求，并使抽象的需求可操作化</p><p>​        (2)在系统开发的早期，场景可以用来构造软件体系结构的雏形</p><p>​        (3)场景可以指导从软件体系结构到系统实际建造的过渡过程</p><p>​        (4)场景提供了对需求更深刻的理解，帮助用户认识软件产品并做出采</p><p>购决策。还可以帮助用户完善软件文档，在软件体系结构层面实现软</p><p>件的可跟踪性</p><p>​        (5)场景在系统建造过程中，可用来控制系统风险并对质量目标具体化</p><p>​        (6)软件体系结构在一个系统的软件生命周期中可能需要变动，场景成为分析变动的必要性及评估体系结构在更新后的合理性等方面的基础</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件质量与保证复习</title>
      <link href="/2019/01/10/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/10/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/软件质量与保证复习/title3.jpg" alt="title3"></p><a id="more"></a><p>第一章</p><p>1、软件质量保证(SQA)是一种应用于整个软件过程的保护性活动，它包括、</p><p>   (1)一种质量管理方法</p><p>   (2)有效的软件工程技术</p><p>   (3)在整个软件过程中采用的正式技术复审</p><p>   (4)一种多层次的测试策略</p><p>   (5)对软件文档及其修改的控制</p><p>   (6)保证软件遵从软件开发标准的流程</p><p>   (7)度量和报告机制</p><p>2、我们应该从哪几个方面考虑软件质量</p><p>   (1)软件结构方面   (2)功能与性能方面   (3)开发标准与文档方面</p><p>3、IEEE对软件质量的定义</p><p>   (1)系统、部件或过程满足规定需求的程度</p><p>   (2)系统、部件或过程满足顾客或客户需要或期望的程度</p><p>   该定义相对客观，强调了产品（或服务）和客户/社会需求的一致性</p><p>4、ANSI关于软件质量的定义</p><p>   与软件产品满足规定的和隐含的需求的能力有关的特征和特性的全体</p><p>   (1)软件产品中能满足用户给定需求的全部特性的集合</p><p>   (2)软件具有所期望的各种属性组合的程度</p><p>   (3)用户主观得出的软件是否满足其综合期望的程度</p><p>   (4)决定所用软件在使用中将满足其综合期望程度的软件合成特性</p><p>5、软件质量保证的目的：</p><p>   (1)通过对软件产品和活动进行评审和审计来验证软件是否符合标准</p><p>   (2)软件质量保证组在项目一开始时就一起建立计划、标准和过程，这些使软件项目满足机构方针的需求</p><p>6、软件测试是使用人工或自动手段来运行或测定某个系统的过程，检验他是否满足规定的需求或者弄清预期结果与实际结果之间的差别。</p><p>第二章</p><p>7、软件质量控制是一组由开发组织使用的程序和方法，使用他可在规定的资金投入和时间限制的条件下，提供满足客户质量要求的软件产品并持续不断地改善开发过程和开发组织自身，以提高将来生产高质量软件产品的能力。</p><p>8、软件质量控制的基本方法：目标问题度量法、风险管理法</p><p>第三章</p><p>9、软件过程度量中的常见问题：度量太多太频繁、度量太少太迟、度量了不正确的事物和属性、度量的定义不精确、收集了数据却没有利用、错误的解释度量数据、自动化工具欠缺</p><p>10、软件配置管理是一种标识、组织和控制修改的技术。作为CMM2级的一个关键域，在整个软件的开发活动中占有重要位置，是贯穿于整个软件过程中的保护性活动。用于标识变化、控制变化、保证变化被适当的实现、向其他可能有兴趣的人员报告变化</p><p>11、一个软件研发项目可以划分为三阶段：计划阶段、开发阶段和维护阶段</p><p>第四章</p><p>12.软件可靠性评价准则</p><p>   (1)模型拟合性</p><p>   (2)模型预计程度</p><p>   (3)模型偏差</p><p>   (4)模型偏差趋势</p><p>   (5)模型噪声</p><p>   注：345指标值越小，模型的适应性越好</p><p>13、提高软件可靠性的方法和技术</p><p>   (1)建立以可靠性为核心的质量标准。软件质量分为产品质量(软件质量、文档质量)和过程质量。确定划分的个开发过程的质量度量</p><p>   (2)选择开发方法</p><p>   (3)软件重用，包括开发过程重用、软件构件重用、知识重用</p><p>   (4)使用开发管理工具</p><p>   (5)加强测试，测试方法包括走查、机器测试、程序证明或交替程序显示、模拟测试、设计审查</p><p>   (6)容错设计：容错设计可以避免故障，不让差错和缺陷潜入软件</p><p>第五章</p><p>14、能力成熟度模型CMM为软件过程改进提供了一个框架，将整个软件改进过程分为5个成熟度等级，用于定义一个有序的尺度，用于衡量组织软件过程成熟度评价其软件过程能力</p><table><thead><tr><th>等级</th><th>特征</th><th>关键域</th></tr></thead><tbody><tr><td>初始级</td><td>软件过程混乱无序、对过程几乎没有定义、依靠个人才能成功、反应式管理方式</td><td></td></tr><tr><td>可重复级</td><td>建立基本的项目管理、制定必要的项目管理、能利用以前的类似项目取得成功</td><td>需求管理、项目计划、项目跟踪和监控、软件子合同管理、软件配置管理、软件质量保证</td></tr><tr><td>已定义级</td><td>将软件管理和过程文档化标准化、综合成标准软件过程并用于所有的软件开发</td><td>组织过程定义、组织过程焦点、培训大纲、软件集成管理、软件产品工程、组织协调、专家评审</td></tr><tr><td>已管理级</td><td>通过收集软件过程、产品质量的详细度量对两者进行理解和控制</td><td>定量的软件过程管理   定量的产品质量管理</td></tr><tr><td>优化级</td><td>软件过程的量化反馈和新的思想和技术促进过程的不断改进</td><td>缺陷预防、过程变更、   技术变更管理</td></tr></tbody></table><p> 15、CMM/CMMI在质量保证中的四个目标，质量保证实现的具体实施方法</p><p>目标：(1)软件质量保证活动是有计划的‘</p><p>​          (2)软件产品和活动与适用的标准、规程和需求的符合性要得到客观验证      (3)相关的小组和个人要被告知软件质量保证的活动和结果</p><p>(4)高级管理者处理在软件项目内部不能解决的不符合问题</p><p>具体实施方法：(1)定义项目类型和软件周期</p><p>​                  (2)建立SQA计划，确定项目审计内容</p><p>(3)生成SQA报告</p><p>(4)审计SQA报告     (5)独立汇报</p><p>第六章</p><p>16、为什么需要软件评审</p><p>   (1)提高项目的生产率，早期发现错误，减少返工时间，减少测试时间</p><p>   (2)改善软件的质量</p><p>   (3)在评审过程中，使开发团队的其他人员更熟悉产品和开发过程</p><p>   (4)通过评审，标志着软件开发一个阶段的完成</p><p>   (5)生产出更加容易维护的软件，增加对所开发软件的理解</p><p>17、评审的方法：特别检查、轮查、走查、团队评审、检视</p><p>18、评审的内容：管理评审、技术评审、文档评审、过程评审</p><p>19、文档评审的内容和检查列表、</p><p>内容：需求评审、设计评审、代码评审、质量验证评审</p><p>检查列表：正确性、完整性、一致性、有效性、易测性、模块化、清晰性、可行性、可靠性、可追溯性</p><p>20、评审会议流程</p><p>   (1)准备评审会议，提前发送通知让成员对会议内容有所准备，确保会议召开</p><p>   (2)召开评审会议，流程为评审预备、评审开始、评审决议、评审结束</p><p>   (3)跟踪和分析评审结果，验证作者是否恰当的解决了会议上列出的问题，修改的过程中有没有注入新的缺陷，测量评审的效果</p><p>第七章</p><p>21、全面质量管理和ISO 9000的异同</p><p>   相同之处</p><p>   (1)两者的管理理论和统计理论一致，即产品质量形成于产品全过程，质量体系贯穿于质量形成的全过程</p><p>   (2)实现方法相同，都是PDCA质量环运行模式</p><p>   (3)两者都要求对质量实施系统化的管理，都强调一把手对质量的管理</p><p>   (4)两者的最终目的一致，都是为了提高产品质量，满足顾客的需求，都强调任何一个过程都是可以不断改进和改善的</p><p>   不同之处</p><p>   (1)两者的期间目标不一致：全面质量管理的目标是改变现状，其作业只限一次。ISO9000的目标是维持标准现状，目的是尽量减少实际结果与标准值的偏差。    </p><p>   (2)二者的工作中心不同。全面质量管理以人为中心，ISO9000以标准为中心。</p><p>   (3)两者执行标准和检查方式不同。实施全面质量管理的企业所制定的标准是企业结合滋生特点制定的自我约束的管理体制，其检查方主要是企业内部人员，检查方法是考核和评估。ISO9000系列标准是国际公认的质量管理体系标准，它是世界各国共同遵守的准则。</p><p>22、质量屋结构图</p><p><img src="/2019/01/10/软件质量与保证复习/1.png" alt="1"></p><p>23、6σ是寻求同时增加顾客满意和企业经济增长的经营战略途径，一种全新的管</p><p>理企业。核心是追求零缺陷生产，防范产品责任风险、降低成本、提高生产率和市场占有率、提高顾客满意度和忠诚度</p><p>24、6σ管理的优点</p><p>   (1)提升企业管理的能力：降低管理流程浪费，简化管理流程，降低材料成本</p><p>   (2)节约企业运营的成本</p><p>   (3)增加顾客价值</p><p>   (4)改进服务水平</p><p>   (5)形成积极向上的企业文化</p><p>25.DMAIC模式的5步循坏改进法</p><p>   (1)定义：明确问题、目标和流程</p><p>   (2)评估：找到导致问题产生的关键原因，明确问题的核心所在</p><p>   (3)分析：对原因进行进一步分析，确认他们之间是否存在因果关系</p><p>   (4)改进：挑选最理想的改进方案付诸实施</p><p> (5)控制：根据控制标准，及时解决各种问题，使改进过程不偏离预定的轨道</p><p>第九章</p><p>26、软件测试的原则</p><p>   (1)在整个软件开发过程中尽早地和不断地进行软件测试</p><p>   (2)在开始测试时，不应默认程序中不存在错误</p><p>   (3)设计测试用例，要给出测试的预期结果</p><p>   (4)测试工作应避免由系统开发人员或开发机构本身来测试</p><p>   (5)对合理和不合理的输入都要进行测试</p><p>   (6)重点测试错误群集的程序区段</p><p>   (7)除检查系统是否完备外，还要检查程序功能是否有多余</p><p>   (8)用穷举测试是不可能的</p><p>   (9)长期完整保留测试用例和测试文件，直至该软件产品被废弃为止</p><p>27、软件测试过程：单元测试-集成测试-系统测试-验收测试-回归测试贯穿整个测试过程</p><p>第十二章</p><p>28、软件缺陷是存在于软件之中的那些不希望或不可接受的偏差</p><p>29、软件缺陷的产生原因：程序编写错误、未按照规定编写代码、软件越来越复杂、开发人员的态度、沟通问题、需求变更过于频繁、进度压力、管理失误</p><p>30、软件缺陷特征：缺陷的发生都是有原因的、缺陷的重现性、缺陷的积累性放大性、缺陷的修复可能引进新的缺陷</p><p>31、软件缺陷属性：缺陷标识、缺陷类型、缺陷严重程度、缺陷优先级、缺陷状态、缺陷起源、缺陷来源、缺陷根源</p><p>32、报告软件缺陷的基本原则：软件缺陷的尽快报告、有效的描述软件缺陷</p><p>第十三章</p><p>33、集成测试与单元测试和系统测试的区别</p><p>   (1)范围不同</p><p>单元测试主要关注模块的内部</p><p>集成测试主要关注穿越接口的数据、信息是否正确，是否会丢失</p><p>集成测试仅针对软件系统展开测试</p><p>系统测试包括软件系统以及与软件系统交互的所有硬件和软件平台</p><p>   (2)依据不同</p><p>单元测试针对详细设计做测试，依据是详细设计说明书</p><p>集成测试针对概要设计做测试，依据是概要设计说明书</p><p>系统测试针对需求做测试，依据是需求规格说明书及行业标准</p><p>34、几种集成测试实施方案的比较</p><p>   (1)非增量式集成测试：先分散测试，然后集中起来再一次完成集成测试。</p><p>缺点：如果模块的接口处存在错误，会在集成测试时一下子暴露出来；</p><p>难以判断出错的原因和位置，改正错误时容易引入新的错误。</p><p>   (2)自顶向下的优点：逐步求精，一开始便能让测试者看到系统的框架。</p><p>缺点:被调用的模拟子模块可能不能反映真实情况，导致测试行不充分。</p><p>   (3)自底向上的优点：即使数据流没有完全形成，测试数据也很容易生成。</p><p>缺点：只有模块全部被装进去，才能看到整个系统的框架。</p><p>   (4)三明治集成测试：自底向上和自顶向下相结合，有助于尽早发现缺陷和提高工作效率。</p><p>   (5)核心系统先行集成测试：能保证一些重要功能和服务的实现，对于快速软件开发很有效果。但要求系统明确区分核心部件和外围软件部件。</p><p>   (6)高频集成测试：特点是集成次数频繁，必须借助自动化工具来实现。</p><p>35、集成测试的过程分为三个阶段</p><p>   (1)计划阶段：完成集成测试计划，制订集成测试策略</p><p>   (2)计划实现阶段：建立继承测试环境，完成测试计划和开发</p><p>   (3)执行评估阶段：执行集成测试用例，记录和评估测试结果</p><p>第十四章</p><p>36、系统测试主要方法：性能测试、强度测试、安全性测试、兼容性测试、恢复测试、用户图形界面测试、安装测试、可靠性测试、配置测试、可用性测试、文档资料测试、网站测试</p><p>37、性能测试就是对软件的运行性能指标进行测试，判断系统集成之后在实际的使用环境下能否稳定可靠的运行。</p><p>性能测试中主要考虑时间性能和空间性能两方面</p><p>目标：判断被测系统是否满足预期的性能需求；判断系统的性能表现</p><p>第十五章</p><p>38、测试文档的撰写</p><p>   (1)测试计划：分为作为产品的测试计划和作为工具的测试计划</p><p>​      测试计划包括：概要、目标和标准、测试的领域、测试方法描述、</p><p>测试进度表、测试资源、配置范围、测试工具</p><p>   (2)测试规范：包括背景信息、测试特性、功能考虑、测试考虑</p><p>   (3)测试案例和测试报告</p><p>   (4)软件缺陷报告：包括软件缺陷名称、待测软件版本、优先级与严重性、</p><p>详细测试步骤、缺陷造成的后果、预计结果、其他信息</p><p>39、一个好的文档具有以下三点：提高可用性、提高可靠性、降低支持费用</p><p>40、调试方法：蛮力法、回溯法、原因排除法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件质量保证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究rand()随机数</title>
      <link href="/2019/01/01/%E6%8E%A2%E7%A9%B6rand-%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2019/01/01/%E6%8E%A2%E7%A9%B6rand-%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/探究rand-随机数/title2.jpg" alt="title2"></p><a id="more"></a><p>####关于srand()函数</p><p>​    srand（）函数用于设置随机种子，一般参数为time（0）作为随机种子</p><h4 id="关于time-函数"><a href="#关于time-函数" class="headerlink" title="关于time()函数"></a>关于time()函数</h4><p>​    time（0）函数返回当前时间戳（以秒为单位，从1900.01.01开始，时间戳是32位整数，所以2036年就会失效）</p><p>####关于rand()函数</p><p>​    rand（）会随机生成一个整型(实质是一套算法，若种子相同，一套算法算出来的东西也相同)</p><h4 id="关于rand-函数的随机性"><a href="#关于rand-函数的随机性" class="headerlink" title="关于rand()函数的随机性"></a>关于rand()函数的随机性</h4><p>​    由于rand()函数也是一种算法，传入相同的随机种子，生成的数也是相同的，所以广义上来说，随机数并不是真正的随机，是一种伪随机。</p><p>​    一个随机算法，需要保证在规定的范围内的每一个数都有可能出现且出现的概率是相同的，根据传入的随机种子不同，随机数也不同。</p><p>####rand()函数算法如何实现0～2^32 - 1均匀随机的出现？</p><p>​    利用费马定理：如果p是一个素数，a^(φ(p)) % p = 1(当a与p互素时)</p><p>​    具体见代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 100000</span><br><span class="line"></span><br><span class="line">//100000以内的素数数组</span><br><span class="line">int prime[MAX_N + 5] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">//my_seed是一个随机种子，rand()算法核心的两个参数a_num, b_num,</span><br><span class="line">//利用my_seed = my_seed * a_num % b_num能够保证my_seed在1～b_num - 1均匀的出现</span><br><span class="line">static int my_seed = 37, a_num, b_num;</span><br><span class="line"></span><br><span class="line">//自定义rand()函数</span><br><span class="line">int my_rand() &#123;</span><br><span class="line">#define i my_seed</span><br><span class="line">    do &#123;</span><br><span class="line">        //rand()算法的核心，该算式能够保证i在1～9999均匀的出现</span><br><span class="line">        i = i * a_num % b_num;</span><br><span class="line">    &#125; while (i &gt; 10000);</span><br><span class="line">    return i;</span><br><span class="line">#undef i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//至于a_num和b_num如何得到，下面是求解过程</span><br><span class="line"></span><br><span class="line">//预处理全部素数</span><br><span class="line">void init_prime() &#123;</span><br><span class="line">    for (int i = 2; 2 * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        if (!prime[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0]; j++) &#123;</span><br><span class="line">            if (i * prime[j] &gt; MAX_N) break;</span><br><span class="line">            prime[i * prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速幂函a^b % c</span><br><span class="line">int quick_mod(int a, int b, int c) &#123;</span><br><span class="line">    int ans = 1, temp = a % c;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans *= temp;</span><br><span class="line">        temp *= temp;</span><br><span class="line">        temp %= c;</span><br><span class="line">        ans %= c;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//由于b为质数且a,b互质，根据费马定理小定理a^(φ(p)) % p = 1，也就是a^(p - 1) % p = 1</span><br><span class="line">//因此我们只需要确定p - 1的全部约数不为1，即确定a^i是循环节为p - 1的算式</span><br><span class="line">int get_len(int a, int b) &#123;</span><br><span class="line">    for (int i = 1; i &lt; b - 1; i++) &#123;</span><br><span class="line">        if ((b - 1) % i) continue;</span><br><span class="line">        if (quick_mod(a, i, b) == 1) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return b - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_a_and_b(int *a, int *b) &#123;</span><br><span class="line">    //找到一个大于13000的素数b_num</span><br><span class="line">    for (int i = 1; i &lt;= prime[0]; i++) &#123;</span><br><span class="line">        *b = prime[i];</span><br><span class="line">        if (prime[i] &gt; 13000) break;    </span><br><span class="line">    &#125;</span><br><span class="line">    //根据b_num找到符合条件的a_num</span><br><span class="line">    for (int i = 2; i &lt; *b; i++) &#123;      </span><br><span class="line">        if (get_len(i, *b) != *b - 1) continue;</span><br><span class="line">        *a = i;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对a（也就是a_num），b(也就是b_num)进行验证</span><br><span class="line">void check(int a, int b) &#123;</span><br><span class="line">    a_num = a, b_num = b;</span><br><span class="line">    int vis[10001] = &#123;0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        int temp = my_rand();</span><br><span class="line">        if (vis[temp]) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[temp] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; OK&quot; &lt;&lt; endl;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init_prime();</span><br><span class="line">    int a, b;</span><br><span class="line">    get_a_and_b(&amp;a, &amp;b);</span><br><span class="line">    check(a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler56</title>
      <link href="/2019/01/01/Euler56/"/>
      <url>/2019/01/01/Euler56/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler56/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><p>一古戈尔（10100）是一个巨大的数字：一后面跟着一百个零。100100则更是无法想像地巨大：一后面跟着两百个零。然而，尽管这两个数如此巨大，各位数字和却都只有1。</p><p>若a, b &lt; 100，所有能表示为ab的自然数中，最大的各位数字和是多少？</p><p>思路：</p><p>​    一道考验基操的题——大数乘法。打一遍当热热手～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void mul (int *num, int val) &#123;</span><br><span class="line">    for (int i = 1; i &lt;= num[0]; i++) &#123;</span><br><span class="line">        num[i] *= val;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= num[0]; i++) &#123;</span><br><span class="line">        if (num[i] &gt;= 10) &#123;</span><br><span class="line">            num[i + 1] += num[i] / 10;</span><br><span class="line">            num[i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(num[num[0] + 1]) &#123;</span><br><span class="line">        num[0] ++;</span><br><span class="line">        num[num[0] + 1] = num[num[0]] / 10;</span><br><span class="line">        num[num[0]] %= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int mx = 0;</span><br><span class="line">    for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">        int num[205] = &#123;1, 1&#125;;</span><br><span class="line">        for (int j = 1; j &lt;= 100; j++) &#123;</span><br><span class="line">            int k = 0;</span><br><span class="line">            mul(num, i);</span><br><span class="line">            for (int p = 1; p &lt;= num[0]; p++) &#123;</span><br><span class="line">                k += num[p];</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &gt; mx) &#123;</span><br><span class="line">                mx = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, mx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模版 </tag>
            
            <tag> 大数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler53</title>
      <link href="/2019/01/01/Euler53/"/>
      <url>/2019/01/01/Euler53/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler53/title6.jpg" alt="title6"></p><a id="more"></a><p>题意：</p><p>从五个数12345中选择三个恰好有十种方式，分别是：</p><p>123、124、125、134、135、145、234、235、245和345</p><p>在组合数学中，我们记作：5C3 = 10。</p><p>一般来说，</p><p>nCr=n!r!(n−r)!n!r!(n−r)!，其中r ≤ n，n! = n×(n−1)×…×3×2×1，且0! = 1。</p><p>直到n = 23时，才出现了超出一百万的组合数：23C10 = 1144066。</p><p>若数值相等形式不同也视为不同，对于1 ≤ n ≤ 100，有多少个组合数nCr超过一百万？</p><p>思路：</p><p>​    由于当n的取值范围小于等于100，因此可以利用杨辉三角来做～，开两个二维数组，当值小于1000000时，用dp【n】【m】来存储C（n，m）的值，当值大于1000000时，直接用book【n】【m】=1标记一下，推导方程见代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll dp[105][105] = &#123;0&#125;;</span><br><span class="line">bool book[105][105] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            if (j == 0 || j == i) dp[i][j] = 1;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (book[i - 1][j - 1] || book[i - 1][j]) &#123;</span><br><span class="line">                    sum ++;</span><br><span class="line">                    book[i][j] = 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span><br><span class="line">                    if (dp[i][j] &gt; 1000000) &#123;</span><br><span class="line">                        book[i][j] = 1;</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler93</title>
      <link href="/2019/01/01/Euler93/"/>
      <url>/2019/01/01/Euler93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler93/title8.jpg" alt="title8"></p><a id="more"></a><p>题意：</p><p>使用集合{1, 2, 3, 4}中每个数字恰好一次以及(+, −, *, /)四则运算和括号，可以得到不同的正整数。</p><p>例如，</p><p>8 = (4 <em> (1 + 3)) / 2<br>14 = 4 </em> (3 + 1 / 2)<br>19 = 4 <em> (2 + 3) − 1<br>36 = 3 </em> 4 * (2 + 1)</p><p>注意不允许直接把数字连起来，如12 + 34。</p><p>使用集合{1, 2, 3, 4}，可以得到31个不同的数，其中最大值是36，以及1到28之间所有的数。</p><p>若使用包含有四个不同数字a &lt; b &lt; c &lt; d的集合可以得到从1到n之间所有的数，求其中使得n最大的集合，并将你的答案写成字符串：abcd。</p><p>思路：</p><p>​    由于有（）所以不知道如何插空，因为后缀表达式不含括号，这时候我们可以将算式转化为后缀表达式。只要满足前i位运算符 &lt; 数字个数这一条件，把全部组合计算一遍即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int vis[10005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">double calc (char * result, int n) &#123;</span><br><span class="line">    stack&lt;double&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (result[i] &lt;= &apos;9&apos; &amp;&amp; result[i] &gt;= &apos;0&apos;)&#123;</span><br><span class="line">            s.push(result[i] - &apos;0&apos;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        double a = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        double b = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        switch(result[i]) &#123;</span><br><span class="line">            case &apos;+&apos;: &#123;</span><br><span class="line">                s.push (a + b);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &apos;-&apos;: &#123;</span><br><span class="line">                s.push (b - a);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &apos;*&apos;: &#123;</span><br><span class="line">                s.push (a * b);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &apos;/&apos;: &#123;</span><br><span class="line">                s.push (b / a);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define EPS 1e-7</span><br><span class="line"></span><br><span class="line">void dfs(char * result, int k, int a, int b, int *num) &#123;</span><br><span class="line">    if (k == 7) &#123;</span><br><span class="line">        double ret = calc (result, 7);</span><br><span class="line">        if (ret &gt; 0 &amp;&amp; fabs(ret - floor(ret)) &lt;= EPS) &#123;</span><br><span class="line">            vis[(int)ret] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (b + 1 &lt; a) &#123;</span><br><span class="line">        result[k] = &apos;+&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">        result[k] = &apos;-&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">        result[k] = &apos;*&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">        result[k] = &apos;/&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">    &#125;</span><br><span class="line">    if (a &lt; 4) &#123;</span><br><span class="line">        result[k] = num[a] + &apos;0&apos;;</span><br><span class="line">        dfs(result, k + 1, a + 1, b, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int mx = 0;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt;10; j++) &#123;</span><br><span class="line">            for (int p = j + 1; p &lt; 10; p++) &#123;</span><br><span class="line">                for (int q = p + 1; q &lt; 10; q++) &#123;</span><br><span class="line">                    memset(vis, 0, sizeof(vis));</span><br><span class="line">                    int num[4] = &#123;i, j, p, q&#125;;</span><br><span class="line">                    char result[7] = &#123;0&#125;;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        dfs(result, 0, 0, 0, num);</span><br><span class="line">                    &#125;while(next_permutation(num, num + 4));</span><br><span class="line">                    int tt = 1;</span><br><span class="line">                    for (; vis[tt]; tt++);</span><br><span class="line">                    if (mx &lt; tt) &#123;</span><br><span class="line">                        mx = tt;</span><br><span class="line">                        flag = i * 1000 + j * 100 + p * 10 + q;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, flag);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler72</title>
      <link href="/2019/01/01/Euler72/"/>
      <url>/2019/01/01/Euler72/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler72/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>考虑形如n/d的分数，其中n和d均为正整数。如果n &lt; d且其最大公约数为1，则该分数称为最简真分数。</p><p>如果我们将d ≤ 8的最简真分数构成的集合按大小升序列出，我们得到：</p><p>1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8</p><p>可以看出该集合中共有21个元素。</p><p>d ≤ 1,000,000的最简真分数构成的集合中共有多少个元素？</p><p>思路：</p><p>​    就是求前1000000项的欧拉函数和，套用线性筛模版求欧拉函数即可。记住三个原理：1.当n为素数，φ(n) = n - 1</p><p>​    2.当p为素数且p，q互素，φ(p✖️q） = φ(p)✖️φ(q)</p><p>​    3.当p为素数且p，q不互素，φ(p✖️q） = p✖️φ(q)</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 1000000</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">int prime[N + 5] = &#123;0&#125;;</span><br><span class="line">int book[N + 5] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            book[i] = i - 1;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt;= N; j++) &#123;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                book[i * prime[j]] = book[i] * prime[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                book[i * prime[j]] = book[i] * book[prime[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ll sum = 0;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        sum += book[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    答案为303963552391</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler61</title>
      <link href="/2019/01/01/Euler61/"/>
      <url>/2019/01/01/Euler61/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler61/title12.jpg" alt="title12"></p><a id="more"></a><p>三角形数、正方形数、五边形数、六边形数、七边形数和八边形数统称为多边形数。它们分别由如下的公式给出：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>三角形数</td><td>P3,n=n(n+1)/2</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>正方形数</td><td>P4,n=n2</td><td>1, 4, 9, 16, 25, …</td></tr><tr><td>五边形数</td><td>P5,n=n(3n−1)/2</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>六边形数</td><td>P6,n=n(2n−1)</td><td>1, 6, 15, 28, 45, …</td></tr><tr><td>七边形数</td><td>P7,n=n(5n−3)/2</td><td>1, 7, 18, 34, 55, …</td></tr><tr><td>八边形数</td><td>P8,n=n(3n−2)</td><td>1, 8, 21, 40, 65, …</td></tr></tbody></table><p>由三个4位数8128、2882、8281构成的有序集有如下三个有趣的性质。</p><ol><li>这个集合是循环的，每个数的后两位是后一个数的前两位（最后一个数的后两位也是第一个数的前两位）。</li><li>每种多边形数——三角形数（P3,127=8128）、正方形数（P4,91=8281）和五边形数（P5,44=2882）——在其中各有一个代表。</li><li>这是唯一一个满足上述性质的4位数有序集。</li></ol><p>存在唯一一个包含六个4位数的有序循环集，每种多边形数——三角形数、正方形数、五边形数、六边形数、七边形数和八边形数——在其中各有一个代表。求这个集合的元素和</p><p>思路：</p><p>​    模块1：找出全部1000～9999的x边形数n，并把n存到g【x】【n / 100】动态数组中</p><p>​    模块2：对数组{3, 4, 5, 6, 7, 8}进行全排列，并进行dfs</p><p>​    详细见代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Triangle (int n) &#123;</span><br><span class="line">    return n * (n + 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Square(int n ) &#123;</span><br><span class="line">    return n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Pentagonal (int n ) &#123;</span><br><span class="line">    return n * (3 * n - 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Hexagonal (int n )&#123;</span><br><span class="line">    return n * (2 * n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Heptagonal (int n) &#123;</span><br><span class="line">    return n * (5 * n - 3) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Octagonal (int n) &#123;</span><br><span class="line">    return n * (3 * n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int (*FuncList[6])(int) = &#123;</span><br><span class="line">        Triangle , Square, Pentagonal, Hexagonal,Heptagonal, Octagonal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;g[10][105];</span><br><span class="line">vector&lt;int&gt;gg[10];</span><br><span class="line"></span><br><span class="line">void model1 () &#123;</span><br><span class="line">    for (int i = 1; ; i++) &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            int t = FuncList[j](i);</span><br><span class="line">            if (1000 &lt;= t &amp;&amp; t &lt; 10000) &#123;</span><br><span class="line">                g[j][t / 100].push_back(t);</span><br><span class="line">                gg[j].push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt;= 10000) &#123;</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag == 6) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int *num, int t, int now, int k, int sum) &#123;</span><br><span class="line">    if (k == 6) &#123;</span><br><span class="line">        if (now % 100 == t / 100) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, sum);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int m = now % 100;</span><br><span class="line">    for (int i = 0; i &lt; g[num[k]][m].size(); i++) &#123;</span><br><span class="line">        int tt = g[num[k]][m][i];</span><br><span class="line">        bool flag = dfs(num, t, tt, k + 1, sum + tt);</span><br><span class="line">        if(flag) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void model2() &#123;</span><br><span class="line">    int num[6] = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">    bool flag = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        for (int i = 0; i &lt; gg[num[0]].size(); i++) &#123;</span><br><span class="line">            int t = gg[num[0]][i];</span><br><span class="line">            flag = dfs(num, t, t, 1, t);</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while(next_permutation(num, num + 6) &amp;&amp; !flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    model1();</span><br><span class="line">    model2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷2719搞笑世界杯</title>
      <link href="/2019/01/01/%E6%B4%9B%E8%B0%B72719%E6%90%9E%E7%AC%91%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
      <url>/2019/01/01/%E6%B4%9B%E8%B0%B72719%E6%90%9E%E7%AC%91%E4%B8%96%E7%95%8C%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/洛谷2719搞笑世界杯/title3.jpg" alt="title3"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>随着世界杯小组赛的结束,法国,阿根廷等世界强队都纷纷被淘汰,让人心痛不已. 于是有人组织了一场搞笑世界杯,将这些被淘汰的强队重新组织起来和世界杯一同比赛.你和你的朋友欣然去购买球票.不过搞笑世界杯的球票出售方式也很特别,它们只准备了两种球票.A 类票——免费球票 B 类票——-双倍价钱球票.购买时由工作人员通过掷硬币决定,投到正面，的买A类票, 反面的买B类票.并且由于是市场经济,主办方不可能倒贴钱,所以他们总是准备了同样多的A类票和B类票.你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置.</p><p>这时工作人员开始通过硬币售票.不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了,因为剩下的这两张票全是免费票。</p><p>你和你的朋友在欣喜之余,想计算一下排在队尾的两个人同时拿到一种票的概率是多少(包括同时拿A 类票或B类票) 假设工作人员准备了2n 张球票,其中n 张A类票,n 张B类票,并且排在队伍中的人每人必须且只能买一张球票(不管掷到的是该买A 还是该买B).</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>输入文件仅一行,包含球票数2n . 其中,0&lt;n&lt;=1250 ，n 为整数。</p><p>输出格式：</p><p>输出文件只包含一个数,为拿到同一种票的概率,精确到小数点后4 位。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">256</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.9500</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    概率dp的入门题，我们设dp【i】【j】代表A类票有i张，B类票有j张最后两张相同的概率。我们初始化dp【i】【0】= 1（2 &lt;= i &lt;= n），dp【0】【i】 = 1（2 &lt;= i &lt;= n），其余为0.然后利用dp【i】【j】= dp【i - 1】【j】✖️0.5 + dp【i】【j-1】✖️0.5，最后dp【n】【n】即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">double dp[1300][1300] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 2; i &lt;= n / 2; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n / 2; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n / 2; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] * 0.5 + dp[i][j - 1] * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.4f\n&quot;, dp[n / 2][n / 2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 概率dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1140相似基因</title>
      <link href="/2019/01/01/%E6%B4%9B%E8%B0%B71140%E7%9B%B8%E4%BC%BC%E5%9F%BA%E5%9B%A0/"/>
      <url>/2019/01/01/%E6%B4%9B%E8%B0%B71140%E7%9B%B8%E4%BC%BC%E5%9F%BA%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/洛谷1140相似基因/title1.jpg" alt="title1"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>两个基因的相似度的计算方法如下：</p><p>对于两个已知基因，例如AGTGATG和GTTAG，将它们的碱基互相对应。当然，中间可以加入一些空碱基-，例如：</p><p><img src="/2019/01/01/洛谷1140相似基因/1.jpg" alt="1"></p><p>这样,两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：</p><p><img src="/2019/01/01/洛谷1140相似基因/2.jpg" alt="2"></p><p>那么相似度就是：(−3)+5+5+(−2)+(−3)+5+(−3)+5=9。因为两个基因的对应方法不唯一，例如又有：</p><p><img src="/2019/01/01/洛谷1140相似基因/3.jpg" alt="3"></p><p>相似度为：(−3)+5+5+(−2)+5+(−1)+5=14。规定两个基因的相似度为所有对应方法中，相似度最大的那个。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>共两行。每行首先是一个整数，表示基因的长度；隔一个空格后是一个基因序列，序列中只含A,C,G,T四个字母。1≤1≤序列的长度≤100。</p><p>输出格式：</p><p>仅一行，即输入基因的相似度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 AGTGATG</span><br><span class="line">5 GTTAG</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    我们设dp【i】【j】为第一个基因的1～i位和第二个基因的1～j位的最大相似值，那么可以得到递推公式dp【i】【j】=max（dp【i-1】【j】+ maps【i】【-】，dp【i】【j-1】 + maps【-】【j】，dp【i - 1】【j - 1】+ maps【i】【j】）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int maps[5][5] = &#123;</span><br><span class="line">        5, -1, -2, -1, -3,</span><br><span class="line">        -1, 5, -3, -2, -4,</span><br><span class="line">        -2, -3, 5, -2, -2,</span><br><span class="line">        -1, -2, -2, 5, -1,</span><br><span class="line">        -3, -4, -2, -1, 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char s1[105], s2[105];</span><br><span class="line">int dp[105][105] = &#123;0&#125;;</span><br><span class="line">map&lt;char, int&gt;zcy;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    zcy[&apos;A&apos;] = 0;</span><br><span class="line">    zcy[&apos;C&apos;] = 1;</span><br><span class="line">    zcy[&apos;G&apos;] = 2;</span><br><span class="line">    zcy[&apos;T&apos;] = 3;</span><br><span class="line">    scanf(&quot;%d%s&quot;, &amp;n, s1 + 1);</span><br><span class="line">    scanf(&quot;%d%s&quot;, &amp;m, s2 + 1);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0] + maps[zcy[s1[i]]][4];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[0][i] = dp[0][i - 1] + maps[4][zcy[s2[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = max(max(dp[i - 1][j] + maps[zcy[s1[i]]][4],</span><br><span class="line">                               dp[i][j - 1] + maps[4][zcy[s2[j]]]),</span><br><span class="line">                           dp[i - 1][j - 1] + maps[zcy[s1[i]]][zcy[s2[j]]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[n][m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1436棋盘分割</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71436%E6%A3%8B%E7%9B%98%E5%88%86%E5%89%B2/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71436%E6%A3%8B%E7%9B%98%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1436棋盘分割/title7.jpg" alt="title7"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的两部分中的任意一块继续如此分割，这样割了(n-1)次后，连同最后剩下的矩形棋盘共有n块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)</p><p><img src="/2018/12/31/洛谷1436棋盘分割/1.jpg" alt="1"></p><p>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成n块矩形棋盘，并使各矩形棋盘总分的平方和最小。</p><p>请编程对给出的棋盘及n，求出平方和的最小值。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行为一个整数n(1 &lt; n &lt; 15)。</p><p>第2行至第9行每行为8个小于100的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。</p><p>输出格式：</p><p>仅一个数，为平方和。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 1 1 1 1 3</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 0</span><br><span class="line">1 1 1 1 1 1 0 3</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1460</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    主要是考验思维吧，只要想到用五维dp就可以很快的推出dp推导式。dp【i】【j】【p】【q】【m】代表左上角坐标（i，j），右下角坐标（p，j）的矩形切m刀的最大值。</p><p>然后dp推导式在代码中</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int maps[10][10];</span><br><span class="line">int sum[10][10] = &#123;0&#125;;</span><br><span class="line">int dp[10][10][10][10][15] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    memset(dp, 0x3f3f3f3f, sizeof(dp));</span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= 8; j++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;maps[i][j]);</span><br><span class="line">            sum[i][j] = sum[i][j - 1] + maps[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= 8; j++) &#123;</span><br><span class="line">            for (int p = i; p &lt;= 8; p++) &#123;</span><br><span class="line">                for (int q = j; q &lt;= 8; q++) &#123;</span><br><span class="line">                    int suu = 0;</span><br><span class="line">                    for (int o = i; o &lt;= p; o++) &#123;</span><br><span class="line">                        suu += sum[o][q] - sum[o][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][p][q][0] = suu * suu;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int o = 1; o &lt; n; o++) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 8; j++) &#123;</span><br><span class="line">                for (int p = i; p &lt;= 8; p++) &#123;</span><br><span class="line">                    for (int q = j; q &lt;= 8; q++) &#123;</span><br><span class="line">                        for (int k = i; k &lt; p; k++) &#123;</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][k][q][o - 1] + dp[k + 1][j][p][q][0]);</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][k][q][0] + dp[k + 1][j][p][q][o - 1]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (int k = j; k &lt; q; k++) &#123;</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][p][k][o - 1] + dp[i][k + 1][p][q][0]);</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][p][k][0] + dp[i][k + 1][p][q][o - 1]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[1][1][8][8][n - 1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1481魔族密码</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71481%E9%AD%94%E6%97%8F%E5%AF%86%E7%A0%81/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71481%E9%AD%94%E6%97%8F%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1481魔族密码/title10.jpg" alt="title10"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>风之子刚走进他的考场，就……</p><p>花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花）</p><p>风之子：我呕……（杀死人的眼神）快说题目！否则……-_-###</p><p>花花：……咦<del>好冷</del>我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉<em>^_^</em>）。魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含1个字母，至多75个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链：</p><p>i int integer</p><p>但下面的单词不组成词链：</p><p>integer</p><p>intern 现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。</p><p>风之子：密码就是最长词链所包括的单词数阿……</p><p>花花：活活活，还有，看你长得还不错，给你一个样例吧：</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>这些文件的格式是，第一行为单词表中的单词数N（1&lt;=N&lt;=2000），下面每一行有一个单词，按字典顺序排列，中间也没有重复的单词咧！！</p><p>输出格式：</p><p>你要提交的文件中只要在第一行输出密码就行啦^^</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">i</span><br><span class="line">int</span><br><span class="line">integer</span><br><span class="line">intern</span><br><span class="line">internet</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    依次将每个单词加入字典树中，并计算建树过程中（路径上）节点的最大值，该节点即为【节点】.num=max（【节点】.num，【最大节点】.num+1），最后num最大的节点即位所求</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    node *son[26];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct tree &#123;</span><br><span class="line">    node *head;</span><br><span class="line">&#125;head;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">char s[105];</span><br><span class="line">int ans = 0;</span><br><span class="line"></span><br><span class="line">void add(node *point, int ceng, int maxx, int len) &#123;</span><br><span class="line">    if (ceng == len) &#123;</span><br><span class="line">        maxx = max(maxx, point -&gt; num);</span><br><span class="line">        point -&gt; num = maxx + 1;</span><br><span class="line">        if (ans &lt; point -&gt; num) ans = point -&gt; num;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int k = s[ceng] - &apos;a&apos;;</span><br><span class="line">    maxx = max(maxx, point -&gt; num);</span><br><span class="line">    if (point -&gt; son[k] == NULL) &#123;</span><br><span class="line">        point -&gt; son[k] = (node *) malloc(sizeof(node));</span><br><span class="line">        add(point -&gt; son[k], ceng + 1, maxx, len);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        add(point -&gt; son[k], ceng + 1, maxx, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(node *point) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        if (point -&gt; son[i] == NULL) continue;</span><br><span class="line">        Delete(point -&gt; son[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    head.head = (node *)malloc(sizeof(node));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, s);</span><br><span class="line">        int len = strlen(s);</span><br><span class="line">        add(head.head, 0, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    Delete(head.head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1507NASA的食物计划</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71507NASA%E7%9A%84%E9%A3%9F%E7%89%A9%E8%AE%A1%E5%88%92/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71507NASA%E7%9A%84%E9%A3%9F%E7%89%A9%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1507NASA的食物计划/title11.jpg" alt="title11"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NASA(美国航空航天局)因为航天飞机的隔热瓦等其他安全技术问题一直大伤脑筋,因此在各方压力下终止了航天飞机的历史,但是此类事情会不会在以后发生，谁也无法保证,在遇到这类航天问题时,解决方法也许只能让航天员出仓维修,但是多次的维修会消耗航天员大量的能量,因此NASA便想设计一种食品方案,让体积和承重有限的条件下多装载一些高卡路里的食物.</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>航天飞机的体积有限,当然如果载过重的物品,燃料会浪费很多钱,每件食品都有各自的体积、质量以及所含卡路里,在告诉你体积和质量的最大值的情况下,请输出能达到的食品方案所含卡路里的最大值,当然每个食品只能使用一次.</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行 两个数 体积最大值(&lt;400)和质量最大值(&lt;400)</p><p>第二行 一个数 食品总数N(&lt;50).</p><p>第三行－第3+N行</p><p>每行三个数 体积(&lt;400) 质量(&lt;400) 所含卡路里(&lt;500)</p><p>输出格式：</p><p>一个数 所能达到的最大卡路里(int范围内)</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">320 350</span><br><span class="line">4</span><br><span class="line">160 40 120</span><br><span class="line">80 110 240</span><br><span class="line">220 70 310</span><br><span class="line">40 400 220</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">550</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    01背包的变形题，题目有三个量v（体积），w（重量），val（价值），因此我们可以开一个二维dp数组dp【i】【j】代表最大体积是i，最大重量是j条件下的最大价值，最后dp【V】【W】即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int v[55], w[55], val[55];</span><br><span class="line">int dp[405][405] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int V, W, n;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;V, &amp;W);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;, &amp;v[i], &amp;w[i], &amp;val[i]);</span><br><span class="line">        for (int p = V; p &gt;= v[i]; p--) &#123;</span><br><span class="line">            for (int q = W; q &gt;= w[i]; q--) &#123;</span><br><span class="line">                dp[p][q] = max(dp[p - v[i]][q - w[i]] + val[i], dp[p][q]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[V][W]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1137旅行计划</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71137%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71137%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1137旅行计划/title9.jpg" alt="title9"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明要去一个国家旅游。这个国家有N个城市，编号为1至N，并且有M条道路连接着，小明准备从其中一个城市出发，并只往东走到城市i停止。</p><p>所以他就需要选择最先到达的城市，并制定一条路线以城市i为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。</p><p>现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的i，都需要你为小明制定一条路线，并求出以城市i为终点最多能够游览多少个城市。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行为两个正整数N,M。</p><p>接下来M行，每行两个正整数x,y，表示了有一条连接城市x与城市y的道路，保证了城市x在城市y西面。</p><p>输出格式：</p><p>N行，第i行包含一个正整数，表示以第i个城市为终点最多能游览多少个城市。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>均选择从城市1出发可以得到以上答案。</p><p>对于20%的数据，N≤100；</p><p>对于60%的数据，N≤1000；</p><p>对于100%的数据，N≤100000,M≤200000</p><p>思路：</p><p>​    这道题利用拓扑排序找到所有能够从i节点到达的节点j，令dp【j】 = dp【i】+ 1，最后dp数组就是所求</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int ru[100005] = &#123;0&#125;;</span><br><span class="line">int dp[100005] = &#123;0&#125;;</span><br><span class="line">vector&lt;int&gt;zcy[100005];</span><br><span class="line">queue&lt;int&gt;que;</span><br><span class="line"></span><br><span class="line">void tupo() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        if (!ru[i]) &#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!que.empty()) &#123;</span><br><span class="line">        int t = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for (int i = 0; i &lt; zcy[t].size(); i++) &#123;</span><br><span class="line">            int k = zcy[t][i];</span><br><span class="line">            dp[k] = max(dp[k], dp[t] + 1);</span><br><span class="line">            ru[k] --;</span><br><span class="line">            if (!ru[k]) que.push(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        zcy[a].push_back(b);</span><br><span class="line">        ru[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    tupo();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1108低价购买</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71108%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71108%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1108低价购买/title5.jpg" alt="title5"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(216216范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。</p><p>这里是某支股票的价格清单：</p><p>日期 1,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,12</p><p>价格68,69,54,64,68,64,70,67,78,62,98,8768,69,54,64,68,64,70,67,78,62,98,87</p><p>最优秀的投资者可以购买最多44次股票，可行方案中的一种是：</p><p>日期 2,5,6,102,5,6,10</p><p>价格 69,68,64,6269,68,64,62</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行: N(1≤N≤5000)N(1≤N≤5000)，股票发行天数</p><p>第2行: NN个数，是每天的股票价格。</p><p>输出格式：</p><p>两个数:最大购买次数和拥有最大购买次数的方案数(≤231≤231)当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">68 69 54 64 68 64 70 67 78 62 98 87</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题有两问，一问是求最长下降子序列，一个是求最长下降子序列的个数。我们可以先举个例子来看一下：设置f数组为最长下降子序列的长度，g数组为最长下降子序列的个数，对于样例：</p><p>val数组：3 7 6 4 5 5 3</p><p>f数组：1 1 2 3 3 3 4</p><p>g数组：1 1 1 1 0 1 2    </p><p>​    也就是说，g数组有三个规则：</p><pre><code>1. 当f【i】为1的时候，g【1】 = 12. 当f【i】==f【j】+1&amp;&amp;val【i】&lt; val【j】时，g【i】+= g【j】3. 当f【i】== f【j】&amp;&amp;val【i】==val【j】时，g【i】= 0</code></pre><p>最后max（f【i】）即是最长长度，所有f【i】==最长长度的g【i】的和即为个数</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using std::cin;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line"></span><br><span class="line">int val[5005] = &#123;0&#125;;</span><br><span class="line">int dp[5005][2] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">            if (val[j] &gt; val[i]) &#123;</span><br><span class="line">                dp[i][0] = std::max(dp[i][0], dp[j][0] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[i][0] == 1) &#123;</span><br><span class="line">            dp[i][1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">            if (dp[i][0] == dp[j][0] + 1 &amp;&amp; val[j] &gt; val[i]) &#123;</span><br><span class="line">                dp[i][1] += dp[j][1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i][0] == dp[j][0] &amp;&amp; val[j] == val[i]) &#123;</span><br><span class="line">                dp[i][1] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxx = 1, sum = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        maxx = std::max(dp[i][0], maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (dp[i][0] == maxx) &#123;</span><br><span class="line">            sum += dp[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxx &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces1096DEasy Problem</title>
      <link href="/2018/12/29/CodeForces1096DEasy-Problem/"/>
      <url>/2018/12/29/CodeForces1096DEasy-Problem/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/29/CodeForces1096DEasy-Problem/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length 𝑛n consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence hard; otherwise the statement is easy. For example, hard, hzazrzd, haaaaard can be considered hard statements, while har, hart and drah are easy statements. </p><p>Vasya doesn’t want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the ambiguity of the statement is 00, and removing 𝑖i-th character increases the ambiguity by 𝑎𝑖ai (the index of each character is considered as it was in the original statement, so, for example, if you delete character r from hard, and then character d, the index of d is still 44 even though you delete it from the string had).</p><p>Vasya wants to calculate the minimum ambiguity of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it!</p><p>Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.</p><p>Input</p><p>The first line contains one integer 𝑛n (1≤𝑛≤1051≤n≤105) — the length of the statement.</p><p>The second line contains one string 𝑠s of length 𝑛n, consisting of lowercase Latin letters — the statement written by Vasya.</p><p>The third line contains 𝑛n integers 𝑎1,𝑎2,…,𝑎𝑛a1,a2,…,an (1≤𝑎𝑖≤9982443531≤ai≤998244353).</p><p>Output</p><p>Print minimum possible ambiguity of the statement after Vasya deletes some (possibly zero) characters so the resulting statement is easy.</p><p>Examples</p><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">hhardh</span><br><span class="line">3 2 9 11 7 1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">hhzarwde</span><br><span class="line">3 2 6 9 4 8 7 1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">hhaarr</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给你一个n个字符的字符串，每个字符都有一个权制，问你删除最小的权值，使得剩下的字符串里不包含子序列hard。问最小删除的字符的权值和是多少？</p><p>思路：</p><p>​    求最小删除的字符权值和，我们可以转化为求剩余不包含子序列hard的字符串的最大权值。我们可以设dp{i}{j}代表第i个字符为第j种状态的最大权值（状态共有5种，0代表0～i全部子序列都不包含h，1代表0～i全部子序列最多包含h，2代表0～i全部子序列最多包含ha，3代表0～i全部子序列最多包含har，4代表0～i全部子序列最多包含hard，最后dp{n}{0～3}的最大值即为答案）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char s[100005];</span><br><span class="line">long long dp[100005][5];</span><br><span class="line">long long val[100005];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">    long long sum = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;val[i]), sum += val[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (s[i] == &apos;h&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0];</span><br><span class="line">            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]) + val[i];</span><br><span class="line">            for (int j = 2; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (s[i] == &apos;a&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + val[i];</span><br><span class="line">            dp[i][1] = dp[i - 1][1];</span><br><span class="line">            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + val[i];</span><br><span class="line">            for (int j = 3; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (s[i] == &apos;r&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + val[i];</span><br><span class="line">            dp[i][1] = dp[i - 1][1] + val[i];</span><br><span class="line">            dp[i][2] = dp[i - 1][2];</span><br><span class="line">            dp[i][3] = max(dp[i - 1][2], dp[i - 1][3]) + val[i];</span><br><span class="line">            for (int j = 4; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (s[i] == &apos;d&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + val[i];</span><br><span class="line">            dp[i][1] = dp[i - 1][1] + val[i];</span><br><span class="line">            dp[i][2] = dp[i - 1][2] + val[i];</span><br><span class="line">            dp[i][3] = dp[i - 1][3];</span><br><span class="line">            dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]) + val[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long long mx = 0;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        mx = max(mx, dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, sum - mx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb复习(三)</title>
      <link href="/2018/12/26/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%89/"/>
      <url>/2018/12/26/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/26/JavaWeb复习三/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="三-创建和部署MVC-Web应用"><a href="#三-创建和部署MVC-Web应用" class="headerlink" title="三 创建和部署MVC Web应用"></a>三 创建和部署MVC Web应用</h1><h2 id="3-1-一个简单应用的组成"><a href="#3-1-一个简单应用的组成" class="headerlink" title="3.1 一个简单应用的组成"></a>3.1 一个简单应用的组成</h2><p>​    一个简单Web应用包括html表单、servlet控制器、一个模型（普通Java类）、一个xml部署描述文件、一个jsp视图</p><h2 id="3-2-步骤"><a href="#3-2-步骤" class="headerlink" title="3.2 步骤"></a>3.2 步骤</h2><h3 id="3-2-1-分析用户视图以及高层体系结构"><a href="#3-2-1-分析用户视图以及高层体系结构" class="headerlink" title="3.2.1 分析用户视图以及高层体系结构"></a>3.2.1 分析用户视图以及高层体系结构</h3><p><img src="/2018/12/26/JavaWeb复习三/1.png" alt="1"></p><h4 id="3-2-1-1对于访问链接："><a href="#3-2-1-1对于访问链接：" class="headerlink" title="3.2.1.1对于访问链接："></a>3.2.1.1对于访问链接：</h4><p>根据上图：</p><p>​    1:客户请求访问页面    </p><p>​    2.容器找到html页面</p><p>​    3.容器把页面返还给浏览器</p><h4 id="3-2-1-2-对于访问servlet："><a href="#3-2-1-2-对于访问servlet：" class="headerlink" title="3.2.1.2 对于访问servlet："></a>3.2.1.2 对于访问servlet：</h4><p>根据上图：</p><p>​    4:客户把请求数据发送给容器</p><p>​    5.容器根据url找到对应的servlet，并把请求传递给这个servlet</p><p>​    6.servlet调用模型（普通java类）</p><p>​    7.类返回一个结果，servelet把回答增加到请求对象</p><p>​    8.servlet把请求转给jsp</p><p>​    9.jsp从请求对象得到答案</p><p>​    10.jsp为生成容器生成页面</p><p>​    11.容器把页面返回给用户</p><h3 id="3-3-2-创建项目的开发环境"><a href="#3-3-2-创建项目的开发环境" class="headerlink" title="3.3.2 创建项目的开发环境"></a>3.3.2 创建项目的开发环境</h3><p>​    MVC项目的标准层级结构</p><p><img src="/2018/12/26/JavaWeb复习三/2.png" alt="2"></p><h3 id="3-3-3-创建项目的部署环境"><a href="#3-3-3-创建项目的部署环境" class="headerlink" title="3.3.3 创建项目的部署环境"></a>3.3.3 创建项目的部署环境</h3><p>​    Tomcat的层级结构：</p><p><img src="/2018/12/26/JavaWeb复习三/3.png" alt="3">    </p><h3 id="3-3-4-对Web应用各组件进行迭代开发和测试"><a href="#3-3-4-对Web应用各组件进行迭代开发和测试" class="headerlink" title="3.3.4 对Web应用各组件进行迭代开发和测试"></a>3.3.4 对Web应用各组件进行迭代开发和测试</h3><h4 id="3-3-4-1-构建和测试html表单"><a href="#3-3-4-1-构建和测试html表单" class="headerlink" title="3.3.4.1 构建和测试html表单"></a>3.3.4.1 构建和测试html表单</h4><h5 id="3-3-4-1-1-构建："><a href="#3-3-4-1-1-构建：" class="headerlink" title="3.3.4.1.1 构建："></a>3.3.4.1.1 构建：</h5><p>​    举个例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>填写表单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--html认为/login就是要调用的servlet(客户知道的url名)，在项目目录结构中并不存在--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"haha"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/login"</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"men"</span>&gt;</span>男</span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"women"</span>&gt;</span>女</span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"SUBMIT"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-3-4-1-2-部署和测试"><a href="#3-3-4-1-2-部署和测试" class="headerlink" title="3.3.4.1.2:部署和测试"></a>3.3.4.1.2:部署和测试</h5><p>​    1.在开发环境中创建html，然后保持在项目名/web下</p><p>​    2.把html文件的副本放在tomcat/webapps/项目名中</p><p>​    3.创建web.xml文档，保存在开发环境项目名/etc下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--该部署文件的主要目的是定义逻辑名与实际类文件之间的映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>部署名<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>类文件的完全限定名<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>部署名<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--.do只是一个约定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/用户可知的url名.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    4.把web.xml文件的副本放在/tomcat/webapps/项目名/WEB-INF目录下</p><p>​    5.启动tomcat（cd到tomcat主目录，然后运行/bin/startup.sh）</p><p>​    6.测试页面（输入<a href="http://localhost:8080/项目名）" target="_blank" rel="noopener">http://localhost:8080/项目名）</a></p><h4 id="3-3-4-2-构建控制器servlet第一个版本"><a href="#3-3-4-2-构建控制器servlet第一个版本" class="headerlink" title="3.3.4.2 构建控制器servlet第一个版本"></a>3.3.4.2 构建控制器servlet第一个版本</h4><h5 id="3-3-4-2-1-编写servlet"><a href="#3-3-4-2-1-编写servlet" class="headerlink" title="3.3.4.2.1 编写servlet"></a>3.3.4.2.1 编写servlet</h5><p>​    利用html表单测试这个控制器（确保html页面能适当调用servlet，且servlet能正确接收html参数）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写doPost方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"haha&lt;br&gt;"</span>);</span><br><span class="line">        <span class="comment">//获取表单中的name信息（根据html标记中的name属性匹配）</span></span><br><span class="line">        String s = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        out.println(<span class="string">"he is "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-4-2-2-编译servlet"><a href="#3-3-4-2-2-编译servlet" class="headerlink" title="3.3.4.2.2 编译servlet"></a>3.3.4.2.2 编译servlet</h5><p>​    命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//切到项目目录下</span><br><span class="line">cd project</span><br><span class="line">//路径根据不同的存放目录是不同的，tomcat之后是相同的</span><br><span class="line">//-d用来告诉编译器，.class文件放在适当包结构中的clases目录下</span><br><span class="line">javac -classpath /路径/tomcat/common/lib/servlet-api.jar:classes:. -d classes src/com/web/testServlet.java</span><br></pre></td></tr></table></figure><h5 id="3-3-4-2-3-部署servlet"><a href="#3-3-4-2-3-部署servlet" class="headerlink" title="3.3.4.2.3 部署servlet"></a>3.3.4.2.3 部署servlet</h5><p>​    创建.class文件副本，把它移到tomcat/项目/WEB-INF/classes/com/web下</p><h5 id="3-3-4-2-4-测试servlet"><a href="#3-3-4-2-4-测试servlet" class="headerlink" title="3.3.4.2.4 测试servlet"></a>3.3.4.2.4 测试servlet</h5><p>​    重启tomcat然后访问网页即可</p><h4 id="3-3-4-3-为模型类构建测试类，构建并测试模型类"><a href="#3-3-4-3-为模型类构建测试类，构建并测试模型类" class="headerlink" title="3.3.4.3 为模型类构建测试类，构建并测试模型类"></a>3.3.4.3 为模型类构建测试类，构建并测试模型类</h4><p>​    例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.model;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public String getName(String name) &#123;</span><br><span class="line">        String s = &quot;hello, &quot;;</span><br><span class="line">        s = s + name;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-4-servlet升级到第二版"><a href="#3-3-4-4-servlet升级到第二版" class="headerlink" title="3.3.4.4 servlet升级到第二版"></a>3.3.4.4 servlet升级到第二版</h4><h5 id="3-3-4-4-1-改写"><a href="#3-3-4-4-1-改写" class="headerlink" title="3.3.4.4.1 改写"></a>3.3.4.4.1 改写</h5><p>​    可以调用模型类,如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.web</span><br><span class="line"></span><br><span class="line">import com.model.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">pulbic class TestServlet extends HttpServlet &#123;</span><br><span class="line">    //重写doPost方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;</span><br><span class="line">        //新补充的内容：</span><br><span class="line">        String s = request.getParameter(&quot;name&quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        String s1 = t.getName(s);</span><br><span class="line">        </span><br><span class="line">        response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(&quot;haha&lt;br&gt;&quot;);</span><br><span class="line">        //获取表单中的name信息（根据html标记中的name属性匹配）</span><br><span class="line">        out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-4-4-2-部署"><a href="#3-3-4-4-2-部署" class="headerlink" title="3.3.4.4.2 部署"></a>3.3.4.4.2 部署</h5><p>​    1.编译servlet</p><p>​    2.将servlet文件的副本替换到之前的/tomcat/wabapps/项目/WEB-INF/classes/com/web下</p><p>​    3.把模型的class文件移动到/tomcat/wabapps/项目/WEB-INF/classes/com/model下</p><p>​    4.重启tomcat</p><p>​    5.打开浏览器浏览</p><h4 id="3-3-4-5-构建jsp，servlet升级到第三版"><a href="#3-3-4-5-构建jsp，servlet升级到第三版" class="headerlink" title="3.3.4.5 构建jsp，servlet升级到第三版"></a>3.3.4.5 构建jsp，servlet升级到第三版</h4><p>​    可以把表示分派到jsp完成</p><p>​    jsp代码如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;这是一个标题&lt;/h1&gt;</span><br><span class="line">        &lt;!-- &lt;% %&gt;标记里有一些标准Java代码--&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">        &lt;!--从这里从请求对象得到一个styles属性--&gt;</span><br><span class="line">        String s = (String)resquest.getAttribute(<span class="string">"styles"</span>);</span><br><span class="line">        out.print(<span class="string">"&lt;br&gt;"</span> + s);</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>​    然后将jsp文件保存在项目目录/web下</p><p>​    将它的副本移动到tomcat/项目名下</p><p>​    servlet代码修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.web</span><br><span class="line"></span><br><span class="line">import com.model.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">pulbic class TestServlet extends HttpServlet &#123;</span><br><span class="line">    //重写doPost方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;</span><br><span class="line">        //新补充的内容：</span><br><span class="line">        String s = request.getParameter(&quot;name&quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        String s1 = t.getName(s);</span><br><span class="line">        </span><br><span class="line">        //response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        //PrintWriter out = response.getWriter();</span><br><span class="line">        //out.println(&quot;haha&lt;br&gt;&quot;);</span><br><span class="line">        //获取表单中的name信息（根据html标记中的name属性匹配）</span><br><span class="line">        //out.println(s1);</span><br><span class="line">        </span><br><span class="line">        //为请求对象增加styles属性，供jsp使用</span><br><span class="line">        request.setAttribute(&quot;styles&quot;, s1);</span><br><span class="line">        //为jsp实例化一个请求分派器</span><br><span class="line">        RequestDispatcher view = request.getRequestDispatcher(&quot;test.jsp&quot;);</span><br><span class="line">        //使用请求分派器要求容器准备好jsp，并向jsp发送请求和响应</span><br><span class="line">        view.forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    重新部署servlet即可，重启tomcat查看</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb复习(二)</title>
      <link href="/2018/12/25/JavaWeb%E5%A4%8D%E4%B9%A0%E4%BA%8C/"/>
      <url>/2018/12/25/JavaWeb%E5%A4%8D%E4%B9%A0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/25/JavaWeb复习二/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="二-web应用体系结构"><a href="#二-web应用体系结构" class="headerlink" title="二.web应用体系结构"></a>二.web应用体系结构</h1><h2 id="2-1-web容器"><a href="#2-1-web容器" class="headerlink" title="2.1 web容器"></a>2.1 web容器</h2><p>​    Servlet没有main()方法，它受控于另一个Java应用，这个Java应用被称为Web容器，Tomcat就是这样一个容器。</p><p>​    对于每个请求，Web容器可以实例化servlet（或至少建一个新线程），可以调用servlet的doPost()或doGet()方法，把方法的重要参数(http请求和http响应对象)交给servlet，可以管理servlet的生死以及servlet的资源</p><h3 id="2-1-1-指向某servlet请求的流程"><a href="#2-1-1-指向某servlet请求的流程" class="headerlink" title="2.1.1 指向某servlet请求的流程"></a>2.1.1 指向某servlet请求的流程</h3><p>​    Web服务器应用得到指向某servlet请求后，此时服务器将请求交给部署该servlet的容器，由容器向servlet提供http请求和响应，并且由容器调用servlet的方法（如doPost()、doGet()）</p><p><img src="/2018/12/25/JavaWeb复习二/1.png" alt="1"></p><p>​    最后线程结束，容器把响应对象转换为一个http响应，并把它返回浏览器，然后删除请求和响应对象</p><h3 id="2-1-2-容器的作用"><a href="#2-1-2-容器的作用" class="headerlink" title="2.1.2 容器的作用"></a>2.1.2 容器的作用</h3><p>​    1.通信支持：利用容器提供的方法，可以让servlet和Web服务器对话，无需自己建立ServerSocket、监听端口、创建流等</p><p>​    2.生命周期管理：它能负责加载类、实例化和初始化Servlet、调用servlet方法以及垃圾回收。有了容器的控制，就不用太多考虑资源管理</p><p>​    3.多线程支持：容器会自动为它接受的每个servlet请求创建一个新的线程。servlet已经运行完相应的http方法，线程就会自动结束</p><p>​    4.声明方式实现安全：利用容器，可以使用xml部署描述文件来配置安全性，而不必将其硬编码写到servlet类代码中</p><p>​    5.JSP支持：容器可以将JSP代码翻译成真正的Java</p><p>​    因此说，有了容器我们可以更专注自己的业务逻辑，而不用过多考虑线程管理、安全性和网络通信等底层服务</p><h2 id="2-2-关于Servlet名称"><a href="#2-2-关于Servlet名称" class="headerlink" title="2.2 关于Servlet名称"></a>2.2 关于Servlet名称</h2><h3 id="2-2-1-Servlet的三个名字"><a href="#2-2-1-Servlet的三个名字" class="headerlink" title="2.2.1 Servlet的三个名字"></a>2.2.1 Servlet的三个名字</h3><p>​    1.客户知道的URL名（虚拟的名字，完全为客户提供）</p><p>​    2.部署servlet人员定义的部署名（虚拟的内部名，只用于部署Servlet）</p><p>​    3.实际的文件名（开发人员的Servlet类拥有一个完全限定名，包括类名和包名）</p><h3 id="2-2-2-Servlet多个名字的好处"><a href="#2-2-2-Servlet多个名字的好处" class="headerlink" title="2.2.2 Servlet多个名字的好处"></a>2.2.2 Servlet多个名字的好处</h3><p>​    1.灵活性高，移动文件而不必担心后期维护</p><p>​    2.安全性高，对客户隐藏了服务器的目录结构</p><h2 id="2-3-关于部署文件"><a href="#2-3-关于部署文件" class="headerlink" title="2.3 关于部署文件"></a>2.3 关于部署文件</h2><p>​    部署文件会告诉容器如何运行servlet和jsp：</p><p>​    1.可以使用两个xml元素把url映射到servlet</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         version=&quot;2.4&quot;&gt;</span><br><span class="line">    &lt;!--一个部署描述文件可以声明多个servlet--&gt;</span><br><span class="line">    &lt;!--servlet-name把servlet和servlet-mapping元素绑定在一起--&gt;</span><br><span class="line">    &lt;!--servlet元素告诉容器哪个类文件属于一个特定Web应用--&gt;</span><br><span class="line">    &lt;1--servlet-name是部署名--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;!--servlet-class是java类,也就是类的完全限定名--&gt;</span><br><span class="line">        &lt;servlet-class&gt;testServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;!--url-pattern是客户所用的请求名，也就是用户知道的url名--&gt;</span><br><span class="line">        &lt;url-pattern&gt;/Serv1&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>​    2.对Web应用的安全角色、错误页面、标记库、初始配置信息等方面进行定制</p><p>​    也就是说，利用部署描述文件，可以利用一种声明方式修改应用，而无需修改源代码</p><h2 id="2-4-MVC设计模式"><a href="#2-4-MVC设计模式" class="headerlink" title="2.4 MVC设计模式"></a>2.4 MVC设计模式</h2><p>​    若不使用mvc设计模式，那么流程图servlet请求的流程图如下：</p><p><img src="/2018/12/25/JavaWeb复习二/2.png" alt="2"></p><p>​    我们发现业务逻辑与表示之间有很强的联系，因为我们需要在两者之间放别的东西，使得业务逻辑本身就能作为一个可重用的Java类。</p><p>​    因此，我们引入模型-视图-控制器（MVC）设计模式，它的核心就是把业务逻辑从servlet中抽出来，放到一个模型中（模型就是可重用的普通java类，它是业务数据和处理该数据的方法组合）</p><h2 id="2-5-J2EE"><a href="#2-5-J2EE" class="headerlink" title="2.5 J2EE"></a>2.5 J2EE</h2><p>​    J2EE是一种超级规范，它结合了sevlets、jsp、ejb规范。一个完全兼容j2EE应用服务器必须有一个web容器和一个ejb容器。</p><p>​    tomcat是一个web容器，而不是一个完整的j2EE应用服务器</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb复习(一)</title>
      <link href="/2018/12/24/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%80/"/>
      <url>/2018/12/24/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>​                          <img src="/2018/12/24/JavaWeb复习一/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><h2 id="1-1-web应用"><a href="#1-1-web应用" class="headerlink" title="1.1 web应用"></a>1.1 web应用</h2><p>​    一个JavaWeb应用：java+servlet+jsp</p><h2 id="1-2-流程"><a href="#1-2-流程" class="headerlink" title="1.2 流程"></a>1.2 流程</h2><p>​    web服务器用于接受客户需求，然后向客户返回一些结果</p><p>​    浏览器就是一个软件，它可以与服务器通信，能够解释html代码，并将web页面呈现给用户</p><p>​    流程如下：</p><p><img src="/2018/12/24/JavaWeb复习一/1.png" alt="1"></p><p>​    web上浏览器和服务器的大多数通信都是使用http协议完成，http协议支持简单的请求和响应会话，浏览器（客户）发送一个http请求，服务器会用一个http响应做应答。</p><p>​    总结就是：1.html告诉浏览器如何向用户显示内容</p><p>​                2.http是web上客户和服务器进行通信用的协议</p><p>​                3.服务器使用http向客户（浏览器）发送html</p><h2 id="1-3-HTTP协议"><a href="#1-3-HTTP协议" class="headerlink" title="1.3 HTTP协议"></a>1.3 HTTP协议</h2><p>​    http协议是TCP/IP的上层协议（TCP用于保证从一个网络节点向另一个网络节点发送的文件能完整到达，IP是一个底层协议，负责把数据块沿路移动/路由到目的地），需要依赖TCP/IP从一处向另一处完整地传送请求和响应</p><p>​    http会话的结构是一个简单的请求/响应序列：浏览器发出请求，服务器做出响应</p><h2 id="1-4-请求流-响应流要素"><a href="#1-4-请求流-响应流要素" class="headerlink" title="1.4 请求流/响应流要素"></a>1.4 请求流/响应流要素</h2><h3 id="1-4-1请求流关键要素："><a href="#1-4-1请求流关键要素：" class="headerlink" title="1.4.1请求流关键要素："></a>1.4.1请求流关键要素：</h3><p>​    1.http方法</p><p>​    2.要访问的页面(URL)    </p><p>​    3.表单参数（如方法参）</p><h3 id="1-4-2响应流关键要素："><a href="#1-4-2响应流关键要素：" class="headerlink" title="1.4.2响应流关键要素："></a>1.4.2响应流关键要素：</h3><p>​    1.状态码（表明请求是否成功）</p><p>​    2.内容类型（包括文本、图片、html等）</p><p>​    3.内容（具体的html、图片等）</p><h2 id="1-5-http请求"><a href="#1-5-http请求" class="headerlink" title="1.5 http请求"></a>1.5 http请求</h2><p>​    http协议有很多请求方法，常用的有get方法和post方法</p><h3 id="1-5-1-get请求"><a href="#1-5-1-get请求" class="headerlink" title="1.5.1 get请求"></a>1.5.1 get请求</h3><p>​    get是最简单的http方法，用于要求服务器获取一个资源并把资源发过来</p><p>特点：</p><p>​    1.get发送数据是有限的（取决于服务器）</p><p>​    2.get发送的数据会追加到url后，所以发送的数据完全暴露（通过?符隔开，两部分加在一起，整个串组成完整的请求url）</p><h4 id="1-5-1-1get请求解析"><a href="#1-5-1-1get请求解析" class="headerlink" title="1.5.1.1get请求解析"></a>1.5.1.1get请求解析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//GET代表http方法， /books/test.jsp 为web服务器上资源的路径</span><br><span class="line">//sex=man&amp;name=Professional为参数</span><br><span class="line">//HTTP/1.1 为协议的版本</span><br><span class="line">GET /books/test.jsp?sex=man&amp;name=Professional HTTP/1.1//请求行</span><br><span class="line">//以下是请求首部</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept: text/xml,application/xml,text/html;q=0.9,text/plain</span><br></pre></td></tr></table></figure><h3 id="1-5-2-post请求"><a href="#1-5-2-post请求" class="headerlink" title="1.5.2 post请求"></a>1.5.2 post请求</h3><p>​    post方法可以请求某个东西，与此同时可以向服务器发送一些表单数据</p><h4 id="1-5-2-1post请求解析"><a href="#1-5-2-1post请求解析" class="headerlink" title="1.5.2.1post请求解析"></a>1.5.2.1post请求解析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//POST代表http方法， /advisor/test.do 为web服务器上资源的路径</span><br><span class="line">//HTTP/1.1 为协议的版本</span><br><span class="line">POST /advisor/test.do HTTP/1.1//请求行</span><br><span class="line">//以下到空行为请求首部</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept: text/xml,application/xml,text/html;q=0.9,text/plain</span><br><span class="line">（----此处空一行----）</span><br><span class="line">//以下为消息体</span><br><span class="line">color=dark&amp;taste=malty</span><br></pre></td></tr></table></figure><h3 id="1-5-3其他方法"><a href="#1-5-3其他方法" class="headerlink" title="1.5.3其他方法"></a>1.5.3其他方法</h3><p>​    比如head、trace、put、delete、options、connect等方法</p><h2 id="1-6-http响应"><a href="#1-6-http响应" class="headerlink" title="1.6 http响应"></a>1.6 http响应</h2><p>​    http响应可以包含html，http还会在响应内容前增加首部信息，而浏览器使用首部信息来帮助处理html页面</p><h3 id="1-6-1响应解析"><a href="#1-6-1响应解析" class="headerlink" title="1.6.1响应解析"></a>1.6.1响应解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//以下为http响应首部</span><br><span class="line">//HTTP/1.1为http协议版本 200为http状态码 OK为状态码的相应文本</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate</span><br><span class="line">Date: Tue, 26 Jul 2016 09:32:11 GMT</span><br><span class="line">Expires: Tue, 26 Jul 2016 09:32:12 GMT</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 3892</span><br><span class="line">//Content-Type响应首部的值称为MIME类型，用于告诉浏览器要接收的数据是什么类型,它的值域请求首部的Accept值相关</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Last-Modified: Tue, 26 Jul 2016 09:32:12 GMT</span><br></pre></td></tr></table></figure><h2 id="1-7-端口"><a href="#1-7-端口" class="headerlink" title="1.7 端口"></a>1.7 端口</h2><p>​    端口是一个16位的数(范围0～2^16 - 1)，用于标识服务器硬件上一个特定的软件程序</p><p>。它并不是一个可以插入物理设备的位置，只表示服务器应用的“逻辑“数。从0～1023的端口号已经保留，由一些众所周知的服务使用</p><h3 id="1-7-1-常用端口"><a href="#1-7-1-常用端口" class="headerlink" title="1.7.1 常用端口"></a>1.7.1 常用端口</h3><p>​    21：FTP</p><p>​    23：Telnet</p><p>​    25：SMTP</p><p>​    37：Time</p><p>​    80：HTTP</p><p>​    443：HTTPS</p><p>​    110：POP3</p><h2 id="1-8-Web服务器"><a href="#1-8-Web服务器" class="headerlink" title="1.8 Web服务器"></a>1.8 Web服务器</h2><p>​    两个常用的Web服务器，一个是Apache，另一个是Tomcat</p><h2 id="1-9-静态-动态Web页面"><a href="#1-9-静态-动态Web页面" class="headerlink" title="1.9 静态/动态Web页面"></a>1.9 静态/动态Web页面</h2><p>​    静态页面只是原封不动的在目录中，服务器找到静态页面，并把它原样传给客户</p><p>​    对于动态页面而言，Web服务器上有一个辅助应用可以生成非静态的即时页面且能与web服务器通信。每当请求到来时，辅助应用具体写出html，web服务器再把这个html响应到浏览器。辅助应用是一个CGI程序（CGI代表公共网关接口）</p><h3 id="1-9-1-动态页面生成流程"><a href="#1-9-1-动态页面生成流程" class="headerlink" title="1.9.1 动态页面生成流程"></a>1.9.1 动态页面生成流程</h3><p>​    举个动态页面显示当前日期的例子：</p><p><img src="/2018/12/24/JavaWeb复习一/2.png" alt="2"></p><h2 id="1-10-Servlet"><a href="#1-10-Servlet" class="headerlink" title="1.10 Servlet"></a>1.10 Servlet</h2><p>​    Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用于交互式地浏览和修改数据，生成动态Web内容</p><h3 id="1-10-1-Servlet编写、部署、运行"><a href="#1-10-1-Servlet编写、部署、运行" class="headerlink" title="1.10.1 Servlet编写、部署、运行"></a>1.10.1 Servlet编写、部署、运行</h3><p>​    1.项目目录树和tomcat目录树如下：</p><p><img src="/2018/12/24/JavaWeb复习一/3.png" alt="3"></p><p>​    2.在src目录下编写testServlet.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是一个标准的Servlet声明</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testservlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest reque, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        java.util.Date today = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">        out.println(<span class="string">"&lt;html&gt; &lt;body&gt; &lt;h1&gt; time is &lt;/h1&gt; &lt;br&gt; today &lt;/body&gt; &lt;/html&gt;"</span> );</span><br><span class="line">        <span class="comment">//Java嵌套html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3.在etc创建一个部署描述文件web.xml（每个web应用都有一个部署描述文件）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个部署描述文件可以声明多个servlet--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet-name把servlet和servlet-mapping元素绑定在一起--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-class是java类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--url-pattern是客户所用的请求名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Serv1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    4.在project目录下编译servlet，生成的testServelet.class文件将会在classes目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath /yourpath/tomcat/common/lib/Servlet-api.jar -d classes src/testServlet.java</span><br></pre></td></tr></table></figure><p>​    5.将testServelet.class复制到WEB-INF/classes目录下，再把web.xml复制到WEB-INF目录下</p><p>​    6.从tomcat目录下启动tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure><p>​    7.打开浏览器，输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/test/Serv1//test为项目名，Servl为servlet名</span><br></pre></td></tr></table></figure><h2 id="1-11-JSP"><a href="#1-11-JSP" class="headerlink" title="1.11 JSP"></a>1.11 JSP</h2><p>​    在html中引入Java，就是jsp。</p><h3 id="1-11-1-示例"><a href="#1-11-1-示例" class="headerlink" title="1.11.1 示例"></a>1.11.1 示例</h3><p>举个当前日期的例子：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        The time is</span><br><span class="line">        &lt;%= <span class="keyword">new</span> java.util.Date() %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="1-11-2-好处"><a href="#1-11-2-好处" class="headerlink" title="1.11.2 好处"></a>1.11.2 好处</h3><p>​    1.使得Java开发人员处理Java，html开发人员开一专心处理Web（仅仅需要学如何调用具体Java方法）</p><p>​    2.避免html以某种格式放入一个String中导致错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim复制代码到终端外</title>
      <link href="/2018/12/22/vim%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BB%88%E7%AB%AF%E5%A4%96/"/>
      <url>/2018/12/22/vim%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BB%88%E7%AB%AF%E5%A4%96/</url>
      
        <content type="html"><![CDATA[<p>​                            <img src="/2018/12/22/vim复制代码到终端外/title5.jpg" alt="title5"></p><a id="more"></a><p>​    1) 打开 iTerm2 的偏好设置，找到General -&gt; Selection，取消 Copy to pasteboard on selection。</p><p>​    2)在 ~/.vimrc 里添加 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure><p>上面的步骤完成了以后，如果要复制整段代码，就按下面的步骤做：</p><p>​    1.vim打开某一文件，按 ESC 进入 normal 模式<br>​    2.v 进入 visual 模式。</p><p>​    3.shift+g 选中光标后的所有内容</p><p>​    4. y复制选中内容</p><p>​    5. cmd+v 粘贴代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下mysql无法启动的解决办法</title>
      <link href="/2018/12/19/Mac%E4%B8%8Bmysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/12/19/Mac%E4%B8%8Bmysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/19/Mac下mysql无法启动的解决办法/title4.jpg" alt="title4"></p><a id="more"></a><p>​    又到了做课设的日子～然后发现电脑里的mysql服务怎么都打不开，上网百度了一下，原因是某种情况下导致”/usr/local/MySQL/data”的拥有者发生了改变，所以只需要将其拥有者修改为“mysql“就可以了。（个人觉得是更改了管理员导致的吧）</p><p>​    这时候，我们只需要在终端中运行，mysql服务就能运行了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R mysql /usr/local/mysql/data1</span><br></pre></td></tr></table></figure><p>​    Over～</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据找前1000大</title>
      <link href="/2018/12/18/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%89%BE%E5%89%8D1000%E5%A4%A7/"/>
      <url>/2018/12/18/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%89%BE%E5%89%8D1000%E5%A4%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/海量数找前1000大/title3.jpg" alt="title3"></p><a id="more"></a><p>​    打个比方，在100亿个亿中，找前1000大的数，我们应该怎么办？</p><p>​    一般人上来可能会想，可以先排序（比如快排，分治等等），然后取前1000个，这样时间复杂度是O(nlogn)（n为100亿），这样肯定是不可以的​    </p><p>​    我们会发现，我们只需要对前1000个进行处理，而不是每个数都排序确定位置，因此我们可以对排序进行优化。打个比方对快排进行优化：取第一个数做基准，然后利用快排原理把比这个数小的移到左边，比这个数大的移到右边。若左边的数大于1000，直接把右边舍弃，对左边继续进行快排。若左边的数小于1000，记录左边数的个数m，然后对右边继续继续进行快排。此时找的是n - m - 1个数。循环执行直到找到1000，这种时间复杂度是O(n)，大概是2n左右吧。。</p><p>​    利用上边这种方法确实可以解决时间复杂度问题，可是要一次性读取全部的数据，100亿的int型大概需要占用40G内存，普通个人电脑是无法做到的。有的人会想，我可以把数据存在文件中，每次左边的数存1.txt里，右边的数存2.txt，根据上面的判断条件选择读取哪个文件即可。这样的想法不错，可是多次的读写操作，效率会变得很低很低。。。</p><p>​    这时候，我们可以考虑一下分布式，每个计算机负责一部分数据，并行计算前1000大并把数据传送到一个计算机汇总求总的前1000大</p><p>​    上述方法非常好，可是却需要受到硬件条件的限制。我们可以利用最小堆来实现求前1000大，首先取前1000个数构建最小堆，然后每读取一个数，若小于堆顶直接舍弃，若大于则扔掉堆顶，把该数加入到堆中。这样暂用内存不大，不受制于硬件条件，且时间复杂度为O(n)</p><p>​    以上墨迹这么多，就是给大家提供一种思考问题的思路，要考虑到方方面面，而不是单纯的时间复杂度那么简单。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 探究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux一切皆文件</title>
      <link href="/2018/12/18/%E4%BA%86%E8%A7%A3Linux/"/>
      <url>/2018/12/18/%E4%BA%86%E8%A7%A3Linux/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/了解Linux/title2.jpg" alt="title2"></p><a id="more"></a><h4 id="1-一切皆文件"><a href="#1-一切皆文件" class="headerlink" title="1.一切皆文件"></a>1.一切皆文件</h4><p>​    Linux 一切皆文件，不仅是狭义上的文件，像键盘、打印机、虚拟终端，进程间通信和网络通信等输入/输出资源都是定义在文件系统空间下的字节流</p><p>​    好处：对于输入/输出资源，可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源    （注：api是应用程序编程接口）</p><p>​    操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用</p><p>​    在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式</p><p>​    注意点：Linux 文件是没有所谓的扩展名的，一个 Linux文件能否被执行与它是否可执行的属性有关，只要权限中有x就可以执行（不一定执行成功）虽然如此，但期望通过扩展名来了解该文件是什么东西，所以一般还会以适当的扩展名来表示该文件是什么</p><h4 id="2-物理存储机制："><a href="#2-物理存储机制：" class="headerlink" title="2.物理存储机制："></a>2.物理存储机制：</h4><p>​    磁性存储介质磁化后会保留被磁化状态，且状态能被读取和修改，磁化有两个方向可表示0和1，所以用磁性存储介质来存储信息<br>​    而硬盘就是把磁性存储介质做成多个盘片（包含数以亿计的磁性存储单位），并使用磁性读写头对盘片进行读写</p><p>​    由于硬盘中磁性存储单元众多，所以需要一套规则来规划信息如何存取，于是就有了物理、逻辑概念：</p><ol><li>一个硬盘有多张盘片叠成</li><li>每张盘片上的存储颗粒（一存储颗粒为1bit）成环形一圈圈地排布，每一圈称为磁道</li><li>每条磁道上都有一圈存储颗粒，每512*8（512byte，0.5KB）个存储颗粒作为一个扇区</li><li>扇区是硬盘最小的物理存储单位</li><li>N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置</li><li>簇是文件系统的最小存储单位</li><li>所有盘面上的同一磁道构成一个圆柱，称为柱面</li><li>柱面是系统分区的最小单位</li></ol><p>​        磁头读写文件时先分区读写，由inode编号（区内唯一的编号）找到对应磁道和扇区，然后一个柱面一个柱面地进行读写</p><p><img src="/2018/12/18/了解Linux/1.jpg" alt="1"></p><h4 id="3-Linux文件体系："><a href="#3-Linux文件体系：" class="headerlink" title="3.Linux文件体系："></a>3.Linux文件体系：</h4><p>​    Linux以文件的形式对计算机中的数据和硬件资源进行管理，反映在Linux的文件类型上就是：普通文件、目录文件（也就是文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信的接口）等等。而这些种类繁多的文件被Linux使用目录树进行管理（就是以根目录（/）为根，向下呈现分支状的一种树形结构）</p><h5 id="3-1-普通文件"><a href="#3-1-普通文件" class="headerlink" title="3.1. 普通文件"></a>3.1. 普通文件</h5><p>​    类似mp4、pdf这样应用层面上的文件类型都属于普通文件，Linux用户可以根据访问权限对普通文件进行查看、更改和删除</p><h5 id="3-2-目录文件"><a href="#3-2-目录文件" class="headerlink" title="3.2. 目录文件"></a>3.2. 目录文件</h5><p>​    目录文件包含了目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件</p><h5 id="3-3-链接文件"><a href="#3-3-链接文件" class="headerlink" title="3.3. 链接文件"></a>3.3. 链接文件</h5><p>​    类似快捷方式，是指向另一个文件的间接指针</p><h5 id="3-4-块设备文件和字符设备文件"><a href="#3-4-块设备文件和字符设备文件" class="headerlink" title="3.4. 块设备文件和字符设备文件"></a>3.4. 块设备文件和字符设备文件</h5><p>​    这些文件一般隐藏在/dev目录下，在进行设备读取和外设交互时会被使用到。比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</p><h5 id="3-5-管道文件"><a href="#3-5-管道文件" class="headerlink" title="3.5. 管道文件"></a>3.5. 管道文件</h5><p>​    主要用于进程间通讯</p><h5 id="6-套接字文件"><a href="#6-套接字文件" class="headerlink" title=".6. 套接字文件"></a>.6. 套接字文件</h5><p>​    用于进程间的网络通信，也可以用于本机之间的非网络通信，这些文件一般隐藏在/var/run目录下，证明着相关进程的存在</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2018/12/18/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/12/18/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/markdown语法/title1.jpg" alt="title1"></p><a id="more"></a><p>[TOC]</p><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><h4 id="2-目录"><a href="#2-目录" class="headerlink" title="2.目录"></a>2.目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TOC]//一般放在文章开头</span><br></pre></td></tr></table></figure><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure><h4 id="4-行内标记"><a href="#4-行内标记" class="headerlink" title="4.行内标记"></a>4.行内标记</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前面内容`行内标记内容`后面内容</span><br></pre></td></tr></table></figure><h4 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5.代码块"></a>5.代码块</h4><p><img src="/2018/12/18/markdown语法/1.png" alt="1"></p><h4 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[个人博客](wwww.ivan-zcy.top)</span><br></pre></td></tr></table></figure><h4 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片上传失败的备注](图片地址)</span><br></pre></td></tr></table></figure><h4 id="8-序表"><a href="#8-序表" class="headerlink" title="8.序表"></a>8.序表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//有序</span><br><span class="line">1. 内容</span><br><span class="line">2. 内容</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">//无序</span><br><span class="line">* 内容</span><br><span class="line">* 内容</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">//嵌套</span><br><span class="line">1. 内容</span><br><span class="line">1. 内容</span><br><span class="line">2. 内容</span><br><span class="line">2. 内容</span><br></pre></td></tr></table></figure><h4 id="9-选项"><a href="#9-选项" class="headerlink" title="9.选项"></a>9.选项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [] 选项名</span><br></pre></td></tr></table></figure><h4 id="10-分隔线"><a href="#10-分隔线" class="headerlink" title="10.分隔线"></a>10.分隔线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法一</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="11-跳转邮箱"><a href="#11-跳转邮箱" class="headerlink" title="11.跳转邮箱"></a>11.跳转邮箱</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;296763002@qq.com&gt;</span><br></pre></td></tr></table></figure><h4 id="12-字体倾斜"><a href="#12-字体倾斜" class="headerlink" title="12.字体倾斜"></a>12.字体倾斜</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法一：</span><br><span class="line">*内容*</span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">_内容_</span><br></pre></td></tr></table></figure><h4 id="13-字体加粗"><a href="#13-字体加粗" class="headerlink" title="13.字体加粗"></a>13.字体加粗</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法一：</span><br><span class="line">**内容**</span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">__内容__</span><br></pre></td></tr></table></figure><h4 id="14-删除线"><a href="#14-删除线" class="headerlink" title="14.删除线"></a>14.删除线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~内容~~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github使用</title>
      <link href="/2018/12/18/Github%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/18/Github%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/Github使用总结/title.jpg" alt="title"></p><a id="more"></a><p>1.Github是什么？</p><p>​    gitHub是一个面向开源及私有软件项目的托管平台，上面托管了众多优秀的项目</p><p>2.Github常用术语：</p><p>——Repository<br>​    仓库，用于存储你的开源项目</p><p>——Issue<br>​    问题，用于对项目提出意见或建议，以及发现的Bug，修复了就可以Close掉</p><p>——Star<br>​    点赞，想拥有程序员这种完美主义者的赞很难。。。拥有几千赞感觉就逆天了，上万赞的或许只有那些顶级开源项目了。。</p><p>——Watch<br>​    观察，如果对某个项目设置了 Watch，那么该项目有任何更新都可以在第一时间收到通知</p><p>——Fork<br>​    分叉，如果你看到别人一个好的开源项目，你想要做些改进，就可以Fork对方的项目（本质上相当于新建了一个分支）</p><p>——clone</p><p>​    克隆，用于将代码克隆到本地</p><p>——Pull Request<br>​    发起请求，如果你Fork了别人的项目并做了改进，想要把自己的改进合并到对方的项目中，就可以发起合并请求。原作者如果同意，你的改进就加到了原项目中</p><p>——Gist<br>​    用于分享代码片段</p><p>——Organizations</p><p>​    组织，用于组织和团队</p><p>3创建自己的项目：</p><p>​    1) 点击右上角下三角号-&gt;New repository</p><p><img src="/2018/12/18/Github使用总结/1.png" alt="1"></p><p>​    2) 会出现如下界面：<img src="/2018/12/18/Github使用总结/2.png" alt="2"></p><p>​    这样一个项目就创建成功啦～</p><p>4.如何对其他开源项目进行贡献？</p><p>​    <img src="/2018/12/18/Github使用总结/3.png" alt="3"></p><p>1)fork</p><p>​    在想要修改的他人项目页面，点击右上角【fork】</p><p><img src="/2018/12/18/Github使用总结/4.jpg" alt="4"></p><p>​    这时候就会将该项目克隆到你的github仓库中</p><p>2)clone</p><p>​    在本地利用git clone命令，将项目克隆到自己电脑上</p><p><img src="/2018/12/18/Github使用总结/6.png" alt="6"></p><p><img src="/2018/12/18/Github使用总结/7.png" alt="7"></p><p>3)update</p><p>​    接下来就可以在本地对项目进行修改（建议在master上切出一个新分支进行修改，修改完后再将分支merge到master）</p><p>4)push</p><p>​    使用git push命令将改动同步到自己的gitHub项目仓库里</p><p><img src="/2018/12/18/Github使用总结/5.png" alt="5"></p><p>5)pull request</p><p>​    向原作者提交代码,点击文件列表上的【New pull request】</p><p><img src="/2018/12/18/Github使用总结/8.png" alt="8"></p><p>​    系统检查无误显示Able to merge后，就可以点击【Create pull request】进行提交</p><p><img src="/2018/12/18/Github使用总结/9.jpg" alt="9"></p><p>​    之后系统会让写一段注释，用于向原作者阐述你做了哪些修改和优化。若原作者同意将你的代码合并到原项目中，就可以点击【merge pull request】</p><p><img src="/2018/12/18/Github使用总结/10.jpg" alt="10"></p><p>5.修改其他开源项目时原项目发生改变时 如何保持同步？</p><p>1)fetch</p><p>​    先把原项目fetch到自己电脑本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch git@github.com:原作者/原作者项目 master:latest</span><br></pre></td></tr></table></figure><p>​    master是原项目分支，latest是自己项目分支。若latest分支不存在的话，将自动创建。其实也可以将代码fetch到自己的master分支，但不建议这么做</p><p>2)merge</p><p>​    代码fetch到latest分支之后，再切到master分支使用git merge命令将最新代码合并到master分支</p><p>3)push</p><p>​    再使用git push命令，就可以将最新代码推到自己的github项目中</p><p>参考：</p><p>​    <a href="https://www.itcodemonkey.com/article/10049.html" target="_blank" rel="noopener">如何在GitHub上大显身手？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛I乘胜追击</title>
      <link href="/2018/12/11/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BI%E4%B9%98%E8%83%9C%E8%BF%BD%E5%87%BB/"/>
      <url>/2018/12/11/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BI%E4%B9%98%E8%83%9C%E8%BF%BD%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/11/哈理工第八届校团队赛I乘胜追击/title2.jpg" alt="title2"></p><a id="more"></a><p>Description</p><p> 三国时期，群雄割据，战乱频繁。公元228年，孙权派番阳太守周鲂诱骗曹休派兵前来，曹休果然中计。待孙权任陆逊为大都督，朱桓、全琮为左、右督，各领兵三万人迎击曹休时，曹方知被欺。但其仗恃兵力占优，仍决定与吴国交战。彼时陆逊所率大军与与曹休所率大军于石亭展开激战。陆逊探得曹休于长江边共驻扎n座军营，相互以粮道连接，其中第1座军营为大本营。当第i(i&gt;=2)座军营被攻陷时，营中残兵败将将沿粮道向第f[i]座军营逃窜。陆逊极善用兵，常人用a[i]的兵力方能攻下第i座军营，而陆逊仅需a[i]-d[i]的兵力即可攻下。倘给陆以a[i]的兵力，则陆不仅能攻下第i座军营，还可乘胜追击，沿着军士逃跑方向攻下第f[i]座军营。陆逊善用兵如此，故而仅用了最少的兵力便大破曹休，攻下所有军营，生擒一万余人，缴获牛马驴骡车辆上万。试问陆逊于石亭之战中共用兵力几何？（以上史料来自百度百科且有删改，不保证真实准确性）  </p><p>Input  </p><p>第一行一个整数T(T&lt;=50)，代表数据组数在每组数据中：第一行一个整数n(2&lt;=n&lt;=50000)表示军营数目第二行有n-1个整数f【2】~f【n】(f【i】&lt;i)第三行有n个整数a【1】~a【n】(2&lt;=a【i】&lt;=1e9)第四行有n个整数d【1】~d【n】(1&lt;=d【i】&lt;a【i】)  </p><p>Output  </p><p>对于每组数据，输出一行一个整数，表示陆逊攻下所有军营所需使用的最少兵力  </p><p>Sample Input  </p><p>1</p><p>4</p><p>1 1 3</p><p>100 50 2 5</p><p>2 49 1 1  </p><p>Sample Output  </p><p>7  </p><p>Hint  </p><p>输入数据量较大，请合理控制输入效率。</p><p>样例解释：</p><p>首先使用2兵力攻击军营3，并追击至大本营1。然后使用5-1=4兵力攻击军营4。最后使用50-49=1兵力攻击军营2。共使用兵力2+4+1=7。</p><p>思路：</p><p>​    一道树形dp的题，比较难。二维数组dp【50005】【3】，其中dp【i】【0】代表以i本营为根节点的子树(攻打i本营无花费)的最小花费，dp【i】【1】代表以i本营为根节点的子树(攻打i本营花费a【i】- d【i】)的最小花费，dp【i】【2】代表以i本营为根节点的子树(攻打i本营花费a【i】)的最小花费。然后找到dp的递推式即可求出</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector &lt;int&gt; zcy[50005];</span><br><span class="line">int two[50005], one[50005];</span><br><span class="line">ll dp[50005][3];    //dp[i][0]代表无花费，dp[i][1]代表仅攻克自己，dp[i][2]代表连带攻克父节点</span><br><span class="line">ll minn[50005];</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    dp[inx][2] = two[inx];</span><br><span class="line">    dp[inx][1] = one[inx];</span><br><span class="line">    dp[inx][0] = 0;</span><br><span class="line">    for (int i = 0; i &lt; zcy[inx].size(); i++) &#123;</span><br><span class="line">        int ii = zcy[inx][i];</span><br><span class="line">        if (ii == father) continue;</span><br><span class="line">        dfs(ii, inx);</span><br><span class="line">        if (dp[ii][0]) &#123;</span><br><span class="line">            minn[i] = min(dp[ii][0], dp[ii][1]);</span><br><span class="line">            dp[inx][1] += minn[i];</span><br><span class="line">            dp[inx][2] += minn[i];</span><br><span class="line">            dp[inx][0] += minn[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn[i] = dp[ii][1];</span><br><span class="line">            dp[inx][1] += minn[i];</span><br><span class="line">            dp[inx][2] += minn[i];</span><br><span class="line">            dp[inx][0] += minn[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k = dp[inx][0];</span><br><span class="line">    if (k == 0) return;</span><br><span class="line">    int suu = 0;</span><br><span class="line">    for (int i = 0; i &lt; zcy[inx].size(); i++) &#123;</span><br><span class="line">        int ii = zcy[inx][i];</span><br><span class="line">        if (ii == father) continue;</span><br><span class="line">        if (!suu) &#123;</span><br><span class="line">            dp[inx][0] = k - minn[i] + dp[ii][2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[inx][0] = min(dp[inx][0], k - minn[i] + dp[ii][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        suu++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, a;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            zcy[i].push_back(a);</span><br><span class="line">            zcy[a].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;two[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;one[i]);</span><br><span class="line">            one[i] = two[i] - one[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, 0);</span><br><span class="line">        ll ans;</span><br><span class="line">        if(dp[1][0]) &#123;</span><br><span class="line">            ans = min(dp[1][0], dp[1][1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = dp[1][1];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018哈理工院个人赛、校团队赛总结</title>
      <link href="/2018/12/10/2018%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E4%B8%AA%E4%BA%BA%E8%B5%9B%E3%80%81%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/10/2018%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E4%B8%AA%E4%BA%BA%E8%B5%9B%E3%80%81%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/2018哈理工院个人赛、校团队赛总结/title.jpg" alt="title"></p><a id="more"></a><p>​    院个人赛拿了亚军，校团队赛185支队伍拿了第五名。还算满意，今天打算总结总结～</p><p>​    哈理工院个人赛12月2号举行，10道题4个小时。题目比较简单～</p><p>​    两道水题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐玩木桶/">跳转到小乐乐玩木桶</a> 和 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐玩木桶-1/">跳转到小乐乐玩木桶+</a>  刚上来没理解题意，之后就过了～</p><p>​    一道最长公共子序列裸题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐匹配字符串/">跳转到小乐乐匹配字符串</a> 随后就A了</p><p>​    一道简单的思维题没过多久也A了，有一个小小的坑点 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐的组合数/">跳转到小乐乐的组合数</a></p><p>​    一道博弈题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐学博弈/">跳转到小乐乐学博弈</a>     写了很多样例，抱着试试看的态度交了一发过了，没在深思原因</p><p>​    一道模拟题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐和25/">跳转到小乐乐和25</a> 我是用模拟写的，考验的是细心吧</p><p>​    一道状压dp题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐搭积木/">跳转到小乐乐搭积木</a> 正好主攻dp和数论，这道题就笑纳啦</p><p>​    一道bfs题变形，调bug调到哭 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐打游戏/">跳转到小乐乐打游戏</a> 现场赛没做出来，可恨的是我之前做过也做出来了。。快哭了</p><p>​    一道dp题  <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐下象棋/">跳转到小乐乐下象棋</a> 哎当时脑子笨了没想到，赛后重做发现还是蛮简单的</p><p>​    还有一道防Ak题好像是一道主席树变形，自己不主攻线段树也做不出来了</p><p>​    最后拿了院赛的亚军还行吧，冠军被增林老哥拿去了。膜拜膜拜！Orz～</p><p>​    </p><p>​    哈理工校团队赛12月9号举行，哈工大出题，题目中等偏难～</p><p>​    刚上来热身赛三道题：第一道大模拟被队友A了，自己懒得再补～ 第二道是一个01背包的变形题，秒A  <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛热身B信小呆/">跳转到信小呆</a>  第三道是一个线性筛的变形题，也A了 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛热身C孪生素数猜想/">跳转到孪生素数猜想</a>  第一次AK，虽然是热身赛，也值得纪念一下，苦笑～</p><p>​    之后正式赛12道题5小时，最终做出来7个～</p><p>​    上来快速A掉一个暴力的水题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛B咕咕咕/">跳转到咕咕咕</a> </p><p>​    然后过了一道抽屉原理的题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛D所以我也想玩这个序列游戏/">跳转到所以我也想玩这个序列游戏</a> </p><p>​    队友过掉了一道二分题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛K汪汪汪/">跳转到汪汪汪</a> 赛后自己补了一下</p><p>​    随后过了一道01分数规划 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛H刘禅的课程/">跳转到刘禅的课程</a> </p><p>​    一道树形dp的题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛C树上路径计数/">跳转到树上路径计数</a> </p><p>​    随后队友过了一道几何题，队友用算式推出了12维空间求解点关于直线的对称点的公式，膜拜Orz～自己不会就不补了</p><p>​    然后过了一道篇难的数论题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛E格子染色计数/">跳转到格子染色计数</a> </p><p>​    赛后听题解I题也是一道树形dp，一直没往上靠，脑子好笨呀～赛后补了 <a href="http://www.ivan-zcy.top/2018/12/11/哈理工第八届校团队赛I乘胜追击/">跳转到乘胜追击</a></p><p>​    校赛第一不愧是亚洲区预赛金牌爷，10题膜拜膜拜Orz～ </p><p>​    现在西区计院和东区软件学院差距越来越大了，前四名全是西区，前十名8个西区。。。无力。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛E格子染色计数</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BE%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E8%AE%A1%E6%95%B0/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BE%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛E格子染色计数/title5.jpg" alt="title5"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>有排成一行的n个格子，你需要在 m 种颜色中选取 k 种颜色对这 n 个格子染色，要求k 种颜色都要使用，且相邻格子的颜色不同，求方案数（答案对 10^9 + 7取模）。  </p><p>Input  </p><p>第一行为测试数据组数T( 1 &lt;= T &lt;= 10).每组测试数据：第一行有两个个整数n, m, k. (1 &lt;= n, m &lt;= 1e9, k &lt;= 1e6)。  </p><p>Output  </p><p>一个整数, 为染色方案数, 输出答案对 1e9 + 7 取模.  </p><p>Sample Input  </p><p>3</p><p>3 4 2</p><p>3 4 3</p><p>3 4 4  </p><p>Sample Output  </p><p>12</p><p>24</p><p>0</p><p>思路：</p><p>​    这道题难度不小，需要利用卢卡斯定理+容斥定理+线性求阶乘逆元来求解～，答案为C(m,k)✖️(k✖️(k-1)^(n-1) - C(k,k-1)✖️(k-1)✖️(k-2)^(n-1) + C(k,k-2)✖️(k-2)✖️(k-3)^(n-1)…C(k,1)✖️1✖️0^(n-1))</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define N 1000000</span><br><span class="line">#define mod 1000000007</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line">ll fact[N + 5], inv[N + 5];</span><br><span class="line"></span><br><span class="line">ll extend(ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if(a == 0 &amp;&amp; b == 0) return -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = extend(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll reverse(ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = extend(a, n, x, y);</span><br><span class="line">    if (d == 1) return (x % n + n) % n;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    fact[0] = fact[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        fact[i] = fact[i - 1] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N] = reverse(fact[N], mod);</span><br><span class="line">    for (int i = N - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + 1] * (i + 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll C(ll n, ll m) &#123;</span><br><span class="line">    if (n &lt; m || m &lt; 0) return 0;</span><br><span class="line">    if (n &lt; mod) return fact[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">    return C(n / mod, m / mod) * C(n % mod, m % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ls(ll n, ll m) &#123;</span><br><span class="line">    if (n &lt; m || m &lt; 0) return 0;</span><br><span class="line">    ll mm = n - m;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    for (int i = mm + 1; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = i * ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans * inv[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while(b) &#123;</span><br><span class="line">        if (b &amp; 1) &#123;</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= 2;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        ll ans = ls(m, k);</span><br><span class="line">        ll t = k * quick(k - 1, n - 1) % mod;</span><br><span class="line">        int tot = -1;</span><br><span class="line">        for (int i = k - 1; i &gt;= 1; i --) &#123;</span><br><span class="line">            t = (t + tot * (C(k, i) * i % mod * quick(i - 1, n - 1) % mod) + mod) % mod;</span><br><span class="line">            tot = -tot;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * t % mod;</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛C树上路径计数</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BC%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BC%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛C树上路径计数/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>给定一棵有n个顶点的树，你需要统计出树上所有长度为奇数的路径数量。路径长度为经过边的条数。s 到 t 和 t 到 s视作相同。  </p><p>Input  </p><p>第一行为测试数据组数T( 1 &lt;= T &lt;= 5).每组测试数据：第一行有一个整数n（1 &lt;= n &lt;= 1e5），表示顶点数。接下来n - 1 行 每行两个整数u, v，表示u, v之间存在一条边。  </p><p>Output </p><p> 一个整数, 路径长度为奇数的数量。  </p><p>Sample Input  </p><p>2</p><p>2</p><p>1 2</p><p>4 </p><p>1 2</p><p>2 3</p><p>1 4  </p><p>Sample Output  </p><p>1</p><p>4</p><p>思路：</p><p>​    这道题典型的树形dp题，规定1节点为root，dp【i】【0】代表以i为根节点的子树的奇数子节点个数，dp【i】【1】代表以i为根节点的子树的偶数子节点个数，dp【1】【0】+dp【1】【0】✖️dp【1】【1】即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector &lt;int&gt;zcy[100005];</span><br><span class="line">int dp[100005][2];</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    for (int i = 0; i &lt; zcy[inx].size(); i++) &#123;</span><br><span class="line">        int ii = zcy[inx][i];</span><br><span class="line">        if(ii ==father) continue;</span><br><span class="line">        dfs(ii, inx);</span><br><span class="line">        dp[inx][0] += dp[ii][1] + 1;</span><br><span class="line">        dp[inx][1] += dp[ii][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, a, b;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            zcy[a].push_back(b);</span><br><span class="line">            zcy[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, 0);</span><br><span class="line">        ll ans = (ll)dp[1][0] * (dp[1][1] + 1);</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛H刘禅的课程</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BH%E5%88%98%E7%A6%85%E7%9A%84%E8%AF%BE%E7%A8%8B/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BH%E5%88%98%E7%A6%85%E7%9A%84%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛H刘禅的课程/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>刘禅对学习的态度让太傅操碎了心。刘禅有n种课程要学习（礼、乐、射、御、书、数等等），每个课程有对应的重要程度s[i]，刘禅估计了一下，机智的他算出了每个课程他最后能得到的分数c[i]， 太傅给出了他最终成绩的计算公式:</p><p><img src="/2018/12/10/哈理工第八届校团队赛H刘禅的课程/1.png" alt="1"></p><p> 现在他可以推迟k门课程，使得他剩下的n-k门课程的最终成绩尽量高，因为这样父皇才会让他出宫玩耍。机智的刘禅已经算出了答案，不过他想考考你。输出最高的不少于n-k门课程的最终成绩。    </p><p>Input  </p><p>多组数据，请读入到文件末尾（数据组数不超过10）第一行两个非负整数n, k(1≤ n≤ 1e5 , 0≤ k &lt; n) 第二行n个正整数s[i] 第三行n个正整数c[i]1&lt;=s[i],c[i]&lt;=1000  </p><p>Output  </p><p>一个实数，四舍五入保留6位小数  </p><p>Sample Input  </p><p>3 1 </p><p>1 2 3 </p><p>3 2 1  </p><p>Sample Output  </p><p>2.333333  </p><p>Hint  </p><p>去掉最后一门课程即可。</p><p>(2<em>2+3</em>1)/(2+1)=7/3</p><p>思路：</p><p>​    01分数规划的裸题，利用二分找结果ans，会得到si✖️ci/ si = ans ,只要贪心求的前n - k大的si✖️ci - ans✖️si的和，大于等于0返回1，否则返回0</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[100005], b[100005];</span><br><span class="line">int n, k;</span><br><span class="line">double t[100005];</span><br><span class="line"></span><br><span class="line">bool whd(double A, double B) &#123;</span><br><span class="line">    return A &gt; B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool zcy(double val) &#123;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        t[i] = a[i] - val * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(t, t + n, whd);</span><br><span class="line">    for (int i = 0; i &lt; n - k; i++) &#123;</span><br><span class="line">        sum += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &gt;= 0) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) &#123;</span><br><span class="line">        double minn = 0, maxx= 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            a[i] = a[i] * b[i];</span><br><span class="line">            if (maxx &lt; a[i]) &#123;</span><br><span class="line">                maxx = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double mid;</span><br><span class="line">        for (int i = 0; i &lt; 80; i++) &#123;</span><br><span class="line">            mid = (minn + maxx) / 2;</span><br><span class="line">            if (zcy(mid)) minn = mid;</span><br><span class="line">            else maxx = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.6f\n&quot;, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 二分 </tag>
            
            <tag> 01分数规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛K汪汪汪</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BK%E6%B1%AA%E6%B1%AA%E6%B1%AA/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BK%E6%B1%AA%E6%B1%AA%E6%B1%AA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛K汪汪汪/title7.jpg" alt="title7"></p><a id="more"></a><p>题意：</p><p>Description</p><p> 给n个区间[l, r]，判断是否存在区间交叉。即是否存在1 &lt;= i &lt; j &lt;= n，使得li &lt; lj &lt; ri &lt; rj。  </p><p>Input  </p><p>多组数据每组数据第一行一个整数n，第二行到第n + 1行每行两个数分别代表该区间的左右端点。  </p><p>Output  </p><p>如果存在交叉，输出“YES”；否则输出“NO”  </p><p>Sample Input  </p><p>2</p><p>1 3</p><p>2 4</p><p>3</p><p>1 7</p><p>2 4</p><p>5 6  </p><p>Sample Output  </p><p>YES</p><p>NO  </p><p>Hint  </p><p>1 &lt;= n &lt;= 1e5, 1 &lt;= li &lt; ri &lt;= 2e5, 每组数据中所有的l，r互不相同。所有组数据n的和不超过1e6.读入数据较大，请使用高效的读入方式。</p><p>思路：</p><p>​    利用sort按照l从小到大排序，若l相同则按照r从小到大排序，然后遍历，二分查找即可。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace IO &#123;</span><br><span class="line">    const int MX = 4e7;</span><br><span class="line">    char buf[MX];</span><br><span class="line">    int c, sz;</span><br><span class="line"></span><br><span class="line">    void begin() &#123;</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline bool read(int &amp;t) &#123;</span><br><span class="line">        while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++;</span><br><span class="line">        if (c &gt;= sz) return false;</span><br><span class="line">        bool flag = 0; if(buf[c] == &apos;-&apos;) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++)</span><br><span class="line">            t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        if(flag) t = -t;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int l, r;</span><br><span class="line">&#125;stu[100005];</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">bool zcy(node A, node B) &#123;</span><br><span class="line">    if (A.l == B.l) &#123;</span><br><span class="line">        return A.r &lt; B.r;</span><br><span class="line">    &#125;</span><br><span class="line">    return A.l &lt; B.l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int erfen(int val) &#123;</span><br><span class="line">    int star = 0, endd = n - 1;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    while(star &lt;= endd) &#123;</span><br><span class="line">        int mid = (star + endd) / 2;</span><br><span class="line">        if (stu[mid].l &lt;= val) &#123;</span><br><span class="line">            star = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            endd = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    IO::begin();</span><br><span class="line">    while (IO::read(n)) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            IO::read(stu[i].l);</span><br><span class="line">            IO::read(stu[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(stu, stu + n, zcy);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            int inx = erfen(stu[i].l);</span><br><span class="line">            if (inx == -1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = inx; j &lt; n &amp;&amp; stu[j].l &lt; stu[i].r; j++) &#123;</span><br><span class="line">                if(stu[j].r &gt; stu[i].r) &#123;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛D所以我也想玩这个序列游戏</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BD%E6%89%80%E4%BB%A5%E6%88%91%E4%B9%9F%E6%83%B3%E7%8E%A9%E8%BF%99%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BD%E6%89%80%E4%BB%A5%E6%88%91%E4%B9%9F%E6%83%B3%E7%8E%A9%E8%BF%99%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛D所以我也想玩这个序列游戏/title6.jpg" alt="title6"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>今天dxy休息，他想出了一个序列游戏，具体描述如下：你有一个长度为n的正整数序列和一个正整数m，问其中是否存在一个非空子区间使得这个子区间的区间和是m的倍数。</p><p>Input  </p><p>多组数据，读入到文件结尾对于每一组数据第一行：两个数n,m第二行：n个正整数，表示题目中的序列n&lt;=10^6，m&lt;=2000，0&lt;a[i]&lt;=10^9  </p><p>Output  </p><p>对于每组数据输出一行：若存在所描述的区间，则输出YES，否则输出NO  </p><p>Sample Input  </p><p>5 3</p><p>1 2 3 4 5</p><p>5 100</p><p>1 2 3 4 5  </p><p>Sample Output  </p><p>YES</p><p>NO</p><p>思路：</p><p>​    这道题主要利用了抽屉原理，长度为n的一个数组，若n大于等于m，则一定存在一个子区间的和是m的倍数。当n &lt; m时，由于m小于2000，直接暴力求解即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">int a[1000005];</span><br><span class="line">ll sum[1000005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            sum[i] = sum[i - 1] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &gt;= m) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int len = 1; len &lt;= n; len++) &#123;</span><br><span class="line">            for (int i = 1; i + len - 1 &lt;= n; i++) &#123;</span><br><span class="line">                if ((sum[i + len - 1] - sum[i - 1]) % m == 0) &#123;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 抽屉原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛B咕咕咕</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BB%E5%92%95%E5%92%95%E5%92%95/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BB%E5%92%95%E5%92%95%E5%92%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛B咕咕咕/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>给你一个字符串，请数出有多少个连续字符串<strong>”CCPC”，</strong>不区分大小写。  </p><p>Input  </p><p>输入第一行是数据组数T（T&lt;=10）接下来T行每行有一个字符串。（字符串仅由大小写英文字母构成，长度&lt;=100000）  </p><p>Output  </p><p>输出T行，每行输出对应字符串中”CCPC”的个数  </p><p>Sample Input  </p><p>2</p><p>CCpc</p><p>aCCpcCpcecpC  </p><p>Sample Output  </p><p>1</p><p>2</p><p>思路：</p><p>​    大水题，暴力就完了～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char s[100005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        scanf(&quot;%s&quot;, s);</span><br><span class="line">        int n = strlen(s);</span><br><span class="line">        for (int i = 0; i &lt; n - 3;i++) &#123;</span><br><span class="line">            if ((s[i] == &apos;C&apos; || s[i] == &apos;c&apos;) &amp;&amp; (s[i + 1] == &apos;C&apos; || s[i + 1] == &apos;c&apos; ) &amp;&amp; (s[i + 2] == &apos;P&apos; || s[i + 2] == &apos;p&apos;) &amp;&amp; (s[i + 3] == &apos;C&apos; || s[i + 3] == &apos;c&apos;)) &#123;</span><br><span class="line">                sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛热身B信小呆</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABB%E4%BF%A1%E5%B0%8F%E5%91%86/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABB%E4%BF%A1%E5%B0%8F%E5%91%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛热身B信小呆/title1.jpg" alt="title1"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>​    小g得到一张满x减x的购物劵，他想在自己购物车中选择一部分物品来买，购物车里没种物品只能买一件，并且他想尽量少花钱。由于小g很穷很笨，如果它购物车里所有物品价值总和比x小，那么他只能选择放弃这张优惠劵</p><p>​    也就是说他会在n个物品中选若干，使得花费总和大于等于x且最小</p><p>​    问花费最少的钱能拿到货物的最大价值是多少？</p><p>Input  </p><p>​    输入第一行是t(t &lt;= 100)，表示t组样例。接下来输入n和x (0 &lt; n &lt; 100, 0 &lt; x &lt; 10000)，代表小g购物车有n件物品，优惠劵满x减x，接下来一行有n个数(0 &lt; ai &lt; 100)代表n个物品的价格</p><p>Output  </p><p>​    对于每组样例，请输出“Case x: y”, x是输入样例组数，y是小g在花最少的钱能拿到货物的最大价值</p><p>Sample Input  </p><p>2</p><p>3 10</p><p>1 2 3</p><p>3 10</p><p>5 6 3</p><p>Sample Output  </p><p>Case 1: 0</p><p>Case 2: 11</p><p>思路：</p><p>​    01背包的变形题,dp【i】代表总价值为i的货物搭配是否存在(1存在，0不存在)，然后从x开始遍历，若存在dp【i】则直接输出并跳出，不存在输出0</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">bool dp[10005];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, tot = 0, a, n, x;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;x);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            for (int j = i * 100; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (dp[j]) &#123;</span><br><span class="line">                    dp[j + a] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int i = x; i &lt;= n * 100; i++) &#123;</span><br><span class="line">            if(dp[i]) &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;, ++tot, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工第八届校团队赛热身C孪生素数猜想</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABC%E5%AD%AA%E7%94%9F%E7%B4%A0%E6%95%B0%E7%8C%9C%E6%83%B3/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABC%E5%AD%AA%E7%94%9F%E7%B4%A0%E6%95%B0%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛热身C孪生素数猜想/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>​    素数只能被1和自身整除，孪生素数猜想为：存在无穷多个素数对形如（p, p + 2），如3和5， 11和13等</p><p>​    先给定一个数k，判断k是否为孪生素数</p><p>Input  </p><p>​    输入第一行是t(t &lt;= 100)，代表数据组数，接下来每组数据输入一个k(2 &lt; k &lt; 100000)</p><p>Output  </p><p>​    对于每组样例，请输出“Case x: y”, x是输入样例组数，如果是孪生数输出Yes，否则输出No</p><p>Sample Input  </p><p>3</p><p>5</p><p>23</p><p>30</p><p>Sample Output  </p><p>Case 1: Yes</p><p>Case 2: No</p><p>Case 3: No</p><p>思路：</p><p>​    直接线性筛出1e5 + 2以内的全部素数，然后从素数中再筛选出全部的孪生素数并标记为1.直接判断book[k]是否为1，1Yes，0No</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 100002</span><br><span class="line"></span><br><span class="line">bool book[N + 5];</span><br><span class="line">int prime[N + 5];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    prime[0] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            book[prime[j] * i] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    for (int i = 2; i &lt; prime[0]; i++) &#123;</span><br><span class="line">        if ((prime[i] - 2 == prime[i - 1]) || (prime[i] + 2 == prime[i + 1])) &#123;</span><br><span class="line">            book[prime[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(prime[prime[0]] - 2 == prime[prime[0] - 1]) &#123;</span><br><span class="line">        book[prime[0]] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    int T, k, tot = 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">        if(book[k]) &#123;</span><br><span class="line">            printf(&quot;Case %d: Yes\n&quot;, ++tot);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;Case %d: No\n&quot;, ++tot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术-第三章</title>
      <link href="/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/08/C语言核心技术-第三章/title1.jpg" alt="title1"></p><a id="more"></a><p>第三章 字面量</p><p>3.1 整数常量</p><p>​    十进制常量起始数字不可为0</p><p>​    以0开始的数字会被解释成八进制</p><p>​    十六进制以0x或0X作前缀</p><p>​    解析下面两行代码：</p><p>3.2浮点常量</p><p>​    默认类型为double，也可用后缀f或F来说明该常量是float型</p><p>3.3字符串常量</p><p>​    字符串常量可以初始一个char数组，也可以初始化一个指向char的指针，例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p = &quot;hello, zcy!&quot;;//p指向字符&apos;h&apos;</span><br></pre></td></tr></table></figure><p>​    虽然C语言没有严格禁止修改指针指向的字符串字面量，但也不能试图这么做，以下做法是不好的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p = &quot;hello, zcy!&quot;;</span><br><span class="line">*p = &quot;hi, acm!&quot;;//这样做很不好</span><br></pre></td></tr></table></figure><p>​    这样做导致语句不具备可移植性，在某些系统下会产生运行错误。原因有两个：</p><p>​    （1）一些编译器将字符串字面量视为常量，可能将其存在只读存储器中，对其进行写操作将会产生错误</p><p>​    （2）程序中有两个或更多完全相同的字符串字面量，编译器可能会将它们存储在相同的位置，因此修改一个字符串会对其他字符串造成影响。</p><p>​    而使用字符串字面量初始的数组变量不会产生这种影响</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术-第二章下</title>
      <link href="/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8B/"/>
      <url>/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/08/C语言核心技术-第二章下/title4.jpg" alt="title4"></p><a id="more"></a><p>第二章 数据类型</p><p>2.3 对象在内存中的对齐方式</p><p>​    类型都对其对象限定了对应的对齐方式，也就是说类型指定了该类型对象的内存地址形式。形式诸如所有地址都可存储，偶数地址开始存储，被4整除地址开始存储等等。一个类型的对齐用该类型两个连续对象在内存中相距的字节数表示</p><p>2.3.1  _Alignof操作符</p><p>​    _Alignof用于判断一个类型的对齐，使用格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_Alignof(int)  //此时返回4</span><br></pre></td></tr></table></figure><p>2.3.2 _Alignas修饰符</p><p>​    _Alignas用于规定对齐值，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_Alignof(4) short a; //定义一个拥有4字节对齐值的short类型变量a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术-第二章上</title>
      <link href="/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A/"/>
      <url>/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/08/C语言核心技术-第二章上/title3.jpg" alt="title3"></p><a id="more"></a><p>第二章 数据类型</p><p>​    C语言中，对象引用到内存中的一个位置，该位置内容可表示为该对象的值。一个对象的数据类型决定了这个对象在内存中所占用的空间大小，以及所采用的编码方式</p><p>2.1 整数类型</p><p>​    char类型也是一个标准的整数类型</p><p>​    C语言只定义了标准类型最小的存储空间，char类型只占用一个字节，short类型至少占用2字节，long类型至少占用4字节，long long类型至少占用8字节(1字节 == 8位)</p><p>2.1.1stdint.h头文件</p><p>​    stdint.h头文件定义了整数类型以满足对于已知位长的定义：</p><p>​    intN_t / uintN_t    位长为N的整数/无符号整数</p><p>​    int_leastN_t / uint_leastN_t    位长至少为N的整数/无符号整数</p><p>​    int_fastN_t / uint_fastN_t    位长至少为N的最快速的整数/无符号整数</p><p>​    intmax_t / uintmax_t    位长最大的整数/无符号整数</p><p>​    intptr_t / uintptr_t    位长足以存储指针值的整数/无符号整数</p><p>​    关于intptr_t的足以存储指针值的整数如何理解，我百度了一下它的宏定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Types for `void *&apos; pointers.  */</span><br><span class="line"></span><br><span class="line">#if __WORDSIZE == 64  </span><br><span class="line"># ifndef __intptr_t_defined  </span><br><span class="line">typedef long int  intptr_t;  </span><br><span class="line">#  define __intptr_t_defined  </span><br><span class="line"># endif  </span><br><span class="line">typedef unsigned long int  uintptr_t;</span><br><span class="line"></span><br><span class="line">#else  </span><br><span class="line"># ifndef __intptr_t_defined  </span><br><span class="line">typedef int   intptr_t;  </span><br><span class="line">#  define __intptr_t_defined  </span><br><span class="line"># endif  </span><br><span class="line">typedef unsigned int    uintptr_t;  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    显然，intptr_t不是指针类型，而是long int型。至于为什么解释成void *指针，尽管概念上地址是指针, 但内存管理常常使用一个无符号整型更好地完成。因为内核对待物理内存如同一个大数组，并且内存地址只是一个数组索引。而一个指针容易解引用，当直接处理内存存取时, 使用一个整数类型能避免这种解引用，因此避免了 bug。所以内核中内存地址常常是unsigned long型。（关于解引用，可以解释为返回内存地址中保存的值，关于它的解释找到一篇特别好的博文 <a href="https://www.cnblogs.com/Mayfly-nymph/p/8213837.html" target="_blank" rel="noopener">跳转</a> ）</p><p>2.1.2limits.h头文件</p><p>​    该头文件有很多宏定义，用于获得整数类型的范围，例如：INT_MIN,UINT_MAX,INT_LEAST64_MIN 等等</p><p>2.2浮点类型</p><p>​    关于浮点类型精度丢失的原因：</p><p>​    是因为我们在程序里写的是十进制小数，而计算机内部只能用二进制的小数表示, 所以导致无法精确的表达</p><p>​    对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n），所以十进制小数都是由这些小数一点点拼凑出来的一个近似值, 所以才会不准确</p><p>​    例如用二进制来表示十进制的1.2:<br>​    1.01 = 1 + 1/4 = 1.25 , 偏大<br>​    1.001 = 1 + 1/8 = 1.125 , 偏小<br>​    1.0011 = 1 + 1/8 + 1/16 = 1.1875，偏小<br>​    1.001101 = 1 + 1/8+ 1/16 + 1/64 = 1.203125 , 偏大<br>​    1.0011001 = 1 + 1/8 + 1/16 + 1/128 = 1.1953125 ,偏小<br>​    1.00110011 = 1 + 1/8+1/16+1/128+1/256 = 0.19921875 , 偏小<br>​    直到越来越接近…这就是精度缺失的根本原因</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术—第一章下</title>
      <link href="/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8B/"/>
      <url>/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/07/C语言核心技术—第一章下/title1.jpg" alt="title1"></p><a id="more"></a><p>第一章：C语言基础</p><p>1.6编译器运行原理</p><p>​    用文本编辑器写完源码，编译器对翻译单元进行处理，若没有发现错误，则会生成包含对应机器码的目标文件（扩展名为.o或.obj）</p><p>​    目标文件也成为模块，一个链接库包含多个编译好可以快速获取的模块</p><p>​    然后编译器调用链接器将所有目标文件和所用到的链接库函数结合起来，成为一个可执行文件</p><p><img src="/2018/12/07/C语言核心技术—第一章下/1.jpg" alt="1"></p><p>1.6.1编译的8个逻辑步骤</p><p>​    (1)从源码读取并转换字符，如有必要将字符转换成源代码字符集的字符</p><p>​    (2)无论何时，只要反斜线后紧跟换行符，预处理器都会将两者删除，因为行尾字符视为预处理器命令的终止，反斜线可让预处理命令（如宏定义）可以在下一行继续</p><p>​    (3)将源码文件分解为若干预处理器标记和空格符序列，每个注释被看作一个空格</p><p>​    (4)执行预处理命令，展开宏调用</p><p>​    //1～4不仅作用于源码文件，也作用于#include命令插入的文件。</p><p>​    (5)字符常量和字符串字面量中的字符和转义序列被转换成运行字符集中对应的字符</p><p>​    (6)相邻字符串字面量被连接为一个字符串</p><p>​    (7)编译器分析标记序列，生成对应机器码</p><p>​    (8)链接器解析对外部函数和对象的引用，并生成可执行文件</p><p>1.6.2标记</p><p>​    标记可以是关键字、标识符、常量、字符串字面量、符号</p><p>​    将源码解析成标记过程中，采用原则如下：</p><p>​    为避免歧义，每个连续的非空格符必须附加到正在读取的标记后面，直到出现附加后使得有效标记变为无效为止</p><p>​    例如：a+++b。第一个+无法当作标识符的一部分，也不能当作以a开头的关键字的一部分，所以+是一个新标记的开始。第二个+附加到第一个+后面形成一个有效标记++，第三个+附加上来+++不是有效标记，因此表达式被分解成a++ + b</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术—第一章上</title>
      <link href="/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8A/"/>
      <url>/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/07/C语言核心技术—第一章上/title.jpg" alt="title"></p><a id="more"></a><p>第一章：C语言基础</p><p>1.1C语言程序结构</p><p>​    函数定义，全局声明和预处理命令组成了C语言程序</p><p>1.1.1 关于链接库：</p><p>​    C语言链接库除标准库外，还有许多特殊链接库可以使用，例如图形函数链接库。</p><p>​    如果使用非标准库，会限制所开发程序的可移植性。这些程序只能移植到已经加载了这些非标准库的系统上</p><p>1.1.2关于预处理命令</p><p>​    函数中调用的每个函数需要在该函数前声明，预处理命令#include&lt;.h&gt;指示编译器的预处理器将该头文件内容插入到源代码中，以达到声明头文件中函数的目的。</p><p>​    预处理命令每条需独占一行，且#前只能有空格符或制表符，不可有其它字符（若想换行可在前一行最后加反斜线）</p><p>1.1.3关于函数</p><p>​    C语言由函数组成，一个函数可以调用其他函数。函数的定义不能嵌套在另一个函数内（也就是说函数内可以定义局部变量，但是不能定义局部函数）</p><p>1.2源代码文件</p><p>1.2.1模块化</p><p>​    C语言支持模块化，也就是将一个程序组织成多个源代码文件和头文件，然后分别编译他们</p><p>​    对于一个包含多个源文件的程序，可利用头文件来存储函数的声明、全局变量、宏与常量。并通过引用头文件来间接声明它们。</p><p>1.2.2编译单元与标记</p><p>​    每个C源代码文件连同被包含在其中的头文件，构成一个翻译单元。</p><p>​    编译器按次序处理编译单元的内容，把源代码转换成标记。标记是最小的语义单元，如变量名称与运算符</p><p>1.3注释</p><p>​    预处理器仅通过检查注释的结束符来判定注释结束，因此不能嵌套块注释。若想注释包含块注释的代码，可使用条件预处理命令，例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if 0/*如果true则执行之间的代码，false直接跳过 0代表false)</span><br><span class="line">int a = 5; /*定义a*/</span><br><span class="line">    printf(&quot;%d\n&quot;, a); /*输出a*/</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    预处理会把每个注释都替换成一个空格</p><p>1.4环境</p><p>​    编译器转换程序源代码时，所处环境称为编译环境</p><p>​    编译后程序执行，所处环境称为运行环境</p><p>1.5字符集</p><p>​    C语言定义了两个字符集：源代码字符集和运行字符集。源代码字符集用于组成源码，运行字符集是可以被执行程序解释的字符集</p><p>​    在许多C语言实现版本中，两个字符集相同。若不同，则编译器会把源代码中的字符常量和字符串字面量转换成运行字符集中对应的元素</p><p>1.5.1宽字符和多字节字符</p><p>​    为兼容全球的所有语言，有些字符需要超过一个字节来编码。因此出现了两种表示大型字符集的标准化方法：</p><p>​    宽字符：该字符集内，每个字符使用相同的位长</p><p>​    多字节字符：每个字符可以采用一个或多个字节表示，通过它所在字符串或流的上下文，来确定字符值</p><p>1.5.2双字符组和三字符组</p><p>​    有些符号在键盘无法输入，可采用一些等效方法实现。例如双字符组和三字符组。</p><p>​    例如：&lt;: 等价为 [     </p><p>​           %&gt; 等价为 }  </p><p>​            ??&lt; 等价为{    等等</p><p>1.5.3通用符和标识符</p><p>​    通用符即Unicode值，格式为\uXXXX或\UXXXXXXXX （X为16进制数），可用于标识符、字符常量、字符串字面量。</p><p>​    标识符用于引用变量、函数、宏、结构以及其他定义的对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-12-04博客搭建进度</title>
      <link href="/2018/12/04/18-12-04%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/12/04/18-12-04%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/04/18-12-04博客搭建进度/titile.jpg" alt="titile"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页 (11.30更新)</p><p>​    ——调整底部布局 (12.02更新)</p><p>​    ——新增小游戏——见缝插针 (12.02更新)</p><p>​    ——修复音乐弹出、小火箭移动端错误问题</p><p>​    ——更新“关于我”页面特效</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-12-02博客搭建进度</title>
      <link href="/2018/12/02/18-12-02%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/12/02/18-12-02%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/18-12-02博客搭建进度/title9.jpg" alt="title9"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页 (11.30更新)</p><p>​    ——调整底部布局</p><p>​    ——新增小游戏——见缝插针</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐搭积木</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%90%AD%E7%A7%AF%E6%9C%A8/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%90%AD%E7%A7%AF%E6%9C%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐搭积木/title.jpg" alt="title"></p><a id="more"></a><p>题目描述</p><p>小乐乐想要给自己搭建一个积木城堡。 </p><p>积木城堡我们假设为n*m的平面矩形。 </p><p>小乐乐现在手里有1<em>2，2</em>1两种地砖。 </p><p>小乐乐想知道自己有多少种组合方案。 </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入整数n,m。(1&lt;=n,m&lt;=10)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出组合方案数。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>示例2</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>示例3</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    状压dp的入门题，把每一行的状态压缩成一个二进制数（竖为1横为0），然后转化为十进制。依次遍历第一行的所有状态方案数都初始化为1，然后依据dp递推式推出其余行。最后累加最后一行的所有可行性方案的和即可。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define Maxn 2048</span><br><span class="line">using namespace std;</span><br><span class="line">int chg[Maxn*Maxn][2];</span><br><span class="line">ll dp[1&lt;&lt;13][13];</span><br><span class="line">int n,m,tot;</span><br><span class="line"> </span><br><span class="line">void dfs(int c,int s,int scur)&#123;</span><br><span class="line">    if(c&gt;m) return;</span><br><span class="line">    if(c==m)&#123;</span><br><span class="line">        chg[tot][0]=s;</span><br><span class="line">        chg[tot++][1]=scur;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(c+1,s&lt;&lt;1,scur&lt;&lt;1|1);</span><br><span class="line">    dfs(c+1,s&lt;&lt;1|1,scur&lt;&lt;1);</span><br><span class="line">    dfs(c+2,s&lt;&lt;2|3,scur&lt;&lt;2|3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    if(m&gt;n) &#123;</span><br><span class="line">        int kk = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = kk;</span><br><span class="line">    &#125;</span><br><span class="line">    tot=0;</span><br><span class="line">    dfs(0,0,0);</span><br><span class="line">    memset(dp,0,sizeof dp);</span><br><span class="line">    dp[(1&lt;&lt;m)-1][0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;tot;j++)</span><br><span class="line">            dp[chg[j][1]][i]+=dp[chg[j][0]][i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,dp[(1&lt;&lt;m)-1][n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐打游戏</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%89%93%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%89%93%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐打游戏/title8.jpg" alt="title8"></p><a id="more"></a><p>题目描述</p><p>​        小乐乐觉得学习太简单了，剩下那么多的时间好无聊，于是便想打游戏。<br>​        最近新出了一个特别火的游戏，叫吃猪，小乐乐准备玩一玩。<br>​        吃猪游戏很简单，给定一个地图，大小为n*m，在地图中会随机出现一个火山口，只要小乐乐能逃离这个地图，他便能吃猪！<br>​        但吃鸡远没有那么简单：<br>​        1.小乐乐每走一次只能上下左右四个方向中走一步。<br>​        2.小乐乐每走一步，火山喷发的岩浆就会向四周蔓延一个格子，所有岩浆走过的地方都视为被岩浆覆盖。<br>​        3.小乐乐碰到岩浆就会死。<br>​        4.地图中还有很多障碍，使得小乐乐不能到达，但是岩浆却可以把障碍融化。<br>​        5.小乐乐只有走到题目给定的终点才算游戏胜利，才能吃猪。<br>​        小乐乐哪见过这场面，当场就蒙了，就想请帮帮他，告诉他是否能吃猪。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组样例输入</span><br><span class="line"></span><br><span class="line">第一行给定n,m,(1 &lt;= n, m &lt;= 1000)代表地图的大小。</span><br><span class="line"></span><br><span class="line">接下来n行，每一行m个字符，代表地图，对于每一个字符，如果是&apos;.&apos;，代表是平地，&apos;S&apos;代表小乐乐起始的位置，</span><br><span class="line">&apos;E&apos;代表终点，&apos;#&apos;代表障碍物，&apos;F&apos;代表火山口。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出只有一行。如果小乐乐能吃猪，输出&quot;PIG PIG PIG!&quot;。否则输出&quot;A! WO SI LA!&quot;。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">F..</span><br><span class="line">#S#</span><br><span class="line">#.E</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PIG PIG PIG!</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    两个BFS，注意下细节即可。。。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,foot;</span><br><span class="line">&#125;;</span><br><span class="line">int dx[5]=&#123;0,1,-1,0&#125;,n,m;</span><br><span class="line">int dy[5]=&#123;1,0,0,-1&#125;;</span><br><span class="line">char a[1001][1001];</span><br><span class="line">int vis[1001][1001];</span><br><span class="line">int footstep[1001][1001];</span><br><span class="line">int bfs(int startx,int starty)&#123;</span><br><span class="line">    deque&lt;node&gt;Q;</span><br><span class="line">    node start;</span><br><span class="line">    start.x = startx;</span><br><span class="line">    start.y = starty;</span><br><span class="line">    start.foot = 0;</span><br><span class="line">    vis[startx][starty] = 1;</span><br><span class="line">    Q.push_back(start);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        node now = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        // printf(&quot;x=%d y=%d foot = %d\n&quot;,now.x,now.y,now.foot);</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = now.x+dx[i];</span><br><span class="line">            int y = now.y+dy[i];</span><br><span class="line"> </span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;n &amp;&amp;y&gt;=0&amp;&amp;y&lt;m &amp;&amp; a[x][y] != &apos;#&apos; &amp;&amp; a[x][y] != &apos;F&apos;&amp;&amp; !vis[x][y] &amp;&amp; now.foot+1&lt;=footstep[x][y])&#123;</span><br><span class="line">                if(a[x][y] == &apos;E&apos;)&#123;</span><br><span class="line">                    return now.foot+1;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                node then;</span><br><span class="line">                then.x = x;</span><br><span class="line">                then.y = y;</span><br><span class="line">                then.foot = now.foot+1;</span><br><span class="line">                Q.push_back(then);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.clear();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void bfs1(int startx,int starty)&#123;</span><br><span class="line">    deque&lt;node&gt;Q;</span><br><span class="line">    node start;</span><br><span class="line">    start.x = startx;</span><br><span class="line">    start.y = starty;</span><br><span class="line">    start.foot = 0;</span><br><span class="line">    footstep[startx][starty] = 0;</span><br><span class="line">    vis[startx][starty] = 1;</span><br><span class="line">   Q.push_back(start);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        node now = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = now.x+dx[i];</span><br><span class="line">            int y = now.y+dy[i];</span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;n &amp;&amp;y&gt;=0&amp;&amp;y&lt;m &amp;&amp;!vis[x][y])&#123;</span><br><span class="line">                footstep[x][y] = now.foot+1;</span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                node then;</span><br><span class="line">                then.x = x;</span><br><span class="line">                then.y = y;</span><br><span class="line">                then.foot = now.foot+1;</span><br><span class="line">                Q.push_back(then);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.clear();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        int Sx,Sy,Ex,Ey;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,a[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                if(a[i][j] == &apos;S&apos;)&#123;</span><br><span class="line">                    Sx = i,Sy = j;</span><br><span class="line">                &#125;else if(a[i][j] == &apos;F&apos;)&#123;</span><br><span class="line">                    Ex = i,Ey = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(footstep,0,sizeof(footstep));</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        bfs1(Ex,Ey);</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        int ans1 = bfs(Sx,Sy);</span><br><span class="line">        if(ans1)&#123;</span><br><span class="line">            printf(&quot;PIG PIG PIG!\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;A! WO SI LA!\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> BFS </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐下象棋</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E4%B8%8B%E8%B1%A1%E6%A3%8B/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E4%B8%8B%E8%B1%A1%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐下象棋/title7.jpg" alt="title7"></p><a id="more"></a><p>题目描述</p><p>小乐乐一天天就知道玩，这一天又想玩象棋。<br>我们都知道马走日。<br>现在给定一个棋盘，大小是n*m,把棋盘放在第一象限，棋盘的左下角是(0,0),右上角是(n - 1, m - 1);<br>小乐乐想知道，一个马从左下角(0, 0)开始，走了k步之后，刚好走到右上角(n - 1, m - 1)的方案数。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：多组样例输入，每组一行，三个整数n, m, k(1 &lt;= n, m, k &lt;= 200),如题目所示。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：输出答案 mod 1000000007</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    设置dp【i】【j】【k】代表第k步到达坐标为(i,j)的方案数，然后三层for循环找8个方向即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define mod 1000000007</span><br><span class="line">long long dp[205][205][205];</span><br><span class="line">int fx[8][2] = &#123;1, 2, 2, 1, -1, 2, -2, 1, -1, -2, -2, -1, 1, -2, 2, -1&#125;;</span><br><span class="line">int main () &#123;</span><br><span class="line">int n, m, k;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) &#123;</span><br><span class="line">memset(dp, 0, sizeof(dp));</span><br><span class="line">dp[0][0][0] = 1;</span><br><span class="line">for (int p = 1; p &lt;= k; p++) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">for (int q = 0; q &lt; 8; q++) &#123;</span><br><span class="line">int ii = i + fx[q][0];</span><br><span class="line">int jj = j + fx[q][1];</span><br><span class="line">if (ii &gt;= 0 &amp;&amp; ii &lt; n &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; m) &#123;</span><br><span class="line">dp[i][j][p] = (dp[i][j][p] + dp[ii][jj][p - 1]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[n - 1][m - 1][k]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐和25</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%92%8C25/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%92%8C25/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐和25/title6.jpg" alt="title6"></p><a id="more"></a><p>题目描述</p><p>小乐乐特别喜欢25这个数字，他想把所有的数字都变成25的倍数。<br>现在小乐乐得到一个数字，想问问你最少用几次操作才可以把这个数字改造成25的倍数。<br>对于一次操作我们可以把相邻的两位做交换，比如123经过一次操作之后就可以变成213或者132。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组数据输入</span><br><span class="line"></span><br><span class="line">对于每组数据，只有一行输入一个整数n(1 &lt;= n &lt;= 1000000000)。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果经过最少x次操作后，这个数就变成了25的倍数，那么输出x；</span><br><span class="line"></span><br><span class="line">如果这个数无论怎么变化都变不成25的倍数，输出-1.</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>示例2</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">经过一次之后变成2200</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    要想是25的倍数，只要保证最后最后两位是00或者25或者50或者75即可。然后对这四种情况进行模拟即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[15];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        int num0 = 0, num2 = 0, num5 = 0, num7 = 0;</span><br><span class="line">        int tot = 0, flag = 0;</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        while(n) &#123;</span><br><span class="line">            a[++tot] = n % 10;</span><br><span class="line">            n /= 10;</span><br><span class="line">            if (a[tot] == 0) &#123;</span><br><span class="line">                num0++;</span><br><span class="line">            &#125; else if(a[tot] == 2) &#123;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125; else if(a[tot] == 5) &#123;</span><br><span class="line">                num5++;</span><br><span class="line">            &#125; else if(a[tot] == 7) &#123;</span><br><span class="line">                num7++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num0 &gt;= 2) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 0) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 0) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line">        &#125;</span><br><span class="line">        if (num2 &gt;= 1 &amp;&amp; num5 &gt;= 1) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 5) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 2) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        if(num5 &gt;= 1 &amp;&amp; num0 &gt;= 1) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 0) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 5) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line">        &#125;</span><br><span class="line">        if(num7 &gt;= 1 &amp;&amp; num5 &gt;= 1) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 5) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 7) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, minn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐学博弈</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%AD%A6%E5%8D%9A%E5%BC%88/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%AD%A6%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐学博弈/title4.jpg" alt="title4"></p><a id="more"></a><p>题目描述</p><p>小乐乐和小皮蛋开始学习关于博弈的知识。<br>给定两堆石子，第一堆有n个石子，第二堆有m个石子。<br>每次操作可以从一堆石子中拿走一些石子，拿走石子的数量可以是1 - k个，小乐乐先手拿石子，然后依次轮流。<br>假如到小乐乐的轮次，小乐乐拿不了了(也就是所有的石子都被拿光了)，那么小皮蛋就获胜，反之亦然。<br>假设小乐乐和小皮蛋都绝顶聪明，都会采用最佳的策略，请问最后谁会赢。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组数据输入，对于每一组数据，只有一行由空格分开的三个整数n, m, k(0 &lt;= n, m &lt;= 1000000000, k &gt;= |n - m|).</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果小乐乐会赢，输出&quot;HAI YOU SEI!&quot;,否则输出&quot;LAOZI CHUI SI NI!&quot;。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">130 135 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HAI YOU SEI!</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小乐乐会赢</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题有个输入限制k &gt;= |n - m|，自己看着n,m,k的数很大都是1e9，觉得应该是很简单的一个题，规律不可能太复杂。然后自己写了n多的样例，发现只有在n == m的时候小乐乐才会输。莽了一发过了</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, k;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) &#123;</span><br><span class="line">        if (n == m) &#123;</span><br><span class="line">            printf(&quot;LAOZI CHUI SI NI!\n&quot;);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            printf(&quot;HAI YOU SEI!\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐匹配字符串</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐匹配字符串/title3.jpg" alt="title3"></p><a id="more"></a><p>题目描述</p><p>小乐乐有字符串str1,str2。 </p><p>小乐乐想要给他们找朋友。 </p><p>小乐乐想知道在这两个字符串中最多能匹配出多长的相同子串（可非连续）。 </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入字符串str1;</span><br><span class="line"></span><br><span class="line">第二行输入字符串str2;</span><br><span class="line"></span><br><span class="line">数据保证字符串长度小于1000，且非空，字符串仅由小写字母组成。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出最长相同子串的长度。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asd</span><br><span class="line">ad</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    动态规划入门题，两层 for循环分别遍历两个字符串的字符，若s1【i】 == s2【j】，则dp【i】【j】= dp【i - 1】【j - 1】+ 1，否则dp【i】【j】= max(dp【i - 1】【j】,dp【i】【j - 1】)即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s1[1005], s2[1005];</span><br><span class="line">int dp[1005][1005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    scanf(&quot;%s&quot;, s1 + 1);</span><br><span class="line">    scanf(&quot;%s&quot;, s2 + 1);</span><br><span class="line">    int n1 = strlen(s1 + 1);</span><br><span class="line">    int n2 = strlen(s2 + 1);</span><br><span class="line">    for (int i = 1; i &lt;= n1; i++) &#123;</span><br><span class="line">        for (int j = 1; j&lt;= n2; j++) &#123;</span><br><span class="line">            if(s1[i] != s2[j]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[n1][n2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐玩木桶+</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6-1/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐玩木桶-1/title2.jpg" alt="title2"></p><a id="more"></a><p>题目描述</p><p>小乐乐用散落在森林里的木板做了一个木桶。 </p><p>已知底面积为S(㎡)。 </p><p>小乐乐经过各种仪器的精密测量知道了，所有木板的近似长度h[i]。 </p><p>小乐乐只能选用三块木板去拼木桶，小乐乐拼凑成的木桶的最大装水体积是(㎡)？ </p><p>（容量测量，底面积乘高，木桶不倾斜） </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入整数n，S。(3&lt;=n&lt;=1000，1&lt;=s&lt;=1000，n表示拼凑木桶所需木板)</span><br><span class="line"></span><br><span class="line">第二行输入n个整数h[i](1&lt;=h[i]&lt;=1000,h[i]表示i号木板的长度)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出木桶最大装水体积。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 3 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题是上一道题的变形 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐玩木桶/">上题链接</a>  只要sort一下，用s✖️第三大的数即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        printf(&quot;%d\n&quot;, a[n - 3] * m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐玩木桶</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐玩木桶/titile1.jpg" alt="titile1"></p><a id="more"></a><p>题目描述</p><p>小乐乐用散落在森林里的木板做了一个木桶。 </p><p>已知底面积为S(㎡)。 </p><p>小乐乐经过各种仪器的精密测量知道了，所有木板的近似长度h[i]。 </p><p>小乐乐想知道自己拼凑出的木桶的最大装水体积为？ </p><p>（容量测量，底面积乘高，木桶不倾斜） </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入整数n，S。(1&lt;=n,s&lt;=1000，n表示拼凑木桶所需木板)</span><br><span class="line"></span><br><span class="line">第二行输入n个整数h[i](1&lt;=h[i]&lt;=1000,h[i]表示i号木板的长度)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出木桶最大装水体积。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    就是找出最小值，然后用s ✖️最小值即可。。。大水题</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        int a;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            if (minn &gt; a) &#123;</span><br><span class="line">                minn = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, minn * m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈理工院赛-小乐乐的组合数+</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐的组合数/title7.jpg" alt="title7"></p><a id="more"></a><p>题目描述</p><p>小乐乐得知一周有7天之后就对7产生了兴趣。 </p><p>小乐乐得到了两堆数字数字时连续的。 </p><p>第一堆包含[1,n]n个数字，第二堆包含[1,m]m个数字。</p><p>小乐乐想要从两堆中各挑选出一个整数x,y，使得x,y的和为7的倍数。</p><p>请问小乐乐有多少种组合的方式。 </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入整数n,m。(1&lt;=n,m&lt;=1e6)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出满足的对数。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 7</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    从n,m中找一个较小值，用i遍历这个较小值，然后累加（(i + 较大值)  / 7）- (i / 7)即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    long long n, m;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    if (n &gt; m) &#123;</span><br><span class="line">        long long flag = n;</span><br><span class="line">        n = m;</span><br><span class="line">        m = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        long long k = i + m;</span><br><span class="line">        ans += k / 7 - i / 7;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-30博客搭建进度</title>
      <link href="/2018/11/30/18-11-30%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/30/18-11-30%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/30/18-11-30博客搭建进度/title5.jpg" alt="title5"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-29博客搭建进度</title>
      <link href="/2018/11/29/18-11-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/29/18-11-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/29/18-11-29博客搭建进度/title1.jpg" alt="title1"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明</p><p>​    ——实现博文字数统计</p><p>​    ——添加顶部加载条</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近几天</title>
      <link href="/2018/11/28/%E6%9C%80%E8%BF%91%E5%87%A0%E5%A4%A9/"/>
      <url>/2018/11/28/%E6%9C%80%E8%BF%91%E5%87%A0%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/28/最近几天/title4.jpg" alt="title4"></p><a id="more"></a><p>​    比完赛歇了两天后发现，三个星期外出打比赛落下的作业，课程设计，过程性考核扒拉扒拉之类的东西像冰冷的雨点在我脸上胡乱的拍，简直要哭了，直到今天所有的作业算是告一段落</p><p>​    补习班11月17号也开课了，前期课还挺简单（呸呸呸！不奶了不奶了），每次要坐40多分钟公交去补课的地方。哎～睡懒觉的机会没了</p><p>​    12月份院赛，校赛也要开始了。打打就好，过了那个兴奋的年纪</p><p>​    也该准备找工作滚粗了，简历几乎要完稿了，还差最最最重要的照骗，预约了明天的海马体，但愿能拍成照骗而不是照片吧哈哈哈哈</p><p>​    寒假是继续留在哈尔滨补课还是能pass过简历去公司实习，纠结～ 每一步都不想走错，自己继续纠结吧</p><p>​    哈尔滨的冬天 屋里暖气烘烘的 一天到晚好疲乏呀总是睡觉 想出去踢球 想着外边哈哈气都起雾 算了吧 哎 苦涩～</p><p>​                                        ——2018.11.28夜</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-28博客搭建进度</title>
      <link href="/2018/11/28/18-11-28%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/28/18-11-28%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/28/18-11-28博客搭建进度/titile6.jpg" alt="titile6"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景</p><p>​    ——修改网站图片外链至本地</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十八)getcwd(),getline(),chdir()函数</title>
      <link href="/2018/11/16/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-18/"/>
      <url>/2018/11/16/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-18/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/16/C语言查缺补漏-18/title.jpg" alt="title"></p><a id="more"></a><p>关于getcwd()与getline()与chdir()函数使用：</p><p>一.getcwd()函数定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">char *getcwd(char *buf,size_t size);</span><br><span class="line">//getcwd()会将当前工作目录的绝对路径并复制到参数buf所指的内存空间,参数size为buf的空间大小。</span><br></pre></td></tr></table></figure><p>二.getcwd()函数用法:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> path[<span class="number">105</span>];</span><br><span class="line">getcwd(path,<span class="keyword">sizeof</span>(path));</span><br><span class="line"><span class="built_in">puts</span>(path);</span><br></pre></td></tr></table></figure><p>三.getline()函数定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istream&amp; getline(istream &amp;is, string &amp;str, char delim);</span><br><span class="line">istream&amp; getline(istream &amp;is, string &amp;str);</span><br><span class="line">is是进行读入操作的输入流，str是用来存储读入的内容，delim是终结符，遇到该字符停止读取操作，不写默认为回车</span><br></pre></td></tr></table></figure><p>四.getline()函数用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行输入回车结束时：</span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line"></span><br><span class="line">循环输入到ctrl + z结束时：</span><br><span class="line">while (getline(cin, str)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五.chdir函数定义：</p><p>​    chdir 是C语言中的一个系统调用函数（同cd），用于改变当前工作目录。其参数为Path 目标目录，可以是绝对目录或相对目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; </span><br><span class="line">int chdir（const char * path）; </span><br><span class="line">chdir（）用户将当前的工作目录改变成以参数路径所指的目录。</span><br><span class="line">返回值执行成功则返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>六.chdir函数用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chdir(&quot;/tmp&quot;);</span><br><span class="line">//当前目录更改为/tmp</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京站总结</title>
      <link href="/2018/11/15/2018icpc%E5%8C%97%E4%BA%AC%E7%AB%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/15/2018icpc%E5%8C%97%E4%BA%AC%E7%AB%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc北京站总结/title.jpg" alt="title"></p><a id="more"></a><p>​    亚洲区预赛北京站应该是国内最难打的一站吧。。刚开始就没抱什么期待。比赛前一星期做了青岛的重现赛，5题银牌水平，突然就对北京有了一丝期待，但愿能获个奖，希望今年不白玩。</p><p>​    现场赛开始后刚开始，队友告诉我I题可以用数位dp做，连忙看起了i，另两个队友看起了A题。没过10分钟清华大学A题一血。增林老哥紧随其后没多久A题Accept。赛后问队友A题好像是传递闭包，然后自己今天补了一下这道题：<a href="http://www.ivan-zcy.top/2018/11/15/2018icpc北京Jin-Yong-Wukong-Ranking-List传递闭包/">链接</a></p><p>​       I题修修改改，找其中关系解决了n取1e5范围的所有可能。结果WA了，再读题才发现，它喵的这道题n的长度是1e5，而不是数字。。。那肯定规律题没跑了，让志愿者打印了之前处理前9位数的表。找到了规律。在第2个小时Accpet掉：<a href="http://www.ivan-zcy.top/2018/11/15/2018icpc-Palindromes推规律/">链接</a></p><p>​    D题现场赛被我刨除相邻建传送门的可能。。从那之后思路再也没往那上面靠过。很遗憾没出，今天补了补20多分钟就出了，满心悔恨～还是自己脑子太笨了。。 <a href="http://www.ivan-zcy.top/2018/11/15/2018icpc北京Frog-and-Portal转换二进制/">链接</a></p><p>​    B题至今很迷，不知道问题出到哪儿了。我把WA的代码贴出来，希望大佬们能出一组样例Hack一下我的代码。。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int num[205];</span><br><span class="line">int ans[205];</span><br><span class="line">int add[205];</span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    str.clear();</span><br><span class="line">    memset(ans, 0, sizeof(ans));</span><br><span class="line">    memset(add, 0, sizeof(add));</span><br><span class="line">    int tot = 0;</span><br><span class="line">    int flggg = 0;</span><br><span class="line">    int numm = 0;</span><br><span class="line">    while((c = getchar()) != EOF) &#123;</span><br><span class="line">        if (c == &apos;#&apos;) break;</span><br><span class="line">        if (c == &apos;\n&apos;) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            num[tot] = numm;</span><br><span class="line">            numm = 0;</span><br><span class="line">            if (str[str.length() - 1] &gt;= &apos;0&apos; &amp;&amp; str[str.length() - 1] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                flggg = 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flggg = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            numm++;</span><br><span class="line">            if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; &amp;&amp; flggg == 1) &#123;</span><br><span class="line">                str += c;</span><br><span class="line">                flggg = 0;</span><br><span class="line">            &#125; else if (flggg) &#123;</span><br><span class="line">                numm++;</span><br><span class="line">                str += &quot; &quot;;</span><br><span class="line">                str += c;</span><br><span class="line">                flggg = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                str += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str += &quot; &quot;;</span><br><span class="line">    num[tot]++;</span><br><span class="line">    for (int i = 1; i &lt;= tot; i ++) &#123;</span><br><span class="line">        add[i] = add[i - 1] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int flag = 0, start = -1, flaa = 0, num = 0;</span><br><span class="line">    for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) &#123;</span><br><span class="line">                flag = 2;</span><br><span class="line">            &#125; else if (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos; &amp;&amp; flaa == 1)&#123;</span><br><span class="line">                flag = 2;</span><br><span class="line">            &#125; else if (str[i] == &apos; &apos;)&#123;</span><br><span class="line">                if (start != -1) &#123;</span><br><span class="line">                    if (num != 0) printf(&quot; &quot;);</span><br><span class="line">                    for (int j = start; j &lt; i; j++) &#123;</span><br><span class="line">                        printf(&quot;%c&quot;, str[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                    for (int j = 1; j &lt;= tot; j++) &#123;</span><br><span class="line">                        if (add[j] &gt; start) &#123;</span><br><span class="line">                            ans[j] ++;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = -1;</span><br><span class="line">                flag = 0;</span><br><span class="line">                flaa = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (flag == 2)&#123;</span><br><span class="line">            if (str[i] == &apos; &apos;) &#123;</span><br><span class="line">                start = -1;</span><br><span class="line">                flag = 0;</span><br><span class="line">                flaa = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                start = i;</span><br><span class="line">                if (str[i] == &apos;0&apos;) flaa = 1;</span><br><span class="line">            &#125; else if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) &#123;</span><br><span class="line">                flag = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num != 0) &#123;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= tot; i ++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后很惊险的拿了亚洲区预赛北京站的铜牌。。虽然今年很遗憾，但也算满足了。哪里跌倒哪里爬起，以后的日子继续加油吧～</p><p><img src="/2018/11/15/2018icpc北京站总结/1.jpg" alt="1"></p><p><img src="/2018/11/15/2018icpc北京站总结/2.jpg" alt="2"></p><p><img src="/2018/11/15/2018icpc北京站总结/3.jpg" alt="3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京Frog and Portal转换二进制</title>
      <link href="/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACFrog-and-Portal%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
      <url>/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACFrog-and-Portal%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc北京Frog-and-Portal转换二进制/titile2.jpg" alt="titile2"></p><a id="more"></a><p>题意：</p><p>时间限制:1000ms</p><p>单点时限:1000ms</p><p>内存限制:512MB</p><p>描述</p><p>A small frog wants to get to the other side of a river. The frog is initially located at one bank of the river (position 0) and wants to get to the other bank (position 200). Luckily, there are 199 leaves (from position 1 to position 199) on the river, and the frog can jump between the leaves. When at position p, the frog can jump to position p+1 or position p+2.How many different ways can the small frog get to the bank at position 200? This is a classical problem. The solution is the 201st number of Fibonacci sequence. The Fibonacci sequence is constructed as follows: F1=F2=1;Fn=Fn-1+Fn-2.Now you can build some portals on the leaves. For each leaf, you can choose whether to build a portal on it. And you should set a destination for each portal. When the frog gets to a leaf with a portal, it will be teleported to the corresponding destination immediately. If there is a portal at the destination, the frog will be teleported again immediately. If some portal destinations form a cycle, the frog will be permanently trapped inside. Note that You cannot build two portals on the same leaf.Can you build the portals such that the number of different ways that the small frog gets to position 200 from position 0 is M?</p><p>输入</p><p>There are no more than 100 test cases.Each test case consists of an integer M, indicating the number of ways that the small frog gets to position 200 from position 0. (0 ≤ M &lt; 232)</p><p>输出</p><p>For each test case:The first line contains a number K, indicating the number of portals.Then K lines follow. Each line has two numbers ai and bi, indicating that you place a portal at position ai and it teleports the frog to position bi.You should guarantee that 1 ≤ K, ai, bi ≤ 199, and ai ≠ aj if i ≠ j. If there are multiple solutions, any one of them is acceptable.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">2</span><br><span class="line">1 199</span><br><span class="line">2 2</span><br><span class="line">2</span><br><span class="line">4 199</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><p>​    这道题意思就是一共有200层楼梯，可以一次上一层，也可以一次上两层。我们可以建造若干个传送门，可以直接从a传送到b（强制传送）。给你一个n，问到第200层有n种方案数，需要建多少个传送门，如何建？（多种建造方案任选一种即可）</p><p>思路：</p><p>​    这道题应该深思如何建造传送门。有3种合理的建造：</p><ol><li><p>由k层传送到199层，这样总方案数会加上第k层的方案数</p></li><li><p>由k层传送到k层。死循环，总方案数不会记入该层方案数</p></li><li><p>由k层传送到k+1层。会使k层的方案数累计到k+1层中。</p><p>由这三种构造，我们可以转化为二进制来求解。</p><p>比如当n为7时，它的二进制为111，也就是1 + 2 + 4</p><p>那么传送门就应该建6个。</p><p>分别是1传送到199（总方案数+1）</p><p>（这样2，3分别有1，1种方案数）</p><p>3传送到4</p><p>（这样4，5分别有2，2种方案数）</p><p>5传送到199 （总方案数+2）</p><p>（这样6，7分别有2，2种方案数）</p><p>7传送到8</p><p>（这样8，9分别有4，4种方案数）</p><p>9传送到199 （总方案数+4）</p><p>10传送到10 （封死）</p><p>（10以后无法到达200，方案数为0）</p><p>这样总方案数为7，符合条件</p></li></ol><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int flag[205];</span><br><span class="line">long long dp[205];</span><br><span class="line">int main () &#123;</span><br><span class="line">    long long n;</span><br><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        memset(flag, 0, sizeof(flag));</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            printf(&quot;2\n1 1\n2 1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n % 2) &#123;</span><br><span class="line">            flag[1] = 1;</span><br><span class="line">            ans ++;</span><br><span class="line">            n /= 2;</span><br><span class="line">            int inx = 3;</span><br><span class="line">            while(n) &#123;</span><br><span class="line">                flag[inx] = 2;</span><br><span class="line">                ans++;</span><br><span class="line">                inx += 2;</span><br><span class="line">                if (n % 2) &#123;</span><br><span class="line">                    flag[inx] = 1;</span><br><span class="line">                    ans++;</span><br><span class="line">                    inx += 2;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            flag[inx - 1] = 3;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            n /= 2;</span><br><span class="line">            int inx = 1;</span><br><span class="line">            while(n) &#123;</span><br><span class="line">                flag[inx] = 2;</span><br><span class="line">                ans++;</span><br><span class="line">                inx += 2;</span><br><span class="line">                if (n % 2) &#123;</span><br><span class="line">                    flag[inx] = 1;</span><br><span class="line">                    ans++;</span><br><span class="line">                    inx += 2;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            flag[inx - 1] = 3;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">        for (int i = 1; i &lt;= 198; i++) &#123;</span><br><span class="line">            if (flag[i] == 1) &#123;</span><br><span class="line">                printf(&quot;%d 199\n&quot;, i);</span><br><span class="line">            &#125; else if (flag[i] == 2) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;, i, i + 1);</span><br><span class="line">            &#125; else if (flag[i] == 3)&#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京Palindromes推规律</title>
      <link href="/2018/11/15/2018icpc-Palindromes%E6%8E%A8%E8%A7%84%E5%BE%8B/"/>
      <url>/2018/11/15/2018icpc-Palindromes%E6%8E%A8%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc-Palindromes推规律/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>时间限制:1000ms</p><p>单点时限:1000ms</p><p>内存限制:512MB</p><p>描述</p><p>Recently, Nvoenewr learnt palindromes in his class.A palindrome is a nonnegative integer that is the same when read from left to right and when read from right to left. For example, 0, 1, 2, 11, 99, 232, 666, 998244353353442899 are palindromes, while 10, 23, 233, 1314 are not palindromes.Now, given a number, Nvoenewr can determine whether it’s a palindrome or not by using loops which his teacher has told him on the class. But he is now interested in another question: What’s the K-th palindrome? It seems that this question is too difficult for him, so now he asks you for help.Nvoenewr counts the number from small to big, like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101 and so on. So the first palindrome is 0 and the eleventh palindrome is 11 itself.<br>Nvoenewr may ask you several questions, and the K may be very big.</p><p>输入</p><p>The first line contains one integer T(T &lt;= 20) —— the number of questions that Nvoenewr will ask you.Each of the next T lines contains one integer K. You should find the K-th palindrome for Nvoenewr.Let’s say K is a n-digit number. It’s guaranteed that K &gt;= 1, 1 &lt;= n &lt;= 100000 and the sum of n in all T questions is not greater than 1000000.</p><p>输出</p><p>Print T lines. The i-th line contains your answer of Nvoenewr’s i-th question.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">101</span><br></pre></td></tr></table></figure><p>​    翻译成汉语就是问第n个回文数是多少？n的长度范围是1e5</p><p>思路：</p><p>​    队友当时告诉我用数位dp做，然后我想了一手觉得还是找联系吧。然后发现只要处理前九位就能填满1e5的数据范围。。直到错了两发才发现，他喵的n的数据范围不是1e5，而是n的数字长度为1e5。好吧，即然这样肯定是有规律了，然后就利用之前处理的前1e9个打表找到其中的规律然后Accept（规律见代码）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 100000</span><br><span class="line"></span><br><span class="line">char s[N + 5];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T --) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, s);</span><br><span class="line">        int len = strlen(s);</span><br><span class="line">        if (len == 1) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, s[0] - &apos;0&apos; - 1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len == 2 &amp;&amp; s[0] == &apos;1&apos; &amp;&amp; s[1] == &apos;0&apos;) &#123;</span><br><span class="line">            printf(&quot;9\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[0] == &apos;1&apos;) &#123;</span><br><span class="line">            if (s[1] == &apos;0&apos;) &#123;</span><br><span class="line">                printf(&quot;9&quot;);</span><br><span class="line">                for (int i = 2; i &lt; len; i++) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int i = len - 2; i &gt; 1; i--) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;9\n&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%d&quot;, s[0] - &apos;0&apos; - 1);</span><br><span class="line">            for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">                printf(&quot;%c&quot;, s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = len - 2; i &gt; 0; i--) &#123;</span><br><span class="line">                printf(&quot;%c&quot;, s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d\n&quot;, s[0] - &apos;0&apos; - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京Jin Yong’s Wukong Ranking List传递闭包</title>
      <link href="/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACJin-Yong-Wukong-Ranking-List%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/"/>
      <url>/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACJin-Yong-Wukong-Ranking-List%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc北京Jin-Yong-Wukong-Ranking-List传递闭包/title2.jpg" alt="title"></p><a id="more"></a><p>时间限制:1000ms</p><p>单点时限:1000ms</p><p>内存限制:512MB</p><p>描述</p><p>Jin Yong was the most famous and popular Chinese wuxia (The one who fight bad people by his Wukong i.e. Wushu and Kongfu) novelist who lived in Hong Kong. Between 1955 and 1972, he wrote 14 novels which earned him a reputation as one of the greatest and most popular Chinese writers. Over 100 million copies of his works have been sold worldwide，not including a countless number of pirated copies. Jin Yong’s works seem to have magic. Once you begin to read a novel of his, you just can’t stop until you finish it.Last month, Jin Yong passed away at the age of 94. Many Jin Yong’s fans in PKU held a meeting to memorize him. Jin Yong’s fans always like to discuss or argue or even quarrel about whose Wukong are better among the wuxia characters of his novel. During the meeting, this happened again:Every fans said some words like “Qiao Feng’s Wukong is better than Guo Jing’s”. Obviously, those words may contradict each other and then cause quarrels. As a boring and girlfriendless male programmer of EECS school, you always want to make some things. So you are eager to point out the contradictions as soon as possible. That means, you want to find out the first one whose words contradict the words said by others before him.Please note that if A is better than B, and B is better than C, then of course A must be better than C.</p><p>输入</p><p>There are no more than 15 test cases.For each test case:The first line is an integer n( 1 &lt;= n &lt;=20), meaning that there are n sentences.The following n lines are those n sentences which is in the format below:s1 s2This means someone said that s1’s Wukong was better than s2’s. Both s1 and s2 are names of Jin Yong’s characters which consists of only English letters. It’s guaranteed that s1 and s2 are different, and their length is no more than 30. Names are case sensitive.</p><p>输出</p><p>For each test case, print the first sentence which cause a contradiction. If there are no contradiction, print 0 instead.</p><p>提示</p><p>DON’T try to figure out who are those names in the sample and waste your time.</p><ul><li><p>样例输入</p><p><code>2</code></p><p> <code>BrokenReputation ExtinctNun</code></p><p> <code>HelloLaught EnvelopeNotFlat</code></p><p><code>6</code></p><p><code>LandOverWind LonelyLight</code></p><p><code>FireMonk CutTheForest</code></p><p><code>CutTheForest LookCrazy</code></p><p><code>MakeFoxRush LetMeGo</code></p><p><code>HeroAunt UniqueLand</code></p><p><code>LookCrazy FireMonk</code></p></li><li><p>样例输出</p><p><code>0</code></p><p><code>LookCrazy FireMonk</code></p></li></ul><p>​    题意就是给出一个n代表有n行，每行两个a，b，代表a的武功高于b，问最早从第几行开始导致前后矛盾，若不矛盾输出0</p><p>思路：</p><p>​    比赛时队友用传递闭包做的，今天自己做了一下。这个题可以转化为有向图判定是否成环（利用map&lt;string, int&gt;映射一下名字），可以用bool型的book{i}{j}来代表从i到j是否连通。每一行都更新一下，若book{i}{j}和book{j}{i}都为1就代表前后矛盾</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s1[25], s2[25];</span><br><span class="line">map&lt;string, int&gt;zcy;</span><br><span class="line">bool book[50][50];</span><br><span class="line">int res1[50], res2[50];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        zcy.clear();</span><br><span class="line">        memset(book, 0, sizeof(book));</span><br><span class="line">        int tot = 0;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; s1[i];</span><br><span class="line">            cin &gt;&gt; s2[i];</span><br><span class="line">            if (!zcy[s1[i]]) &#123;</span><br><span class="line">                zcy[s1[i]] = ++tot;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!zcy[s2[i]]) &#123;</span><br><span class="line">                zcy[s2[i]] = ++tot;</span><br><span class="line">            &#125;</span><br><span class="line">            if (book[zcy[s2[i]]][zcy[s1[i]]] || flag) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res1[0] = zcy[s2[i]];</span><br><span class="line">            res2[0] = zcy[s1[i]];</span><br><span class="line">            int tot1 = 0, tot2 = 0;</span><br><span class="line">            for (int j = 1; j &lt;= tot; j++) &#123;</span><br><span class="line">                if(book[j][zcy[s2[i]]] == 1) &#123;</span><br><span class="line">                    res1[++tot1] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 1; j &lt;= tot; j++) &#123;</span><br><span class="line">                if(book[zcy[s1[i]]][j] == 1) &#123;</span><br><span class="line">                    res2[++tot2] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int p = 0; p &lt;= tot1; p++) &#123;</span><br><span class="line">                for (int q = 0; q &lt;= tot2; q++) &#123;</span><br><span class="line">                    if(book[res2[q]][res1[p]] == 0) &#123;</span><br><span class="line">                        book[res1[p]][res2[q]] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        cout &lt;&lt; s1[i] &lt;&lt; &quot; &quot; &lt;&lt; s2[i] &lt;&lt; endl;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 传递闭包 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc徐州站总结</title>
      <link href="/2018/11/14/2018icpc%E5%BE%90%E5%B7%9E%E7%AB%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/14/2018icpc%E5%BE%90%E5%B7%9E%E7%AB%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>​    <img src="/2018/11/14/2018icpc徐州站总结/title3.jpg" alt="title3"></p><a id="more"></a><p>​    这场比赛有很多没想到吧，努力了那么久，没想到以打铁草草收场。赛后听题解说c题和i题是水题，直到最后一个小时才有人开始做这两个题。我们队也根本没有想过这两个题会是水题。直到比赛半个多小时过去，清华大学才Accept掉第一个A题。所有队伍都开始尝试做这道，我们队也不例外。</p><p>​    关于A题，题意跳转连接：<a href="http://www.ivan-zcy.top/2018/11/14/icpc2018徐州Rikka-with-Minimum-Spanning/">跳转</a> 这道题题干特别特别长，大概就是给出一个随机函数自动生成n个点m条边的无向图，让你求它的最小生成树个数✖️最小生成树权值的值。关于求最小生成树权值很简单，直接可以用Kruskal求解，而最小生成树个数我们队想了好久，刚开始试图Matrix_Tree算法来求，结果发现由于N为1e5，二维数组根本没有办法放开。后来改用dfs，修修改改直到4小时40分钟才Accept掉。</p><p>​    毫无疑问，打铁了。。。距离铜牌只差了12分钟罚时。。。而且给出的正解，竟然说随机函数不可能生成两个及以上的最小生成树。。。。自己辛辛苦苦用最小生成树个数✖️最小生成树权值求出来的，一些队只用简单的最小生成树权值就求出来。。。欲哭无泪，只能说自己还是太菜。。。</p><p>​    来时抱着争银保铜的信心，结果遗憾草草收场…</p><p>​    抛去比赛，中国矿业大学的校园很大很美，校园里大到可以举办半程马拉松，Orz，又是别人家的大学系列。除此之外徐州的地锅鸡也非常非常好吃。一切都过去了，就这样吧～</p><p><img src="/2018/11/14/2018icpc徐州站总结/2.jpg" alt="2"></p><p><img src="/2018/11/14/2018icpc徐州站总结/3.jpg" alt="3"></p><p><img src="/2018/11/14/2018icpc徐州站总结/1.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc徐州Rikka with Minimum Spanning</title>
      <link href="/2018/11/14/icpc2018%E5%BE%90%E5%B7%9ERikka-with-Minimum-Spanning/"/>
      <url>/2018/11/14/icpc2018%E5%BE%90%E5%B7%9ERikka-with-Minimum-Spanning/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/14/icpc2018徐州Rikka-with-Minimum-Spanning/title1.jpg" alt="title1"></p><a id="more"></a><p>给你一个随机函数，其中n为点的数量，m为边的数量，该函数会自动初始化出一张无向无环图，函数如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef unsigned long long ll;</span><br><span class="line">ll k1,k2;</span><br><span class="line">ll xorShift128Plus()</span><br><span class="line">&#123;</span><br><span class="line">    ll k3=k1,k4=k2;</span><br><span class="line">    k1=k4;</span><br><span class="line">    k3^=k3&lt;&lt;23;</span><br><span class="line">    k2=k3^k4^(k3&gt;&gt;17)^(k4&gt;&gt;26);</span><br><span class="line">    return k2+k4;</span><br><span class="line">&#125;</span><br><span class="line">void gen()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d%llu%llu&quot;,&amp;n,&amp;m,&amp;k1,&amp;k2);for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[i].u=xorShift128Plus()%n+1;</span><br><span class="line">        e[i].v=xorShift128Plus()%n+1;</span><br><span class="line">        e[i].w=xorShift128Plus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用如上所示随机函数求出该图所形成的最小生成树个数与该最小生成树总权值的乘积</p><p>题解：</p><p>​    这道题题意其实非常非常长，有很多很多干扰项（比如介绍了一种计算最小生成树数目的算法），翻译成汉语简化一下就是上面那个意思。</p><p>​    嗯嗯，我们队就是被这道题给KO了，辛辛苦苦写了4个多小时的最小生成树计数✖️最小生成树权值才过的题，最后给出的正解居然是直接构造最小生成树就行了。。。。由于随机数生成器过于给力，根本就不会出来两种以上的最小生成树，只需要特判0就行了。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define MAX 100000</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define ll unsigned long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m, p[MAX+5];</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[MAX + 5];</span><br><span class="line"></span><br><span class="line">int find(int r) &#123;</span><br><span class="line">    if(p[r] != r)  p[r] = find(p[r]);</span><br><span class="line">    return p[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp (node a, node b) &#123;</span><br><span class="line">    return a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll k1,k2;</span><br><span class="line"></span><br><span class="line">ll xorShift128Plus() &#123;</span><br><span class="line">    ll k3 = k1,k4 = k2;</span><br><span class="line">    k1 = k4;</span><br><span class="line">    k3 ^= k3 &lt;&lt; 23;</span><br><span class="line">    k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26);</span><br><span class="line">    return k2 + k4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void gen() &#123;</span><br><span class="line">    scanf(&quot;%d%d%llu%llu&quot;,&amp;n, &amp;m, &amp;k1, &amp;k2);</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[i].u = xorShift128Plus() % n + 1;</span><br><span class="line">        e[i].v = xorShift128Plus() % n + 1;</span><br><span class="line">        e[i].w = xorShift128Plus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void kurskal() &#123;</span><br><span class="line">    gen();</span><br><span class="line">    sort(e + 1, e + m + 1, cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    ll sum = 0;</span><br><span class="line">    for(int i = 1;i &lt;= m;i++) &#123;</span><br><span class="line">        int fu = find(e[i].u);</span><br><span class="line">        int fv = find(e[i].v);</span><br><span class="line">        if(fu != fv) &#123;</span><br><span class="line">            p[fu] = fv;</span><br><span class="line">            sum += e[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum = sum % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt == n-1) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt == n-1) printf(&quot;%llu\n&quot;, sum%mod);</span><br><span class="line">    else printf(&quot;0\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">        kurskal();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    没错，就是这么简单～估计这是这一生最令我伤心的一题了吧。。。</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-13博客搭建进度</title>
      <link href="/2018/11/13/18-11-13%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/13/18-11-13%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/13/18-11-13博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM常用数学公式</title>
      <link href="/2018/11/13/ACM%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/11/13/ACM%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/13/ACM常用数学公式/title.jpg" alt="title"></p><a id="more"></a><p><strong>注意：仅支持电脑查看</strong></p><div class="row">    <embed src="数学公式.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Tournament 规律+思维</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BTournament-%E8%A7%84%E5%BE%8B-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BTournament-%E8%A7%84%E5%BE%8B-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Tournament-规律-思维/titile4.jpg" alt="titile4"></p><a id="more"></a><p>题意：</p><p><img src="/2018/11/09/2018icpc青岛Tournament-规律-思维/1.png" alt="1"></p><p><img src="/2018/11/09/2018icpc青岛Tournament-规律-思维/2.png" alt="2"></p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible</span><br><span class="line">2 1 4 3</span><br><span class="line">3 4 1 2</span><br><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure><p>​    这道题大概就是给T组样例，每组样例n个骑士，m轮比赛。每个骑士每轮比赛都得参加，且每轮比赛对手都不能相同，输出一个矩阵a【i】【j】代表第i轮和j骑士进行对决的是a【i】【j】骑士。若有多种情况，答案输出字典序最小的那个。</p><p>思路：</p><p>​    通过打暴力码得到当n为2的次幂时，最多可以有n - 1次对决。否则当n为256的倍数时（由于n的范围只有1000且n不为2的次幂，所以从256算就可以了），最多可以有(1 + 2 + 4 + 8 + … + 128)轮比赛, 当n为128的倍数时，最多可以有(1 + 2 + 4 + … +64 )轮比赛 ……当n为2的倍数时，最多有1轮比赛。</p><p>​    因此只要超过这些轮比赛，直接Impossible即可。</p><p>​    对于满足条件的，我们找出矩阵的规律即可（对于&lt;=2的，与第i - 1轮对每2个一组的数平分两半相互交换，对于&lt;=4的，与第i - 2轮对每4个一组的数平分两半相互交换，对于&lt;= 8的，与第i - 4轮对每8个一组的数平分两半相互交换…依此递推）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int a[1005][1005];</span><br><span class="line">int ttt[15] = &#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;;</span><br><span class="line"></span><br><span class="line">int quick(int a, int b) &#123;</span><br><span class="line">    int ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if(b &amp; 1) ans *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n, m;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int sum = 0, tot = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        int nn = n;</span><br><span class="line">        while(nn % 2 == 0) &#123;</span><br><span class="line">            nn /= 2;</span><br><span class="line">            sum += quick(2, tot);</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; m) &#123;</span><br><span class="line">            printf(&quot;Impossible\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                a[1][i] = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= m + 1; i++) &#123;</span><br><span class="line">                int flaa;</span><br><span class="line">                for (int j = 0; j &lt; 15; j++) &#123;</span><br><span class="line">                    if (ttt[j] &lt; i) &#123;</span><br><span class="line">                        flaa = ttt[j + 1];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flaa /= 2;</span><br><span class="line">                //printf(&quot;%d\n&quot;, flaa);</span><br><span class="line">                for (int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">                    if (j % (flaa * 2) &lt; flaa) &#123;</span><br><span class="line">                        a[i][j] = a[i - flaa][j + flaa];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        a[i][j] = a[i - flaa][j - flaa];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (j == n - 1) &#123;</span><br><span class="line">                        printf(&quot;%d\n&quot;, a[i][j]);</span><br><span class="line">                    &#125; else&#123;</span><br><span class="line">                        printf(&quot;%d &quot;, a[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3162Walking Race 树形dp+单调队列+模拟vector</title>
      <link href="/2018/11/09/POJ3162Walking-Race-%E6%A0%91%E5%BD%A2dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%A8%A1%E6%8B%9Fvector/"/>
      <url>/2018/11/09/POJ3162Walking-Race-%E6%A0%91%E5%BD%A2dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%A8%A1%E6%8B%9Fvector/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/POJ3162Walking-Race-树形dp-单调队列-模拟vector/titile2.jpg" alt="titile2"></p><a id="more"></a><p>题意：</p><p>Description</p><p>flymouse’s sister wc is very capable at sports and her favorite event is walking race. Chasing after the championship in an important competition, she comes to a training center to attend a training course. The center has <em>N</em> check-points numbered 1 through <em>N</em>. Some pairs of check-points are directly connected by two-way paths. The check-points and the paths form exactly a tree-like structure. The course lasts <em>N</em> days. On the <em>i</em>-th day, wc picks check-point <em>i</em> as the starting point and chooses another check-point as the finishing point and walks along the only simple path between the two points for the day’s training. Her choice of finishing point will make it that the resulting path will be the longest among those of all possible choices.</p><p>After every day’s training, flymouse will do a physical examination from which data will obtained and analyzed to help wc’s future training be better instructed. In order to make the results reliable, flymouse is not using data all from <em>N</em> days for analysis. flymouse’s model for analysis requires data from a series of consecutive days during which the difference between the longest and the shortest distances wc walks cannot exceed a bound <em>M</em>. The longer the series is, the more accurate the results are. flymouse wants to know the number of days in such a longest series. Can you do the job for him?</p><p>Input</p><p>The input contains a single test case. The test case starts with a line containing the integers <em>N</em> (<em>N</em> ≤ 106) and <em>M</em> (<em>M</em> &lt; 109). Then follow <em>N</em> − 1 lines, each containing two integers <em>fi</em> and <em>di</em> (i = 1, 2, …, <em>N</em> − 1), meaning the check-points <em>i</em> + 1 and <em>fi</em> are connected by a path of length <em>di</em>.</p><p>Output</p><p>Output one line with only the desired number of days in the longest series.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>Hint</p><p>Explanation for the sample:</p><p>There are three check-points. Two paths of lengths 1 and 3 connect check-points 2 and 3 to check-point 1. The three paths along with wc walks are 1-3, 2-1-3 and 3-1-2. And their lengths are 3, 4 and 4. Therefore data from all three days can be used for analysis.</p><p>​    翻译成汉语，每个样例输入一个n,m,然后再给出n - 1个边的点权。n个点组成一颗树，求出每个点的离它最远的距离记为a【i】,问连续的区间中差值全部小于等于m的最长区间的长度。</p><p>思路：</p><p>​    对于求出每个点离它最远的距离a【i】，我们可以通过树形dp来求解（注意需要用链式前向星或者模拟vector来求解，否则TLE），然后再通过尺取+单调队列来求最长长度（当然用线段树也可以求解）。单调队列需要开两个，一个存最大值队列，一个存最小值队列。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#define N 1000005</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;;</span><br><span class="line">int n, m;</span><br><span class="line">node point[N * 2];</span><br><span class="line">node dp[N][3];</span><br><span class="line">int last[N * 2], fin[N];</span><br><span class="line">deque&lt;int&gt;maxn, minn;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    int x = 0;</span><br><span class="line">    while(ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while(&apos;0&apos; &lt;= ch &amp;&amp; ch &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        x = x * 10 + ch - &apos;0&apos;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    node c;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        a = read();</span><br><span class="line">        b = read();</span><br><span class="line">        c.inx = a;</span><br><span class="line">        c.val = b;</span><br><span class="line">        point[++tot] = c;</span><br><span class="line">        last[tot] = fin[i];</span><br><span class="line">        fin[i] = tot;</span><br><span class="line">        c.inx = i;</span><br><span class="line">        point[++tot] = c;</span><br><span class="line">        last[tot] = fin[a];</span><br><span class="line">        fin[a] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs (int inx, int father) &#123;</span><br><span class="line">    for (int i = fin[inx]; i != 0; i = last[i]) &#123;</span><br><span class="line">        node son = point[i];</span><br><span class="line">        if (son.inx == father) continue;</span><br><span class="line">        dfs(son.inx, inx);</span><br><span class="line">        if (dp[inx][0].inx == 0) &#123;</span><br><span class="line">            dp[inx][0].val = dp[son.inx][0].val + son.val;</span><br><span class="line">            dp[inx][0].inx = son.inx;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (dp[inx][0].val &lt; dp[son.inx][0].val + son.val) &#123;</span><br><span class="line">                dp[inx][1].val = dp[inx][0].val;</span><br><span class="line">                dp[inx][1].inx = dp[inx][0].inx;</span><br><span class="line">                dp[inx][0].val = dp[son.inx][0].val + son.val;</span><br><span class="line">                dp[inx][0].inx = son.inx;</span><br><span class="line">            &#125; else if (dp[inx][1].val &lt; dp[son.inx][0].val + son.val) &#123;</span><br><span class="line">                dp[inx][1].val = dp[son.inx][0].val + son.val;</span><br><span class="line">                dp[inx][1].inx = son.inx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs1 (int inx, int father) &#123;</span><br><span class="line">    for (int i = fin[inx]; i != 0; i = last[i]) &#123;</span><br><span class="line">        node son = point[i];</span><br><span class="line">        if (son.inx == father) continue;</span><br><span class="line">        if (dp[inx][0].inx == son.inx) &#123;</span><br><span class="line">            dp[son.inx][2].val = son.val + max(dp[inx][1].val, dp[inx][2].val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[son.inx][2].val = son.val + max(dp[inx][0].val, dp[inx][2].val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(son.inx, inx);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    init();</span><br><span class="line">    dfs(1, -1);</span><br><span class="line">    dp[1][2].val = 0;</span><br><span class="line">    dfs1(1, -1);</span><br><span class="line">    int start = 1;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][0].val = max(dp[i][0].val, dp[i][2].val);</span><br><span class="line">        while(!maxn.empty() &amp;&amp; dp[maxn.back()][0].val &lt; dp[i][0].val) &#123;</span><br><span class="line">            maxn.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        maxn.push_back(i);</span><br><span class="line">        while(!minn.empty() &amp;&amp; dp[minn.back()][0].val &gt; dp[i][0].val) &#123;</span><br><span class="line">            minn.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        minn.push_back(i);</span><br><span class="line">        while(dp[maxn.front()][0].val - dp[minn.front()][0].val &gt; m) &#123;</span><br><span class="line">            if (maxn.front() &lt; minn.front()) &#123;</span><br><span class="line">                start = maxn.front() + 1;</span><br><span class="line">                maxn.pop_front();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start = minn.front() + 1;</span><br><span class="line">                minn.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(i - start + 1, res);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Flippy Sequence 思维</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFlippy-Sequence-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFlippy-Sequence-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Flippy-Sequence-思维/titile3.jpg" alt="titile3"></p><a id="more"></a><p>题意：</p><p><img src="/2018/11/09/2018icpc青岛Flippy-Sequence-思维/1.png" alt="1"></p><p><img src="/2018/11/09/2018icpc青岛Flippy-Sequence-思维/2.png" alt="2"></p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">00</span><br><span class="line">11</span><br><span class="line">5</span><br><span class="line">01010</span><br><span class="line">00111</span><br></pre></td></tr></table></figure><p>#### </p><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>#### </p><p>Hint</p><p>For the second sample test case, there are two valid operation pairs: (1, 1, 2, 2) and (2, 2, 1, 1).</p><p>For the third sample test case, there are six valid operation pairs: (2, 3, 5, 5), (5, 5, 2, 3), (2, 5, 4, 4), (4, 4, 2, 5), (2, 4, 4, 5) and (4, 5, 2, 4).</p><p>​    题意就是给你T组样例，每组样例给你两个长度为n的字符串s1,s2，每个字符串必须且只能反转一个连续的区间（0变1，1变0），问两个字符串反转完毕变成相同字符串的方案数？</p><p>思路：</p><p>​    我们把两个字符串每一位相同的设为0，不同的设为1.若出现了3个及3个以上连续的1，那么永远无法通过反转一次得到相同字符串，此时输出0；若出现了2个连续的1，那么一定是6种方案；若出现了1个连续的1，方案数= (连续1的个数 - 1) ✖️ 2 + （n - 连续1的个数) ✖️2；若没有出现连续的1，方案数=（1 + n）✖️ n / 2。</p><p>​    一定要细心细心再细心！！因为细节没处理好WA了4发当时心态都崩了。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define N 1000005</span><br><span class="line">char s1[N], s2[N];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n, c;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        scanf(&quot;%s%s&quot;, s1, s2);</span><br><span class="line">        int num = 0;</span><br><span class="line">        int flag = 0, flaa = 0;</span><br><span class="line">        int start, endd;</span><br><span class="line">        int num1 = 0, num2 = 0, num3 = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s1[i] == s2[i]) c = 0;</span><br><span class="line">            else c = 1;</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    if (num == 1) &#123;</span><br><span class="line">                        endd = i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (num == 1) &#123;</span><br><span class="line">                    num2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (num == 0) &#123;</span><br><span class="line">                    if (flag == 0) &#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num1++;</span><br><span class="line">                &#125; else if(num == 1) &#123;</span><br><span class="line">                    num3++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    flaa = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i == n - 1) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    if (num == 1) &#123;</span><br><span class="line">                        endd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flaa) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (num == 0) &#123;</span><br><span class="line">            long long sum = (long long)(1 + n) * n / 2;</span><br><span class="line">            printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (num == 1) &#123;</span><br><span class="line">            long long sum = (long long)(num1 - 1) * 2;</span><br><span class="line">            sum += (n - (endd - start + 1)) * 2;</span><br><span class="line">            printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">        &#125; else if (num == 2) &#123;</span><br><span class="line">            printf(&quot;6\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Books 思维</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BBooks-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BBooks-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Books-思维/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>DreamGrid went to the bookshop yesterday. There are  books in the bookshop in total. Because DreamGrid is very rich, he bought the books according to the strategy below: </p><ul><li>Check the  books from the 1st one to the -th one <strong>in order</strong>.</li><li>For each book being checked now, if DreamGrid has enough money (not less than the book price), he’ll buy the book and his money will be reduced by the price of the book.</li><li>In case that his money is less than the price of the book being checked now, he will skip that book.</li></ul><p>BaoBao is curious about how rich DreamGrid is. You are asked to tell him the maximum possible amount of money DreamGrid took before buying the books, which is a non-negative integer. All he knows are the prices of the  books and the number of books DreamGrid bought in total, indicated by . </p><p>Input</p><p>There are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case:</p><p>The first line contains two integers  and  (, ), indicating the number of books in the bookshop and the number of books DreamGrid bought in total.</p><p>The second line contains  non-negative integers  (), where  indicates the price of the -th book checked by DreamGrid.</p><p>It’s guaranteed that the sum of  in all test cases will not exceed .</p><p>#### </p><p>Output</p><p>For each test case output one line.</p><p>If it’s impossible to buy  books for any initial number of money, output “Impossible” (without quotes).</p><p>If DreamGrid may take an infinite amount of money, output “Richman” (without quotes).</p><p>In other cases, output a non-negative integer, indicating the maximum number of money he may take.</p><p>#### </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 2</span><br><span class="line">1 2 4 8</span><br><span class="line">4 0</span><br><span class="line">100 99 98 97</span><br><span class="line">2 2</span><br><span class="line">10000 10000</span><br><span class="line">5 3</span><br><span class="line">0 0 0 0 1</span><br></pre></td></tr></table></figure><p>#### </p><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">96</span><br><span class="line">Richman</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure><p>​    大概意思就是给T组样例，每组一个n，m代表n本书，买了其中m本。然后再给出n本书的价格。购买规则是从前往后遍历书，只要书的价格小于自己剩余的钱数，就购买，否则就跳过。问恰好能买m本拥有的钱最多是多少？若过能全买输出Richman，如果不能恰好买m本输出Impossible；</p><p>思路：</p><p>​    若n == m就Richman，否则第一遍遍历价格为0的书的数量。如果大于m就Impossible。否则就遍历剩下的不为0的图书，小于&lt;= m - 价格为0的数量时，累加钱数，当&gt; m - 价格为0的数量时，比较出其中的最小值。最后答案为累加的钱数+ 最小值 -1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100005];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n, m;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        long long sum = 0;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        if (n == m) flag = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            if (a[i] == 0) num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num &gt; m) flag = 2;</span><br><span class="line">        else m -= num;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            int tot = 0;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                if (flag) break;</span><br><span class="line">                if (a[i] == 0) continue;</span><br><span class="line">                tot++;</span><br><span class="line">                if (tot &lt;= m) &#123;</span><br><span class="line">                    sum += a[i];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    minn = min(minn, a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (minn == 0) &#123;</span><br><span class="line">            flag = 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum += minn - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag == 1) printf(&quot;Richman\n&quot;);</span><br><span class="line">        else if(flag == 2) printf(&quot;Impossible\n&quot;);</span><br><span class="line">        else printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Function and Function 规律</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFunction-and-Function-%E8%A7%84%E5%BE%8B/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFunction-and-Function-%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Function-and-Function-规律/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p><img src="/2018/11/09/2018icpc青岛Function-and-Function-规律/1.png" alt="1"></p><p><img src="/2018/11/09/2018icpc青岛Function-and-Function-规律/2.png" alt="2"></p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">123456789 1</span><br><span class="line">888888888 1</span><br><span class="line">888888888 2</span><br><span class="line">888888888 999999999</span><br><span class="line">98640 12345</span><br><span class="line">1000000000 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">18</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1000000000</span><br></pre></td></tr></table></figure><p>​    大概意思就是给出f(n)和g^k(n)的通项公式，让你求g^k(n)。</p><p>思路：</p><p>​    由于n的范围是1e9，每一位累加和肯定不会超过100，只需要几次递归就可以得到10以内的f(n)，至于10以内的递归，我们可以一眼看出它们的循环结和规律</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int a[10] = &#123;1, 0, 0, 0, 1, 0, 1, 0, 2, 1&#125;;</span><br><span class="line"></span><br><span class="line">int dfs (int x, int k) &#123;</span><br><span class="line">    if (k == 0) return x;</span><br><span class="line">    if (x &lt; 10) &#123;</span><br><span class="line">        if (x == 8) &#123;</span><br><span class="line">            if (k == 1) return a[8];</span><br><span class="line">            else if(k == 2) return a[2];</span><br><span class="line">            if(k % 2 == 1) return a[0];</span><br><span class="line">            else return a[1];</span><br><span class="line">        &#125; else if(x == 0) &#123;</span><br><span class="line">            if(k % 2 == 1) return a[0];</span><br><span class="line">            else return a[1];</span><br><span class="line">        &#125; else if(x == 1) &#123;</span><br><span class="line">            if(k % 2 == 1) return a[1];</span><br><span class="line">            else return a[0];</span><br><span class="line">        &#125; else if(x == 2 || x == 3 || x== 5 || x == 7) &#123;</span><br><span class="line">            if (k == 1) return a[x];</span><br><span class="line">            else if (k % 2 == 0) &#123;</span><br><span class="line">                return a[0];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (x == 4 || x == 6 || x == 9) &#123;</span><br><span class="line">            if (k == 1) return a[x];</span><br><span class="line">            else if (k % 2 == 0) &#123;</span><br><span class="line">                return a[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (x) &#123;</span><br><span class="line">        sum += a[x % 10];</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return dfs(sum, k - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, x, k;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T --) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;x, &amp;k);</span><br><span class="line">        int ans =dfs (x, k);</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU3586Information Disturbing 二分+树形dp</title>
      <link href="/2018/11/08/HDU3586Information-Disturbing-%E4%BA%8C%E5%88%86-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/08/HDU3586Information-Disturbing-%E4%BA%8C%E5%88%86-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/08/HDU3586Information-Disturbing-二分-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Problem Description</p><p>In the battlefield , an effective way to defeat enemies is to break their communication system.<br>The information department told you that there are n enemy soldiers and their network which have n-1 communication routes can cover all of their soldiers. Information can exchange between any two soldiers by the communication routes. The number 1 soldier is the total commander and other soldiers who have only one neighbour is the frontline soldier.<br>Your boss zzn ordered you to cut off some routes to make any frontline soldiers in the network cannot reflect the information they collect from the battlefield to the total commander( number 1 soldier).<br>There is a kind of device who can choose some routes to cut off . But the cost (w) of any route you choose to cut off can’t be more than the device’s upper limit power. And the sum of the cost can’t be more than the device’s life m.<br>Now please minimize the upper limit power of your device to finish your task.</p><p>Input</p><p>The input consists of several test cases.<br>The first line of each test case contains 2 integers: n(n&lt;=1000）m(m&lt;=1000000).<br>Each of the following N-1 lines is of the form:<br>ai bi wi<br>It means there’s one route from ai to bi(undirected) and it takes wi cost to cut off the route with the device.<br>(1&lt;=ai,bi&lt;=n,1&lt;=wi&lt;=1000)<br>The input ends with n=m=0.</p><p>Output</p><p>Each case should output one integer, the minimal possible upper limit power of your device to finish your task.<br>If there is no way to finish the task, output -1.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">3 5 5</span><br><span class="line">4 2 6</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​    这道题就是说给出n，m分别代表节点数和权值，再给出n-1条边ai,bi,wi，代表ai与bi之间有一条无向路，道路权值为wi。问在截断的道路总权值不超过m的前提下使得所有的叶节点都不能与跟节点相连，截断的道路中最大的权值尽可能的小，问最小值是多少？</p><p>思路：</p><p>​    一道较难的树形dp题，我们一般看到在什么什么的前提下，使得某个值最小或者最大。就应该想到用二分来求解。我们通过二分最小值，然后满足所截道路的权值都小于等于二分值进行dfs。最后找到最小满足条件的即是答案。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 1005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt;point[N];</span><br><span class="line">int n, m;</span><br><span class="line">int dp [N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    node t;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        t.val = c;</span><br><span class="line">        t.inx = b;</span><br><span class="line">        point[a].push_back(t);</span><br><span class="line">        t.inx = a;</span><br><span class="line">        point[b].push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int inx, int father, int w) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        if (son.inx == father) continue;</span><br><span class="line">        dfs(son.inx, inx, w);</span><br><span class="line">        if (dp[son.inx] == 0) &#123;     //当儿子节点没有成立的截断</span><br><span class="line">            if (son.val &lt;= w) &#123;</span><br><span class="line">                sum += son.val;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;                    //当儿子节点有成立的截断</span><br><span class="line">            if (son.val &lt;= w) &#123;</span><br><span class="line">                sum += min(dp[son.inx], son.val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sum += dp[son.inx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[inx] = sum;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int erfen() &#123;</span><br><span class="line">    int star = 1, endd = m;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    while (star &lt;= endd) &#123;</span><br><span class="line">        int mid = (star + endd) &gt;&gt; 1;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        bool flag = dfs(1, -1, mid);</span><br><span class="line">        if (flag == true &amp;&amp; dp[1] &lt;= m) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            endd = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            star = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while ((scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &amp;&amp; (n || m)) &#123;</span><br><span class="line">        init();</span><br><span class="line">        int ans = erfen();</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3140Contestants Division 树形dp</title>
      <link href="/2018/11/08/POJ3140Contestants-Division-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/08/POJ3140Contestants-Division-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/08/POJ3140Contestants-Division-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Description</p><p>In the new ACM-ICPC Regional Contest, a special monitoring and submitting system will be set up, and students will be able to compete at their own universities. However there’s one problem. Due to the high cost of the new judging system, the organizing committee can only afford to set the system up such that there will be only one way to transfer information from one university to another without passing the same university twice. The contestants will be divided into two connected regions, and the difference between the total numbers of students from two regions should be minimized. Can you help the juries to find the minimum difference?</p><p>Input</p><p>There are multiple test cases in the input file. Each test case starts with two integers <em>N</em> and <em>M</em>, (1 ≤ <em>N</em> ≤ 100000, 1 ≤ <em>M</em> ≤ 1000000), the number of universities and the number of direct communication line set up by the committee, respectively. Universities are numbered from 1 to <em>N</em>. The next line has <em>N</em> integers, the <em>K</em>th integer is equal to the number of students in university numbered <em>K</em>. The number of students in any university does not exceed 100000000. Each of the following <em>M</em> lines has two integers <em>s</em>, <em>t</em>, and describes a communication line connecting university <em>s</em> and university <em>t</em>. All communication lines of this new system are bidirectional.</p><p><em>N</em> = 0, <em>M</em> = 0 indicates the end of input and should not be processed by your program.</p><p>Output</p><p>For every test case, output one integer, the minimum absolute difference of students between two regions in the format as indicated in the sample output.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 6</span><br><span class="line">1 1 1 1 1 1 1</span><br><span class="line">1 2</span><br><span class="line">2 7</span><br><span class="line">3 7</span><br><span class="line">4 6</span><br><span class="line">6 2</span><br><span class="line">5 7</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br></pre></td></tr></table></figure><p>​    这道题翻译成汉语就是给出n个点，m条边，每个点都有一个权值，问去掉哪条边剩余两部分的权值差最小并输出最小值</p><p>思路：</p><p>​    这道题有一个巨大的坑点，就是点的数据范围是1e5，边的数据范围是1e6，虽然如此，但是题里说了这么一句：“以便只有一种方式将信息从一所大学转移到另一所大学，而不会两次通过同一所大学”，因此这一定是无向无环图，边一定是点的数量-1，也就说一定是一颗树。因此这道题就可以通过树形dp来求解了</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 100005</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">ll val[N];</span><br><span class="line">ll dp[N];</span><br><span class="line">ll sum;</span><br><span class="line">vector&lt;int&gt;point[N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    sum = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;val[i]);</span><br><span class="line">        sum += val[i];</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        point[a].push_back(b);</span><br><span class="line">        point[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    dp[inx] = val[inx];</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        int son = point[inx][i];</span><br><span class="line">        if(son == father) continue;</span><br><span class="line">        dfs(son, inx);</span><br><span class="line">        dp[inx] += dp[son];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        if (n == m &amp;&amp; n == 0) break;</span><br><span class="line">        init();</span><br><span class="line">        dfs(1, -1);</span><br><span class="line">        ll minn = sum;</span><br><span class="line">        ll t;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            if (sum - dp[i] &gt; dp[i]) &#123;</span><br><span class="line">                t = sum - dp[i] - dp[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                t = dp[i] - sum + dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, t);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;, ++tot, minn);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3107 Godfather 树形dp+模拟vector</title>
      <link href="/2018/11/07/POJ3107-Godfather-%E6%A0%91%E5%BD%A2dp-%E6%A8%A1%E6%8B%9Fvector/"/>
      <url>/2018/11/07/POJ3107-Godfather-%E6%A0%91%E5%BD%A2dp-%E6%A8%A1%E6%8B%9Fvector/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/07/POJ3107-Godfather-树形dp-模拟vector/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>Description</p><p>Last years Chicago was full of gangster fights and strange murders. The chief of the police got really tired of all these crimes, and decided to arrest the mafia leaders.</p><p>Unfortunately, the structure of Chicago mafia is rather complicated. There are <em>n</em> persons known to be related to mafia. The police have traced their activity for some time, and know that some of them are communicating with each other. Based on the data collected, the chief of the police suggests that the mafia hierarchy can be represented as a tree. The head of the mafia, Godfather, is the root of the tree, and if some person is represented by a node in the tree, its direct subordinates are represented by the children of that node. For the purpose of conspiracy the gangsters only communicate with their direct subordinates and their direct master.</p><p>Unfortunately, though the police know gangsters’ communications, they do not know who is a master in any pair of communicating persons. Thus they only have an undirected tree of communications, and do not know who Godfather is.</p><p>Based on the idea that Godfather wants to have the most possible control over mafia, the chief of the police has made a suggestion that Godfather is such a person that after deleting it from the communications tree the size of the largest remaining connected component is as small as possible. Help the police to find all potential Godfathers and they will arrest them.</p><p>Input</p><p>The first line of the input file contains <em>n</em> — the number of persons suspected to belong to mafia (2 ≤ <em>n</em> ≤ 50 000). Let them be numbered from 1 to <em>n</em>.</p><p>The following <em>n</em> − 1 lines contain two integer numbers each. The pair <em>ai</em>, <em>bi</em> means that the gangster <em>ai</em> has communicated with the gangster <em>bi</em>. It is guaranteed that the gangsters’ communications form a tree.</p><p>Output</p><p>Print the numbers of all persons that are suspected to be Godfather. The numbers must be printed in the increasing order, separated by spaces.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p>​    题目大体意思就是给出一个无向无环图，从中去掉一个结点使其分为一个或多个无向无环图，问去掉哪个结点分成的最大树的结点数最小，把所有符合条件的结点按从小到大的顺序输出出来</p><p>思路：</p><p>​    我们可以把无向无环图看作是一棵树，网上说就是求树的所有重心（也就是结点到其它结点的距离和最小）。我的思路也和网上查不多。我们可以强制以1作为根节点，然后由叶到根求每个节点作为根节点的子树的结点和。利用dp【i】存储去掉i结点分成的k颗树的最大结点数，那么dp【i】为i的全部儿子结点为根的子树的最大值与n - (i为根节点的子树结点数)，取两者的较大值即为dp【i】</p><p>​    因为是一遍遍历嘛～复杂度大概为O(n)，用vector存储邻接表2s竟然TLE我的天！！！换成数组模拟vector只有400多ms，再加上快速读模版只耗费了110ms，就酱紫～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 50005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace IO &#123;</span><br><span class="line">    const int MX = 8e5;</span><br><span class="line">    char buf[MX];</span><br><span class="line">    int c, sz;</span><br><span class="line">    void begin() &#123;</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool read(int &amp;t) &#123;</span><br><span class="line">        while (c &lt; sz &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) &#123;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (c &gt;= sz) return false;</span><br><span class="line">        for (t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) &#123;</span><br><span class="line">            t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int point[2 * N];</span><br><span class="line">int last[2 * N];</span><br><span class="line">int flag[N];</span><br><span class="line">int num[N];</span><br><span class="line">int dp[N];</span><br><span class="line">int ans[N];</span><br><span class="line"></span><br><span class="line">int read() &#123;</span><br><span class="line">    char c = getchar();</span><br><span class="line">    int x = 0;</span><br><span class="line">    while (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        x = x * 10 + c - &apos;0&apos;;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b, tot = 0;;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        IO::read(a);</span><br><span class="line">        IO::read(b);</span><br><span class="line">        point[++tot] = b;</span><br><span class="line">        last[tot] = flag[a];</span><br><span class="line">        flag[a] = tot;</span><br><span class="line">        point[++tot] = a;</span><br><span class="line">        last[tot] = flag[b];</span><br><span class="line">        flag[b] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    num[inx] = 1;</span><br><span class="line">    for (int i = flag[inx]; i != 0; i = last[i]) &#123;</span><br><span class="line">        int son = point[i];</span><br><span class="line">        if(son == father) continue;</span><br><span class="line">        dfs(son, inx);</span><br><span class="line">        num[inx] += num[son];</span><br><span class="line">        dp[inx] = max(dp[inx], num[son]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[inx] = max(dp[inx], n - num[inx]);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    IO::begin();</span><br><span class="line">    IO::read(n);</span><br><span class="line">    init();</span><br><span class="line">    dfs(1, -1);</span><br><span class="line">    int minn = 0x3f3f3f3f;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if(minn &gt; dp[i]) &#123;</span><br><span class="line">            tot = 0;</span><br><span class="line">            ans[tot++] = i;</span><br><span class="line">            minn = dp[i];</span><br><span class="line">        &#125; else if(minn == dp[i]) &#123;</span><br><span class="line">            ans[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; tot; i++) &#123;</span><br><span class="line">        if (i == tot - 1) printf(&quot;%d\n&quot;, ans[i]);</span><br><span class="line">        else printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces219D 树形dp</title>
      <link href="/2018/11/07/CodeForces219D-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/07/CodeForces219D-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/07/CodeForces219D-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>The country Treeland consists of <em>n</em> cities, some pairs of them are connected with unidirectional roads. Overall there are <em>n</em> - 1 roads in the country. We know that if we don’t take the direction of the roads into consideration, we can get from any city to any other one.</p><p>The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city <em>a</em> is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city <em>a</em> to any other city. For that some roads may have to be inversed.</p><p>Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country.</p><p>Input</p><p>The first input line contains integer <em>n</em> (2 ≤ <em>n</em> ≤ 2·105) — the number of cities in Treeland. Next <em>n</em> - 1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si, ti (1 ≤ si, ti ≤ <em>n</em>; <em>si</em> ≠ ti) — the numbers of cities, connected by that road. The <em>i</em>-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to <em>n</em>.</p><p>Output</p><p>In the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order.</p><p>Examples：</p><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>​    这道题翻译成汉语，大概意思就是给出一个有向无环图，问选择哪个节点道路方向反转次数最少且可以到达任意节点。输出最小反转次数和满足条件的全部节点</p><p>思路：</p><p>​    由于是有向无环图，我们可以将其转化为树（强制节点1为根节点），我们设正常方向权值为1，反方向权值为0.然后我们第一遍dfs从叶到根遍历每个每个节点作为根节点的子树从根节点到每个节点权值和dp【i】。然后根节点1到所有节点的反转次数为num【1】= n - 1 - dp【i】,第二遍dfs从根到叶求每个节点到全部节点的反转次数即可,利用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当从父到子为正向时</span><br><span class="line">num[son.inx] = num[father] + 1;</span><br><span class="line">//当从父到子为反向时</span><br><span class="line">num[son.inx] = num[father] - 1;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#define N 200005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx, val;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;point[N];</span><br><span class="line">vector&lt;int&gt;ans;</span><br><span class="line">int dp[N];//</span><br><span class="line">int num[N];</span><br><span class="line"></span><br><span class="line">void dfs (int inx, int father) &#123;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        if(son.inx == father) continue;</span><br><span class="line">        dfs(son.inx, inx);</span><br><span class="line">        dp[inx] += son.val + dp[son.inx];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs1 (int inx, int father) &#123;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        if(son.inx == father) continue;</span><br><span class="line">        if(son.val == 1) &#123;</span><br><span class="line">            num[son.inx] = num[inx] + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            num[son.inx] = num[inx] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(son.inx, inx);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, a, b;</span><br><span class="line">    node c;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        memset(num, 0, sizeof(num));</span><br><span class="line">        ans.clear();</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            point[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            c.inx = b;</span><br><span class="line">            c.val = 1;</span><br><span class="line">            point[a].push_back(c);</span><br><span class="line">            c.inx = a;</span><br><span class="line">            c.val = 0;</span><br><span class="line">            point[b].push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, -1);</span><br><span class="line">        num[1] = n - 1 - dp[1];</span><br><span class="line">        dfs1(1, -1);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if(minn &gt; num[i]) &#123;</span><br><span class="line">                ans.clear();</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                minn = num[i];</span><br><span class="line">            &#125; else if(minn == num[i]) &#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, minn);</span><br><span class="line">        for (int i = 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            printf(&quot;%d%c&quot;, ans[i], i == ans.size() - 1? &apos;\n&apos;: &apos; &apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU2196 Computer树形dp</title>
      <link href="/2018/11/07/HDU2196-Computer%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/07/HDU2196-Computer%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/07/HDU2196-Computer树形dp/title1.jpg" alt="title1"></p><a id="more"></a><p>Problem Description</p><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.<br><img src="http://acm.hdu.edu.cn/data/images/C128-1005-1.JPG" alt="img"></p><p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p><p>Input</p><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. </p><p>Output</p><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给你n个点，再给n - 1行每行两个整数a, b，代表第i个电脑和a相连距离为b。最后输出每台电脑距离最远电脑的距离</p><p>思路：</p><p>​    这题我们可以把图转化为树，可以说是树形dp吧。我们通过第一遍dfs由叶到根递归计算每个节点作为根节点的子树中，与该节点距离最远和次远的距离与儿子节点。再通过第二遍dfs由根到叶递归计算每个节点往上走（非该子树）节点的最长距离。最后我们遍历每个节点，只需要比较该节点作为根节点的子树中的最长距离与往上走的最大值，取较大值即为答案。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 10005</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int son, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct gold &#123;</span><br><span class="line">    int maxx, son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;node&gt;point[N];</span><br><span class="line">gold maxn[N][3];  //0最大值 1次大值 2父最大值</span><br><span class="line">int pre[N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    node c;</span><br><span class="line">    mem(maxn);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        pre[i] = a;</span><br><span class="line">        c.son = i;</span><br><span class="line">        c.val = b;</span><br><span class="line">        point[a].push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx) &#123;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i ++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        dfs(son.son);</span><br><span class="line">        if(maxn[inx][0].maxx &lt; son.val + maxn[son.son][0].maxx) &#123;</span><br><span class="line">            maxn[inx][1].maxx = maxn[inx][0].maxx;</span><br><span class="line">            maxn[inx][1].son = maxn[inx][0].son;</span><br><span class="line">            maxn[inx][0].maxx = son.val + maxn[son.son][0].maxx;</span><br><span class="line">            maxn[inx][0].son = son.son;</span><br><span class="line">        &#125; else if(maxn[inx][1].maxx &lt; son.val + maxn[son.son][0].maxx) &#123;</span><br><span class="line">            maxn[inx][1].maxx = son.val + maxn[son.son][0].maxx;</span><br><span class="line">            maxn[inx][1].son = son.son;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs1(int inx) &#123;</span><br><span class="line">    int father = pre[inx];</span><br><span class="line">    if(inx != 1) &#123;</span><br><span class="line">        int t;</span><br><span class="line">        for(int i = 0; i &lt; point[father].size(); i++) &#123;</span><br><span class="line">            if(point[father][i].son == inx) &#123;</span><br><span class="line">                t = point[father][i].val;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(maxn[father][0].son == inx) &#123;</span><br><span class="line">            maxn[inx][2].son = father;</span><br><span class="line">            maxn[inx][2].maxx = t + max(maxn[father][1].maxx, maxn[father][2].maxx);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn[inx][2].son = father;</span><br><span class="line">            maxn[inx][2].maxx = t + max(maxn[father][0].maxx, maxn[father][2].maxx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        dfs1(point[inx][i].son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        int ans;</span><br><span class="line">        init();</span><br><span class="line">        dfs(1);</span><br><span class="line">        dfs1(1);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = max(maxn[i][0].maxx, maxn[i][2].maxx);</span><br><span class="line">            printf(&quot;%d\n&quot;, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1520Anniversary party树形dp</title>
      <link href="/2018/11/06/HDU1520Anniversary-party-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/06/HDU1520Anniversary-party-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/06/HDU1520Anniversary-party-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Problem Description</p><p>There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings.</p><p>Input</p><p>Employees are numbered from 1 to N. A first line of input contains a number N. 1 &lt;= N &lt;= 6 000. Each of the subsequent N lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from -128 to 127. After that go T lines that describe a supervisor relation tree. Each line of the tree specification has the form:<br>L K<br>It means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line<br>0 0 </p><p>Output</p><p>Output should contain the maximal sum of guests’ ratings.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>​    翻译成汉语再翻译成直男的视野，大概意思就是给出一个树，树上n个点，每个点都有一个权值，不能同时选取相邻的两个节点，问满足上述条件选取节点的最大权值和</p><p>思路：</p><p>​    这道题是一道典型的树形dp，我们利用邻接表记录节点之间的关系，由根到叶进行dp。</p><p>​    对于dp【i】【0】代表以该节点为根节点的子树且根节点不被选取的最大权值和</p><p>​    dp【i】【1】代表以该节点为根节点的子树且根节点被选取的最大权值和</p><p>​    我们可以得到父子之间的递推关系式子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当父节点不被选取时，它的dp[inx][0]等于每个儿子节点被选取和不被选取的最大值的和</span><br><span class="line">dp[inx][0] += max(dp[son][1], dp[son][0]);</span><br><span class="line"></span><br><span class="line">//当父节点被选取时，它的dp[inx][1]等于每个儿子节不被选取的和 + 父亲节点的权值</span><br><span class="line">dp[inx][1] = val[inx];</span><br><span class="line">dp[inx][1] += dp[son][0];</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 6005</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int val[N];</span><br><span class="line">int pre[N];</span><br><span class="line">vector&lt;int&gt;point[N];</span><br><span class="line">ll dp[N][2];        //1参加 0不参加</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) == 2) &#123;</span><br><span class="line">        if (a == 0 &amp;&amp; b == 0) break;</span><br><span class="line">        point[b].push_back(a);</span><br><span class="line">        pre[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx) &#123;</span><br><span class="line">    dp[inx][1] = val[inx];</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        int son = point[inx][i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        dp[inx][0] += max(dp[son][1], dp[son][0]);</span><br><span class="line">        dp[inx][1] += dp[son][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        init();</span><br><span class="line">        int root;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if(pre[i] == i) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        printf(&quot;%d\n&quot;, max(dp[root][1], dp[root][0]));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSOI307加分二叉树 区间dp</title>
      <link href="/2018/11/06/SSOI307%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8C%BA%E9%97%B4dp/"/>
      <url>/2018/11/06/SSOI307%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8C%BA%E9%97%B4dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/06/SSOI307加分二叉树-区间dp/titile2.jpg" alt="titile2"></p><a id="more"></a><p>【问题描述】</p><p>  设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：<br>subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数<br> 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br> 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；<br> （1）tree的最高加分<br> （2）tree最高得分的前序遍历<br>【输入格式】</p><p>第1行：一个整数n（n＜30），为节点个数。<br>第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。<br>【输出格式】</p><p>第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。<br>第2行：n个用空格隔开的整数，为该树的前序遍历。<br>【输入样例1】</p><p>5<br>5 7 1 2 10<br>【输出样例1】</p><p>145<br>3 1 2 4 5</p><p>思路:</p><p>​    虽然这是一个在树上的动态规划题，但实际还是一道区间DP，dp【i】【j】代表区间[i, j]的最高得分，dp【1】【n】即为答案，利用数组query【i】【j】记录该区间的根节点，通过dfs就可以得到最高得分的前序遍历。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll dp[35][35];</span><br><span class="line">int query[35][35];</span><br><span class="line">int tot, n;</span><br><span class="line"></span><br><span class="line">void dfs(int left, int right) &#123;</span><br><span class="line">    if (left &gt; right) return;</span><br><span class="line">    int k = query[left][right];</span><br><span class="line">    if (tot != n - 1) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, k);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    dfs(left, k - 1);</span><br><span class="line">    dfs(k + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        tot = 0;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        memset(query, 0, sizeof(query));</span><br><span class="line">        for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;dp[i][i]);</span><br><span class="line">            query[i][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int len = 1; len &lt;= n - 1; len++) &#123;</span><br><span class="line">            for (int i = 1; i + len &lt;= n; i++) &#123;</span><br><span class="line">                for (int k = i; k &lt;= i + len; k++) &#123;</span><br><span class="line">                    ll left, right;</span><br><span class="line">                    if(k == i) &#123;</span><br><span class="line">                        right = dp[i + 1][i + len];</span><br><span class="line">                        left = 1;</span><br><span class="line">                    &#125; else if (k == i + len) &#123;</span><br><span class="line">                        right = 1;</span><br><span class="line">                        left = dp[i][i + len - 1];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        right = dp[k + 1][i + len];</span><br><span class="line">                        left = dp[i][k - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (dp[k][k] + right * left &gt; dp[i][i + len]) &#123;</span><br><span class="line">                        dp[i][i + len] = dp[k][k] + right * left;</span><br><span class="line">                        query[i][i + len] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, dp[1][n]);</span><br><span class="line">        dfs(1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Not a subsequence动态规划</title>
      <link href="/2018/11/06/%E8%AE%A1%E8%92%9C%E5%AE%A2Not-a-subsequence%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2018/11/06/%E8%AE%A1%E8%92%9C%E5%AE%A2Not-a-subsequence%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/06/计蒜客Not-a-subsequence动态规划/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>In this problem we consider strings over a fixed finite alphabet of size k. The alphabet contains the first k characters from the list</p><p>a,b,c,…,z,A,B,C,…,Z,0,1,…,9.</p><p>For every test case, we are given the value of k(notice that it cannot exceed 62), and consider only strings consisting of the first k characters from the list.</p><p>Given a string s[1..n], we are interested in strings which are not its subsequences. Formally, a string t[1..m] is a subsequence of a string s[1..n] when one can choose not necessarily contiguous‾not necessarily contiguous indices 1≤i1&lt;i2&lt;…im≤n such that t[1]=s[i1],t[2]=s[i2],…,t[m]=t[im]</p><p>For example, acb is a subsequence of babcaabbabcaab. Now, given a string s[1..n], we would like to compute the smallest mm such that there is a string t[1..m], which is not a subsequence of s[1..n]. Additionally, we would like to count the number of such shortest strings t[1..m].</p><p>As the latter number can be quite large, output it modulo 10^9+7.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with the number of test cases T≤100.</p><p>Then the descriptions of TT test cases follow. A single test case consists of a single line containing the size of the alphabet k(k∈[1,62]) and the string s【1..n】(n∈[1,10^6])]. The string consists of the first k characters from a−zA−Z0−9.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For every test case output one line containing two numbers.</p><p>The first number is the smallest mm such that there is a string t[1..m] consisting of the first kkcharacters from a−zA−Z0−9, which is not a subsequence of s[1..n].</p><p>The second number is the total count of such shortest strings t[1..m] modulo 10^9+7.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 abba</span><br><span class="line">62 0123456789</span><br><span class="line">3 aabbcbbcbabcbab</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 52</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概意思就是给你T组样例，每组样例有一个n，代表有n种字符，然后再给出一个字符串。问字符串中不存在的子串的最小长度是多少？有多少种（答案取余1e9+7）？例如 abba，对于字符a,b来说，它不存在的最小子串长度为3，分别为aaa,bbb,aab,baa,bbb</p><p>思路：</p><p>​    一道特别难的dp题，关键是思路吧~</p><p>​    我们首先考虑字符串中不存在的子串的最小长度，我们从前往后遍历，每当出现一个没有标记过的字符就标记一次，当n个字符都标记过时，此时子串长度为1的都有了，因此最小长度只能是2，此时我们需要清空标记，继续往后遍历，每当出现一个没有标记过的字符就标记一次，当n个字符都标记过时，此时子串长度为2的都有了（因为每种字符前面一定每种字符至少存在一次），因此最小长度只能是3</p><p>​    我们再来考虑不存在的最小长度子串有多少种，若最小长度子串为1，那么种类为n-字符串中字符的种类数。若最小长度子串大于1时呢？这时候就需要DP推导式了..</p><p>​    给大家举个例子吧：对于3 abbcbabc来说：</p><p>​    从前往后遍历，第一个字符为a，没有标记过，然后标记该字符，此时字符计数num = 1。那么长度为2的以a结尾的子串没有出现的种类数为3（分别是aa,ba,ca），总计数sum[2] = 3。并设置字符a上一次出现的位置为1</p><p>​    第二个字符b，没有标记过，然后标记该字符，此时字符计数num = 2。那么长度为2的以b结尾没有出现的子串种类数为2（分别是bb,cb），总计数sum[2] = 3 + 2 = 5。并设置字符b上一次出现的位置为2</p><p>​    第三个字符b，标记过，此时字符计数num = 2。长度为2的以b结尾没有出现的子串种类数为1（cb），总计数sum[2] = 3 + 2 + 1 - 2 = 4(也就是sum[2] + 1 - 上次b出现加的2)。并设置字符b上一次出现的位置为3</p><p>​    第四个字符c，没有标记过，然后标记该字符，此时字符计数num = 3。那么长度为2的以c结尾没有出现的子串种类数为1（分别是cc），总计数sum[2] = 3 + 2 + 1 - 2 + 1 = 5。并设置字符c上一次出现的位置为4,此时num==字符种类数，因此没出现的最小子串长度至少为2，清空标记与字符计数num</p><p>​    第五个字符b，没有标记过，然后标记该字符，此时字符计数num = 1。那么长度为3的以b结尾没有出现的子串种类数为5（分别是aab,bab,cab,cbb,ccb），总计数sum[3] = sum[2] = 5,由于上一次出现过b且上次出现b是求长度为2的，因此sum[2] = sum[2] - 1 = 4(也就是sum[2]- 上一次b出现增加的1)，并设置字符b上一次出现的位置为5</p><p>​    第六个字符a，没有标记过，然后标记该字符，此时字符计数num = 2。那么长度为3的以a结尾没有出现的子串种类数为4（分别是aaa,baa,caa,cca），总计数sum[3] = 5 + 4 = 9,由于上一次出现过a且上次出现a是求长度为2的，因此sum[2] = sum[2] - 3 = 1(也就是sum[2]- 上一次a出现增加的3)，并设置字符a上一次出现的位置为6</p><p>​    第七个字符b，标记过，此时字符计数num = 2。那么长度为3的以b结尾没有出现的子串种类数为1（ccb），总计数sum[3] = 5 + 4 + 1   = 10,由于上一次出现过b且上次出现b是求长度为3的，因此sum[3] = sum[3] - 5 = 5(也就是sum[3]- 上一次b出现增加的5)，并设置字符b上一次出现的位置为7</p><p>​    第八个字符c，没有标记过，然后标记该字符，此时字符计数num = 3。那么长度为3的以c结尾没有出现的子串种类数为1（ccc），总计数sum[3] = 5 + 1 = 6,由于上一次出现过c且上次出现c是求长度为2的，因此sum[2] = sum[2] - 1 = 0(也就是sum[2]- 上一次c出现增加的1)，并设置字符c上一次出现的位置为8,由于num == 字符种类数，因此没出现的最小子串长度至少为3</p><p>​    因此最小子串长度为3，没出现的种类数为sum[3] = 6</p><p>​    原理就是这个原理～只需要线性就能求解</p><p>​    </p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 1000000</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define ll long long</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">char s[N + 5];//存储字符串</span><br><span class="line">int map[300];//存储字符映射</span><br><span class="line">bool book[70];//标记数组</span><br><span class="line">ll add[70];//存储该字符上一次增加的值</span><br><span class="line">int flag[70];//记录该字符上一次是为了长度为几的子串贡献的add</span><br><span class="line">ll dp[N + 5];//dp[i]存储长度为i的子串没有出现的种类数</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for (int i = &apos;a&apos;; i &lt;= &apos;z&apos;; i++) &#123;</span><br><span class="line">        map[i] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = &apos;A&apos;; i &lt;= &apos;Z&apos;; i++) &#123;</span><br><span class="line">        map[i] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = &apos;0&apos;; i &lt;= &apos;9&apos;; i++) &#123;</span><br><span class="line">        map[i] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d%s&quot;, &amp;n, s);</span><br><span class="line">        int len = strlen(s);</span><br><span class="line">        mem(book);</span><br><span class="line">        mem(dp);</span><br><span class="line">        mem(flag);</span><br><span class="line">        mem(add);</span><br><span class="line">        dp[1] = n;</span><br><span class="line">        int chang = 1, num = 0;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int t = map[s[i]];</span><br><span class="line">            if(chang == 1) &#123;</span><br><span class="line">                dp[2] = (dp[2] + n - num + mod) % mod;</span><br><span class="line">                if (book[t]) &#123;</span><br><span class="line">                    dp[2] = (dp[2] - add[t] + mod) % mod;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[1]--;</span><br><span class="line">                &#125;</span><br><span class="line">                add[t] = n - num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[chang + 1] = (dp[chang + 1] + dp[chang]) % mod;</span><br><span class="line">                ll zj = dp[chang];</span><br><span class="line">                if(book[t]) &#123;</span><br><span class="line">                    dp[chang + 1] = (dp[chang + 1] - add[t] + mod) % mod;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (flag[t] == chang - 1) &#123;</span><br><span class="line">                        dp[chang] = (dp[chang] - add[t] + mod) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                add[t] = zj;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[t] = chang;</span><br><span class="line">            if(!book[t]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                book[t] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (num == n) &#123;</span><br><span class="line">                chang++;</span><br><span class="line">                mem(book);</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %lld\n&quot;, chang, dp[chang]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Gold Rush水题</title>
      <link href="/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Gold-Rush%E6%B0%B4%E9%A2%98/"/>
      <url>/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Gold-Rush%E6%B0%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/05/计蒜客Gold-Rush水题/title1.jpg" alt="title1"></p><a id="more"></a><p>题意：</p><p>Alice and Bob are on an adventure trip. Deep in the woods they discover a mysterious deep cave which they enter flutteringly. They find an old console with a giant bar of gold in it. On the bar, there is a number n. Both tried to carry the gold out the cave, but it was still to heavy for one of them.</p><p>Suddenly a little fairy appears in the corner of the cave and approaches Alice and Bob: “This gold is heavy. It weights 2^n femto-grams (10^−15) and nncan reach 62.”</p><p>Bob answered: “What luck! Alice’s knapsack can carry up to aa femto-grams and mine bb femto-grams with a+b=2^n.” Alice interjected: “But how can we divide the gold?”</p><p>Fairy: “I can help you with a spell that can burst one piece of gold into two equally weighted ones. But for each single spell, the cave will be locked one additional day.”</p><p>Alice consults with Bob to use the help of the fairy and take all of the gold. How long will they be trapped if they are clever?</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with the number t≤1000 of test cases.</p><p>Then tt lines follow, each describing a single test case consisting of three numbers n,an,a and bb with a,b≥1,a+b=2^n, and 1≤n≤62.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output one line for every test case with the minimal number of days that Alice and Bob are locked in the cave.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 2 2</span><br><span class="line">2 1 3</span><br><span class="line">10 1000 24</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概意思就是有T组样例，每组样例有一个数是2^n，把它分成a，b，每次只能把一个数分成两个该数的一半，问最少分多少次能够分成a，b巴拉巴拉～</p><p>​    </p><p>思路：</p><p>​    我们只需要得到a，b的最小值t，然后循环把2^n累除2，若比t小就用t-该数，直到t为0为止</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n;</span><br><span class="line">long long quick(long long a, long long b) &#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    while(b) &#123;</span><br><span class="line">        if(b&amp;1) ans *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    long long n, a, b;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        long long res = quick(2, n);</span><br><span class="line">        long long minn = min(a, b);</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(minn) &#123;</span><br><span class="line">            res /= 2;</span><br><span class="line">            num++;</span><br><span class="line">            if(res &lt;= minn) &#123;</span><br><span class="line">                minn -= res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Algebraic Teamwork思维</title>
      <link href="/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Algebraic-Teamwork%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Algebraic-Teamwork%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/05/计蒜客Algebraic-Teamwork思维/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>The great pioneers of group theory and linear algebra want to cooperate and join their theories. In group theory, permutations – also known as bijective functions – play an important role. For a finite set A, a function σσ: A → A is called a permutation of A if and only if there is some function ρ : A →  A with</p><p>σ(ρ(a))=a and ρ(σ(a))=afor all a∈A.</p><p>The other half of the new team – the experts on linear algebra – deal a lot with idempotent functions. They appear as projections when computing shadows in 3D games or as closure operators like the transitive closure, just to name a few examples. A function pp : A → A is called idempotent if and only if</p><p>p(p(a))=p(a)for all a∈A.</p><p>To continue with their joined research, they need your help. The team is interested in non-idempotent permutations of a given finite set AA. As a first step, they discovered that the result only depends on the set’s size. For a concrete size 1≤n≤10^5, they want you to compute the number of permutations on a set of cardinality nnthat are <strong>not</strong> idempotent.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with the number t≤100 of test cases.</p><p>Then tt lines follow, each containing the set’s size 1≤n≤10^5.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output one line for every test case containing the number modulo 1000000007=(109+7) of <strong>non</strong>-idempotent permutations on a set of cardinality nn.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2171</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">6425</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给出T组数据，每组数据给出一个集合A的范围n，问有多少对映射σ和ρ，使得σ(ρ(a))=a and ρ(σ(a))=afor all a∈A.但不满足p(p(a))=p(a)for all a∈A.</p><p>思路：</p><p>​    对于第一个条件，我们只要满足a经过ρ，σ映射后还为a且映射关系都为一一映射，这道题刚开始以为是错排的种类数，结果不对后仔细一想，不满足p(p(a))=p(a)for all a∈A.，只要有一个a不满足即可，所以只要不是完全不变的映射即可（种类数为1），答案也就是全排列-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">const long long mod = 1e9+7;</span><br><span class="line">long long jc[100005];</span><br><span class="line">void init() &#123;</span><br><span class="line">    jc[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= 100000; i++) &#123;</span><br><span class="line">        jc[i] = i * jc[i - 1] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;, jc[n] - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Bounty Hunter多路dp</title>
      <link href="/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Bounty-Hunter/"/>
      <url>/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Bounty-Hunter/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/05/计蒜客Bounty-Hunter/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Spike is a bounty hunter and he is currently tracking a criminal! To investigate he uses his spaceship, the Swordfish II, and travels to Ndifferent places on 2D Euclidean space before returning to his crew at the starting location with all the information he has gathered. The starting location is the leftmost place (with the lowest x-coordinate) and Spike wants to travel to everyeveryother place before returning. However space fuel costs a lot of Woolongs and Spike would rather spend his money on special beef with bell peppers. Therefore he wants to travel the minimum possible distance.</p><p>On top of that he is being chased by the Red Dragon crime syndicate. To make sure they don’t catch him he can only visit places in increasing order of their xx-coordinate until he reaches the rightmost place (with the largest x-coordinate), then he can turn around and visit places in decreasing order of their x-coordinate until he reaches his starting location again.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with an integer T(1≤T≤100) specifying the number of test cases that follow.</p><p>Each test case consists of an integer N(2≤N≤512) specifying the number of places in the tour.</p><p>The coordinates of these places are given as integers in the next NN lines, xx-coordinate first, yy-coordinate second (0≤x,y≤5000).</p><p>The places are given in ascending order of the x-coordinate.</p><p>Every place has a unique x-coordinate.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, output on a single line the minimum travel distance needed to complete the tour.</p><p>Your output should have an absolute or relative error of at most 10^-2</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 0</span><br><span class="line">3 2</span><br><span class="line">4 1</span><br><span class="line">3</span><br><span class="line">100 1</span><br><span class="line">200 1</span><br><span class="line">300 1</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9.300563079746</span><br><span class="line">400</span><br></pre></td></tr></table></figure><p>大概意思就是给T组样例，每组样例有n个地方，从最左边开始，从左往右走到最右边，再从最右边返回到最左边，每个点有且经过一次，求最短路径</p><p>思路：</p><p>​    我们找一个人从起点开始绕一圈的最短路，其实就是找两个人从起点到达终点（两个人除了终点和起点，不能经过相同的点）路径和的最小值。这是一个旅行商问题。由于505数值太大，因此可以用多路dp来求解</p><p>​    我们设dp【i】【j】保证第一个人到达i点，第二个人到达j点，i &lt; j且j之前的所有点都经过的最小花费，有关递推式在代码中有标注</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    double x, y;</span><br><span class="line">&#125;point[550];</span><br><span class="line"></span><br><span class="line">bool zfq (node A, node B) &#123;</span><br><span class="line">    return A.x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double sq(node A, node B) &#123;</span><br><span class="line">    return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dp[550][550];      //dp[i][j]保证第一个到达i点，第二个人到达j点，i &lt; j且j之前的所有点都经过的最小花费</span><br><span class="line">double d[550][550];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        double ans = inf;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(point, point + n, zfq);</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = inf;</span><br><span class="line">                d[i][j] = sq(point[i], point[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][1] = d[0][1];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j][j + 1] = min (dp[j][j + 1], dp[i][j] + d[i][j + 1]);//可能是i走到j+1</span><br><span class="line">                dp[i][j + 1] = min (dp[i][j + 1], dp[i][j] + d[j][j + 1]);//也可能是j走到j+1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i ++) &#123;</span><br><span class="line">            ans = min(ans, dp[i][n - 1] + d[i][n - 1]);//由于i&lt;j，所以需额外加一个for循环求dp[n-1][n-1]的最小值</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%f\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 多路dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Equator尺取法</title>
      <link href="/2018/11/04/%E8%AE%A1%E8%92%9C%E5%AE%A2Equator/"/>
      <url>/2018/11/04/%E8%AE%A1%E8%92%9C%E5%AE%A2Equator/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/04/计蒜客Equator/title1.jpg" alt="title1"></p><a id="more"></a><p>题意：</p><p>In a galaxy far away, the planet Equator is under attack! The evil gang Galatic Criminal People Cooperation is planning robberies in Equator’s cities. Your help is needed! In order to complete your training for becoming a lord of the dark side you should help them deciding which cities to rob.</p><p>As the name says, the desert planet Equator only can be inhabited on its equator. So the gang lands there at some point and travels into some direction robbing all cities on their way until leaving the planet again.</p><p><img src="/2018/11/04/计蒜客Equator/1.jpg" alt="1"></p><p>But what is still open for them is to decide where to land, which direction to take, and when toleave. Maybe they shouldn’t even enter the planet at all? They do not consider costs for travelingor for running their ship, those are peanuts compared to the money made by robbery!</p><p>The cities diﬀer in value: some are richer, some are poorer, some have better safety functions. So the gang assigned expected proﬁts or losses to the cities. Help them deciding where to begin and where to end their robbery to maximize the money in total when robbing every city in between.<br>输入</p><p>The input starts with the number of test cases T ≤ 30. Each test case starts a new line containingthe number of cities 1 ≤ n ≤ 1 000 000. In the same line n integers c i follow. Each c i (0 ≤ i &lt; n,−1000 ≤ c i ≤ +1000) describes the money obtained when robbing city i, a negative c i describes the amount of money they would lose.<br>输出</p><p>For each test case print one integer describing the maximum money they can make in total.<br>样例输入</p><p>3<br>3 1 2 3<br>8 4 5 -1 -1 1 -1 -1 5<br>2 -1 -1<br>样例输出</p><p>6<br>14</p><p>0</p><p>​    这道题翻译成中文的意思大概就是给出一个n个数围成一圈，问最大连续子序列的和是多少？</p><p>思路：</p><p>这道题解法有很多，自己习惯用尺取来求解。对于一个循环的序列，它的最大连续自序列要么是在这个数组中连续，要么是在这个数组中首尾相连。对于在这个数组中连续，我们可以通过尺取法求出来。对于收尾相连，我们可以换位思考，求出数组中连续的最小连续子序列，那么用数组的权值和减去最小连续子序列，剩下的两段连接起来就是收尾相连的最大连续子序列，我们只需要比较数组中连续的和数组首尾相连，取最大值即是正确答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">ll a[1000005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T --) &#123;</span><br><span class="line">        ll sum = 0;</span><br><span class="line">        ll maxx = 0;</span><br><span class="line">        ll minn = 0x3f3f3f3f;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int endd = 0;</span><br><span class="line">        ll num = 0;</span><br><span class="line">        while(endd &lt; n) &#123;</span><br><span class="line">            if (num + a[endd] &lt; 0) &#123;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num += a[endd];</span><br><span class="line">                maxx = max(num, maxx);</span><br><span class="line">            &#125;</span><br><span class="line">            endd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        num = 0; endd = 0;</span><br><span class="line">        while(endd &lt; n) &#123;</span><br><span class="line">            if (num + a[endd] &gt; 0) &#123;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num += a[endd];</span><br><span class="line">                minn = min(num, minn);</span><br><span class="line">            &#125;</span><br><span class="line">            endd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = max(maxx, sum - minn);</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 尺取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯消元</title>
      <link href="/2018/10/26/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
      <url>/2018/10/26/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/26/高斯消元/title.jpg" alt="title"></p><a id="more"></a><p>待补～</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十四)莫比乌斯反演</title>
      <link href="/2018/10/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/10/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/莫比乌斯反演/title.jpg" alt="title"></p><a id="more"></a><p>​    上一篇将了二项式反演，这一篇讲一下莫比乌斯反演</p><p>学习莫比乌斯反演前，我们先要学习一下莫比乌斯函数</p><p>一.莫比乌斯函数定义：</p><p>​    定义如下：</p><p>​        μ(1) = 1    当x = 1时</p><p>​        μ(x) = (-1)^k    当x由k个不同的质数相乘得到时（保证每个质数都不同且只有质数）</p><p>​        μ(x) = 0    其余情况</p><p>​    </p><p>二.莫比乌斯函数性质：</p><p>​    性质1:当n = 1时，∑ μ(d) = 1   （其中d为n的全部因子）</p><p>​            当n&gt;1时，∑ μ(d) = 0   （其中d为n的全部因子）</p><p>​    性质2：∑ μ(d) / d = φ(n) / n     φ(n)为欧拉函数</p><p>三.线性处理莫比乌斯函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mu[N + 5], vis[N + 5], prime[N + 5];//mu数组用来存储莫比乌斯函数值，vis数组用于标记，prime用于存素数</span><br><span class="line">void init()&#123;</span><br><span class="line">    mu[1] = 1;</span><br><span class="line">    for(int i = 2; i &lt;= N; i ++)&#123;</span><br><span class="line">        if(!vis[i])&#123;//如果是素数</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            mu[i] = -1;//莫比乌斯函数为1</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt;= N; j ++)&#123;</span><br><span class="line">            vis[i * prime[j]] = 1;</span><br><span class="line">            if(i % prime[j]) mu[i * prime[j]] = -mu[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                mu[i * prime[j]] = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四.莫比乌斯反演公式：</p><p><img src="/2018/10/24/莫比乌斯反演/1.jpg" alt="1"></p><p>或者：</p><p><img src="/2018/10/24/莫比乌斯反演/2.jpg" alt="2"></p><pre><code>其中d|n表示能被n整除的所有因子d</code></pre><p>五.例题</p><p>​    给出x, y的范围(x &lt;= a, y &lt;= b),问满足gcd(x, y) == k的对数？</p><p>​    当然啦，有其它巧妙的思路，比如利用欧拉函数+容斥原理，下面来说一下莫比乌斯反演的做法：</p><p>​    设g(d)为满足gcd(x, y) == d的x,y对数，f(d)为满足gcd(x, y) == d的倍数 的x，y的对数</p><p>​    则：f(1) = g(1) + g(2) + g(3) + …</p><p>​        f(2) = g(2) + g(4) + g(6) + …</p><p>​    我们由题意可得f(n) = (a / n)✖️(b / n)</p><p>​    再根据莫比乌斯反演求解g(1) = μ(1)✖️f(1) + μ(2)✖️f(2) + μ(3)✖️f(3) +… + μ(a)✖️f(a)  (当a &lt; b时)即可</p><p>​    若是对数(1, 2)和(2, 1)算作一个则需要去重！！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十三)二项式反演</title>
      <link href="/2018/10/24/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/10/24/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/二项式反演/title1.jpg" alt="title1"></p><a id="more"></a><p>一.引出反演</p><p>​    对于公式f(n) = g(1) + g(2) + … + g(n)，我们只要已知g(x)的函数方程，就可以得到任意的f(n)。但是已知f(x)的函数方程，我们能得到任意的g(n)吗？</p><p>​    这时候，我们就需要用到反演定理了。利用反演定理，我们就可以通过f(x)求任意的g(n)了</p><p>二.反演定理:</p><p><img src="/2018/10/24/二项式反演/1.png" alt="1"></p><p>​    对于不同的的用法，c，d是不同的，至于推导。。。我是不会，Orz～ 关于常用的反演，数学家们已经推倒出来c函数和d函数，我们直接记住用就可以了。</p><p>​    我们常见的反演有二项式反演，斯特林反演，莫比乌斯反演和最值反演，接下来说一下二项式反演。</p><p>三.二项式反演：</p><p>​        <img src="/2018/10/24/二项式反演/2.png" alt="2"></p><p>​    其中（上:n 下:i）代表C(n, i)</p><p>​    </p><p>四.例题：</p><p>​    比如，n封信全部装错的方案数？</p><p>​    当然啦，有个错排公式能O(n)的的推出来，我们还是先看一下二项式反演的做法：</p><p>​    我们设g(i)代表i封信全部装错的方案数</p><p>​    那么∑ C(n, i)✖️g(i)正好是全部的装信情况，也就是n!</p><p>​    因此,f(n) = n! = ∑ C(n, i)✖️g(i)</p><p>​    我们根据二项式反演公式得g(n) = ∑ (-1)^(n - i)✖️C(n, i)✖️f(i)</p><p>​    因此我们只需要累加i从0～n的 (-1)^(n - i)✖️C(n, i)✖️(i)!的和，即为正确答案～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十二)母函数</title>
      <link href="/2018/10/24/%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2018/10/24/%E6%AF%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/母函数/title2.jpg" alt="title2"></p><a id="more"></a><p>一.引出母函数</p><p>​    母函数，也就是生成函数，在ACM中常常用于求解组合数学的计数问题。</p><p>​    一般的，能用母函数做的题，也能用其它方法（诸如推规律啦，DP啦）等等来做，母函数的复杂度为O(n^3),可以说是非常高了，所以只有在数据特别小且实在想不到其他方法求解的时候才可以尝试一下用母函数来做</p><p>​    那么，什么是母函数呢？</p><p>二.母函数的内容与例子</p><p>​    把一个已知的序列和x的多项式{x^0, x^1, x^2, … , x^n}合并起来，产生的新的多项式就叫做原来序列的母函数。</p><p>​    例如：序列{1, 0, 2, 4, 3, 1, 2}的母函数为f(x) = 1✖️x^0 + 0✖️x^1+ 2✖️x^2 + 4✖️x^3 + 3✖️x^4 + 1✖️x^5 + 2✖️x^6;</p><p>​    下面就讲解两道例题，来说明母函数的用法：</p><p>​    1.例如有1g, 2g, 3g, 4g砝码各一枚，问能称几种重量，每种重量的方案数？</p><p>​        1g砝码就是x^0 + x^1，2g砝码就是 x^0 + x^2，3g砝码就是x^0 + x^3，4g砝码就是x^0 + x^4</p><p>​        把他们累乘并化简，得到：1 + x + x^2 + 2✖️x^3 + 2✖️x^4 + 2✖️x^5 + 2✖️x^6 + 2✖️x^7 + x^8 + x^9 + x^10</p><p>​    我们从方程式可知，可以称0～10种重量，其中3～7有两种称法，其余一种</p><p>​    </p><p>​    2.有1分，2分，3分邮票无限，问贴出不同数值的方案数 （数值小于等于100）？</p><p>​        一分邮票可表示为(x^0 + x^1 + x^2 + x^3 + ….+ x^100)</p><p>​        二分邮票可表示为(x^0 + x^2 + x^4 + x^6 + ….+ x^100)</p><p>​        三分邮票可表示为(x^0 + x^3 + x^6 + x^9 + ….+ x^99)        </p><p>​        将三者累乘即可得到如例1中的方程式，即可一眼得到答案（可利用剪枝省略数值&gt;100的部分）</p><p>三.母函数的代码实现</p><p>​    我们拿第2个例子来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll N = 100;//设置上界</span><br><span class="line">ll c1[N + 5];   //c1[i]为最终多项式幂为i的系数</span><br><span class="line">ll c2[N + 5];   //c2为临时合并的多项式</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    c1[0] = 1;  //初始化0的情况算1种</span><br><span class="line">    for (int i = 1; i &lt;= 3; i++) &#123;          //遍历每种邮票</span><br><span class="line">        for (int j = 0; j &lt;= N; j += i) &#123;    //该种邮票存在的次幂j</span><br><span class="line">            for (int k = 0; j + k &lt;= N; k++) &#123;</span><br><span class="line">                c2[j + k] += c1[k] * 1;     //因为每种邮票的不同次幂系数都为1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt;= N; j++) &#123;     //将中间状态c2转移到c1并清空c2</span><br><span class="line">            c1[j] = c2[j];</span><br><span class="line">            c2[j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//c1[i]即为组成i分钱的方案数</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1430 康托展开</title>
      <link href="/2018/10/24/HDU1430-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2018/10/24/HDU1430-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/HDU1430-康托展开/title.jpg" alt="title"></p><a id="more"></a><p>这道题需要用到上一篇讲的康托展开与逆展开原理 <a href="http://www.ivan-zcy.top/2018/10/24/康托展开/">跳转</a></p><p>题意：</p><p>Problem Description</p><p>在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为：</p><p>1 2 3 4<br>8 7 6 5</p><p>对于魔板，可施加三种不同的操作，具体操作方法如下：</p><p>A: 上下两行互换,如上图可变换为状态87654321<br>B: 每行同时循环右移一格,如上图可变换为41236785<br>C: 中间4个方块顺时针旋转一格,如上图可变换为17245368</p><p>给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。</p><p>Input</p><p>每组测试数据包括两行，分别代表魔板的初态与目态。</p><p>Output</p><p>对每组测试数据输出满足题意的变换步骤。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345678</span><br><span class="line">17245368</span><br><span class="line">12345678</span><br><span class="line">82754631</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line">AC</span><br></pre></td></tr></table></figure><p>思路：</p><p>  上一篇举的例子就是这道题。在上一篇中我们说过，这道题无论把序列作为10进制或利用状压转成二进制都无法进行存储。因此需要利用康托展开的方式进行存储。</p><p>​    因此，我们只需要利用BFS预处理出初状态为1,2,3,4,5,6,7,8到每种状态的最小步骤即可，然后利用map将1,2,3,4,5,6,7,8映射到真正的初始状态，然后利用该映射关系得到目标状态相对于1,2,3,4,5,6,7,8的状态目标状态值t，ans[t]即为结果，因此只需要预处理，其它查询都是O(1)操作</p><p>​    </p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 100000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s1[10], s2[10];</span><br><span class="line">ll fact[10];</span><br><span class="line">queue&lt;ll&gt; q;</span><br><span class="line">bool book[N + 5];</span><br><span class="line">bool flag[10];</span><br><span class="line">string ans[N + 5];</span><br><span class="line">map&lt;d, d&gt; zcy;</span><br><span class="line"></span><br><span class="line">//逆康托展开</span><br><span class="line">string inv_cantor (ll num) &#123;</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    mem(flag);</span><br><span class="line">    For(i, 0, 7) &#123;</span><br><span class="line">        ll t = num / fact[7 - i];</span><br><span class="line">        num %= fact[7 - i];</span><br><span class="line">        ll tot = -1;</span><br><span class="line">        For(j, 1, 8) &#123;</span><br><span class="line">            if (!flag[j]) tot++;</span><br><span class="line">            if (tot == t) &#123;</span><br><span class="line">                flag[j] = 1;</span><br><span class="line">                s += (&apos;0&apos; + j);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//康托展开</span><br><span class="line">ll cantor (string s) &#123;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    For(i, 0, 7) &#123;</span><br><span class="line">        d tot = 0;</span><br><span class="line">        For (j, i + 1, 7) &#123;</span><br><span class="line">            if (s[i] &gt; s[j]) tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += tot * fact[7 - i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//三种操作</span><br><span class="line">string chooes (string s, d inv) &#123;</span><br><span class="line">    if (inv == 0) &#123;</span><br><span class="line">        For(i, 0, 3) &#123;</span><br><span class="line">            swap(s[i], s[7 - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (inv == 1)&#123;</span><br><span class="line">        Forr(i, 3, 1) &#123;</span><br><span class="line">            swap(s[i], s[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 4, 6) &#123;</span><br><span class="line">            swap(s[i], s[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        swap(s[1], s[2]);</span><br><span class="line">        swap(s[1], s[5]);</span><br><span class="line">        swap(s[1], s[6]);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//预处理开始为1,2,3,4,5,6,7,8到各个状态的最小步数</span><br><span class="line">void init () &#123;</span><br><span class="line">    mem(fact);</span><br><span class="line">    mem(book);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    fact[0] = fact [1] = 1;</span><br><span class="line">    For(i, 2, 7) &#123;//预处理阶乘</span><br><span class="line">        fact[i] = fact[i - 1] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    book[0] = 1;</span><br><span class="line">    q.push(0);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        ll num = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        string s = inv_cantor (num);</span><br><span class="line">        For(i, 0, 3) &#123;//保证字典序最小</span><br><span class="line">            string ss = chooes (s, i);</span><br><span class="line">            ll num1 = cantor(ss);</span><br><span class="line">            if (!book[num1]) &#123;</span><br><span class="line">                q.push(num1);</span><br><span class="line">                book[num1] = 1;</span><br><span class="line">                ans[num1] = ans[num] + (char)(&apos;A&apos; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init ();</span><br><span class="line">    while (scanf(&quot;%s&quot;, s1 + 1) == 1) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, s2 + 1);</span><br><span class="line">        zcy.clear();</span><br><span class="line">        string s = &quot;&quot;;</span><br><span class="line">        For(i, 1, 8) &#123;//利用映射关系把初始转化为12345678的序列,目标序列随之改变</span><br><span class="line">            zcy[s1[i] - &apos;0&apos;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 1, 8) &#123;</span><br><span class="line">            s += (&apos;0&apos; + zcy[s2[i] - &apos;0&apos;]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll num = cantor(s);</span><br><span class="line">        printf(&quot;%s\n&quot;, ans[num].data());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十一)康托展开与逆康托展开</title>
      <link href="/2018/10/24/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2018/10/24/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/康托展开/title5.jpg" alt="title5"></p><a id="more"></a><p>一.引出康托展开</p><p>​    动态规划题有一类分支叫状压DP，意思就是把状态压缩为一个二进制数组，然后转为十进制数存储。一般n的大小不会超过20，因为20个状态的组合就有2^20,也就是1e6种可能。</p><p>​    对于一些题目，紧紧利用状态压缩，会发现状态的组合数远远超过1e6的范围，那时候我们没有办法在1s内遍历出来，或者大到根本连数组都开不出来的时候，一般情况下就需要用到康托展开</p><p>​    例如：对于一个组合 1 2 3 4 5 6 7 8，A操作可以让其转变为8 7 6 5 4 3 2 1，B操作可以让其转变为4 1 2 3 6 7 8 5，C操作可以让其转变为1 7 2 4 5 3 6 8</p><p>​    给出一个初始组合和目标组合，问由初始到目标最少的变换步骤，若多种则选字典树最小的那种？</p><p>​    对于这种题，如果我们把1～8看作0～7，拿这8个数的当作一个状态来存储，需76543210种状态（且里边有些状态根本就不可能出现，如11111111），这样肯定是不可行的。</p><p>​    如果我们利用状态压缩把它转为2进制，0为000，1为001，2为010….7为111,那么8个数连在一起共有24位，也就是需要2^24 = 16777216个状态进行存储，然后缩小了7倍，但是数组依旧太大了</p><p>​    这时候，我们需要考虑康托展开对状态进行定义</p><p>二.关于康托展开</p><p>​    和状压数组不同，康托展开数组a[i]代表的是该序列从第i位开始到最后一位，第i位的数排第几(排名和i都是从0开始)</p><p>​    举个例子：3，5，4，1，2中：a[0] = 2,a[1] = 3, a[2] = 2,a[3] = 0, a[4] = 0</p><p>​    那么3 5 4 1 2的状态值 = a[0]✖️4! + a[1]✖️3! + a[2]✖️2! + a[3]✖️1! + a[4]✖️0! = 70</p><p>​    也就是说，康托展开能够把状态压缩到极致（即像上边那种没有用过的诸如11111111等都被抛弃掉，只剩有用的状态存在），即节省了空间也节省了时间。</p><p>三.关于康托逆展开</p><p>​    我们在二中得到的70可以通过康托逆展开重新得到3，5，4，1，2，方法如下：</p><p>​    70 / 4! = 2余22，因此a[0] = 2;</p><p>​    22 / 3! = 3余4，因此a[1] = 3;             </p><p>​    4 / 2! = 2余0，因此a[2] = 2;</p><p>​    0 / 1! = 0余0，因此a[3] = 0;</p><p>​        0 / 0! = 0余0，因此a[4] = 0;</p><p>​    在1, 2 , 3,  4,  5中，第2大（从0开始算）的数是3</p><p>​    在1, 2 ,  4,  5中，第3大（从0开始算）的数是5</p><p>​    在1, 2 ,  4中，第2大（从0开始算）的数是4    </p><p>​    在1, 2中，第0大（从0开始算）的数是1，最后一个数就是2</p><p>​    因此就能得到序列3，5，4，1，2</p><p>​    以上就是康托逆展开</p><p>四.代码实现：</p><p>​    (1)康托展开实现代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fact[10];//fact[i]存储i的阶乘的值</span><br><span class="line">//把数组s合并为一个状态num, k代表数组长度</span><br><span class="line">void cantor (int s[], ll &amp;num, int k) &#123;</span><br><span class="line">    num = 0;</span><br><span class="line">    for (int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for (int j = i + 1; j &lt; k; j++) &#123;</span><br><span class="line">            if (s[i] &gt; s[j]) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        num += fact[k - i - 1] * cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （2）康托逆展开代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fact[10];//fact[i]存储i的阶乘的值</span><br><span class="line">//把状态值num转回数组s</span><br><span class="line">bool book[10];//判断序列中下角标为i的数是否已经标记</span><br><span class="line">void inv_cantor (int s[], ll num, int k) &#123;</span><br><span class="line">    memset (book, 0, sizeof(book));</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        int p = num / fact[k - i - 1];</span><br><span class="line">        num %= fact[k - i - 1];</span><br><span class="line">        int tot = 0;</span><br><span class="line">        for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">            if (!book[j]) tot ++;</span><br><span class="line">            if (tot == p) &#123;</span><br><span class="line">                book[j] = 1;</span><br><span class="line">                s[i] = j + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    理论就是这些～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十)卢卡斯定理与扩展卢卡斯</title>
      <link href="/2018/10/23/%E5%85%B3%E4%BA%8E%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
      <url>/2018/10/23/%E5%85%B3%E4%BA%8E%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/关于卢卡斯定理/title.jpg" alt="title"></p><a id="more"></a><p>​    在数论中我们经常遇到求组合数的问题，比如有n个球放入m个箱子里(m &gt; n)，每个箱子只能放一个球，问有多少种方案？类似这种题目就需要用到组合数来求解</p><p>​    学习该内容需学会之前讲的逆元和中国剩余定理。跳转链接：<a href="http://www.ivan-zcy.top/2018/10/22/关于逆元/">逆元</a>  <a href="http://www.ivan-zcy.top/2018/10/23/中国剩余定理/">中国剩余定理</a></p><p>​    那么求组合数都有什么方法呢？</p><p>一.其实早在古代，伟大的先人就解决了求解组合数的问题，那就是伟大的杨辉三角</p><p>​    我们发现        </p><p>​    1</p><p>​    1，1</p><p>​    1，2，1</p><p>​    1，3，3，1</p><p>​    1，4，6，4，1</p><p>​    1，5，10，10，5，1</p><p>​    有没有发现，C（n,m）的值就是第n行m列的值（下标从0开始）</p><p>​    虽然这样可以求组合数，但是它的复杂度是O(n^2)太大了，只能求解1e3以内的组合数</p><p>二.我们可以进一步优化</p><p>​    由于已知C（n,m）= n！/ (n - m)! ✖️m！</p><p>​    我们只需要预处理出前n的阶乘与前n阶乘的逆元，每次就可以O（1）的时间求出组合数的值</p><p>​    因此，我们只需要耗费O(n)的复杂度预处理就可以了</p><p>​    因此它可以求1e6以内的组合数</p><p>三.卢卡斯定理</p><p>​    卢卡斯定理：C（n,m）% p = C（n / p ,m / p)✖️C（n % p ,m % p) % p</p><p>​    当n和m特别大时题目中必须有取余操作，要不会爆longlong，若p小于1e7时卢卡斯定理就派上了用场。</p><p>​    附上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll fact[N + 5];</span><br><span class="line">ll inv[N + 5];</span><br><span class="line"></span><br><span class="line">//省略中间的扩展欧几里得求逆元</span><br><span class="line"></span><br><span class="line">void init () &#123;</span><br><span class="line">    fact[0] = fact[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i ++) &#123;</span><br><span class="line">        fact[i] = fact[i - 1] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N] = mod_reverse(fact[N], mod);     //调用扩展欧几里得求逆元</span><br><span class="line">    for (int i = N -1; i &gt;= 0; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + 1] * (i + 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll C (ll n, ll m) &#123;</span><br><span class="line">    if (n &lt; m || m &lt; 0) return 0;</span><br><span class="line">    if (n &lt; mod) return fact[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">    return C (n / mod, m / mod) * C (n % mod, m % mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码只适用于p&lt;1e7且p为素数的情况，若p为合数呢？</p><p>​    此时就需要用到扩展卢卡斯定理了（此前需学会中国剩余定理）</p><p>四.扩展卢卡斯定理：</p><p>​    由于p为合数，因此我们可以将p分解为p1^a1✖️p2^a2✖️…pk^ak的形式</p><p>​    因此我们可以利用卢卡斯定理求得：</p><p>​    ans ≡ x1 (mod p1^a1)</p><p>​    ans ≡ x2 (mod p2^a2)</p><p>​    ……</p><p>​     ans ≡ xk (mod pk^ak)    </p><p>​    不同质数的幂次方之间肯定两两互质，通过求得每组的解xi，再利用中国剩余定理就可以合并得到最终答案</p><p>​    每组解xi的求法：C（n，m）% (pi^ai)</p><p>​    因此我们需要获得剔除pi因子后的乘积n！,m！的逆元,（n - m）！的逆元的乘积去取模（pi^ai）并加入被剔除的pi的贡献即可</p><p>​    那么我们如何求n！剔除pi因子的乘积呢？</p><p>​    例如19! % (3^2) = （1✖️2✖️4✖️5✖️7✖️8）✖️(10✖️11✖️13✖️14✖️16✖️17)✖️(19)✖️(1✖️2✖️3✖️4✖️5✖️6)</p><p>​    （）内的代表一个分组，每个分组在取余pi^ai后结果相同，因此只需暴力一个分组，利用快速幂求解即可，对于(19)这种不足一个分组的，可以暴力单度计算。对于(1✖️2✖️3✖️4✖️5✖️6)，可提前预处理出来</p><p>​    最后xi = (n)! % (pi^ai)✖️inv((m)! % (pi^ai), pi^ai)✖️inv((m)! % (pi^ai), pi^ai)✖️pi^k即可（其中k为pi在C(n, m )中出现的次数）</p><p>​    最后利用中国剩余定理将xi合并即可</p><p>​    附上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll ksm(ll a, ll b, ll mod) &#123;&#125;  //省略快速幂</span><br><span class="line">ll extend_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123;&#125; //省略扩展欧几里得</span><br><span class="line">ll mod_reverse (ll a, ll n) &#123;&#125; //省略逆元</span><br><span class="line"></span><br><span class="line">//用于求n!%(pi^ai) 其中pk =（pi^ai）</span><br><span class="line">ll mul(ll n,ll pi,ll pk) &#123;</span><br><span class="line">    if(!n) return 1;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    if(n / pk) &#123;</span><br><span class="line">        for(ll i = 2;i &lt; pk; i++)</span><br><span class="line">            if(i % pi) ans = ans * i % pk;</span><br><span class="line">        ans = ksm(ans, n / pk, pk);</span><br><span class="line">    &#125;</span><br><span class="line">    for(ll i = 2;i &lt;= n % pk; i++)</span><br><span class="line">        if(i % pi) ans = ans * i % pk;</span><br><span class="line">    return ans * mul(n / pi, pi, pk) % pk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求xi</span><br><span class="line">ll C(ll n, ll m, ll mod, ll pi, ll pk) &#123;</span><br><span class="line">    if(m &gt; n) return 0;</span><br><span class="line">    ll a = mul(n, pi, pk),b = mul(m, pi, pk),c = mul(n-m, pi, pk);</span><br><span class="line">    ll k=0, ans;</span><br><span class="line">    for(ll i = n; i; i /= pi) k += i / pi;</span><br><span class="line">    for(ll i = m; i; i /= pi) k -= i / pi;</span><br><span class="line">    for(ll i = n - m; i; i /= pi) k -= i / pi;</span><br><span class="line">    ans = a * mod_reverse(b, pk) % pk * mod_reverse(c, pk) % pk * ksm(pi, k, pk) % pk;</span><br><span class="line">    return ans * (mod / pk) % mod * mod_reverse(mod / pk, pk) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展卢卡斯</span><br><span class="line">ll exLucas(ll n, ll m, ll mod) &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(ll x = mod, i = 2; i &lt;= mod; i++)</span><br><span class="line">        if(x % i == 0) &#123;</span><br><span class="line">            ll pk = 1;</span><br><span class="line">            while(x % i == 0) &#123;</span><br><span class="line">                pk *= i;</span><br><span class="line">                x /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + C(n, m, mod, i, pk)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    完工～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论九)中国剩余定理与扩展</title>
      <link href="/2018/10/23/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2018/10/23/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/中国剩余定理/title1.jpg" alt="title1"></p><a id="more"></a><p>​    学习中国剩余定理之前必须学会求解逆元： <a href="http://www.ivan-zcy.top/2018/10/22/关于逆元/">跳转</a></p><p>一.中国剩余定理：</p><p>​    记得小时候听过一个故事，就是韩信想知道自己有多少士兵，然后就先让士兵排成x列，余出来a个人，后来又让士兵排成y列，余出来b个人，后来又让士兵排成z列，余出来c个人，最后韩信直接算出了自己的士兵数。。Orz～</p><p>​    呃呃呃，感觉有点像小学的时候做过的奥数题。。。    </p><p>​    假使x，y，z分别为3，5，7，a，b，c分别为2，3，2，那么我们问最小士兵数是多少？</p><p>​    注意一点！！！x,y,z必须满足两两互质！！！</p><p>​    根据逆元的性质，我们可以知道：</p><p>​    3✖️5✖️mod_reverse(15, 7) ≡ 1 （mod 7） （1）</p><p>​    3✖️7✖️mod_reverse(21, 5) ≡ 1 （mod 5)      (2)</p><p>​    5✖️7✖️mod_reverse(35, 3) ≡ 1 （mod 3）    (3)</p><p>​    把(1)乘2，(2)乘3，(3)乘2，得：</p><p>​    2✖️3✖️5✖️mod_reverse(15, 7) ≡ 2 （mod 7） （4）</p><p>​    3✖️3✖️7✖️mod_reverse(21, 5) ≡ 3 （mod 5)      (5)</p><p>​    2✖️5✖️7✖️mod_reverse(35, 3) ≡ 2 （mod 3）    (6)</p><p>​    我们设：</p><p>​    a = 2✖️3✖️5✖️mod_reverse(15, 7)</p><p>​    b = 3✖️3✖️7✖️mod_reverse(21, 5)</p><p>​    c = 2✖️5✖️7✖️mod_reverse(35, 3)</p><p>​    因此我们可以得到：</p><p>​    (a + b + c) % 3 = a % 3 + b % 3 + c % 3 = 0 + 0 + 2 = 2;</p><p>​    (a + b + c) % 5 = a % 5 + b % 5 + c % 5 = 0 + 3 + 0 = 3;</p><p>​    (a + b + c) % 7 = a % 7 + b % 7 + c % 7 = 2 + 0 + 0 = 2;</p><p>​    所以说，士兵数为a + b + c就满足该条件</p><p>​    代码实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//省略扩展欧几里得求逆元的函数</span><br><span class="line">ll china (ll n, ll *a, ll *m) &#123;//m[i]代表3，5，7等除数，a[i]代表2，3，2等余数</span><br><span class="line">    ll M = 1;//M代表所有除数的乘积</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        M *= m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ll w = M / m[i];</span><br><span class="line">        ret = (ret + a[i] * w * mod_reverse(w, m[i])) % M;</span><br><span class="line">        //若上面的式子爆longlong，可利用快速乘来求解</span><br><span class="line">    &#125;</span><br><span class="line">    return (ret + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>二.中国剩余定理扩展：</p><p>​    前边注意中已经标注了，中国剩余定理的前提是x，y，z（也就是说除数）必须两两互质。如果不互质我们又该怎么办呢？</p><p>​    我们假设x ≡ a1 (mod n1)</p><p>​            x ≡ a2 (mod n2)</p><p>​    合并两式，得：n1k1 = n2k2 + a2 - a1</p><p>​    两边同除gcd(n1, n2)，得：</p><p>​    n1k1 / gcd(n1, n2) = n2k2 / gcd(n1, n2) + (a2 - a1) / gcd(n1, n2)</p><p>​    由于n1 / gcd(n1, n2) 与n2 / gcd(n1, n2)互质，因此：</p><p>​    n1k1 / gcd(n1, n2) ≡  (a2 - a1) / gcd(n1, n2)    （mod n2 / gcd(n1, n2)）</p><p>​    同除n1 / gcd (n1, n2)，得：k1 ≡ mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2) （mod n2 / gcd(n1, n2)）</p><p>​    k1 = mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2) + n2 / gcd(n1, n2)✖️y</p><p>​    把k1代入x = n1k1 + a1，得：</p><p>​    x =     mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2)✖️n1 + n1n2 / gcd(n1, n2)✖️y</p><p>​    呃呃呃，解x就求出来了…</p><p>​    这是两个式子的联立，那么多个呢？</p><p>​    对于多个，我们先求出两个数的解x，把x带入到a2中，并把n2替换为lcm(n1, n2)，然后继续求2，3的解，直到递推到n结束。最后n - 1和 n的解x即为答案。</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn=1e5+5;</span><br><span class="line">int n;</span><br><span class="line">ll m[maxn],a[maxn];//m[i]为除数，a[i]为余数</span><br><span class="line"></span><br><span class="line">//求gcd</span><br><span class="line">ll gcd (ll a, ll b) &#123;</span><br><span class="line">    return a % b == 0? b: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展欧几里得算法</span><br><span class="line">ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 0) return -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = extend_gcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求a关于n的逆元</span><br><span class="line">ll mod_reverse (ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = extend_gcd(a, n, x, y);</span><br><span class="line">    if (d == 1) return (x % n + n) % n;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中国剩余定理扩展</span><br><span class="line">ll work()&#123;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        ll n1 = m[i - 1], n2 = m[i];</span><br><span class="line">        ll a1 = a[i - 1], a2 = a[i];</span><br><span class="line">        ll d = gcd(n1, n2);</span><br><span class="line">        if ((a2 - a1) % d != 0) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        m[i] = m[i - 1] / d * m[i];</span><br><span class="line">        ll x = (mod_reverse(n1 / d, n2 / d) * (a2 - a1) / d) % (n2 / d) * n1 + a1;</span><br><span class="line">        x = (x % m[i] + m[i]) % m[i];</span><br><span class="line">        a[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag) return -1;</span><br><span class="line">    return a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    大概就是这样～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论八)容斥原理与抽屉原理</title>
      <link href="/2018/10/23/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/23/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/容斥原理与抽屉原理/title1.jpg" alt="title1"></p><a id="more"></a><p>一.先讲一下抽屉原理，其实高中的时候我们都学过，它可扩展为3个：</p><p>​    1.把n + 1个物体放到n个抽屉，至少有一个抽屉里物件不少于2</p><p>​    2.把mn + 1个物体放到n个抽屉，至少有一个抽屉里物件不少于m+1</p><p>​    3.把无穷多个物体放到n个抽屉，至少有一个抽屉里有无穷多</p><p>它又衍生出来第二抽屉原理，即：</p><p>​    把nm - 1个物体放到n个抽屉，必有一个抽屉中至多有m - 1个物体</p><p>定理就这么简单，但是想用好属实挺难～</p><p>​    例如给你一个数组a和一个数m，问数组中能否选出几个数相加的和能被m整除？</p><p>​    这个题咋一看和抽屉原理也没啥必然联系啊，那就再仔细瞅瞅。。</p><p>​    联系抽屉原理，我们可以知道，当n &gt; m时，必然能选出几个数的和被m整除。</p><p>​    为什么？因为n个数求余m会产生n个余数，至少有两个相同的余数。</p><p>​    n个m以内的余数一定能组成m的倍数</p><p>​    这样，我们只需要判断 n &lt;= m时的情况即可</p><p>二. 容斥原理</p><p>​    容斥原理原理是为避免重复计算的一种想法，很简单，同抽屉原理一样，难在活学活用～</p><p>​    简单说一下容斥原理，例如下图，我们知道三个圆各自的面积，问三个圆一共占有的面积是多少？这时候为了避免重复运算，就需要用到容斥原理了：</p><p>​    <img src="/2018/10/23/容斥原理与抽屉原理/1.png" alt="1"></p><p>在此感谢百度百科提供的图片资源～～～</p><p>也就是说，3个圆占有的面积是三个圆的面积和 - 红色部分 + G部分</p><p>嗯嗯，原理就是这些，还是实战一下吧：</p><p>​    1.例如从m种颜色挑选k种给n盆花染色，要求相邻花颜色不同，问方案数？</p><p>​    从m种颜色挑选k种共有C(m, k)种方案数，而k种颜色给n盆花染色且相邻花颜色不同，这时候我们就可以利用容斥原理了。</p><p>​    种类数应该是：可用k种颜色保证相邻花色不同的方案数 - 可用k - 1种颜色种颜色保证相邻花色不同的方案数+ 可用k - 1种颜色种颜色保证相邻花色不同的方案数…(-1)^(k - 1)✖️可用1种颜色种颜色保证相邻花色不同的方案数</p><p>​    只需要把种类数✖️C(m, k)即为答案</p><p>​    这样就可以简化思考的复杂度了～</p><p>​    2.求区间(a, b)中与n互质的数的个数，例如求区间(a, b)中与12互质的个数</p><p>​    我们可以先筛选出12的全部素因子2, 3，我们只需要求(a, b)的个数 - 素因子2对(a, b)的贡献 - 素因子3对(a, b)的贡献 + 因子(2✖️3)对(a, b)的贡献，即是最终答案。​</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教BM模版(推规律)</title>
      <link href="/2018/10/23/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E7%89%88-%E6%8E%A8%E8%A7%84%E5%BE%8B/"/>
      <url>/2018/10/23/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E7%89%88-%E6%8E%A8%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/杜教BM模版-推规律/title.jpg" alt="title"></p><a id="more"></a><p>​    无论是矩阵快速幂求第n项，还是给出输出前几项求规律的第n项。。。几乎就没有它做不到的～至于原理。。。呃呃呃，会用就完了！！！</p><p>​    下面是找到的能用的BM模版：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</span><br><span class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><br><span class="line">#define pb push_back</span><br><span class="line">#define mp make_pair</span><br><span class="line">#define all(x) (x).begin(),(x).end()</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">#define SZ(x) ((int)(x).size())</span><br><span class="line">typedef vector&lt;int&gt; VI;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const ll mod=1000000007;</span><br><span class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</span><br><span class="line">// head</span><br><span class="line"></span><br><span class="line">int _,n;</span><br><span class="line">namespace linear_seq &#123;</span><br><span class="line">    const int N=10010;</span><br><span class="line">    ll res[N],base[N],_c[N],_md[N];</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; Md;</span><br><span class="line">    void mul(ll *a,ll *b,int k) &#123;</span><br><span class="line">        rep(i,0,k+k) _c[i]=0;</span><br><span class="line">        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">        for (int i=k+k-1;i&gt;=k;i--) if (_c[i])</span><br><span class="line">            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;</span><br><span class="line">        rep(i,0,k) a[i]=_c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span><br><span class="line">        //        printf(&quot;%d\n&quot;,SZ(b));</span><br><span class="line">        ll ans=0,pnt=0;</span><br><span class="line">        int k=SZ(a);</span><br><span class="line">        assert(SZ(a)==SZ(b));</span><br><span class="line">        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;</span><br><span class="line">        Md.clear();</span><br><span class="line">        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);</span><br><span class="line">        rep(i,0,k) res[i]=base[i]=0;</span><br><span class="line">        res[0]=1;</span><br><span class="line">        while ((1ll&lt;&lt;pnt)&lt;=n) pnt++;</span><br><span class="line">        for (int p=pnt;p&gt;=0;p--) &#123;</span><br><span class="line">            mul(res,res,k);</span><br><span class="line">            if ((n&gt;&gt;p)&amp;1) &#123;</span><br><span class="line">                for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0;</span><br><span class="line">                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;</span><br><span class="line">        if (ans&lt;0) ans+=mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    VI BM(VI s) &#123;</span><br><span class="line">        VI C(1,1),B(1,1);</span><br><span class="line">        int L=0,m=1,b=1;</span><br><span class="line">        rep(n,0,SZ(s)) &#123;</span><br><span class="line">            ll d=0;</span><br><span class="line">            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;</span><br><span class="line">            if (d==0) ++m;</span><br><span class="line">            else if (2*L&lt;=n) &#123;</span><br><span class="line">                VI T=C;</span><br><span class="line">                ll c=mod-d*powmod(b,mod-2)%mod;</span><br><span class="line">                while (SZ(C)&lt;SZ(B)+m) C.pb(0);</span><br><span class="line">                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                L=n+1-L; B=T; b=d; m=1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ll c=mod-d*powmod(b,mod-2)%mod;</span><br><span class="line">                while (SZ(C)&lt;SZ(B)+m) C.pb(0);</span><br><span class="line">                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return C;</span><br><span class="line">    &#125;</span><br><span class="line">    int gao(VI a,ll n) &#123;</span><br><span class="line">        VI c=BM(a);</span><br><span class="line">        c.erase(c.begin());</span><br><span class="line">        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;</span><br><span class="line">        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (~scanf(&quot;%d&quot;,&amp;n)) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        v.push_back(1);//这儿就可以输入前几项的数，用来推规律</span><br><span class="line">        v.push_back(2);</span><br><span class="line">        v.push_back(4);</span><br><span class="line">        v.push_back(7);</span><br><span class="line">        v.push_back(13);</span><br><span class="line">        v.push_back(24);</span><br><span class="line">        //VI&#123;1,2,4,7,13,24&#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,linear_seq::gao(v,n-1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-23博客搭建进度</title>
      <link href="/2018/10/23/18-10-23%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/23/18-10-23%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/18-10-23博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计</p><p>​    ——新增博文数量统计</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论七)关于sqrt、pow与log的巧用</title>
      <link href="/2018/10/22/%E5%85%B3%E4%BA%8Esqrt%E4%B8%8Elog%E7%9A%84%E5%B7%A7%E7%94%A8/"/>
      <url>/2018/10/22/%E5%85%B3%E4%BA%8Esqrt%E4%B8%8Elog%E7%9A%84%E5%B7%A7%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/22/关于sqrt与log的巧用/title.jpg" alt="title"></p><a id="more"></a><p>一. sqrt</p><p>​    大家都知道sqrt(x)是求x的平方根，c中自带的math.h库有关于该函数的使用。这里就不多叙述~</p><p>​    关于求sqrt，这里有一个神人约翰-卡马克，大家可以百度搜索一下这个神人的辉煌事迹（求sqrt的神秘数字），附上它的代码%一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float Q_rsqrt( float number )</span><br><span class="line">&#123;</span><br><span class="line">long i;</span><br><span class="line">float x2, y;</span><br><span class="line">const float threehalfs = 1.5F;</span><br><span class="line"></span><br><span class="line">x2 = number * 0.5F;</span><br><span class="line">y = number;</span><br><span class="line">i = * ( long * ) &amp;y; // evil floating point bit level hacking</span><br><span class="line">i = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck?</span><br><span class="line">y = * ( float * ) &amp;i;</span><br><span class="line">y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration</span><br><span class="line">// y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed</span><br><span class="line"></span><br><span class="line">#ifndef Q3_VM</span><br><span class="line">#ifdef __linux__</span><br><span class="line">assert( !isnan(y) ); // bk010122 - FPE?</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    它的这段代码求sqrt(number)的倒数，速度比math.h库中的(float)(1.0/sqrt(x))快4倍！！！</p><p>​    注释中的what the fuck? 也表明了我们普通人的心情。。。。</p><p>​    话不多说，%%%%%%%%%%%%%%%%%%%%%%%%%%就完了</p><p>​    </p><p>二.pow</p><p>​    关于pow函数也存在与math.h库中，具体使用也不详细介绍，我们来说一下它的巧用</p><p>​    假如a^b = c，我们已知b和c，如何求a？（其中b &lt;= 200, a &lt;= 1e9, c &lt;=1e100 ）</p><p>​    注意！！c的取值范围是1e100！！！</p><p>​    这时候就有一个巧办法了，虽然double精度不足1e100，但我们只需要知道它的前16位即可，因为当b错一位，c的前16位变化很大。所以虽然double只保留了16位，但计算出的c是唯一的。因此：</p><p>​    pow (c, 1 / n)保留0位小数，即为a</p><p>三.log</p><p>​    关于log的巧妙用法</p><p>​    第一个：例如给出a, b, c, d,如何比较a^b与c^d的大小？</p><p>​    我们只需要求p = b✖️log(a);   q = d✖️log(c)</p><p>​                如果p - q的绝对值 &lt;= 1e-6，则两者相等，</p><p>​                如果 p &lt; q ，则a^b &lt; c^d，</p><p>​                否则a^b &gt; c^d</p><p>​    </p><p>​    第二个：求一个数x有多少位数：</p><p>​        利用(int)log10(x) + 1可以求得x一共多少位</p><p>​    第三个：求一个数x在二进制下有多少位：</p><p>​        利用(int)log2(x) + 1可以求得x在二进制下一共多少位</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论六)关于欧拉(定理、公式、函数、降幂)</title>
      <link href="/2018/10/22/%E5%85%B3%E4%BA%8E%E6%AC%A7%E6%8B%89-%E5%AE%9A%E7%90%86-%E5%85%AC%E5%BC%8F-%E5%87%BD%E6%95%B0/"/>
      <url>/2018/10/22/%E5%85%B3%E4%BA%8E%E6%AC%A7%E6%8B%89-%E5%AE%9A%E7%90%86-%E5%85%AC%E5%BC%8F-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/22/关于欧拉-定理-公式-函数/title.jpg" alt="title"></p><a id="more"></a><p>​    最最开始的时候，我以为欧拉函数，欧拉定理，欧拉公式是一个东西，傻傻分不清。傻笑～</p><p>​    后来知道，这完完全全是三种东西！！要说有啥必然的联系，它们可能都叫欧拉吧～</p><p>​    首先，我们来讲一下三者的定义：</p><p>​    欧拉定理：若n,a为正整数且互质，则a^(Φ(n)) = 1 (mod n)</p><p>​    欧拉公式：e^(i✖️x) = cos(x) + i✖️sin(x)  （例如把x = π带进去，得e^(i✖️π) = -1）</p><p>​    欧拉函数：Φ(n)，用于求1～n中与n互质的个数，若n为质数，那么Φ(n) = n - 1<br>​    欧拉降幂：我们知道当幂特别大的时候可以用快速幂来求，而当幂大到10^1000时快速幂也求不了了。。这时候就需要用到欧拉降幂，它的定理如下（前提是a，p互质）：</p><p>​              a^b ≡ a^(b % Φ(p) + Φ(p)) (mod p)，当x &gt;= p时</p><p>​               a^b ≡ a^(b % Φ(p)) (mod p)，当x &lt; p时</p><p>关于欧拉公式在ACM中我还没有做过相关的题，因此先只讲欧拉函数和欧拉降幂，欧拉定理</p><p>一.关于欧拉定理没什么好说的～</p><p>​    之前我们说过一嘴费马小定理：a ^ (p - 1 ) ≡ 1 (mod p)</p><p>​    又说过当p为素数时Φ(p) = p - 1，因此欧拉定理实际上是费马小定理的推广</p><p>二.关于欧拉函数的求解，我们知道n为质数的情况了，若n为合数呢？</p><p>​    学到了以下四种求法n的欧拉函数：</p><p>​    1.利用容斥原理：</p><p>​        我们先找到n的全部质因子，然后利用容斥原理删掉全部的因子，剩下的就是与n互质的个数</p><p>​        例如30 = 2✖️3✖️5</p><p>​        Φ(30) = 30 - 30 / 2 - 30 / 3 - 30 / 5 + 30 / (2✖️3) + 30 / (2✖️5) + 30 / (3✖️5) - 30 / (2✖️3✖️5)</p><p>​               = 8</p><p>​    2.上面的写法很麻烦，下面有种简便的写法：</p><p>​            30 = 30✖️1 / 2 ✖️2 / 3✖️4 / 5  = 8，这样就能自动容斥啦，时间复杂度是O(sqrt(n))</p><p>​    3.埃筛法：</p><p>​        是不是很耳熟！！！对，求素数有埃筛和线筛，求欧拉函数也有埃筛和线筛～，埃筛的原理就是利用方法2～，时间复杂度是O(n✖️sqrt(n))</p><p>​        </p><p>​        代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getEuler() &#123;</span><br><span class="line">    memset(euler, 0, sizeof(euler));</span><br><span class="line">    euler[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!euler[i]) &#123;</span><br><span class="line">            for (int j = i; j &lt;= N; j += i) &#123;</span><br><span class="line">                if (!euler[j]) &#123;</span><br><span class="line">                    euler[j] = j;//若不存在先初始化</span><br><span class="line">                &#125;</span><br><span class="line">                euler[j] = euler[j] / i * (i - 1);//实质就是方法2 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>​    4.线性筛</p><p>​    线性筛，顾名思义就是线性求解1～n的欧拉函数，需用到一下几个性质：</p><p>​        1.当p为素数时，Φ(p) = p - 1;</p><p>​        2.当p为素数且i % p ==0时，Φ(i✖️p) = Φ(i)✖️p</p><p>​        3.当p为素数且i % p != 0时，Φ(i✖️p) = Φ(i)✖️(p - 1)</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll phi[N + 5];//存储欧拉函数</span><br><span class="line">ll prime[N + 5];//存素数</span><br><span class="line">void Euler() &#123;</span><br><span class="line">    phi[1] = 1;</span><br><span class="line">    memset(phi, 0, sizeof(phi));</span><br><span class="line"> prime[0] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if(!phi[i]) &#123;//若i为素数</span><br><span class="line">            phi[i] = i - 1;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; (ll)i * prime[j] &lt;= N; j++) &#123;</span><br><span class="line">            if (i % prime[j]) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j] - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三.欧拉降幂：</p><p>​        根据 a^b ≡ a^(b % Φ(p) + Φ(p)) (mod p)，当x &gt;= p时</p><p>​               a^b ≡ a^(b % Φ(p)) (mod p)，当x &lt; p时    </p><p>​    我们可以得到以下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Mod(a, b) a &lt; b? a: a % b + b   //重定义取模，按照欧拉定理的条件</span><br><span class="line"></span><br><span class="line">map&lt;ll,ll&gt; mp;//记忆化存储欧拉函数</span><br><span class="line"></span><br><span class="line">//按照欧拉定理的条件进行快速幂</span><br><span class="line">ll qpow(ll x, ll n, ll mod) &#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n &amp; 1) &#123;</span><br><span class="line">            res = Mod(res * x, mod);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        x = Mod(x * x, mod);</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求k的欧拉函数值</span><br><span class="line">ll phi(ll k) &#123;</span><br><span class="line">    ll i;</span><br><span class="line">    ll s = k;</span><br><span class="line">    ll x = k;</span><br><span class="line">    if (mp.count(k))</span><br><span class="line">        return mp[x];                    //记忆化存储</span><br><span class="line">    for(i = 2; i * i &lt;= k; i++) &#123;</span><br><span class="line">        if (k % i == 0)</span><br><span class="line">            s = s / i * (i - 1);//利用方法2</span><br><span class="line">        while(k % i == 0)</span><br><span class="line">            k /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k &gt; 1)</span><br><span class="line">        s = s / k * (k - 1);</span><br><span class="line">    mp[x]=s;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！！当快速幂需要用到之前的递归时，也需要迭代模!!!</p><p>​    例如 a[1]^(a[2]^(a[3]^(a[4]…)))</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL solve(LL l,LL r,LL mod) &#123;</span><br><span class="line">    if (l==r||mod==1) return Mod(a[l], mod);//如果到右端点或者φ值等于1，那么直接返回当前数字</span><br><span class="line">    return qpow(a[l], solve(l+1, r, phi(mod)), mod);//否则指数为[l+1,r]区间的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论五)关于自己理解的逆元</title>
      <link href="/2018/10/22/%E5%85%B3%E4%BA%8E%E9%80%86%E5%85%83/"/>
      <url>/2018/10/22/%E5%85%B3%E4%BA%8E%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/22/关于逆元/title.jpg" alt="title"></p><a id="more"></a><p>学这个之前建议看看之前发的那篇关于快速幂和扩展gcd的博文：<a href="http://www.ivan-zcy.top/2018/10/21/快速幂、快速乘与gcd扩展-杂谈/">跳转</a></p><p>一.引出逆元的用途</p><p>在讲逆元是什么之前，先说一下我们遇到的错误。。</p><p>​    对于特别大的数的连乘，让我们对最终结果取模1e9 + 7，可能在连乘的时候就已经爆longlong了，我们应该怎么做呢？</p><p>​    根据同余定理可知，(a✖️b) % mod = ( (a % mod) ✖️ (b % mod)) % mod，因此，我们可以设longlong型数ans = 1，每次乘以一个较大数的时候，都取模一下1e9+7，避免爆longlong。代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ll mod = 1e9 + 7;</span><br><span class="line">ll ans = 1;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    ans = ans * a[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line">最终ans即为n个数连乘取模1e9 + 7的结果</span><br></pre></td></tr></table></figure><p>​    </p><p>​    若是不只是乘法，中间再夹杂着除法，我们再按照上面的方式ans = ans / a[i] % mod，当我们兴冲冲的上交后，一个冷冰冰的WA在我们脸上胡乱的拍～</p><p>​    这是为啥呢？</p><p>​    因为同余定理中不包含(a / b) % mod = ((a % mod)  / (b % mod)) % mod，记住不包含！！！</p><p>​    那么我们该怎么办呢？好办，我们将除法改成乘不就完了嘛～</p><p>​    除以一个数不就是乘一个数的倒数嘛，一个倒数在取模mod时为多少呢？</p><p>​    这时候逆元就出现了！！</p><p>​    也就是说，a / b % mod相当于a ✖️ b关于mod的逆元 % mod</p><p>​    我们只需要求b关于mod的逆元就可以了～</p><p>二.逆元的求法</p><p>​    至于求逆元的方式有很多，比如利用费马小定理，扩展欧几里得，欧拉定理等等…我比较常用方法是费马小定理和扩展欧几里得</p><p>​    (1)利用费马小定理求逆元：</p><p>​        我们由于费马小定理可知：当p为素数时，有a ^ (p - 1) ≡ 1 (mod p) </p><p>​        两边同时除a，得a^(p - 2) ≡ inv(a) (mod p)    其中inv(a)是a关于p的逆元</p><p>​        因此:  inv(a) = a ^ (p - 2) (mod p)</p><p>​        我们就可以通过使用快速幂求得a ^ (p  - 2)取模p得到 a 关于p的逆元</p><p>​        代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//利用快速幂求a^(p - 2) mod p</span><br><span class="line">ll pow_mod (ll a, ll b, ll p) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans = ans * a % p;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//费马小定理求a关于p的逆元</span><br><span class="line">ll permat (ll a, ll p) &#123;</span><br><span class="line">    return pow_mod (a, p - 2, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)利用扩展欧几里得求逆元</p><p>​    上一篇我们学了gcd的求法，它是根据欧几里得算法的核心 gcd (a, b) = gcd (b, a % b)递归得到的</p><p>​    那么，扩展欧几里得是什么呢？</p><p>​    我们可以利用已知的a，b，一定存在至少一组解x，y，使它们满足贝祖等式：a✖️x + b✖️y = gcd(a, b)</p><p>​    至于这个定理为什么成立，我也没学。。。Orz，我觉得会用就可以了，冷汗😓</p><p>​    根据a✖️x + b✖️y = gcd(a, b)，若a，b互质，那么此时a✖️x + b✖️y = gcd(a, b) = 1</p><p>​    我们对a✖️x + b✖️y = 1同时取余b，会得到a✖️x % b + b✖️y % b = 1 % b</p><p>​     =&gt; a✖️x % b = 1 % b    </p><p>​     =&gt; a✖️x = 1(mod b)        </p><p>​    大家看着是不是似成相识呢？，对！x就是a关于b的逆元</p><p>​    因此，我们就可以通过扩展欧几里得算法求解x即可。</p><p>关于扩展欧几里得算法：</p><p>​    我们设x✖️a + y✖️b = d （d为gcd(a, b));   (1)</p><p>​    那么x1✖️b + y1✖️(a % b) = d;    (2)</p><p>​    也就是说x✖️a + y✖️b = x1✖️b + y1✖️(a % b); （3）</p><p>​    因为a % b = a - (a / b)✖️b;  (4)</p><p>​    我们把(4)带入(3)，得：</p><p>​    x✖️a + y✖️b = x1✖️b + y1✖️(a - (a / b)✖️b)  (5)</p><p>​    化简得：x✖️a + y✖️b =  y1✖️a + (x1 - (a / b)✖️y1)✖️b （6） </p><p>​    因此，我们可得x = y1， y = x1 - (a / b)✖️y1</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//扩展欧几里得</span><br><span class="line">ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp; y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b== 0) return -1;//此时由于a,b无最大公约数，所以出错</span><br><span class="line">    if (b == 0) &#123;//递归终止条件，若b == 0，那么gcd(a,b) == a，a * x + b * y = gcd (a, b) = 1，因此x = 1</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;//返回a用于判断a是否为1，用以确定原a,b是否互质</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = extend_gcd (b, a % b, y, x);//由扩展欧几里得可得</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求逆元 ax = 1 (mod p)</span><br><span class="line">ll mod_reverse (ll a, ll p) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = extend_gcd(a, p, x, y);//把a带入a，p带入b，通过扩展欧几里得求x</span><br><span class="line">    if (d == 1) return (x % p + p) % p;//如果a == 1表明gcd(a,p)为1，也就是a,p互质，因此输出x</span><br><span class="line">    else return -1;//否则a,p不互质，返回-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三.线性求逆元</p><p>​    求素数有线性筛，那么逆元呢？逆元当然不能落后啦，于是线性求逆元出现了Orz～</p><p>​    线性求逆元的公式是：inv(a) = (p - p / a)✖️inv(p % a) % p</p><p>​    证明过程：设x = p % a, y = p / a;</p><p>​    则有x + y✖️a = p</p><p>​    因此(x + y✖️a) % p = 0</p><p>​    x % p = (- y)✖️a % p</p><p>​    x✖️inv(a) % p = (-y) % p</p><p>​    inv(a) = (p - y)✖️inv(x) % p</p><p>​    inv(a) = (p - p / a)✖️inv(p % a) % p</p><p>这样，我们就可以利用之前的逆元求解后面的逆元了，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">    inv[0] = 1;</span><br><span class="line">    inv[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">inv[i] = ((p - p / i) * inv[p % i]) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>四.线性求阶乘逆元</p><p>​    如果我们需要求0!到n!的逆元，对每个元素都求一遍会特别慢<br>​    前面说了，逆元就可一看做是求倒数</p><p>​    那么就有1 / (n+1)! × (n+1)=1/ n!</p><p>​    因此inv[n + 1]✖️(n + 1) = inv[n] (mod p)</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll fact[N + 5];//存储阶乘</span><br><span class="line">ll inv[N + 5];//存储阶乘的逆元</span><br><span class="line">fact[0] = 1;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">    fact[i] = fact[i - 1] * i % p;//线性求阶乘</span><br><span class="line">&#125;</span><br><span class="line">inv[N] = mod_reverse(fact[N], p);//利用前面学的扩展欧几里得求fact[N]关于p的逆元</span><br><span class="line">for (int i = N - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    inv[i] = inv[i + 1] * (i + 1) % mod;   //求线性阶乘逆元</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    以上就是我对逆元的全部理解了，就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论四)快速幂与gcd扩展</title>
      <link href="/2018/10/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E5%BF%AB%E9%80%9F%E4%B9%98%E4%B8%8Egcd%E6%89%A9%E5%B1%95-%E6%9D%82%E8%B0%88/"/>
      <url>/2018/10/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E5%BF%AB%E9%80%9F%E4%B9%98%E4%B8%8Egcd%E6%89%A9%E5%B1%95-%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/快速幂、快速乘与gcd扩展-杂谈/title.jpg" alt="title"></p><a id="more"></a><p>一.关于快速幂:</p><p>​    我们要想求a^b，也就是b个a相乘，我们可以设置ans = 1，然后for循环b次，用ans累成a得到最终答案ans，这样时间复杂度是O(b)</p><p>​    当b大于1e9，我们用上面的办法就不能在1s内求出结果了。</p><p>​    举个栗子2^11,我们仔细观察一下：</p><p>​        ans = 2 ^ 11</p><p>​            = 2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2</p><p>​            =  4✖️4✖️4✖️4✖️4✖️2</p><p>​            =  16✖️16✖️4✖️2</p><p>​            =  256✖️4✖️2</p><p>​    因此我们可以只求2，4，16，256中2,4,256组合得到2^11，而2,4,16,256可以根据平方递推得到，这样要想求得a ^ b的值时间复杂度只有O(log(b))，可以说是非常快了</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll quick(ll a, ll b) &#123;//求a^b</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans *= a;//只有b为奇数时乘a，例如2^11时ans只累乘2，4，256</span><br><span class="line">        b &gt;&gt;= 1;//相当于b /= 2</span><br><span class="line">        a *= a;//就是上面所说的通过平方和递推，优化运算时间</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二. gcd扩展：</p><p>​    gcd几乎是我们刚入学接触的第一个递归了，大家想必已经熟记于心。</p><p>​    根据gcd(a, b) = gcd (b, a % b) （a &gt; b且 b != 0) 公式，我们只需要知道递归的终止条件，就可以写出这个递归代码。</p><p>​    由于b != 0，所以当a % b == 0时不能继续递归。那么，当a % b == 0时，我们应该返回什么呢？谁才是a,b的最小公约数？</p><p>​    由于a % b == 0，因此a一定是b的倍数，也就说b一定是a的因子，又因为b的最大因子是b，因此a,b的最大公约数一定是b，根据gcd(a, b) = gcd(b, a % b)，我们知道b也是最初始的a,b的最大公约数。</p><p>​    实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll gcd (ll a, ll b) &#123;//前提条件：a,b中不存在0</span><br><span class="line">    return a % b == 0? b: gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    题外话，以前以为该函数的前提条件是a必须大于b。。。其实a&lt;b也可以，因为经过一次递归，就变成了 a = b, b = a，亏我之前还判断a，b的大小。。</p><p>​    好啦，我们说几个gcd的扩展定理：</p><p>​    (1).gcd (ka, kb) = k✖️gcd(a, b)</p><p>​    (2).lcm(ka, kb) = k ✖️lcm(a, b)</p><p>​    (3).lcm(s / a, s / b) = s / gcd(a, b)</p><p>​    </p><p>​    有一些题目可通过这些扩展定理来少走很多弯路～</p><p>​    Over～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论三)素数原理</title>
      <link href="/2018/10/21/%E7%B4%A0%E6%95%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/21/%E7%B4%A0%E6%95%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/素数原理/title.jpg" alt="title"></p><a id="more"></a><p>​    打算写一下自己对ACM中常用到的数论知识，加深巩固和查缺补漏。</p><p>​    在数学中，对于n&gt;1,若n的因子只有1和它本身，那么n就是质数，也称作素数。而在ACM中素数类型的题目是经常会碰到的。</p><p>​    那么我们可以怎么判断素数呢？</p><p>一.对于判断单个n是否为素数，我们可以通过三种情况来判断：</p><p>​    （1）用i遍历2~ n -1，若n % i == 0就代表存在除1和它本身以外的因子，就直接跳出，若执行完就代表没有其它因子，n为素数。时间复杂度为O(n)</p><p>​      (2) 我们可以优化(1)，因为若存在大于sqrt(n)的因子k，那么n / k 的值一定在 2 ~ sqrt(n)中。因此我们只需要用i遍历2 ~ sqrt(n)即可，若n%i == 0就代表存在除1和它本身以外的因子，就直接跳出，若执行完就代表没有其它因子，n为素数，时间复杂度为O(sqrt(n)) 。</p><p>​      (3)    我们继续优化(2)，若 n % 2 != 0，那么从i从3~sqrt(n)，只需要考虑奇数即可。因此时间复杂度为O(sqrt(n) / 2)</p><p>我给出(3)的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool chooes(ll n) &#123;//判断n是否为素数</span><br><span class="line">    if (n % 2 == 0) return false;//若n%2==0，则说明n不是素数</span><br><span class="line">    for (int i = 3; i * i &lt;= n; i += 2) &#123;//从3～sqrt(n)，每次+=2，若存在n % i == 0，则说明n不是素数</span><br><span class="line">        if (n % i == 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;//否则n为素数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二.对于判断2～n每个数是否为素数，我们应该怎么办呢？</p><p>​    我们利用一中最快的(3)方法，时间复杂度为O(n✖️sqrt(n) / 2)，若n为1e5以上，1s之内是筛选不出来的。因此我们只能想别的办法，先来介绍第一种：</p><p>（1）由于是求2～n的每个数，因此我们可以尝试利用之前已经判断过的数来求后面的数是否为素数。我们知道，素数的因子只有1和它本身，那么一个2以上的数的倍数一定不是素数！！又因为合数一定可以由素数累乘得到，所以我们只需要把所有素数的倍数标记为合数，剩余的数一定是质数。</p><p>​    也就是说，对于n = 10，素数2的倍数4，6，8，10一定是合数；</p><p>​                        素数3的倍数6，9一定是合数</p><p>​                        4是合数跳过，素数5的倍数10一定是合数；</p><p>​                        6是合数跳过，得到素数7</p><p>​                        由于8，9，10是合数，因此全部跳过</p><p>​                        我们就得到10以内的素数2，3，5，7</p><p>​    通过这样的办法，我们可以在趋近于线性（实际是nlog(log(n))) 的时间内求出2～n中的每个数是否是素数。</p><p>​    以上的第一种方法，是被埃拉托斯特尼发明的，因此也叫做埃筛法</p><p>​    如果大家觉得还不够快，趋近于线性也不是线性啊！！有没有线性时间就能求出来2～n所有素数的方法呢？</p><p>​    答案是有的，该方法称为线筛。</p><p>（2）我们知道上面的数，对于素数2的倍数4，6，8，10一定是合数；</p><p>​                       对于素数3的倍数6，9一定是合数；</p><p>​    大家有没有发现6此时两次被判定为合数，埃筛之所以不是线性的原因就在于这里。。它可能会造成合数的重复判定。我们怎么样才能每个数只判定一次呢？就是在这个合数的最小素因子时判定该数为合数，其它素因子时不判定，这样就可以保证每个合数只判定一次了。这也就是线性筛的精髓了：</p><p>​    对于2，我们判定为素数，我们检索已经存在的素数2，把2✖️2，也就是4标记为合数；</p><p>​    对于3，我们判定为素数，我们检索已经存在的素数2, 3，把2✖️3，3✖️3，也就是6， 9标记为合数</p><p>​    对于4已标记为合数，我们检索已经存在的素数2，3，把2✖️4，也就是8标记为合数，由于4 % 2 == 0，因此我们直接跳出，不再执行3✖️4也就是12的判定（因为它可以由2✖️6判定，2是12的最小素因子）</p><p>​    对于5，我们判定为素数，我们检索已经存在的素数2，3，5，把2✖️5，3✖️5，5✖️5，也就是10，15，25标记为合数</p><p>​    对于6已标记为合数，    我们检索已经存在的素数2，3，5，把2✖️6，也就是12标记为合数，由于6 % 2 == 0，因此我们直接跳出，不再执行3✖️6也就是18的判定（因为它可以由2✖️9判定，2是18的最小素因子）</p><p>​    ………</p><p>​    就不往下继续写了，通过以上的流程，我们就可以判定2～n中的每个数是否为素数并保证每个数只判定一次（还可以加如果两数相乘大于n直接跳出等限制条件），这样时间复杂度就是O(n)</p><p>我给出(2)方法的实现代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define N 100005</span><br><span class="line"></span><br><span class="line">bool book[N + 5];   //book[i]判断i是否为素数</span><br><span class="line">int prime[N + 5];   //prime数组存储2～N全部素数，若MLE可改小该数组长度</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    prime[0] = 0;       //代表2～N当前有多少个素数</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;             //如果是素数</span><br><span class="line">            prime[++prime[0]] = i;      //存入该素数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; (ll)prime[j] * i &lt;= N; j++) &#123;  //遍历之前存储的素数</span><br><span class="line">            book[prime[j] * i] = 1;     //素数的i倍一定不是素数</span><br><span class="line">            if (i % prime[j] == 0) break;    //保证每个合数只判断一次的精髓</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上就是素数判定和素数筛的一些理论与模版。在ACM中关于素数的题目很活，变形也很多，大家有兴趣可以看一下我博客中的数论标签的题目，里面有很多基于素数筛框架的变形题目～</p><p>​    附上博客地址：<a href="http://www.ivan-zcy.top">跳转</a></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA8512线段树维护线性基</title>
      <link href="/2018/10/21/UVA8512%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2018/10/21/UVA8512%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/UVA8512线段树维护线性基/title.jpg" alt="title"></p><a id="more"></a><p>​    题目需要用到线性基，之前写过线性基的原理和模版，想看的同学点右边 -&gt; <a href="http://www.ivan-zcy.top/2018/10/19/浅谈线性基/">走你</a></p><p>题意：</p><p>Consider an array A with n elements . Each of its element is A[i] (1≤i≤n) . Then gives two integers Q, K, and Q queries follow . Each query , give you L, R, you can get Z by the following rules.</p><p>To get Z , at first you need to choose some elements from A[L] to A[R] ,we call them A[i1],A[i2]…A[it] , Then you can get number Z=K or (A[i1] xor A[i2] … xor A[it]) .</p><p>Please calculate the maximum Z for each query .</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Several test cases .</p><p>First line an integer T (1≤T≤10). Indicates the number of test cases.Then TT test cases follows . Each test case begins with three integer N, Q, K (1≤N≤10000, 1≤Q≤100000, 0≤K≤100000). The next line has N integers indicate A[1] to A[N] (0≤A[i]≤108). Then Q lines , each line two integer L, R (1≤L≤R≤N) .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each query , print the answer in a single line.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 3 0</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>​    翻译成汉语就是，给你一个T代表T组样例，每组样例有n, q, k，表示一个数组有n个数，有q次询问。下一行给出n个数分别是数组中每个数的值。接下来q行每行两个数l,r，问数组a[l] ～a[r]中选几个数的异或和|k的值最大 </p><p>问最大值是多少？</p><p>思路：</p><p>​    由于异或和|k值最大，这里有个小技巧。就是对数组中的每个数进行a[i] = a[i] &amp; (~k)，这样新的数组中最大的异或和|k就是最大值，因此我们只需要求新数组l～r的最大异或和</p><p>​    由于n的数据范围是1e4，q的数据范围是1e5，如果每查询一次重新求一次线性基数组，肯定会超时。因此我们可以利用线段树来维护l～r之间的线性基数组。</p><p>​    再加上各种剪枝，快速读写。用了不到600msA掉</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define N 10005</span><br><span class="line">#define lson rt&lt;&lt;1</span><br><span class="line">#define rson rt&lt;&lt;1|1</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">namespace IO &#123;</span><br><span class="line">    const d MX = 1e7;         //1e7 占用内存 11000kb</span><br><span class="line">    char buf[MX];</span><br><span class="line">    d c, sz;</span><br><span class="line">    </span><br><span class="line">    void begin() &#123;            //该方法用于main方法开头位置，可一次性读完全部输入</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);  //一次性全部读入</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inline bool read(int &amp;t) &#123;        //用于从buf中读入每个数</span><br><span class="line">        while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;))</span><br><span class="line">            c++;</span><br><span class="line">        if (c &gt;= sz) return false;            //若读完整个缓冲块则退出</span><br><span class="line">        bool flag = 0; if(buf[c] == &apos;-&apos;) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++)</span><br><span class="line">            t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        if(flag) t = -t;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inline void write(int t) &#123;</span><br><span class="line">        if (t &gt; 9) write(t / 10);</span><br><span class="line">        putchar(t % 10 + &apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//全局变量</span><br><span class="line">d k;</span><br><span class="line"></span><br><span class="line">//树节点（可存储范围内值的最高位maxn和线性基数组c）</span><br><span class="line">struct node &#123;</span><br><span class="line">    d maxn;</span><br><span class="line">    d c[35];</span><br><span class="line">    void init() &#123;</span><br><span class="line">        mem(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addx(d x) &#123;</span><br><span class="line">        Forr(i, 30, 0) &#123;</span><br><span class="line">            if(x &gt;&gt; i &amp; 1) &#123;</span><br><span class="line">                maxn = i;</span><br><span class="line">                c[i] = x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    d ansmax() &#123;</span><br><span class="line">        d t = 0;</span><br><span class="line">        Forr(i, maxn, 0) &#123;</span><br><span class="line">            if ((t ^ c[i]) &gt; t) &#123;</span><br><span class="line">                t ^= c[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node merge(node A) &#123;</span><br><span class="line">        node t;</span><br><span class="line">        t.init();</span><br><span class="line">        Forr(i, maxn, 0) &#123;</span><br><span class="line">            t.c[i] = c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Forr(i, A.maxn, 0) &#123;</span><br><span class="line">            if (A.c[i]) &#123;</span><br><span class="line">                d x = A.c[i];</span><br><span class="line">                Forr(j, i, 0) &#123;</span><br><span class="line">                    if (x &gt;&gt; j &amp; 1) &#123;</span><br><span class="line">                        if (!t.c[j]) &#123;</span><br><span class="line">                            t.c[j] = x;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        x ^= t.c[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (x == 0) break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.maxn = max(maxn, A.maxn);</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;shu[N &lt;&lt; 2];</span><br><span class="line"></span><br><span class="line">//建树</span><br><span class="line">void Build (d rt, d l, d r) &#123;</span><br><span class="line">    if (l == r) &#123;</span><br><span class="line">        d t;</span><br><span class="line">        IO::read(t);</span><br><span class="line">        t = t &amp; (~k);</span><br><span class="line">        shu[rt].init();</span><br><span class="line">        shu[rt].addx(t);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    d mid = (l + r) &gt;&gt; 1;</span><br><span class="line">    if (l &lt;= mid) Build(lson, l, mid);</span><br><span class="line">    if (mid &lt; r) Build(rson, mid + 1, r);</span><br><span class="line">    shu[rt] = shu[lson].merge(shu[rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">node request (d rt, d l, d r, d L, d R) &#123;</span><br><span class="line">    node t;</span><br><span class="line">    t.init();</span><br><span class="line">    if (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        return shu[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    d mid = (L + R) &gt;&gt; 1;</span><br><span class="line">    if (l &lt;= mid &amp;&amp; r &gt; mid) return request(lson, l, r, L, mid).merge(request(rson, l, r, mid + 1, R));</span><br><span class="line">    else if(l &lt;= mid) return request(lson, l, r, L, mid);</span><br><span class="line">    else if(r &gt;= mid) return request(rson, l, r, mid + 1, R);</span><br><span class="line">    else return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    IO::begin();</span><br><span class="line">    d T, n, q, l, r;</span><br><span class="line">    IO::read(T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        IO::read(n);</span><br><span class="line">        IO::read(q);</span><br><span class="line">        IO::read(k);</span><br><span class="line">        Build(1, 1, n);</span><br><span class="line">        For(i, 1, q) &#123;</span><br><span class="line">            IO::read(l);</span><br><span class="line">            IO::read(r);</span><br><span class="line">            node t = request(1, l, r, 1, n);</span><br><span class="line">            d ans = (t.ansmax() | k);</span><br><span class="line">            IO::write(ans);</span><br><span class="line">            putchar(&apos;\n&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢!</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快到难以想象的快速读模版</title>
      <link href="/2018/10/21/%E5%BF%AB%E5%88%B0%E9%9A%BE%E4%BB%A5%E6%83%B3%E8%B1%A1%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AF%BB%E6%A8%A1%E7%89%88/"/>
      <url>/2018/10/21/%E5%BF%AB%E5%88%B0%E9%9A%BE%E4%BB%A5%E6%83%B3%E8%B1%A1%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AF%BB%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/快到难以想象的快速读模版/z1.jpg" alt="z1"></p><a id="more"></a><p>​    没错，比上一个快速读写模版 <a href="http://www.ivan-zcy.top/2018/10/18/ACM快速读写模版/">跳转</a> 还要快，这个模版是利用fread方法实现一次性读完（速度快，缺点也明显，特别耗费内存！！）</p><p>​    具体模版如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace IO &#123;</span><br><span class="line">    const int MX = 4e7; //1e7 占用内存 11000kb</span><br><span class="line">    char buf[MX];</span><br><span class="line">    int c, sz;</span><br><span class="line">    </span><br><span class="line">    void begin() &#123;//该方法用于main方法开头位置，可一次性读完全部输入</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);  //一次性全部读入</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inline bool read(int &amp;t) &#123;//用于从buf中读入每个数</span><br><span class="line">        while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++;</span><br><span class="line">        if (c &gt;= sz) return false;//若读完整个缓冲块则退出</span><br><span class="line">        bool flag = 0; if(buf[c] == &apos;-&apos;) &#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) </span><br><span class="line">        t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        if(flag) t = -t;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    具体用法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[105];</span><br><span class="line">int main() &#123;</span><br><span class="line">    IO::begin();//一次性读完全部输入</span><br><span class="line">    int T, n;</span><br><span class="line">    IO::read(T);//从buf中读入到T</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">    IO::read(n);    //从buf中读入到n</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            IO::read(a[i]);//从buf中读入到a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意！！！只有当运行ctrl + z时才代表IO::begin()结束（在windows下，Linux下为ctrl + d），程序正式执行～</p><p>​    就酱紫～</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-20博客搭建进度</title>
      <link href="/2018/10/20/18-10-20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/20/18-10-20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/18-10-20博客搭建进度/z.jpg" alt="z"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果</p><p>​    ——新增页面卡通人物效果</p><p>​    ——微调音乐布局</p><p>​    ——微调小火箭布局</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5971二分图染色</title>
      <link href="/2018/10/20/HDU5971/"/>
      <url>/2018/10/20/HDU5971/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5971/title8.jpg" alt="title8"></p><a id="more"></a><p>题意：</p><p>Nowadays, at least one wrestling match is held every year in our country. There are a lot of people in the game is “good player”, the rest is “bad player”. Now, Xiao Ming is referee of the wrestling match and he has a list of the matches in his hand. At the same time, he knows some people are good players,some are bad players. He believes that every game is a battle between the good and the bad player. Now he wants to know whether all the people can be divided into “good player” and “bad player”. </p><p>Input</p><p>Input contains multiple sets of data.For each set of data,there are four numbers in the first line:N (1 ≤ N≤ 1000)、M(1 ≤M ≤ 10000)、X,Y(X+Y≤N ),in order to show the number of players(numbered 1toN ),the number of matches,the number of known “good players” and the number of known “bad players”.In the next M lines,Each line has two numbersa, b(a≠b) ,said there is a game between a and b .The next line has X different numbers.Each number is known as a “good player” number.The last line contains Y different numbers.Each number represents a known “bad player” number.Data guarantees there will not be a player number is a good player and also a bad player.</p><p>Output</p><p>If all the people can be divided into “good players” and “bad players”, output “YES”, otherwise output “NO”.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 0 0</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">5 4 1 0</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给出n个人，m场比赛，已知x个人为好的运动员，y个人为差的运动员，每场比赛两个人必有一个好一个差，问好的和差的是否会前后冲突？如果不冲突是否每个运动员都可以归类？</p><p>思路：</p><p>​    听队友说正解是二分图染色，自己不会图论，就用BFS做了一手，只用62ms成功A掉</p><p>​    初始化book数组为0，把x个好运动员的book[i]初始化为1，y个差运动员的book[i]初始化为-1，并把这x+y个运动员加入到队列中。对队列中的每个运动员进行检查，和该运动员有关的（也就是与他有比赛的）运动员book[i]为0，那么就设置成和他之相反并把有关的运动员加入到队列中。如果和他book[i]相同，那么代表前后矛盾，直接标记为失败并跳出循环。</p><p>​    这是对与X+Y以及与之有关的运动员进行判定，如果没有失败的话，则对所有参与比赛的人进行检索，若存在参加比赛的人book[i]为0，这时候要注意，这个运动员和之前的运动员不存在任何关联！！！所以可以把他设置为book[i]为1并加入到优先队列，再次进行BFS进行检索查看是否有矛盾</p><p>​    若上面两个步骤都没有矛盾，则从头遍历所有运动员，是否有未归类的运动员，若没有则输出YES，否则都是NO。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d book[1005];</span><br><span class="line">vector&lt;d&gt;zcy[1005];</span><br><span class="line">queue&lt;d&gt;line;</span><br><span class="line">d n, m, x, y;</span><br><span class="line">d a[10005], b[10005];</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    d p;</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        zcy[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!line.empty()) &#123;</span><br><span class="line">        line.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, m) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);</span><br><span class="line">        zcy[a[i]].push_back(b[i]);</span><br><span class="line">        zcy[b[i]].push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, x) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">        book[p] = 1;</span><br><span class="line">        line.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, y) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">        book[p] = -1;</span><br><span class="line">        line.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BFS检索与已经入队的运动员有关的运动员是否前后冲突</span><br><span class="line">d work() &#123;</span><br><span class="line">    d flag = 0;</span><br><span class="line">    while (!line.empty()) &#123;</span><br><span class="line">        d t = line.front();</span><br><span class="line">        line.pop();</span><br><span class="line">        d pan = book[t];</span><br><span class="line">        for (d i = 0; i &lt; zcy[t].size(); i++)&#123;</span><br><span class="line">            if(book[zcy[t][i]] == 0) &#123;</span><br><span class="line">                book[zcy[t][i]] = -pan;</span><br><span class="line">                line.push(zcy[t][i]);</span><br><span class="line">            &#125; else if(book[zcy[t][i]] == pan)&#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    while (scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;x, &amp;y) == 4) &#123;</span><br><span class="line">        init();</span><br><span class="line">        d flag = work();</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 1, m) &#123;</span><br><span class="line">            if(!book[a[i]]) &#123;</span><br><span class="line">                book[a[i]] = 1;</span><br><span class="line">                line.push(a[i]);</span><br><span class="line">                flag = work();</span><br><span class="line">                if(flag) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后检索是否存在没有归类的运动员</span><br><span class="line">        For(i, 1, n) &#123;</span><br><span class="line">            if(!book[i]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;YES\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 5976思维</title>
      <link href="/2018/10/20/HDU-5976/"/>
      <url>/2018/10/20/HDU-5976/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU-5976/title7.jpg" alt="title7"></p><a id="more"></a><p>题意：</p><p>​    In a highly developed alien society, the habitats are almost infinite dimensional space.<br>In the history of this planet,there is an old puzzle.<br>​    You have a line segment with x units’ length representing one dimension.The line segment can be split into a number of small line segments: a1,a2, … (x= a1+a2+…) assigned to different dimensions. And then, the multidimensional space has been established. Now there are two requirements for this space:<br>​    1．Two different small line segments cannot be equal ( ai≠aj when i≠j).<br>​    2．Make this multidimensional space size s as large as possible (s= a1∗a2*…).Note that it allows to keep one dimension.That’s to say, the number of ai can be only one.<br>​    Now can you solve this question and find the maximum size of the space?(For the final number is too large,your answer will be modulo 10^9+7)</p><p>Input</p><p>​    The first line is an integer T,meaning the number of test cases.<br>​    Then T lines follow. Each line contains one integer x.<br>​    1≤T≤10^6, 1≤x≤10^9</p><p>Output</p><p>​    Maximum s you can get modulo 10^9+7. Note that we wants to be greatest product before modulo 10^9+7.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p> 翻译成汉语就是给出一个数T代表T组样例，然后每组样例给出一个x，然后将x拆分成任意多个各不相同的数a1,a2a1,a2, … 满足(x= a1+a2a1+a2+…) ，怎样拆分才能使得这些数的乘积最大，输出最大值并取模1e9+7</p><p>思路：</p><p>​    我们先特判a为1的情况，输出1</p><p>​    对于a&gt;1的情况：</p><p>​    由于拆分出的数各不相同，因此我们可以求sum[i]数组代表2 + 3 + .. + i（i &gt;= 2），ans[i]代表2✖️3✖️…✖️i (i &gt;= 2，注意累成需取模1e9+7否则爆longlong)。至于为什么不含1，因此任何数满足n &gt; (n - 1)✖️1，所以拆成1不划算。</p><p>​    我们利用二分找到第一个大于等于a的sum[i]，此时需要分类讨论：</p><p>​    若sum[i] == a，则直接输出ans[i]即为答案</p><p>​    若sum[i] - a == 1，则去掉2和i（也就是用ans[i]分别乘2和i关于1e9+7的逆元），再乘（i + 1）并取模1e9+7即为答案</p><p>​    若sum[i] - a &gt; 1，我们设sum[i] - a为k，k一定小于等于i，我们直接去掉k即可（也就是ans[i]乘k关于1e9+7的逆元）并取模1e9+7即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 45000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d sum[N + 5];</span><br><span class="line">ll ans[N + 5];</span><br><span class="line">const ll mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">//预处理sum与ans数组</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(sum);</span><br><span class="line">    ans[1] = 1;</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        sum[i] += sum[i - 1] + i;</span><br><span class="line">        ans[i] = ans[i - 1] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展欧几里得</span><br><span class="line">ll exten(ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if(a == 0 &amp;&amp; b == 0) return -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = exten(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求逆元</span><br><span class="line">ll mod_reverse(ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll t = exten(a, n, x, y);</span><br><span class="line">    if (t == 1) return (x % n + n) % n;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二分查找第一个大于等于val的sum[i]下角标</span><br><span class="line">d erfen(d val) &#123;</span><br><span class="line">    d l = 2, r = N, mid;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; 1;</span><br><span class="line">        if(sum[mid] &gt;= val) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    d T, a;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        if (a == 1) &#123;//特判当a为1时</span><br><span class="line">            printf(&quot;1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        d inx = erfen(a);</span><br><span class="line">        d t = sum[inx] - a;</span><br><span class="line">        if (t == 0) &#123;//分三种情况讨论</span><br><span class="line">            printf(&quot;%lld\n&quot;, ans[inx]);</span><br><span class="line">        &#125; else if (t == 1) &#123;</span><br><span class="line">            d k = inx + 1;</span><br><span class="line">            ll res = ans[inx] * mod_reverse(2, mod) % mod * mod_reverse(inx, mod) % mod * k % mod;</span><br><span class="line">            printf(&quot;%lld\n&quot;, res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ll res = ans[inx] * mod_reverse(t, mod) % mod;</span><br><span class="line">            printf(&quot;%lld\n&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5974方程化简</title>
      <link href="/2018/10/20/HDU5974/"/>
      <url>/2018/10/20/HDU5974/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5974/title5.jpg" alt="title5"></p><a id="more"></a><p>题意：</p><p>Given two positive integers a and b,find suitable X and Y to meet the conditions:<br>​                                                        X+Y=a<br>​                                              Least Common Multiple (X, Y) =b</p><p>Input</p><p>Input includes multiple sets of test data.Each test data occupies one line,including two positive integers a(1≤a≤2*10^4),b(1≤b≤10^9),and their meanings are shown in the description.Contains most of the 12W test cases.</p><p>Output</p><p>For each set of input data,output a line of two integers,representing X, Y.If you cannot find such X and Y,output one line of “No Solution”(without quotation).</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 8</span><br><span class="line">798 10780</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No Solution</span><br><span class="line">308 490</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给出两个数a，b (a &lt;= 2e4, b &lt;= 1e9)，问是否存在x,y，使得x + y = a, x和y的最小公倍数为b？一共有12万组样例！！</p><p>思路：    </p><p>​    由于有12W组样例，只要每组样例超过1e3几乎就凉了,因此这个题肯定不能暴力。于是我想到了第一种方法：</p><p>​    方法一：先利用素数筛把sqrt(1e9)以内的所有素数筛出来，然后求出b的所有种素因子和每种素因子的个数。</p><p>然后dfs每种素因子（每种素因子可以取0～a[i]个），再加上各种剪枝。。。982ms飘过～～</p><p><img src="/2018/10/20/HDU5974/1.png" alt="1"></p><p>​    </p><p>​    方法一代码耗时982ms实在是太吓人了，万一现场赛评测机一个不高兴给你慢个20ms你就嗝屁了，然后看到网上正解，一拍脑瓜子。哎，智商压制啊～</p><p>​    方法二：我们设x和y的最大公约数为c，那么x = i ✖️ c，y = j ✖️ c。</p><p>​    由于c是x，y的最大公约数，所以i，j一定互质（要是两者不互质存在公约数的话，x，y的最大公约就为c✖️i和j的公约数，而不是c了，因此i，j一定互质）</p><p>​    那么： </p><p>​        a = x + y = (i ✖️ c) + （j✖️c）= （i + j) ✖️ c</p><p>​        b = lcm(x, y) = x ✖️ y / gcd(x, y) = x ✖️ y / c = （i ✖️ c ✖️ j ✖️ c)  / c = i ✖️j✖️c</p><p>​    由于i,j互质，那么（i + j）和 （i * j）也一定互质。我们可以用反证法证明：</p><p>​    若（i + j）,（i✖️j)不互质存在一个素因子t：那么在i✖️j中，t只能是 i的素因子 或 j的素因子(因为i,j互质，不存在公共素因子)；又因为i和j必须都存在素因子t才能使得(i + j)存在素因子t(相当于同余定理，若a % t == 0， 则b % t == 0才能使得（a + b）% t == 0)，因此和i 存在素因子t 或 j存在素因子t相矛盾，所以(i + j)和(i * j)互质</p><p>​    因此gcd(a, b) = c = gcd (x, y)</p><p>​    因此化简得：</p><p>​    x + y = a      (一)</p><p>​    x✖️y = b ✖️ gcd(x, y) = b ✖️gcd(a, b)    （二）</p><p>​    a，b已知，因此就相当于解二元一次方程，把方程（一）带入（二）得：</p><p>​    x✖️(a - x) = b ✖️gcd(a, b) </p><p>=&gt;   x^2 - a✖️x + b✖️gcd(a,b) = 0</p><p>=&gt;    x = (a + sqrt(a^2 - 4✖️b✖️gcd(a,b))) / 2</p><p>​    就可以求出x，y了。这样代码简短，而且耗时只有124ms：</p><p><img src="/2018/10/20/HDU5974/2.png" alt="2"></p><p>​    Orz～</p><p>代码：</p><p>​    方法一：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 32000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line"></span><br><span class="line">bool book[N + 5];</span><br><span class="line">int prime[N + 5];</span><br><span class="line">ll ans[105];</span><br><span class="line">ll ansnum[105];</span><br><span class="line">ll a, b;</span><br><span class="line">bool flag;</span><br><span class="line"></span><br><span class="line">//预处理素数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(prime);</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime[0]) &#123;</span><br><span class="line">            ll t = prime[j] * i;</span><br><span class="line">            if (t &gt; N) break;</span><br><span class="line">            book[t] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求最大公约数</span><br><span class="line">ll gcd (ll y, ll x) &#123;</span><br><span class="line">    ll c = y % x;</span><br><span class="line">    return c == 0? x: gcd(x, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//枚举不同素数组成的因子可能</span><br><span class="line">void dfs(ll now, ll n, ll val) &#123;</span><br><span class="line">    if (flag) return;</span><br><span class="line">    if (val &gt; a / 2) return;</span><br><span class="line">    if(now == n + 1) &#123;</span><br><span class="line">        if(val * (a - val) / gcd((a - val), val) == b) &#123;</span><br><span class="line">            printf(&quot;%lld %lld\n&quot;, val, a - val);</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    dfs(now + 1, n, val);</span><br><span class="line">    For(i, 1, ansnum[now]) &#123;</span><br><span class="line">        res *= ans[now];</span><br><span class="line">        dfs(now + 1, n, val * res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    while (scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) == 2) &#123;</span><br><span class="line">        mem(ansnum);</span><br><span class="line">        ll tot = 0, bb = b;</span><br><span class="line">        flag = 0;</span><br><span class="line">        For(i, 1, prime[0]) &#123;</span><br><span class="line">            if(bb % prime[i] == 0) &#123;</span><br><span class="line">                ans[++tot] = prime[i];</span><br><span class="line">                while(bb % prime[i] == 0) &#123;</span><br><span class="line">                    ansnum[tot]++;</span><br><span class="line">                    bb /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (bb == 1) break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(bb != 1) &#123;</span><br><span class="line">            ans[++tot] = bb;</span><br><span class="line">            ansnum[tot] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, tot, 1);</span><br><span class="line">        if(!flag) &#123;</span><br><span class="line">            printf(&quot;No Solution\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    方法二：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll gcd (ll y, ll x) &#123;</span><br><span class="line">    ll c = y % x;</span><br><span class="line">    return c == 0? x: gcd(x, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    while (scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) == 2) &#123;</span><br><span class="line">        ll c = gcd(max(a, b), min(a, b));</span><br><span class="line">        double x = (sqrt(a * a - 4 * b * c) + a) / 2;</span><br><span class="line">        if (x == (ll)x) &#123;</span><br><span class="line">            ll t = (ll)x;</span><br><span class="line">            printf(&quot;%lld %lld\n&quot;, min(t, a - t), max(t, a - t));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;No Solution\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5978水题</title>
      <link href="/2018/10/20/HDU5978/"/>
      <url>/2018/10/20/HDU5978/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5978/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><p>A box contains black balls and a single red ball. Alice and Bob draw balls from this box without replacement, alternating after each draws until the red ball is drawn. The game is won by the player who happens to draw the single red ball. Bob is a gentleman and offers Alice the choice of whether she wants to start or not. Alice has a hunch that she might be better off if she starts; after all, she might succeed in the first draw. On the other hand, if her first draw yields a black ball, then Bob’s chances to draw the red ball in his first draw are increased, because then one black ball is already removed from the box. How should Alice decide in order to maximize her probability of winning? Help Alice with decision. </p><p>Input</p><p>Multiple test cases (number of test cases≤50), process till end of input.<br>For each case, a positive integer k (1≤k≤10^5) is given on a single line. </p><p>Output</p><p>For each case, output:<br>1, if the player who starts drawing has an advantage<br>2, if the player who starts drawing has a disadvantage<br>0, if Alice’s and Bob’s chances are equal, no matter who starts drawing<br>on a single line. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思是一个箱子中有n个蓝球，1个红球。爱丽丝先抓，鲍勃后抓，直到抓到红球的人获胜为止。问谁赢的概率大。0代表概率一样，1代表爱丽丝赢的概率大，2代表鲍勃赢的概率大</p><p>思路：</p><p>​    当n为1的时候，爱丽丝赢的概率是1 / 2；当n为2的时候，爱丽丝赢的概率是1 / 3 + 2 / 3 ✖️ 1 / 2 =  2 / 3；当n为3的时候，爱丽丝赢的概率是1 / 4 + 3 / 4 ✖️ 2 / 3 ✖️1 / 2 = 1 / 2；当n为4的时候，爱丽丝赢的概率是1 / 5 + 4 / 5 ✖️ 3 / 4 ✖️1 / 3  +  4 / 5 ✖️ 3 / 4 ✖️ 2 / 3 ✖️ 1 / 2 =  3 / 5；</p><p>​    因此我们发现，当n为偶数的时候，爱丽丝赢的概率大，输出1。当n为奇数时，两者赢的概率相同，输出0。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int a;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;a) == 1) &#123;</span><br><span class="line">        if(a &amp; 1) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;1\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5980水题</title>
      <link href="/2018/10/20/HDU5980/"/>
      <url>/2018/10/20/HDU5980/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5980/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>As is known to all,the ASCII of character ‘a’ is 97. Now,find out how many character ‘a’ in a group of given numbers. Please note that the numbers here are given by 32 bits’ integers in the computer.That means,1digit represents 4 characters(one character is represented by 8 bits’ binary digits). </p><p>Input</p><p>The input contains a set of test data.The first number is one positive integer N (1≤N≤100),and then N positive integersai (1≤ aiai≤2^32 - 1) follow</p><p>Output</p><p>Output one line,including an integer representing the number of ‘a’ in the group of given numbers.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">97 24929 100</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，意思是int类型的数在二进制下有32位，问你一个数组中的数，8位8位的看，问存在多少个97</p><p>思路：</p><p>​    我们把数组中的每个数累除256直到0，每次累除都取余256看是否存在97，存在就++即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        unsigned int a;</span><br><span class="line">        int sum =0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%u&quot;, &amp;a);</span><br><span class="line">            while(a) &#123;</span><br><span class="line">                if (a % 256 == 97) sum ++;</span><br><span class="line">                a /= 256;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5979水题</title>
      <link href="/2018/10/20/HDU5979/"/>
      <url>/2018/10/20/HDU5979/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5979/title2.jpg" alt="title2"></p><a id="more"></a><p>题意：</p><p>We have a special convex that all points have the same distance to origin point.<br>As you know we can get N segments after linking the origin point and the points on the convex. We can also get N angles between each pair of the neighbor segments.<br>Now give you the data about the angle, please calculate the area of the convex </p><p>Input</p><p>There are multiple test cases.<br>The first line contains two integer N and D indicating the number of the points and their distance to origin. (3 &lt;= N &lt;= 10, 1 &lt;= D &lt;= 10)<br>The next lines contain N integers indicating the angles. The sum of the N numbers is always 360. </p><p>Output</p><p>For each test case output one float numbers indicating the area of the convex. The printed values should have 3 digits after the decimal point. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">90 90 90 90</span><br><span class="line">6 1</span><br><span class="line">60 60 60 60 60 60</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.000</span><br><span class="line">2.598</span><br></pre></td></tr></table></figure><p>​    2016ICPC大连站的签到题，翻译成汉语，意思是给出n，k，代表凸n边形，每个顶点距离原点的距离为k。然后下一行给出n个角度a[i]，角度之和等于360度。代表从上一个顶点与下一个顶点之间的夹角是a[i]度。问这个凸n边形的面积是多少？</p><p>思路：</p><p>​    由于已知角度和两个顶点距离原点的距离，所以我们可以根据三角形面积公式s = 1 / 2 * sin(夹角度数)分别求出每个三角形的面积。n个三角形的面积求和就是凸n变形的面积。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#define pi acos(-1.0)</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define N 100</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d n;</span><br><span class="line">    double t, a;</span><br><span class="line">    while (scanf(&quot;%d%lf&quot;, &amp;n, &amp;t) == 2) &#123;</span><br><span class="line">        double s = 0;</span><br><span class="line">        For(i, 0, n - 1) &#123;</span><br><span class="line">            scanf(&quot;%lf&quot;, &amp;a);</span><br><span class="line">            s += sin(pi * a / 180) * t * t / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.3f\n&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论二)浅谈线性基</title>
      <link href="/2018/10/19/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2018/10/19/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/19/浅谈线性基/titile1.jpg" alt="titile1"></p><a id="more"></a><p>​    前两天作了一套题，有一道线性基的模版题没出，觉得有必要学一手线性基了..</p><p>一.线性基是什么？</p><p>​    线性基其实就是一个集合。假设一个普通的集合为A，它的线性基集合B是A的一个子集。B中所有子集的异或和组成的集合等价于A中所有子集的亦或和组成的集合（除0外）。</p><p>二.线性基有什么性质：</p><p>​    1.若一个数x能被线性基集合中某个子集的异或和得到，该子集唯一</p><p>​    2.线性基集合中任意一个子集的异或和不为0</p><p>​    3.线性基集合中每个元素的最高位互不相同</p><p>​    4.若线性基集合是满的（也就是说最高位是1～n位的数都存在），那么它的异或集合是【1, 2^n - 1】</p><p>三.关于线性基的代码实现：</p><p>​    我们用p数组存储线性基的元素</p><p>​    （1）关于线性基中元素的插入</p><p>​    我们要插入一个数x，需要从高到低枚举所有位，若x&amp;当前位 != 0，若当前位不存在线性基元素，则将x当作线性基的当前位元素，否则x异或当前位元素，直到x为0或将x添加到线性基中</p><p>​    代码如下 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addx (ll x) &#123;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;//long long型的最大值为2^63 - 1，因此是0～62</span><br><span class="line">        if (x &gt;&gt; i &amp; 1) &#123;</span><br><span class="line">            if (!p[i]) &#123;</span><br><span class="line">                p[i] = x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            x ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (2)关于求最大异或和：</p><p>​    初始化res = 0，从高到低遍历位数，若res ^ p[i]大于res就更新res，最后res即为线性基所能得到的最大异或和</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getmax() &#123;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (res &lt; (res ^ p[i])) res ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (3)关于求异或t后的最大异或和：</p><p>​    同上一样，只需要初始化res = t即可。</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getmaxt() &#123;</span><br><span class="line">    ll res = t;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (res &lt; (res ^ p[i])) res ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (4)关于求最小异或和：</p><p>​    最小值就是线性基中位数由低到高第一个存在的p[i]</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getmin () &#123;</span><br><span class="line">    for (ll i = 0; i &lt;= 62; i++) &#123;</span><br><span class="line">        if (p[i]) return p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (5)关于求异或集合中的第k小值</p><p>​    需要把线性基集合中的元素改为除了最高位为1，其余位为0的形式。也就是说，若j&lt;i且p[i]中第j位是1，就p[i] ^ p[j]</p><p>​    我们对k进行二进制拆分，若第i位为1，就异或p[i]，最终得到的答案就是第k小的异或值</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int tot = -1;</span><br><span class="line">void build () &#123;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (ll j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (p[i] &gt;&gt; j &amp; 1) p[i] ^= p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (ll i = 0; i &lt;= 62; i++) &#123;</span><br><span class="line">        if (p[i]) g[++tot] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll query (ll k) &#123;</span><br><span class="line">//若原数组中存在元素0，则此时需要k--</span><br><span class="line">    if (k &gt;= (1LL * tot)) return -1;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for (ll i = tot; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (k &gt;&gt; i &amp; 1) res ^= g[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四. 线性基能求解什么问题？</p><p>​    (1). 给出一个数组，问一个数能否由数组中的元素异或得到</p><p>​    (2).给出一个数组，问数组中全部子集异或和组成的集合中，第k小的数是多少</p><p>​    (3).给出一个数组和一个数t，问数组全部子集的异或和（可重复）按从小到大排序，第一个等于t的下角标是多少？</p><p>​    (4).给出一个可重集合和k，等概率选一个子集A，得到A的异或和x，问x^k的数学期望值是多少？</p><p>​    (5).给出一个连通无向图（n个点m条边，每个边有一个权值）,问从起点走到终点异或和最小的值是多少？</p><p>​    以上就是总结的线性基的基础，遇到异或问题，可以首先考虑能否使用线性基，就酱～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1636区间dp</title>
      <link href="/2018/10/19/hihoCoder-1636/"/>
      <url>/2018/10/19/hihoCoder-1636/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/19/hihoCoder-1636/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>In Chinese mythology, Pangu is the first living being and the creator of the sky and the earth. He woke up from an egg and split the egg into two parts: the sky and the earth.</p><p>At the beginning, there was no mountain on the earth, only stones all over the land.</p><p>There were N piles of stones, numbered from 1 to N. Pangu wanted to merge all of them into one pile to build a great mountain. If the sum of stones of some piles was S, Pangu would need S seconds to pile them into one pile, and there would be S stones in the new pile. </p><p>Unfortunately, every time Pangu could only merge successive piles into one pile. And the number of piles he merged shouldn’t be less than L or greater than R.</p><p>Pangu wanted to finish this as soon as possible. </p><p>Can you help him? If there was no solution, you should answer ‘0’.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>There are multiple test cases.</p><p>The first line of each case contains three integers N,L,R as above mentioned (2&lt;=N&lt;=100,2&lt;=L&lt;=R&lt;=N).</p><p>The second line of each case contains N integers a1,a2 …aN (1&lt;= ai  &lt;=1000,i= 1…N ), indicating the number of stones of  pile 1, pile 2 …pile N.</p><p>The number of test cases is less than 110 and there are at most 5 test cases in which N &gt;= 50.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, you should output the minimum time(in seconds) Pangu had to take . If it was impossible for Pangu to do his job, you should output  0.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 2</span><br><span class="line">1 2 3</span><br><span class="line">3 2 3</span><br><span class="line">1 2 3</span><br><span class="line">4 3 3</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">6</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思就是给你三个数n，l，r，代表有n堆石子，之后一行有n个数，代表每堆石子的个数。每次只能把连续的l～r堆石子合并为1堆，若能最终把n堆石子合并为1堆，问最小花费是多少？不能合并为1堆则输出0。（l～r堆石子合并为1堆的花费是这些堆的石子数总和）</p><p>思路：</p><p>​    这是一道区间dp题，做的时候一直在研究如何限制合并的堆数为l～r，想破头皮想出来区间DP嵌套dfs的做法，结果超时了。。。最后从网上看了题解，发现自己想问题想复杂了。我们设sum【i】为前i堆石子的石子数和，dp【i】【j】【k】代表区间i～j的石子堆合并成k堆所需要的最小花费，初始化为INF，然后对于dp【i】【j】【i - j + 1】初始化为0，对于dp【i】【i + len - 1】【1】初始化为sum【i + len - 1】 - sum【i - 1】。</p><p>​    对于推导式，当k！=1时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j][k] = min(dp[i][j][k],dp[i][p][k - 1] + dp[p + 1][j][1]);//其中p属于【i，j)</span><br></pre></td></tr></table></figure><p>​    我们在k！=1时其实不需要限制l～r的合并，因为此时没有合并操作，只是i～p有k - 1堆石子，（p + 1） ～</p><p>r有1堆石子，那么i～j有k堆石子，取最小的即可。至于为什么是k - 1 和 1项加，因为遍历全部的p，就包含i～j的所有合并可能且不重复了。因此我们只需要考虑当k == 1时的合并问题</p><p>​    </p><p>​    对于推导式，当k == 1时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j][1] = min(dp[i][j][1], dp[i][p][len - 1] + dp[p + 1][j][1] + sum[j] - sum[i - 1]); //其中p属于【i，j), len属于【l，r】</span><br></pre></td></tr></table></figure><p>​    </p><p>​    因此，就可以用区间dp来求解，将酱～</p><p>代码；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define N 100</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d a[N + 5];                     //每堆石子数</span><br><span class="line">ll sum[N + 5];                  //前缀和</span><br><span class="line">ll dp[N + 5][N + 5][N + 5];     //dp[i][j][k]代表区间i～j能合并成k堆的最小花费</span><br><span class="line">d n, l, r;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">void init () &#123;</span><br><span class="line">    mem(sum);</span><br><span class="line">    memset(dp, INF, sizeof(dp));</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        sum[i] = a[i] + sum[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        For(j, i, n) &#123;</span><br><span class="line">            dp[i][j][j - i + 1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, l, r) &#123;</span><br><span class="line">        For(p, 1, n + 1 - i) &#123;</span><br><span class="line">            dp[p][p + i - 1][1] = sum[p + i - 1] - sum[p - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work () &#123;</span><br><span class="line">    For(len, 2, n) &#123;</span><br><span class="line">        For(i, 1, n - len + 1) &#123;</span><br><span class="line">            For(q, l, r) &#123;</span><br><span class="line">                For(p, i, i + len - 2) &#123;</span><br><span class="line">                    dp[i][i + len - 1][1] = min(dp[i][i + len - 1][1], dp[i][p][q - 1] + dp[p + 1][i + len - 1][1] + sum[i + len - 1] - sum[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            For(k, 2, len - 1) &#123;</span><br><span class="line">                For(p, i, i + len - 2) &#123;</span><br><span class="line">                    dp[i][i + len - 1][k] = min(dp[i][i + len - 1][k], dp[i][p][k - 1] + dp[p + 1][i + len - 1][1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;r) == 3) &#123;</span><br><span class="line">        init();</span><br><span class="line">        work();</span><br><span class="line">        if ((d)dp[1][n][1] == INF) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%lld\n&quot;, dp[1][n][1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM快速读写模版</title>
      <link href="/2018/10/18/ACM%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%A8%A1%E7%89%88/"/>
      <url>/2018/10/18/ACM%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/18/ACM快速读写模版/title.jpg" alt="title"></p><a id="more"></a><p>​    有必要整一个快速读写的模版了，万一就差几十ms给TLE了就嗝屁了～</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int num=0, w=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        w|=ch==&apos;-&apos;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return w? -num: num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速写</span><br><span class="line">inline void write(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&lt;0) &#123;</span><br><span class="line">        putchar(&apos;-&apos;);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x&gt;9) write(x / 10);</span><br><span class="line">    putchar(x % 10 + &apos;0&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t = read();     //读入到t中</span><br><span class="line">    write(t);       //输出t</span><br><span class="line">    putchar(&apos;\n&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVALive 8521组合数+dp</title>
      <link href="/2018/10/18/UVALive-8521/"/>
      <url>/2018/10/18/UVALive-8521/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/18/UVALive-8521/title6.jpg" alt="title6"></p><a id="more"></a><p>题意：</p><p><strong>problem description</strong></p><p>5 friends play LOL together . Every one should BAN one character and PICK one character . The enemy should BAN 5 characters and PICK 5 characters . All these 20 heroes must be different .</p><p>Every one can BAN any heroes by his personal washes . But he can only PICK heroes which he has bought .</p><p>Suppose the enemy can PICK or BAN any heroes. How many different ways are there satisfying the conditions?</p><p>For example , a valid way is :</p><p>Player 1 : picks hero 1, bans hero 2</p><p>Player 2 : picks hero 3, bans hero 4</p><p>Player 3 : picks hero 5, bans hero 6</p><p>Player 4 : picks hero 7, bans hero 8</p><p>Player 5 : picks hero 9, bans hero 10</p><p>Enemies pick heroes 11,12,13,14,15 , ban heroes 16,17,18,19,20 .</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains multiple test cases.(No more than 20)</p><p>In each test case . there’s 5 strings S[1]∼S[5] ,respectively whose lengths are 100 , For the i-th person if he has bought the j-th hero, the j-th character of S[i] is ‘1’, or ‘0’ if not. The total number of heroes is exactly 100 .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case , print the answer mod 1000000007 in a single line .</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0110011100011001001100011110001110001110001010010111111110101010010011010000110100011001001111101011</span><br><span class="line">1000111101111110110100001101001101010001111001001011110001111110101000011101000001011100001001011010</span><br><span class="line">0100101100011110011100110110011100111100010010011001111110101111111000000110001110000110001100001110</span><br><span class="line">1110010101010001000110100011101010001010000110001111111110101010000000001111001110110101110000010011</span><br><span class="line">1000010011111110001101100000101001110100011000111010011111110110111010011111010110101111011111011011</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">515649254</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思是LOL一共有100个英雄，十个人（每队5人）选英雄，每人可以选一个扳一个，问十个人有多少种不同的选扳方案（对答案取余1e9+7）。对面英雄全有，输入5个01串表示我方五个人分别拥有的英雄（1有0无）</p><p>注意点：1.每个人只能选自己拥有的英雄，任意两个人不能选或者扳同一个英雄。同一队伍的1，2，3，4，5召唤师选英雄1，2，3，4，5和选英雄5，4，3，2，1是不同的方案，而1，2，3，4，5召唤师扳英雄1，2，3，4，5和5，4，3，2，1是相同的方案</p><p>思路：</p><p>​    因为我们要求的是全部的方案数，所以我们不用管中间的过程（过程太复杂没法模拟），整体地看待总方案数为：我方选择的英雄方案数✖️敌人选择的英雄方案数✖️我方扳的英雄方案数✖️敌人扳的英雄方案数。</p><p>​    我们无论怎么选取5个英雄，那么敌人只能从剩下的95个中选5个，所以方案数是A（95，5），而我方扳的英雄方案数是C（90， 5），敌人扳的英雄方案数是C（85，5）。至于谁先谁后无所谓，因为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A(95,5) * C(90,5) * C(85,5) = C(95,5) * C(90,5) * A(85,5) = C(95,5) * A(85,5) * C(90,5)</span><br></pre></td></tr></table></figure><p>​    由于敌人选择的英雄方案数✖️我方扳的英雄方案数✖️敌人扳的英雄方案数的值是固定的，我们可以预处理出来，得到g，</p><p>​    因此我们只需要每次利用dp求解我方选择的英雄方案数，再乘g就能得到答案</p><p>​    关于dp求解我方选择的英雄方案数，我们可以设dp【i】【j】代表前j个英雄已经选了i个英雄的方案数，然后遍历每个成员，里层遍历每个英雄。为了避免重复，我们保证每个成员选的英雄都比上一个成员选的英雄下角标大（这样会导致方案数不全，因此我们需在最外层对成员下标进行全排列）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[8][150];</span><br><span class="line">d t[8][150];</span><br><span class="line">ll dp[8][150];</span><br><span class="line"></span><br><span class="line">//扩展欧几里得</span><br><span class="line">ll extend(ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b==0) r -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        r a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g = extend(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    r g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求逆元</span><br><span class="line">ll mod_re(ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll g = extend(a, n, x, y);</span><br><span class="line">    if(g == 1) r (x % n + n) % n;</span><br><span class="line">    r -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求A(95，5) * C(90, 5) * C(85, 5)的值</span><br><span class="line">ll init() &#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    For(i, 81, 95) &#123;</span><br><span class="line">        res = res * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 2, 5) &#123;</span><br><span class="line">        ll g = mod_re(i, mod);</span><br><span class="line">        res = res * g % mod * g % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求我方选择英雄的总类数</span><br><span class="line">ll work() &#123;</span><br><span class="line">    ll ans =0;</span><br><span class="line">    d inx[5] = &#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line">    do &#123;</span><br><span class="line">        mem(dp);</span><br><span class="line">        For(j, 0, 99) &#123;</span><br><span class="line">            dp[0][j] = dp[0][j - 1];</span><br><span class="line">            if(s[inx[0]][j] == &apos;1&apos;) &#123;</span><br><span class="line">                dp[0][j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 1, 4) &#123;</span><br><span class="line">            For(j, 0, 99) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - 1];</span><br><span class="line">                if(s[inx[i]][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + dp[4][99]) % mod;</span><br><span class="line">    &#125;while (next_permutation(inx, inx + 5));</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll g = init();</span><br><span class="line">    while (scanf(&quot;%s&quot;, s[0]) == 1) &#123;</span><br><span class="line">        For(i, 1, 4) &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = work();</span><br><span class="line">        printf(&quot;%lld\n&quot;, g * ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用命令（转）</title>
      <link href="/2018/10/18/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/18/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/18/Vim常用命令/title3.jpg" alt="title3"></p><a id="more"></a><p>作者：Bonnie-帮你<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/daocaoren1543169565/article/details/53114347" target="_blank" rel="noopener">https://blog.csdn.net/daocaoren1543169565/article/details/53114347</a> </p><p>感觉总结的特别好，万分感谢！！转了～</p><p>（一）初级个性化配置你的vim</p><p>1、vim是什么？</p><p>vim是Vi IMproved，是编辑器Vi的一个加强版，一个极其强大并符合IT工程师（程序员、运维）习惯的编辑器。如果你是一名职业的SE，那么一定在寻找一款出色的能够自由定制、满足灵活编辑功能的编辑器。那么答案，就是vim或者Emacs。而这一套连续的博文，就为您介绍vim编辑器。至于另一款强大的编辑器Emacs，我们会在今后的一个系列博文中看到。</p><p>2、配置文件在哪？</p><p>Windows系统的配置文件是vim安装目录下的vimrc文件。</p><p>Linux系统，RHEL和CentOS的配置文件是/etc/vimrc，Debian和Ubuntu的配置文件是/usr/share/vim/vimrc。</p><p>Mac OS X的配置文件是/usr/share/vim/vimrc。</p><p>3、vimRC中的RC是什么意思？</p><p>为什么把这么个没有意义的问题也列出来？原因很简单，就是我在接触vim之初第二个想问的问题就是这个（第一个就是上面的“1”）。一般在运行某个软件、环境或工具之初，要初始执行的一些命令，称为Run Commands，即RC。根据Wikipedia.org的记载，RC缩写的用法源自MIT的相容分时操作系统（Compatible Time-Sharing System，CTSS）[参考1]。所以以后如果你看到了SystemRC或者ScreenRC，也就知其缘由了。</p><p>4、三种基本模式</p><p>在《大家来学vim》中提到vim有6+5种模式，但除了细分程度不同外，实际上常用的只有3种模式：Normal Mode、Insert Mode和Command-line Mode。</p><p>从Normal Mode进入Insert Mode，可以按i、I、a、A、o、O、r、R即可。其中i和I表示插入（Insert），r和R表示替换（replace）。</p><p>从Insert Mode进入Normal Mode，只需要按ESC键即可。</p><p>从Normal Mode进入Command-line Mode，可以按“:”、“/”、“?”。其中“:”表示输入vim命令，“/”表示后面输入要向下搜索的字符串，“?”表示后面输入要向上搜索字符串。</p><p>从Command-line Mode进入Normal Mode，只需要按ESC键即可了。</p><p>你可以把Normal Mode理解为常态，进入其他任何一种模式，需要某种特殊方式，而从其他特殊模式回到Normal Mode，就按ESC键即可。</p><p>5、vim中那些最最常用的配置</p><p>当你尝试去Google一些其他人的vimrc配置时，你一定会找到一篇叫做《The ultimate vim configuration》的文章，不过它的作者，Amix后来在他的博客上提到[参考2]，这份在google搜索vimrc会排在前十的vim配置文件，如今已经过时了，所以他提供了一些更新信息。</p><p>（1）颜色设置</p><pre><code>syntax on       &quot;开启代码高亮syntax off      &quot;关闭代码高亮syntax enable   &quot;开启代码高亮</code></pre><p>（2）搜索设置</p><pre><code>set hlsearch    &quot;开启搜索高亮set nohlsearch  &quot;关闭搜索高亮set incsearch   &quot;输入搜索字符串的同时进行搜索set ignorecase  &quot;搜索时忽略大小写</code></pre><p>（3）用户界面</p><pre><code>set showmode        &quot;开启模式显示set ruler           &quot;开启光标位置提示set number      &quot;显示行号set nonu            &quot;不显示行号set cursorline      &quot;强调光标所在行set cmdheight=1 &quot;命令部分高度为1</code></pre><p>（4）编辑辅助配置</p><pre><code>set autoindent      &quot;自动缩进set noautoindent    &quot;不自动缩进set smartindent     &quot;智能缩进set autoread        &quot;当文件在外部被改变时，vim自动更新载入set showmatch       &quot;显示匹配的括号</code></pre><p>参考：</p><pre><code>Run Commands，http://en.wikipedia.org/wiki/Run_commandsThe Ultimate vim Configuration(vimRC)，http://amix.dk/blog/post/19486</code></pre><p>（二）常用的状态切换按键</p><p>1、Normal Mode -&gt; Insert Mode</p><p>i 小写字母i，在光标位置插入<br>a 小写字母a，在光标的下一个位置插入<br>I 大写字母I，在光标所在行的第一个非空格处插入<br>A 大写字母A，在光标所在行的最后一个字符处插入<br>o 小写字母o，在光标所在行的下一行处插入新行<br>O 大写字母O，在光标所在行的上一行处插入新航<br>r 小写字母r，替换光标所在处的字符一次<br>R 大写字母R，持续替换光标所在处的字符，直到按下ESC</p><p>2、Normal Mode -&gt; Command-line Mode</p><p>:w 保存文件<br>:w! 强制保存文件（前提是用户有修改文件访问权限的权限）<br>:q 退出缓冲区<br>:q! 强制退出缓冲区而不保存<br>:wq 保存文件并退出缓冲区<br>:wq! 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限）</p><p>:w 另存为名为filename文件<br>:n1,n2 w 将n1行到n2行的数据另存为名为filename文件<br>:x 如果文件有更改，则保存后退出。否则直接退出。</p><p>3、Insert Mode -&gt; Normal Mode</p><p>按下ESC键</p><p>4、Command-line -&gt; Normal Mode</p><p>按下ESC键</p><p>（三）常用光标移动按键</p><p>1、光标字符操作</p><pre><code>j 向下k 向上h 向左l 向右$ 光标移动到行尾（End），注意要按Shift键0 光标移动到行首（Home）^ 光标移动到行首第一个非空白字符（Home），注意要按Shift键</code></pre><p>2、光标词操作</p><pre><code>w 光标移动到后一词的词首W 光标移动到后一词的词首且忽略标点符号e 光标移动到后一词的词尾E 光标移动到后一词的词尾且忽略标点符号b 光标移动到前一词的词首B 光标移动到前一词的词首且忽略标点符号</code></pre><p>3、光标句操作</p><pre><code>) 光标移动到后一句的句首( 光标移动到前一句的句首% 配合“(”和“)”使用，寻找相匹配的另一半</code></pre><p>4、光标行操作</p><pre><code>G 光标移动到文档的最后一行的第一个非空白字符nG 光标移动到文档的第n行，相当于”:n”gg 光标移动到文档的第1行的第一个非空白字符，相当于”1G”，也相当于”:1″光标向下移动N行</code></pre><p>5、光标段操作</p><pre><code>} 光标移动到下一段的段首{ 光标移动到上一段的段首% 配合“(”和“)”使用，寻找相匹配的另一半</code></pre><p>6、光标页操作</p><pre><code>Ctrl+f 向下翻页（Pagedown）Ctrl+b 向上翻页（Pageup）Ctrl+d 向下翻半页Ctrl+u 向上翻半页H 光标移动到目前显示页的第一行M 光标移动到目前显示页的中间行L 光标移动到目前显示页的最后一行</code></pre><p>7、光标自由操作</p><pre><code>Ctrl+o 回到光标的上一位置</code></pre><p>（四）常用编辑操作按键</p><p>1、删除操作（delete）</p><pre><code>dd 删除光标所在行ndd 删除从光标所在行开始，向下的n行d1G 删除从光标所在行开始，到第一行的所有行dG 删除从光标所在行开始，到最后一行的所有行d$ 删除从光标所在位置，到行尾的所有字符d0 删除从光标所在位置，到行首的所有字符</code></pre><p>2、复制操作（yank）</p><pre><code>yy 复制光标所在行nyy 复制从光标所在行开始，向下的n行y1G 复制从光标所在行开始，到第一行的所有行yG 复制从光标所在行开始，到最后一行的所有行y$ 复制从光标所在位置，到行尾的所有字符y0 复制从光标所在位置，到行首的所有字符</code></pre><p>3、粘贴操作（paste）</p><pre><code>p 小写字母p，粘贴剪贴板中的数据，从光标所在行的下一行开始P 大写字母P，粘贴剪贴板中的数据，从光标所在行的上一行开始</code></pre><p>4、撤销与重做操作（undo，redo）</p><pre><code>u （Undo）撤销上一个操作Ctrl+r （Redo）重做上一个操作</code></pre><p>5、重复操作</p><pre><code>. 重复上一操作</code></pre><p>6、替换操作（replace）</p><pre><code>r 替换光标所在处字符R 进入替换模式，直至按ESC退出cc 替换光标所在行cw 替换光标所在的英文单词~ 转换大小写</code></pre><p>7、排版操作</p><pre><code>:le 光标所在行左对齐:ri 光标所在行右对齐:ce 光标所在行居中</code></pre><p>（五）常用多缓冲区操作按键</p><p>1、多文件编辑模式</p><pre><code>argument list模式，就是在打开vim编辑器时，携带多个文件路径参数。buffer list模式，就是在进入vim编辑器后，打开多个缓冲区进行编辑。</code></pre><p>2、单一缓冲区打开多个文件</p><pre><code>:files 显示目前打开了哪些文件:n 切换到下一个缓冲区内容:N 切换到上一个缓冲区内容:2n 切换到下下个缓冲区内容:bn 下一个缓冲区内容（buffer next）:bp 上一个缓冲区内容（buffer previous）</code></pre><p>3、多个缓冲区打开多个文件</p><pre><code>:sp [filename] 打开一个新的缓冲区，如果有filename则内容为该文件，否则为当前文件Ctrl+w n 新建一个缓冲区Ctrl+w q 退出光标所在的缓冲区Ctrl+w j 光标移动到下一缓冲区Ctrl+w k 光标移动到上一缓冲区Ctrl+w l 光标移动到右一缓冲区Ctrl+w h 光标移动到左一缓冲区Ctrl+w v 左右切割窗口新建缓冲区Ctrl+w s 上下切割窗口新建缓冲区Ctrl+w o 使光标所在缓冲区最大化，其他缓冲区隐藏</code></pre><p>（六）常用搜索与书签操作快捷键</p><ol><li>搜索字符串</li></ol><p>/string 向下搜索字符串“string”?string 向上搜索字符串“string”</p><ol start="2"><li>重复上次搜索</li></ol><p>n 根据上次搜索条件找到下一个匹配的字符串N 根据上次搜索条件找到上一个匹配的字符串</p><ol start="3"><li>搜索单词</li></ol><ul><li>向下搜索光标所在处的单词（完全匹配）# 向上搜索光标所在处的单词（完全匹配）g* 向下搜索光标所在处的单词（部分匹配）g# 向上搜索光标所在处的单词（部分匹配）</li></ul><ol start="4"><li>标记书签（mark）</li></ol><p>ma a为小写字母，为光标所在处设定文档书签amA A为大写字母，为光标所在处设定全局书签A</p><ol start="5"><li>使用书签（mark）</li></ol><p><code>a 到文档书签a处，Tab键上方&#39;a 到文档书签a所在行行首处，Enter键左边</code>A 到全局书签A处，Tab键上方’A 到全局书签A所在行行首处，Enter键左边`n 如果n=0，缓冲区将打开上一次的文档，且光标在上次编辑最后的位置，1-9以此类推’n 如果n=0，缓冲区将打开上一次的文档，且光标在上次编辑最后的位置所在行的行首，1-9以此类推</p><ol start="6"><li>查看书签列表</li></ol><p>:marks 查看当前所有书签</p><p>（7）关于加密</p><p>1、加密你的文本文件</p><p>当你用vim打开或新建一个文件时，如果加上-x参数，即：</p><p>vim -x filename</p><p>那么vim会提示你：</p><p>Enter entryption key:</p><p>当你输入了密码后，vim会提示你重复输入以确认：</p><p>Enter same key again:</p><p>你在设置密码的时候，是以*来显示的，非明文。当下次有人（包括你自己）打开该文件的时候，vim就会提示：</p><p>Need encryption key for “main.cpp”<br>Enter encryption key:</p><p>这时你只要输入你之前所设置的密码就可以了。如果你输入的密码是错误的，vim并不会提示你密码错误，而是显示一堆无意义的垃圾代码。</p><p>2、解除加密与重设密码</p><p>打开你已经加密的文件，然后输入：</p><p>:set key=</p><p>这样，你的密码就被设置为空了，今后进入就不再需要输入密码了。而如果你向重设密码的话，你可以输入：</p><p>:X</p><p>注意是个大写字母X。这时vim会提示你，只要反复输入两次新的密码就可以了：</p><p>Enter entryption key: <strong>*</strong><br>Enter sanme key again: <strong>*</strong></p><p>3、加密引起的问题</p><p>vim的加密功能，可以说是问题一大堆。比如：</p><p>（1）如果密码输入错误，vim不会拒绝访问者编辑文件。在这种显示乱码的情况下编辑文件并保存，整个文件就会变得混乱不堪，无法辨识。今后即使使用正确的密码打开文件，也看不到正确的文档了。</p><p>（2）如果对一个需要编译的源代码文件进行了加密，则无法通过编译器的语法检查。</p><p>（3）交换文件是无法加密的。这样引起什么问题？问题就是如果其他用户想办法读取到了你的交换文件，就可以绕过解密环节，你的加密也就无意义了。解决的办法就是，不使用交换文件。方法有三个，一是修改你的vimrc文件（vim配置文件）：</p><p>set noswapfile</p><p>二是在用vim打开文件之初就输入命令：</p><p>vim -x -n filename</p><p>（注意-x是加密参数，与我们所说的swap没有关系，不要搞混）</p><p>三是在进入vim编辑该文件后，输入：</p><p>:setlocal noswapfile</p><p>不过不使用交换文件的坏处就是，你可能会面临数据丢失而无法找回的悲剧。所以又想用加密，又想不丢失文件的朋友们，就勤按“:w”吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1632模拟</title>
      <link href="/2018/10/17/hihoCoder-1632/"/>
      <url>/2018/10/17/hihoCoder-1632/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/17/hihoCoder-1632/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>The Yongzheng Emperor (13 December 1678 – 8 October 1735), was the fifth emperor of the Qing dynasty of China. He was a very hard-working ruler. He cracked down on corruption and his reign was known for being despotic, efficient, and vigorous.</p><p>Yongzheng couldn’t tolerate people saying bad words about Qing or him. So he started a movement called “words prison”. “Words prison” means literary inquisition. In the famous Zhuang Tinglong Case, more than 70 people were executed in three years because of the publication of an unauthorized history of the Ming dynasty.</p><p>In short, people under Yongzheng’s reign should be very careful if they wanted to write something. So some poets wrote poems in a very odd way that only people in their friends circle could read. This kind of poems were called secret poems.</p><p>A secret poem is a N×N matrix of characters which looks like random and meaning nothing. But if you read the characters in a certain order, you will understand it. The order is shown in figure 1 below:</p><p><img src="/2018/10/17/hihoCoder-1632/1.jpg" alt="1"></p><p>​            figure 1                                                                               figure 2</p><p>Following the order indicated by arrows, you can get “THISISAVERYGOODPOEMITHINK”, and that can mean something.</p><p>But after some time, poets found out that some Yongzheng’s secret agent called “Mr. blood dripping” could read this kind of poems too. That was dangerous. So they introduced a new order of writing poems as shown in figure 2. And they wanted to convert the old poems written in old order as figure1 into the ones in new order. Please help them.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>There are no more than 10 test cases.</p><p>For each test case:</p><p>The first line is an integer N( 1 &lt;= N &lt;= 100), indicating that a poem is a N×N matrix which consist of capital letters.</p><p>Then N lines follow, each line is an N letters string. These N lines represent a poem in old order.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, convert the poem in old order into a poem in new order.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">THSAD </span><br><span class="line">IIVOP </span><br><span class="line">SEOOH </span><br><span class="line">RGETI </span><br><span class="line">YMINK</span><br><span class="line">2</span><br><span class="line">AB</span><br><span class="line">CD</span><br><span class="line">4</span><br><span class="line">ABCD</span><br><span class="line">EFGH</span><br><span class="line">IJKL</span><br><span class="line">MNOP</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THISI</span><br><span class="line">POEMS</span><br><span class="line">DNKIA</span><br><span class="line">OIHTV</span><br><span class="line">OGYRE</span><br><span class="line">AB</span><br><span class="line">DC</span><br><span class="line">ABEI</span><br><span class="line">KHLF</span><br><span class="line">NPOC</span><br><span class="line">MJGD</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概是将一串字符按图一的规律排列，让你输出将这串字符按图二的规律排列并输出。</p><p>思路：</p><p>​    没啥别的，暴力大模拟就完了。。。不过暴力一定要优雅和简练！！比如我哈哈哈～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, star, endd) for(d i = star; i &gt;= endd; i--)</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s1[105][105], s2[105][105], s3[105][105];</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d n;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        mem(s2);</span><br><span class="line">        mem(s3);</span><br><span class="line">        For(i, 0, n - 1) &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, s1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        For(i, 0, 2 * n - 2) &#123;</span><br><span class="line">            if (i &amp; 1) &#123;</span><br><span class="line">                For(j, 0, i) &#123;</span><br><span class="line">                    if (i - j &gt; n - 1 || j &gt; n - 1) continue;</span><br><span class="line">                    s2[tot / n][tot % n] = s1[j][i - j];</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Forr(j, i, 0) &#123;</span><br><span class="line">                    if (i - j &gt; n - 1 || j &gt; n - 1) continue;</span><br><span class="line">                    s2[tot / n][tot % n] = s1[j][i - j];</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = 0;</span><br><span class="line">        for (int i = n; i &gt;= 1; i -= 2) &#123;</span><br><span class="line">            for (int j = (n - i) / 2; j &lt;= n - 2 - (n - i) / 2; j++) &#123;</span><br><span class="line">                s3[(n - i) / 2][j] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = (n - i) / 2; j &lt;= n - 2 - (n - i) / 2; j++) &#123;</span><br><span class="line">                s3[j][n - 1 - (n - i) / 2] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = n - 1 - (n - i) / 2; j &gt;= (n - i) / 2 + 1; j--) &#123;</span><br><span class="line">                s3[n - 1 - (n - i) / 2][j] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = n - 1 - (n - i) / 2; j &gt;= (n - i) / 2 + 1; j--) &#123;</span><br><span class="line">                s3[j][(n - i) / 2] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &amp; 1) &#123;</span><br><span class="line">            s3[n / 2][n / 2] = s2[n - 1][n - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 0, n - 1) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, s3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 大模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1631模拟</title>
      <link href="/2018/10/17/hihoCoder-1631/"/>
      <url>/2018/10/17/hihoCoder-1631/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/17/hihoCoder-1631/title7.jpg" alt="title7"></p><a id="more"></a><p>题意：</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>There are many homeless cats in PKU campus. They are all happy because the students in the cat club of PKU take good care of them. Li lei is one of the members of the cat club. He loves those cats very much. Last week, he won a scholarship and he wanted to share his pleasure with cats. So he bought some really tasty fish to feed them, and watched them eating with great pleasure. At the same time, he found an interesting question:</p><p>There are m fish and n cats, and it takes ci minutes for the ith cat to eat out one fish. A cat starts to eat another fish (if it can get one) immediately after it has finished one fish. A cat never shares its fish with other cats. When there are not enough fish left, the cat which eats quicker has higher priority to get a fish than the cat which eats slower. All cats start eating at the same time. Li Lei wanted to know, after x minutes, how many fish would be left.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>There are no more than 20 test cases.</p><p>For each test case:</p><p>The first line contains 3 integers: above mentioned m, n and x (0 &lt; m &lt;= 5000, 1 &lt;= n &lt;= 100, 0 &lt;= x &lt;= 1000).</p><p>The second line contains n integers c1,c2 … cn,  ci means that it takes the ith cat ci minutes to eat out a fish ( 1&lt;= ci &lt;= 2000).</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, print 2 integers p and q, meaning that there are p complete fish(whole fish) and q incomplete fish left after x minutes.</p><p>样例输入</p><p>2 1 1</p><p>1</p><p>8 3 5</p><p>1 3 4</p><p>4 5 1</p><p>5 4 3 2 1</p><p>样例输出</p><p>1 0</p><p>0 1</p><p>0 3</p><p>​    翻译成汉语就是给m条鱼，n只猫，每只猫吃鱼的速度为c[i]。问x秒后有多少条鱼没被吃，多少条鱼没吃完？（同一秒吃的快的猫先拿鱼吃）</p><p>思路：</p><p>​    用两个数m代表剩余鱼数，mm代表n-完全吃光的鱼数，两数都初始化为n。先把猫吃鱼的速度排个序，开一个book数组记录一下每个猫的状态（0时代表需要拿一个鱼，1时代表正在吃鱼），我们初始化为0。然后遍历x秒，每秒从快-&gt;慢的猫进行遍历。若状态为0则m–，并把状态更改为1。若时间正好时该鱼速度的倍数，那么mm–，然后把状态更新为0。最后注意当m为0的时候跳出，再注意一下特判就可以啦。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d a[105];</span><br><span class="line">d book[105];</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d m, n, x;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;x) == 3) &#123;</span><br><span class="line">        d mm = m;</span><br><span class="line">        mem(book);</span><br><span class="line">        For(i, 1, n) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + 1, a + n + 1);</span><br><span class="line">        For(i, 1, x) &#123;</span><br><span class="line">            d flag = 0;</span><br><span class="line">            For(j, 1, n) &#123;</span><br><span class="line">                if (!book[j]) &#123;</span><br><span class="line">                    book[j] = 1;</span><br><span class="line">                    m--;</span><br><span class="line">                    if(m == 0) &#123;</span><br><span class="line">                        if(i % a[j] == 0) &#123;//需要特判m为0的时候是否i%a[j] == 0</span><br><span class="line">                            mm --;</span><br><span class="line">                            book[j] = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i % a[j] == 0) &#123;</span><br><span class="line">                    mm --;</span><br><span class="line">                    book[j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;, m, mm - m);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6237思维</title>
      <link href="/2018/10/17/HDU6237/"/>
      <url>/2018/10/17/HDU6237/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/17/HDU6237/title1.jpg" alt="title1"></p><a id="more"></a><p>​    这是2017年ccpc哈尔滨站的一道数论题，很荣幸在我们学校举办，题目另辟蹊径，很好的一道素数题。</p><p>题意：</p><p>Problem Description</p><p>After he has learned how to play Nim game, Bob begins to try another stone game which seems much easier.</p><p>The game goes like this: one player starts the game with N piles of stones. There is ai stones on the ith pile. On one turn, the player can move exactly one stone from one pile to another pile. After one turn, if there exits a number x(x&gt;1) such that for each pile bi is the multiple of x where bi is the number of stone of the this pile now), the game will stop. Now you need to help Bob to calculate the minimum turns he need to stop this boring game. You can regard that 0 is the multiple of any positive number.</p><p>Input</p><p>The first line is the number of test cases. For each test case, the first line contains one positive number N(1≤N≤100000), indicating the number of piles of stones.</p><p>The second line contains N positive number, the ith number ai(1≤ai≤100000) indicating the number of stones of the ith pile.</p><p>The sum of N of all test cases is not exceed 5∗105.</p><p>Output</p><p>For each test case, output a integer donating the answer as described above. If there exist a satisfied number x initially, you just need to output 0. It’s guaranteed that there exists at least one solution. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2</span><br><span class="line">5 7</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思就是给你一个T代表有T组样例，然后每组样例第一行给出一个n代表有n堆石子，然后分别输入每堆石子的石子数。只能从一堆石子中取一个石子移动到另一堆，问至少移动几次能使得每一堆的石子数的公共gcd &gt; 1（若此时已经gcd&gt;1了就输出0，一堆石子允许全部移光）</p><p>​    </p><p>思路：</p><p>​    我们求出所有堆石子的总和sum，然后筛选出它的全部素因子。也就是说，要想让每堆石子的公共gcd大于1，至少其中一个素因子是全部石子堆的因子。因此我们需要遍历每个素因子，分别求出每堆石子数变成该素因子的倍数所需的最小步数，取个最小值就是答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d T, n;</span><br><span class="line">d a[N + 5];</span><br><span class="line">d b[N + 5];</span><br><span class="line">ll prime[105];</span><br><span class="line">bool book[N + 5];</span><br><span class="line">ll prime1[N + 5];</span><br><span class="line"></span><br><span class="line">//筛1e5以内素数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    prime1[0] = 0;</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime1[++prime1[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime1[0]) &#123;</span><br><span class="line">            ll t = prime1[j] * i;</span><br><span class="line">            if (t &gt; N) break;</span><br><span class="line">            book[t] = 1;</span><br><span class="line">            if (i % prime1[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//筛选出t的全部素因子</span><br><span class="line">void su(ll t) &#123;</span><br><span class="line">    prime[0] = 0;</span><br><span class="line">    for (d i = 1; i &lt;= prime1[0]; i ++) &#123;</span><br><span class="line">        if (t % prime1[i] == 0) &#123;</span><br><span class="line">            prime[++prime[0]] = prime1[i];</span><br><span class="line">            while (t % prime1[i] == 0) &#123;</span><br><span class="line">                t /= prime1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (t == 1) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (t != 1) &#123;</span><br><span class="line">        prime[++prime[0]] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从大到小排列</span><br><span class="line">bool cmp (d A, d B) &#123;</span><br><span class="line">    r A &gt; B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求每堆素因子为t的倍数时的最小移动次数</span><br><span class="line">ll Num(ll t) &#123;</span><br><span class="line">    ll sum = 0, ans = 0;</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        b[i] = a[i] % t;</span><br><span class="line">        sum += b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + 1, b + n + 1, cmp);</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        if (b[i] == 0) break;</span><br><span class="line">        ans += t - b[i];</span><br><span class="line">        sum -= t;</span><br><span class="line">        if (sum == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历全部素因子，取最小次数</span><br><span class="line">ll work() &#123;</span><br><span class="line">    ll minn = 99999999999;</span><br><span class="line">    For(i, 1, prime[0]) &#123;</span><br><span class="line">        minn = min(minn, Num(prime[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    r minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        ll sum = 0;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        For(i, 1, n) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        su(sum);</span><br><span class="line">        ll ans = work();</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces-1047C思维</title>
      <link href="/2018/10/16/CodeForces-1047C/"/>
      <url>/2018/10/16/CodeForces-1047C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/16/CodeForces-1047C/title5.jpg" alt="title5"></p><a id="more"></a><p>题意：</p><p>​    Mr. F has nn positive integers, a1,a2,…,an.</p><p>​    He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.</p><p>​    But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.</p><p>​    Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.</p><p>Input:</p><p>​    The first line contains an integer nn (2≤n≤3⋅10^5) — the number of integers Mr. F has.</p><p>​    The second line contains nn integers, a1,a2,…,an (1≤ai≤1.5⋅10^7).</p><p>Output:</p><p>​    Print an integer — the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.</p><p>​    You should not remove all of the integers.</p><p>​    If there is no solution, print «-1» (without quotes).</p><p>Examples</p><p>Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 4</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6 9 15 30</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>Note</p><p>In the first example, the greatest common divisor is 1 in the beginning. You can remove 1 so that the greatest common divisor is enlarged to 2. The answer is 1.</p><p>In the second example, the greatest common divisor is 3 in the beginning. You can remove 6 and 9 so that the greatest common divisor is enlarged to 15. There is no solution which removes only one integer. So the answer is 2.</p><p>In the third example, there is no solution to enlarge the greatest common divisor. So the answer is −1.</p><p>​    翻译成汉语就是给你n个数，你会得到这n个数的公共gcd，问最少删除几个数，使得删除后的公共gcd比原来的大，如果有输出最少删除数，没有输出-1</p><p>思路：</p><p>​    我们知道，一个数val可以写成p1^a1 ✖️p2^a2✖️ …✖️pn^an的形式，若每个数中都存在pk1，pk2，且pk1在每个数中最少存在t1次，pk2在每个数中最少存在t2次，那么这n个数的公共gcd为pk1^t1✖️pk2^t2</p><p>​    因此，我们想要提高公共gcd的大小，有以下两种办法：</p><p>​    1.对于每个数都存在的素因子，我们去除它最小的幂次方数，如2, 4, 12，它们中都存在素因子2，2中存在1个素因子2，4中存在2个素因子2，12中存在2个素因子2，因此我们只要去掉最小的幂次方的次数，也就是1个素因子2的2，就可以使得gcd变大</p><p>​    2.对于不是每个数都存在的素因子，我们只要去掉存在改素因子的数，就可以使得gcd变大</p><p>​    对于以上两种情况，我们记录一个最小值即可，若最后需要去除n个或者没办法去除，那么就输出-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 15000000</span><br><span class="line">#define NN 1000000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d book[N + 5];      //book[i]存i的最小素因子在prime中的下角标</span><br><span class="line">d prime[NN + 5];    //存全部素数</span><br><span class="line">d num[NN + 5];      //存该素数在几个数中出现(若个数等于n取答案与numminx[i]的最小值 小于n取答案与n-num[i]的最小值）</span><br><span class="line">d minx[NN + 5];     //该素数在n个数中若出现，存在其中一个数中出现的次数的最小值</span><br><span class="line">d numminx[NN + 5];  //该素数在n个数中若出现且是最小值的个数</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(num);</span><br><span class="line">    memset(minx, 0x3f3f3f3f, sizeof(minx));</span><br><span class="line">    mem(numminx);</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            book[i] = prime[0];</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime[0]) &#123;</span><br><span class="line">            if (prime[j] * i &gt; N) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            book[i * prime[j]] = j;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work(d a) &#123;</span><br><span class="line">    while(a != 1) &#123;</span><br><span class="line">        d aa = a;</span><br><span class="line">        d t = prime[book[a]], inx = 0;</span><br><span class="line">        num[book[a]]++;</span><br><span class="line">        while (a % t == 0) &#123;</span><br><span class="line">            inx ++;</span><br><span class="line">            a /= t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (inx &lt; minx[book[aa]]) &#123;</span><br><span class="line">            minx[book[aa]] = inx;</span><br><span class="line">            numminx[book[aa]] = 1;</span><br><span class="line">        &#125; else if (inx == minx[book[aa]]) &#123;</span><br><span class="line">            numminx[book[aa]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    d n, a;</span><br><span class="line">    d minn = 0x3f3f3f3f;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        work(a);</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, prime[0]) &#123;</span><br><span class="line">        if(!num[i]) continue;</span><br><span class="line">        if (num[i] == n) &#123;</span><br><span class="line">            minn = min(numminx[i], minn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = min(n - num[i], minn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (minn == 0x3f3f3f3f || minn == 0 || minn == n) printf(&quot;-1\n&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;, minn);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-048快速乘</title>
      <link href="/2018/10/16/Project-Euler-048/"/>
      <url>/2018/10/16/Project-Euler-048/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/16/Project-Euler-048/title.jpg" alt="title"></p><a id="more"></a><h3 id="048题："><a href="#048题：" class="headerlink" title="048题："></a>048题：</h3><p>题意：</p><p>​    十项的自幂级数求和为 1^1 + 2^2 + 3^3 + … + 10^10 = 10405071317。</p><p>​    求如下一千项的自幂级数求和的最后10位数字：1^1 + 2^2 + 3^3 + … + 1000^1000</p><p>思路：</p><p>​    设mod为1e10，根据同余定理，我们可以利用快速幂求i^i关于mod的模。但是有一个问题，就是快速幂中存在两数先相乘再取余mod的过程，可能两数在相乘时就爆long long了。因此，我们可以通过一个小技巧来防治爆long long。</p><p>​    对于a * b % mod，我们设k为1e5，那么一定存在a = ik + j，b = pk + q （其中i = a / k，j = a % k，p = b / k，q = b % k）</p><p>​    把a和b带入原式，得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a * b % mod = (ik + j) * (pk + q) % mod</span><br><span class="line">= (ipk^2 + iqk + jpk + jq) % mod</span><br></pre></td></tr></table></figure><p>​    由于ipk^2,iqk,jpk,jq都在longlong范围内，因此解决了爆longlong问题</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define t (ll)1e5</span><br><span class="line">#define mod (ll)1e10</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line"></span><br><span class="line">//乘法防爆longlong</span><br><span class="line">ll mul (ll a, ll b) &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    ll i = a / t;</span><br><span class="line">    ll j = a % t;</span><br><span class="line">    ll p = b / t;</span><br><span class="line">    ll q = b % t;</span><br><span class="line">    ans = (i * p % mod * t % mod *t % mod + i * q % mod * t % mod + j * p % mod * t % mod + j * q % mod) % mod;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速幂</span><br><span class="line">ll quick(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans = mul(ans, a);</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//循环球i^i</span><br><span class="line">ll work() &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    For(i, 1, 1000) &#123;</span><br><span class="line">        ans = (ans + quick(i, i)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main()</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = work();</span><br><span class="line">    printf(&quot;%&quot; PRId64 &quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：<strong>9110846700</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6228求边的左右节点数</title>
      <link href="/2018/10/15/HDU6228/"/>
      <url>/2018/10/15/HDU6228/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/15/HDU6228/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Problem Description</p><p>Consider a un-rooted tree T which is not the biological significance of tree or plant, but a tree as an undirected graph in graph theory with n nodes, labelled from 1 to n. If you cannot understand the concept of a tree here, please omit this problem.<br>Now we decide to colour its nodes with k distinct colours, labelled from 1 to k. Then for each colour i = 1, 2, · · · , k, define Ei as the minimum subset of edges connecting all nodes coloured by i. If there is no node of the tree coloured by a specified colour i, Ei will be empty.<br>Try to decide a colour scheme to maximize the size of E1 ∩ E2 · · · ∩ Ek, and output its size.</p><p>Input</p><p>The first line of input contains an integer T (1 ≤ T ≤ 1000), indicating the total number of test cases.<br>For each case, the first line contains two positive integers n which is the size of the tree and k (k ≤ 500) which is the number of colours. Each of the following n - 1 lines contains two integers x and y describing an edge between them. We are sure that the given graph is a tree.<br>The summation of n in input is smaller than or equal to 200000.</p><p>Output</p><p>For each test case, output the maximum size of E1 ∩ E1 … ∩ Ek.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">6 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">6 2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概意思就是有一颗树，在树上的点涂色，每个点涂一种颜色，一共可以涂k种颜色，然后你需要把每种颜色的点按最短路径用该种颜色连起来，问涂k次的边最多有几条？</p><p>​    第一行输入的是T代表有T组样例，每组样例第一行为n，k，分别代表树上有n个节点，可用k种颜色给节点涂色。之后n-1行a,b代表节点a到节点b之间有一条边</p><p>思路：</p><p>​    我们可以把树转化为图，对于每个边进行dfs（利用记忆化搜索），分别求出该边左边和右边的节点数，只要都大于等于k就可以累加，累加和就是答案。时间复杂度，大概也就O(n)吧，因为记忆化搜索dfs多也多不多少。。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    d left, right;</span><br><span class="line">&#125;bian[200005];</span><br><span class="line">d num[200005][2];         //num[i][0]存储第i个边左边的节点数，num[i][1]存储第i个边右边的节点数</span><br><span class="line">vector&lt;int&gt;zcy[200005];     //zcy[i]存储以i点为端点的边的编号,zcy[i].size()即为边的个数</span><br><span class="line"></span><br><span class="line">//利用dfs+记忆化搜索求编号为now的边的chooes（0为左，1为右）的节点数</span><br><span class="line">int dfs(int now, int chooes) &#123;</span><br><span class="line">    if(num[now][chooes]) return num[now][chooes];       //记忆化搜索</span><br><span class="line">    int ans = 1, t;</span><br><span class="line">    if (chooes == 0) &#123;</span><br><span class="line">        t = bian[now].left;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t = bian[now].right;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; zcy[t].size(); i++) &#123;</span><br><span class="line">        int next = zcy[t][i];</span><br><span class="line">        if (bian[next].left == bian[now].left &amp;&amp; bian[next].right == bian[now].right) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bian[next].left == t) &#123;</span><br><span class="line">            if (num[next][1]) &#123;          //记忆化搜索</span><br><span class="line">                ans += num[next][1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans += dfs(next, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (num[next][0]) &#123;          //记忆化搜索</span><br><span class="line">                ans += num[next][0];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans += dfs(next, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num[now][chooes] = ans;              //记录中间状态</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, k;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">        memset(num, 0, sizeof(num));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;bian[i].left, &amp;bian[i].right);</span><br><span class="line">            zcy[bian[i].left].push_back(i);</span><br><span class="line">            zcy[bian[i].right].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(i, 0);    //每个边两个dfs，分别求左边和右边（由于有记忆化搜索，所以可以不用右边=节点数-左边）</span><br><span class="line">            dfs(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (num[i][0] &gt;= k &amp;&amp; num[i][1] &gt;= k) ans++;        //此时满足条件</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-021线性求约数和</title>
      <link href="/2018/10/15/Project-Euler-021/"/>
      <url>/2018/10/15/Project-Euler-021/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/15/Project-Euler-021/title3.jpg" alt="title3"></p><a id="more"></a><h3 id="021题："><a href="#021题：" class="headerlink" title="021题："></a>021题：</h3><p>题意：</p><p>​    记d(n)为n的所有真因数（小于n且整除n的正整数）之和<br>​    如果d(a) = b且d(b) = a，且a ≠ b，那么a和b构成一个亲和数对，a和b被称为亲和数</p><p>​    例如，220的真因数包括1、2、4、5、10、11、20、22、44、55和100，因此d(220) = 284；而284的真因数包括1、2、4、71和142，因此d(284) = 220</p><p>​    求所有小于10000的亲和数的和</p><p>思路：</p><p>​    在数论中我们称d(n)这样的函数为约数和函数。具体有以下几个性质：</p><p>​    1.约数和函数为积性函数，因此满足任意两个互质的数a，b，都有d(a✖️b) = d(a) ✖️d(b)</p><p>​    2.若b = a ✖️ a中的最小素因子p1 ，也就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = p1^a1 * p2^a2 * ... * pn^an</span><br><span class="line">b = p1 * p1^a1 * p2^a2 * ... * pn^an</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(b) = d(a) * (1 - p1^(a1 + 2)) / (1 - p1^(a1 + 1))</span><br></pre></td></tr></table></figure><p>​    </p><p>​    3.对于素数来说，它的约数只有1和它本身，所以：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(n) = n + 1;    //当n为素数</span><br></pre></td></tr></table></figure><p>​    </p><p>​    4.对于求解一般的约数和函数，我们有一个约数和定理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(n)=(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak)</span><br><span class="line">//n = p1^a1 * p2^a2 *...* pk^ak且p都为素数</span><br></pre></td></tr></table></figure><p>​    通过等比数列求和公式化简一下，为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(n)=Π (1 - pi^(ai + 1)) / (1 - pi)</span><br><span class="line">//pi为它的素因子，ai为该种素因子的个数</span><br></pre></td></tr></table></figure><p>​    我们就可以根据n的素因子种类pi和每种的个数ai来求约数和了。关于pi和ai我们可以利用之前的线性筛求因子个数框架来求取 抛个链接：<a href="http://www.ivan-zcy.top/2018/10/12/Project-Euler-012/">走你</a> </p><p>​    </p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define N (d)1e4</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)</span><br><span class="line">#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)</span><br><span class="line">#define printfl(a) printf(&quot;%lld\n&quot;, a)</span><br><span class="line">#define printfd(a) printf(&quot;%d\n&quot;, a)</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line"></span><br><span class="line">ll prime[N + 5];     //存全部的素数</span><br><span class="line">ll dd[N + 5];        //用来存约数和</span><br><span class="line">ll book[N + 5];     //book[i]用来存储i的最小素因子幂次方值，如book[24] = 8</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(dd);</span><br><span class="line">    mem(book);</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if(!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            dd[i] = i + 1;              //素数的约数只有1和它本身</span><br><span class="line">            book[i] = i;                //素数的最小素因子幂次方值等于它本身</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime[0]) &#123;</span><br><span class="line">            ll t = prime[j] * i;</span><br><span class="line">            if (t &gt; N) break;</span><br><span class="line">            if (i % prime[j] == 0) &#123;        //当为性质2的时候</span><br><span class="line">                book[t] = book[i] * prime[j];</span><br><span class="line">                dd[t] = dd[i] * (book[i] * prime[j] * prime[j] - 1) / (book[i] * prime[j] - 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;                        //当为性质1的时候</span><br><span class="line">                dd[t] = dd[prime[j]] * dd[i];</span><br><span class="line">                book[t] = prime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        dd[i] -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 0, N) &#123;</span><br><span class="line">        if (dd[i] != i &amp;&amp; dd[i] &lt;= N &amp;&amp; i == dd[dd[i]]) &#123;</span><br><span class="line">            ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printfl(ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果是：<strong>31626</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6265狄利克雷卷积</title>
      <link href="/2018/10/14/HDU6265%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"/>
      <url>/2018/10/14/HDU6265%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/14/HDU6265狄利克雷卷积/title4.jpg" alt="title4"></p><a id="more"></a><p>下面就做一道欧拉函数|积性函数|狄利克雷卷积的题吧，相关原理在上一篇博文：<a href="http://www.ivan-zcy.top/2018/10/14/积性函数与狄利克雷卷积/">点我跳转</a> </p><p>题意：</p><p><img src="/2018/10/14/HDU6265狄利克雷卷积/1.png" alt="1"></p><p>​    翻译成汉语，大概意思就是首先输入一个数T代表有T组样例，每组样例第一行m代表有m对&lt;p,q&gt;（其中p为素数，每对中的p各不相同），计算得到全部pi^qi的乘积n，最后求一下∑d|n φ(d) × n / d的值取模998244353</p><p>思路：</p><p>​    由于p和q数据范围是1e8，我们没办法求出全部p^q的乘积n（爆long long），只能想办法化简公式和通过中间过程来得到答案，又因为给出的∑d|n φ(d) × n / d包含求和，我们遍历辣么大的数的求和铁定超时，所以还应该想办法把公式化简成O(1)的，也就是把求和给去掉</p><p>​    我们接着按照上面的需求想问题：</p><p>​    令函数f(n) = n，令h(n) = ∑d|n φ(d) × n / d，是不是发现了点什么！！！对，h(n）是φ(n)与f(n)的狄利克雷卷积。由于φ(n)是欧拉函数，所以它是积性函数，f(n) = n是单位函数，所以它是完全积性函数，那么h(n)一定也是积性函数，它满足a,b互质，则h(a <em> b) = h(a) </em> h(b)的性质</p><p>​    又因为每对中的p都是不同的素数！！！因此每对pi^qi之间都是互质的，所以,我们就可以解决爆long long 问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h(n) = h(p1^q1 * p2^q2 * ... * pm^qm) = ∏ h(pi ^ qi)  //i为从1～m</span><br></pre></td></tr></table></figure><p>​    这样我们从求h(n)变成了求m个h(pi^qi)的乘积了</p><p>​    此时pi^qi也会爆long long，我们先别管继续往下走</p><p>​    这时候∑d|n φ(d) × n / d就变成了求∑d|p^q φ(d) × p^q / d .我们需要通过化简∑d|p^q φ(d) × p^q / d为O(1)来解决超时问题，怎么化简呢？手写了一份化简过程：</p><p><img src="/2018/10/14/HDU6265狄利克雷卷积/2.jpg" alt="2"></p><p> 我们就可以把h(p^q) = ∑d|p^q φ(d) × p^q / d 化简为h(p^q) = p^q + q <em> p^(q - 1) </em> (p - 1)</p><p>这样我们就可以通过h(n) =  ∏ h(pi ^ qi)来求h(n)了（通过不断的取余998244353来防治爆longlong）</p><p>​    Over～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mod 998244353</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)</span><br><span class="line">#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)</span><br><span class="line">#define printfl(a) printf(&quot;%lld\n&quot;, a)</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line"></span><br><span class="line">//快速幂</span><br><span class="line">ll quick(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) &#123;</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    d T, m;</span><br><span class="line">    ll p, q;</span><br><span class="line">    scanfd(T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        ll ans = 1;</span><br><span class="line">        scanfd(m);</span><br><span class="line">        For (i, 1, m) &#123;</span><br><span class="line">            ll res = 0;</span><br><span class="line">            scanfl(p);</span><br><span class="line">            scanfl(q);</span><br><span class="line">            res = quick(p, q - 1) * q % mod * (p - 1) % mod;</span><br><span class="line">            res = (res + quick(p, q)) % mod;</span><br><span class="line">            ans = ans * res % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        printfl(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论一)积性函数与狄利克雷卷积</title>
      <link href="/2018/10/14/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"/>
      <url>/2018/10/14/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/14/积性函数与狄利克雷卷积/title1.jpg" alt="title1"></p><a id="more"></a><p>​    今天做的一道题就是有关积性函数与狄利克雷卷积的，很懵逼。觉得有必要学一手了</p><h4 id="一-积性函数是什么呢？"><a href="#一-积性函数是什么呢？" class="headerlink" title="一.  积性函数是什么呢？"></a>一.  积性函数是什么呢？</h4><p>​    对于函数f，对于任意的a,b互质，都有:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(a * b) = f(a) * f(b)</span><br></pre></td></tr></table></figure><p>​    这样的函数f就称为积性函数，若a,b不互质也满足上述条件的话，那么函数f又可称为完全积性函数</p><p>​    </p><p>它又有什么性质呢？</p><p>1.若n = p1^q1✖️p2^q2✖️ …✖️pn^qn，那么对于积性函数f，有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) = f(p1^q1) * f(p2^q2) * ... * f(pn^qn)</span><br></pre></td></tr></table></figure><p>2.若积性函数f满足f(p^n) = f^n(p)，那么f也是完全积性函数</p><h4 id="二-那么，狄利克雷卷积是什么呢？"><a href="#二-那么，狄利克雷卷积是什么呢？" class="headerlink" title="二.  那么，狄利克雷卷积是什么呢？"></a>二.  那么，狄利克雷卷积是什么呢？</h4><p>​    对于任意函数f,g，令h = f * g,都有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h(n) = ∑d|n f(d)⋅g(n / d)  //d为能被n整除的数</span><br></pre></td></tr></table></figure><p>​    此时这个h就可以称为f和g的狄利克雷卷积</p><p>它有什么性质呢？</p><p>​    1.狄利克雷卷积满足交换律，结合律，加法分配律：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f * g = g * f</span><br><span class="line">f * g * h = f * (g * h)</span><br><span class="line">f * (g + h) = f * g + f *h</span><br></pre></td></tr></table></figure><p>​    2.积性函数卷个积性函数的狄利克雷卷积仍旧是积性函数</p><p>​    </p><h3 id="三-常见的积性函数和狄利克雷卷积有哪些？"><a href="#三-常见的积性函数和狄利克雷卷积有哪些？" class="headerlink" title="三.  常见的积性函数和狄利克雷卷积有哪些？"></a>三.  常见的积性函数和狄利克雷卷积有哪些？</h3><p>我们先说一下常见的积性函数：</p><p>  1.id^k(n) = n^k：幂函数，属于完全积性函数</p><p>  2.I(n) = 1:  恒等函数，属于完全积性函数，相当于id^0(n)</p><p>  3.id(n) = n： 单位函数，属于完全积性函数，相当于id^1(n)</p><p>  4.e(n) = [n = 1]：代表单位元函数，它卷上任意的函数都得原函数，即：    </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e * f = f</span><br></pre></td></tr></table></figure><p>  5.φ(n)：欧拉函数，表示小于等于 n 且与 n 互质的数的个数</p><p>  6.μ(n)：莫比乌斯函数，在狄利克雷卷积中与恒等函数互为逆元：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">μ * I = e</span><br></pre></td></tr></table></figure><p>​    关于莫比乌斯函数公式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">μ(n) = 1;//当n为1时</span><br><span class="line">μ(n) = (-1)^k//当n由k个不同质数相乘得到时</span><br><span class="line">μ(n) = 0;//其余情况</span><br></pre></td></tr></table></figure><p>  7.σ(n)：约数和函数，表示n的全部约数和</p><p>  8.τ(n)：约数个数函数，表示n的全部约数个数</p><p>  9.σk(n)=∑d|n d^k ：因数函数，表示n全部约数的k次方和</p><p>再来说一下常用的狄利克雷卷积：</p><ol><li>I ∗ μ = e （即莫比乌斯函数与恒等函数互为逆元）</li><li>μ∗id = φ  (即莫比乌斯函数卷上单位函数为欧拉函数)</li><li>I ∗ id = σ（即恒等函数卷个单位函数为约数和函数）</li><li>I ∗ I = τ  （即恒等函数卷个恒等函数为约数个数函数）</li><li>I * φ = id (即恒等函数卷个欧拉函数为单位函数)</li></ol><p>可以由狄利克雷卷积证明很多结论，比如：</p><p>1.n = ∑d|n  φ(d) ，也就是n等于全部 φ(d)的和（φ(d)为d的欧拉函数）</p><p>2.σ(n) = ∑d|n  τ(d) ∗ φ(n / d)，也就是欧拉函数卷个约数个数函数为约数和函数</p><p>3.二项式反演：<img src="/2018/10/14/积性函数与狄利克雷卷积/1.png" alt="1"></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6267推规律+线性阶乘逆元</title>
      <link href="/2018/10/14/HDU6267/"/>
      <url>/2018/10/14/HDU6267/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/14/HDU6267/title.jpg" alt="title"></p><a id="more"></a><p>去年杭州站没做上来的一道数学题，今天补了～</p><p>题意：</p><p>​    Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query, you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifies the nodes with labels from 0 to n − 1 and then visits them one by one. For each i (1 ≤ i ≤ n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i = 1 to n - 1:</span><br><span class="line">    father[i] = random(0, i - 1);</span><br></pre></td></tr></table></figure><p>​    where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. </p><p>​    Knowing n and the value of the i-th node ai, Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her? </p><p>Input </p><p>​    The first line contains an integer T (1 ≤ T ≤ 10) representing the number of test cases.<br> For each test case, the first line contains an integer n (1 ≤ n ≤ 100000), the number of the nodes in the rooted tree.<br>​    The second line contains n integers a0, a1, …, an−1 (1 ≤ ai ≤ 100000) represent the values of nodes. </p><p>Output </p><p>​    It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p ∗ q−1 mod 998244353 in one line. q−1 is the inverse of q under module number 998244353. </p><p>Example </p><p><img src="/2018/10/14/HDU6267/1.png" alt="1"></p><p>Explanation </p><p>​    The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3 ∗ 2−1 mod 998244353 = 499122178. </p><p>​    There are two possible shapes in the second test case, node 1’s father destines to be 0, but node 2’s father might be node 0 or node 1. Both conditions are equally possible. </p><p>​    If node 2’s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. </p><p>​    If node 2’s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. </p><p>​    So the expectation is (6+2+3+6+5+3)/6 = 25/6. The output is 25∗6−1 mod 998244353 = 166374063. </p><p>​    这么一大串英文，翻译成汉语大概也就是说让你输入一个T，代表有T组样例。每组样例第一行输入一个n，代表一个树有n个节点，然后循环输入每个节点的权值。它组成树的方式是：k号节点等概率的选择0～k-1中任意一个节点当它的父节点。然后随意选一个节点，问以它为根节点组成的子树的权值和的数学期望是多少？</p><p>思路：</p><p>​    n个节点，每个节点等概率的选择0～k-1中任意一个节点当它的父节点。那么这n个节点组成树的可能性为（n - 1）!个。例如4个节点可能组成以下6种树：</p><p><img src="/2018/10/14/HDU6267/2.png" alt="2"></p><p>​    又因为任选一个节点当根节点，所以共有n * （n - 1），也就是n!种子树</p><p>​    因此我们可以通过求（每个节点在全部子树的贡献和）/ n！来求数学期望值。</p><p>​    我们可以看到，0号节点在全部子树的贡献是6次（每种树只有选取0号节点当根节点才包含0号节点），也就是3!</p><p>​     1号节点在全部子树的贡献是12次（每种树只有选取0号节点或者1号节点才包含1号节点），也就是3! + 3! / 1</p><p>​     2号节点在全部子树的贡献是15次（有3种树选0，1，2号节点当根节点包含2号节点，有3种树选0，2号节点当根节点才包含2号节点）,也就是3! + 3! / 1 + 3! / 2</p><p>​     3号节点在全部子树的贡献是17次（有1种树选0，1，2，3号节点当根节点包含3号节点，有2种树选0，1，3号节点当根节点包含3号节点，有1种树选0，2，3号节点当根节点包含3号节点，有2种树选0，3号节点当根节点包含3号节点),也就是3! + 3! / 1 + 3! / 2 + 3! / 3</p><p>​    我们发现第k号节点的贡献为：(n - 1)! + (n - 1) ! / 1 + …. + (n - 1) / k</p><p>​    所以我们设i号节点的贡献为pi，权值为qi，那么每个节点在全部子树的贡献和为∑pi*qi （i从0到n-1），再除以n！即为数学期望。因为需要取余998244353且包含除法，因此需要用到求逆元。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define mod 998244353</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)</span><br><span class="line">#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)</span><br><span class="line">#define printfl(a) printf(&quot;%lld\n&quot;, a)</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line"></span><br><span class="line">ll q[N + 5];        //存储每个节点的权值</span><br><span class="line">ll fact[N + 5];       //存储阶乘</span><br><span class="line">ll inv[N + 5];      //存储阶乘的逆元</span><br><span class="line">ll inv1[N + 5];     //存储线性逆元</span><br><span class="line">ll num[N + 5];      //存储节点的贡献值</span><br><span class="line"></span><br><span class="line">//扩展欧几里得算法</span><br><span class="line">ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 0) r -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        r a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = extend_gcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    r t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求a关于mod的逆元</span><br><span class="line">ll mod_reverse (ll a) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll t = extend_gcd(a, mod, x, y);</span><br><span class="line">    if (t == 1) r (x % mod + mod) % mod;</span><br><span class="line">    r -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//预处理1～100000阶乘及逆元，处理线性逆元</span><br><span class="line">void init() &#123;</span><br><span class="line">    fact[0] = fact[1] = 1;</span><br><span class="line">    inv1[0] = inv1[1] = 1;</span><br><span class="line">    For (i, 2, N) &#123;</span><br><span class="line">        fact[i] = fact[i - 1] * i % mod;</span><br><span class="line">        inv1[i] = (mod - mod / i) * inv1[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N] = mod_reverse(fact[N]);</span><br><span class="line">    Forr (i, N - 1, 0) &#123;</span><br><span class="line">        inv[i] = inv[i + 1] * (i + 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//处理权值和</span><br><span class="line">ll work(d n) &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    num[0] = fact[n - 1];</span><br><span class="line">    ans = (ans + num[0] * q[0]) % mod;</span><br><span class="line">    For(i, 1, n - 1) &#123;</span><br><span class="line">        num[i] = (num[i - 1] + fact[n - 1] * inv1[i]) % mod;</span><br><span class="line">        ans = (ans + num[i] * q[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    d T, n;</span><br><span class="line">    scanfd(T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanfd(n);</span><br><span class="line">        For (i, 0, n - 1) &#123;</span><br><span class="line">            scanfl(q[i]);</span><br><span class="line">            q[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = work(n) * inv[n] % mod;</span><br><span class="line">        printfl(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-019菜勒公式</title>
      <link href="/2018/10/13/Project-Euler-019/"/>
      <url>/2018/10/13/Project-Euler-019/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-019/title.jpg" alt="title"></p><a id="more"></a><h3 id="019题："><a href="#019题：" class="headerlink" title="019题："></a>019题：</h3><p>题意：</p><p>​    在二十世纪（1901年1月1日到2000年12月31日）中，有多少个月的1号是星期天？</p><p>思路：</p><p>​    我们需要遍历从1901到2000年的每一月，判断是否1号为星期天。</p><p>​    一.先用日历看一下1901年一月1号是星期几，然后根据把星期一到星期天定义为0～6，预处理每个月的天数（注意平年和闰年），然后累加取余7，只要判断是否为6即可，是就累加到结果中</p><p>​    </p><p>​    二.利用蔡勒公式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;</span><br><span class="line">//其中w为星期（0～6分别代表星期一到星期天），y，m，d分别代表年月日</span><br></pre></td></tr></table></figure><p>​    该公式有个注意点，就是当月份为1月或2月时，分别把它当作上一年的13月14月计算。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 1000005</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool chooes(d y, d m, d day) &#123;</span><br><span class="line">    if(m == 1 || m == 2) &#123;</span><br><span class="line">        y --;</span><br><span class="line">        m += 12;</span><br><span class="line">    &#125;</span><br><span class="line">    d w = (day + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;</span><br><span class="line">    if (w == 6) r 1;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d ans = 0;</span><br><span class="line">    for (d i = 1901; i &lt;= 2000; i++) &#123;</span><br><span class="line">        for (d j = 1; j &lt;= 12; j++) &#123;</span><br><span class="line">            if(chooes(i, j, 1)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案是：<strong>171</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-047线性求质因子种类</title>
      <link href="/2018/10/13/Project-Euler-047/"/>
      <url>/2018/10/13/Project-Euler-047/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-047/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="047题："><a href="#047题：" class="headerlink" title="047题："></a>047题：</h3><p>题意：</p><p>首次出现连续两个数均有两个不同的质因数是在：</p><p>​    14 = 2 × 7<br>​    15 = 3 × 5</p><p>首次出现连续三个数均有三个不同的质因数是在：</p><p>​    644 = 22 × 7 × 23<br>​    645 = 3 × 5 × 43<br>​    646 = 2 × 17 × 19</p><p>首次出现连续四个数均有四个不同的质因数时，其中的第一个数是多少？</p><p>思路：</p><p>​    有一下两个思路：</p><p>​    一.先预处理前1e6个素数，然后从1开始往后遍历每个数，如果满足连续四个数的素因子种类都为4，就返回并输出，时间复杂度为O(n*m)，n为预处理的1e6，m为找到的那个数</p><p>​    二.利用线性筛框架，把标记数组改为记录该数有多少种不同素因子的数组。时间复杂度为O(n + m)</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 1000005</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d prime[N];//记录1e6范围内的全部素数</span><br><span class="line">d book[N];//book[i]记录数字i由多少种不同素因子相乘得到</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(book);</span><br><span class="line">    for (d i = 2; i &lt; N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            book[i] = 1;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                book[prime[j] * i] = book[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            book[prime[j] * i] = book[i] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (d i = 2; i &lt; N - 4; i++) &#123;</span><br><span class="line">        if(book[i] == 4 &amp;&amp; book[i + 1] == 4 &amp;&amp; book[i + 2] == 4 &amp;&amp; book[i + 3] == 4) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId32&quot;\n&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>134043</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-029思维</title>
      <link href="/2018/10/13/Project-Euler-029/"/>
      <url>/2018/10/13/Project-Euler-029/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-029/title.jpg" alt="title"></p><a id="more"></a><h3 id="029题："><a href="#029题：" class="headerlink" title="029题："></a>029题：</h3><p>题意：</p><p>考虑所有满足2 ≤ a ≤ 5和2 ≤ b ≤ 5的整数组合生成的幂ab：</p><blockquote><p>22=4, 23=8, 24=16, 25=32<br>32=9, 33=27, 34=81, 35=243<br>42=16, 43=64, 44=256, 45=1024<br>52=25, 53=125, 54=625, 55=3125</p></blockquote><p>如果把这些幂按照大小排列并去重，我们得到以下由15个不同的项组成的序列：</p><p>4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125</p><p>在所有满足2 ≤ a ≤ 100和2 ≤ b ≤ 100的整数组合生成的幂ab排列并去重所得到的序列中，有多少个不同的项？</p><p>思路：</p><p>​    我们肯定没有办法计算类似100^100的值，因此我们只能考虑什么情况下a^b的值等于p^q的值</p><p>​    我们可以发现:  2^6  =  4^3  =  8^2，这种情况下我们只需要计算一个即可</p><p>​    我们把4^3化简得到 (2^2)^3 = 2^6,8^2化简得到(2^3)^2=2^6，所以，4，8，16等数都可以看作是2的平方数的形式</p><p>​    因此我们可以创建一个map&lt;inde, bool&gt;zcy[105]的映射数组， 用i遍历2～100，然后若book[i]不存在（即i不是任何数的幂次方)，就对它的所有幂次方进行遍历，设它的inx次方为t，那么它t^j == (i ^ inx) ^j == (i) ^ (inx <em> j)，利用map[i]【j </em> inx】映射判断是否存在过该数。若不存在就累加。时间复杂度大概1e4，完美的解决了爆longlong的问题</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int, bool&gt;zcy[1005];</span><br><span class="line"></span><br><span class="line">ll ans = 0;</span><br><span class="line">bool book[105];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    for (d i = 2; i &lt;= 100; i++) &#123;//遍历a</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">            d t = i, inx = 1;</span><br><span class="line">            while (t &lt;= 100) &#123;</span><br><span class="line">                book[t] = 1;</span><br><span class="line">                for (d j = 2; j &lt;= 100; j++) &#123;//遍历j</span><br><span class="line">                    if (!zcy[i][j * inx]) &#123;对于t来说，它等于i^inx,因此它就相当于i^(inx * j)</span><br><span class="line">                        ans ++;</span><br><span class="line">                        zcy[i][j * inx] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                inx ++;</span><br><span class="line">                t *= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>9183</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-024思维</title>
      <link href="/2018/10/13/Project-Euler-024/"/>
      <url>/2018/10/13/Project-Euler-024/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-024/title2.jpg" alt="title2"></p><a id="more"></a><h3 id="024题："><a href="#024题：" class="headerlink" title="024题："></a>024题：</h3><p>题意：</p><p>​    排列指的是将一组物体进行有顺序的放置。例如，3124是数字1、2、3、4的一个排列。如果把所有排列按照数字大小或字母先后进行排序，我们称之为字典序排列。0、1、2的字典序排列是：</p><p>​    012   021   102   120   201   210</p><p>​    数字0、1、2、3、4、5、6、7、8、9的字典序排列中第一百万位的排列是什么？</p><p>思路：</p><p>​    设n = 1e6，这个题可以预处理出1～9位数的组合数分别是sum[1~9]；</p><p>​    然后用i遍历从9～1</p><p>​    如果n % sum[i] != 0，那么最高位数字是剩余数字中第n / sum[i] 个数（从0开始）并取出</p><p>​    如果n % sum[i] == 0，那么最高位数字是剩余数字中第n / sum[i] - 1个数（从0开始）并取出，剩余数字由大到小排序，并跳出i循环</p><p>​    这样只需要一次遍历就可以求出第1000000位的排列是多少</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const ll n = 1e6;</span><br><span class="line">ll sum[15];</span><br><span class="line">bool book[15];</span><br><span class="line"></span><br><span class="line">//预处理</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(sum);</span><br><span class="line">    sum[0] = 1;</span><br><span class="line">    for (d i = 1; i &lt;= 9; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - 1] * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求第m个数是多少</span><br><span class="line">void work (ll m) &#123;</span><br><span class="line">    for (d i = 9; i &gt;= 1; i--) &#123;</span><br><span class="line">        ll t = m / sum[i];</span><br><span class="line">        if (m % sum[i] == 0) &#123;//当m%sum[i]==0时</span><br><span class="line">            d num = 0;</span><br><span class="line">            for (d j = 0; j &lt;= 9; j++) &#123;</span><br><span class="line">                if (!book[j]) &#123;</span><br><span class="line">                    if (num == t - 1) &#123;</span><br><span class="line">                        printf(&quot;%&quot; PRId32, j);</span><br><span class="line">                        book[j] = 1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (d j = 9; j &gt;= 0; j--) &#123;</span><br><span class="line">                if(!book[j]) &#123;</span><br><span class="line">                    printf(&quot;%&quot; PRId32, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">            r;</span><br><span class="line">        &#125;</span><br><span class="line">        //当m % sum[i] != 0时</span><br><span class="line">        d num = 0;</span><br><span class="line">        for (d j = 0; j &lt;= 9; j++) &#123;</span><br><span class="line">            if (!book[j]) &#123;</span><br><span class="line">                if (num == t) &#123;</span><br><span class="line">                    printf(&quot;%&quot; PRId32, j);</span><br><span class="line">                    book[j] = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m %= sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //最后别忘已经固定的个位数</span><br><span class="line">    for (d i = 0; i &lt;= 9; i ++) &#123;</span><br><span class="line">        if (!book[i])  &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId32&quot;\n&quot;, i);</span><br><span class="line">            r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    work (n);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>2783915460</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-015组合数</title>
      <link href="/2018/10/13/Project-Euler-015/"/>
      <url>/2018/10/13/Project-Euler-015/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-015/title.jpg" alt="title"></p><a id="more"></a><h3 id="015题："><a href="#015题：" class="headerlink" title="015题："></a>015题：</h3><p>题意：</p><p>从一个2×2方阵的左上角出发，只允许向右或向下移动，则恰好有6条通往右下角的路径。</p><p><img src="/2018/10/13/Project-Euler-015/p015.gif" alt="p015"></p><p>对于20×20方阵来说，这样的路径有多少条？</p><p>思路：</p><p>​    有两个解题思路：</p><p>​    一.利用DP求解，我们可以设二维数组<code>dp【i】【j】</code>代表到达第i行第j列的方案数，初始化<code>dp【0】【0】= 1</code>利用dp推导式<code>dp【i】【j】=dp【i-1】【j】+dp【i】【j-1】</code>就可求出<code>dp【20】【20】</code>了。这样复杂度式O(n^2)</p><p>​    </p><p>​    二.我们可以利用组合数求解，由于它只能向右或者向下，那么想要到达第i行第j列，就必须往下走i步，往右走j步，有且只能走i+j步。所以我们就可以转化为有i+j个盒子，红球有i个，蓝球有j个，问不同的颜色组成方案。也就是(i + j)! /(i! * j!)的值，时间复杂度为O(n+m) n为行，m为列.一定要注意爆longlong范围的解决方法。</p><p>代码：</p><p>​    还是只写复杂度最低的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//用于求(n + m)! / (n)! * (m)!</span><br><span class="line">ll work (ll n, ll m) &#123;</span><br><span class="line">    ll ans1 = 1, t = 20;</span><br><span class="line">    for (ll i = n + m; i &gt; max(n, m); i--) &#123;</span><br><span class="line">        ans1 *= i;</span><br><span class="line">        while (ans1 % t == 0 &amp;&amp; t &gt;= 2) &#123;//解决爆longlong</span><br><span class="line">            ans1 /= t;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    ll ans = work (20, 20);</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为：<strong>137846528820</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C与C++区别（转）</title>
      <link href="/2018/10/13/C%E4%B8%8EC-%E5%8C%BA%E5%88%AB-%E8%BD%AC/"/>
      <url>/2018/10/13/C%E4%B8%8EC-%E5%8C%BA%E5%88%AB-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/C与C-区别-转/title.jpg" alt="title"></p><a id="more"></a><p>原文地址：<a href="https://www.itcodemonkey.com/article/9905.html" target="_blank" rel="noopener">点我跳转</a></p><p><img src="/2018/10/13/C与C-区别-转/1.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针详解（转）</title>
      <link href="/2018/10/13/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E2%80%94%E8%BD%AC/"/>
      <url>/2018/10/13/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E2%80%94%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/C语言指针详解—转/title3.jpg" alt="title3"></p><a id="more"></a><p>看到讲得特别好，果断转了，原文地址：<a href="https://www.itcodemonkey.com/article/9898.html" target="_blank" rel="noopener">点我跳转</a></p><p><img src="/2018/10/13/C语言指针详解—转/1.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-012积性函数性质</title>
      <link href="/2018/10/12/Project-Euler-012/"/>
      <url>/2018/10/12/Project-Euler-012/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/12/Project-Euler-012/title2.jpg" alt="title2"></p><a id="more"></a><h3 id="012题："><a href="#012题：" class="headerlink" title="012题："></a>012题：</h3><p>题意：</p><p>​    三角形数数列是通过逐个加上自然数来生成的。例如，第7个三角形数是 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28。三角形数数列的前十项分别是：</p><p>​    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>​    让我们列举出前七个三角形数的所有约数：</p><p>​    1: 1<br>     3: 1,3<br>​    6: 1,2,3,6<br>​    10: 1,2,5,10<br>​    15: 1,3,5,15<br>​    21: 1,3,7,21<br>​    28: 1,2,4,7,14,28</p><p>​    我们可以看出，28是第一个拥有超过5个约数的三角形数。</p><p>​    第一个拥有超过500个约数的三角形数是多少？</p><p>思路：</p><p>​    任何一个数都可以写成一个或多个素数的乘积，我们设为n = p1^n1 <em> p2 ^ n2 </em>…..</p><p>​    因此，一个数的因子个数，等同于(n1 + 1) <em> (n2 + 1) </em>….</p><p>​    为什么呢？我们可以想一下，对于素因子p1，我们有n1 + 1种选择，分别是：不选，选一个，选两个…直到选n1个，同理p2有n2+1种选择，所以种类数就是(n1 + 1) <em> (n2 + 1) </em>….</p><p>​    因此，我们只需要计算一个数有多少种素因子，每种素因子的个数，就可以通过算式直接求得一个数的因子数，求法有两种：</p><p>​    ——一种是预处理全部素数，然后每次遍历整除直到该数为1，时间复杂度是O(n)，其中n为满足条件的数 </p><p>​    ——另一种方式是创建记忆化数组数组，存储每个数的最小素因子。再利用：如果a,b互质，那么num(a ✖️ b) = num (a) ✖️ num(b)  ,又因为三角形数都是n / 2 ✖️ (n - 1)或n / 2 ✖️ (n + 1)（n &gt;= 2且n为偶数），所以我们只预处理sqrt（n）项即可（注：num(a)代表数字a的因子数），时间复杂度为O(sqrt(n))</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 40000</span><br><span class="line"></span><br><span class="line">d book[N + 5];      //存储每个数的最小素因子</span><br><span class="line">d prime[N + 5];     //存储2～40000全部素数</span><br><span class="line">d number[N + 5];//存储前40000数的因子数</span><br><span class="line"></span><br><span class="line">//利用线性筛框架初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(prime);</span><br><span class="line">    for (d i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            book[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            book[prime[j] * i] = prime[j];</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于求S(n)</span><br><span class="line">ll mul (ll n) &#123;</span><br><span class="line">    r (n + 1) * n / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求n的因子数</span><br><span class="line">d num(ll n) &#123;</span><br><span class="line">    if (n == 1) r 1;</span><br><span class="line">    d res = 1;</span><br><span class="line">    d t = book[n];</span><br><span class="line">    while(n % t == 0) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        n /= t;</span><br><span class="line">    &#125;</span><br><span class="line">    r res * num(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用当a，b互质，num(a * b) = num(a) * num(b)求a*b的因子数</span><br><span class="line">void work () &#123;</span><br><span class="line">    for (ll i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        number[i] = num(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (ll i = 2; i &lt;= N; i += 2) &#123;</span><br><span class="line">        d p1 = number[i / 2] * number[i - 1];</span><br><span class="line">        d p2 = number[i / 2] * number[i + 1];</span><br><span class="line">        if (p1 &gt; 500) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId64&quot;\n&quot;, i / 2 * (i - 1));</span><br><span class="line">            r;</span><br><span class="line">        &#125; else if(p2 &gt; 500) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId64&quot;\n&quot;, i / 2 * (i + 1));</span><br><span class="line">            r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>76576500</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-009素勾股数</title>
      <link href="/2018/10/12/Project-Euler-009/"/>
      <url>/2018/10/12/Project-Euler-009/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/12/Project-Euler-009/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="009题："><a href="#009题：" class="headerlink" title="009题："></a>009题：</h3><p>题意：</p><p>​    毕达哥拉斯三元组是三个自然数a &lt; b &lt; c组成的集合，并满足</p><p>​    a2 + b2 = c2</p><p>​    例如，32 + 42 = 9 + 16 = 25 = 52。</p><p>​    有且只有一个毕达哥拉斯三元组满足 a + b + c = 1000。求这个三元组的乘积abc</p><p>​    相同类型的还有039题，有时间大家可以做一下！</p><p>思路：</p><p>​    暂时想到了二个：</p><p>​    一.两层嵌套for循环分别从1～1000遍历a和b，只要满足a + b &lt; 1000 &amp;&amp; a^2 + b ^ 2 == （1000 - a - b）^2即可，时间复杂度大概1e6</p><p>​    二.利用素勾股数公式：满足gcd(n, m) == 1的互质数，存在a = 2 <em> n </em> m; b = m^2 - n^2; c = m^2 + n ^2，这是只需要遍历n和m（取值范围都是1～32），只要满足a+b+c == 1000即可，时间复杂度大概是1e3</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//求gcd</span><br><span class="line">d gcd(d a, d b) &#123;</span><br><span class="line">    r b == 0?a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work() &#123;</span><br><span class="line">    for (d i = 1; i &lt;= 32; i++) &#123;</span><br><span class="line">        for (d j = i + 1; j &lt;= 32 &amp;&amp; i * i + j * j &lt; 1000; j++) &#123;</span><br><span class="line">            if (gcd(j, i) == 1) &#123;</span><br><span class="line">                d a = 2 * i * j;</span><br><span class="line">                d b = j * j - i * i;</span><br><span class="line">                d c = j * j + i * i;</span><br><span class="line">                d sum = a + b + c;</span><br><span class="line">                if (1000 % sum == 0) &#123;</span><br><span class="line">                    d t = 1000 / sum;</span><br><span class="line">                    printf(&quot;%&quot; PRId64&quot;\n&quot;, (ll)t * t * t * a * b * c);</span><br><span class="line">                    r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    work();</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    答案是：<strong>31875000</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-045思维</title>
      <link href="/2018/10/12/Project-Euler-045/"/>
      <url>/2018/10/12/Project-Euler-045/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/12/Project-Euler-045/title.jpg" alt="title"></p><a id="more"></a><h3 id="045题："><a href="#045题：" class="headerlink" title="045题："></a>045题：</h3><p>题意：</p><p>​    三角形数、五边形数和六角形数分别由以下公式给出：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>三角形数</td><td>Tn=n(n+1)/2</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>五边形数</td><td>Pn=n(3n−1)/2</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>六边形数</td><td>Hn=n(2n−1)</td><td>1, 6, 15, 28, 45, …</td></tr></tbody></table><p>​    可以验证，T285 = P165 = H143 = 40755。</p><p>​    找出下一个同时是三角形数、五边形数和六角形数的数</p><p>思路：</p><p>​    由于六边形增长速度最快，所以我们优先根据公式遍历六边形数。然后我们看一下三角形数，把n = 2k - 1带入公式，得到Tk = k(2k - 1)，所以，每下角标为2n - 1的三角形数都是六边形数，也就是说是六边形数，一定也是三角形数</p><p>​    因此我们只需要判断六边形数是否为五边形数即可，找到第一个就返回</p><p>​    有以下三个想法判断是否为五边形数：</p><p>​        1.先预处理出前10000个五边形数(应该不会超过这些)，然后利用map<long long,="" bool="">zcy映射一下这些五边形数，然后从144开始遍历六边形数，只要zcy[六边形数]存在就直接输出，时间复杂度O(m + n)，其中m为预处理的五边形数的个数 </long></p><p>​        2.外层for循环从144开始遍历六边形数，然后利用二分五边形数下角标查找是否存在对应的五边形数，若存在则返回并输出，时间复杂度O(n * logn)</p><p>​        3.for循环从144开始遍历六边形数，设得到的数设为t，我们求n(3n−1)/2 = t 的正整数解，也就是n = (1 + sqrt(1 + 24t)) / 6，若n为正整数则该数也为五边形数，时间复杂度O(n)</p><p>代码：</p><p>​    老规矩上时间复杂度最低的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//六边形公式</span><br><span class="line">ll g(ll a) &#123;</span><br><span class="line">    r a * (2 * a - 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断该六边形数g(a)是否为五边形数</span><br><span class="line">bool chooes(ll a) &#123;</span><br><span class="line">    ll t = g(a);</span><br><span class="line">    f inx = (sqrt(24 * t + 1) + 1 ) / 6;</span><br><span class="line">    if (inx == (ll)inx) return true;</span><br><span class="line">    r false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    for (ll i = 144; ; i++) &#123;</span><br><span class="line">        if (chooes(i)) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId64&quot;\n&quot;, g(i));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案为：<strong>1533776805</strong></p><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-044剪枝</title>
      <link href="/2018/10/11/Project-Euler-044/"/>
      <url>/2018/10/11/Project-Euler-044/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/11/Project-Euler-044/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="044题："><a href="#044题：" class="headerlink" title="044题："></a>044题：</h3><p>题意：</p><p>​    五边形数由公式Pn=n(3n−1)/2生成。前十个五边形数是：</p><p>​    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …</p><p>​    可以看出P4 + P7 = 22 + 70 = 92 = P8。然而，它们的差70 − 22 = 48并不是五边形数。</p><p>​    在所有和差均为五边形数的五边形数对Pj和Pk中，找出使D = |Pk − Pj|最小的一对；此时D的值是多少？</p><p>思路：</p><p>​    我们假设a[j] - a[i] = a[t]; a[j] + a[i] = a[k];</p><p>​    想了很久，只能想到极度剪枝的O(n^2)做法，大概三四秒出的答案。</p><p>​    我们可以先预处理出前3000个数，然后用map映射一下。然后从小到大遍历a[t]，内层嵌套遍历a[i],只要有一个满足“a[i] + a[t]存在且2 * a[i] + a[t]存在”，就直接返回a[t]。因为以后再出现的就一定大于等于当前a[t]，可以减少时间浪费。</p><p>​    然后我们进一步剪枝，对于内层for循环遍历a[i]，当i &gt; t时只要a[t] + a[i] &lt; a[i + 1]，那么当i大于当前i值时一定会有a[t] + a[i] &lt; a[i + 1],所以可以直接break跳出</p><p>​    层层剪枝 + map映射之后，速度还是很慢，有些忧伤。。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 3000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;ll, bool&gt;zcy;</span><br><span class="line">ll a[N + 5];</span><br><span class="line"></span><br><span class="line">//预处理前3000个数，并map一下</span><br><span class="line">void init() &#123;</span><br><span class="line">    zcy.clear();</span><br><span class="line">    for (ll i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        a[i] = i * (3 * i - 1) / 2;</span><br><span class="line">        zcy[a[i]] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll work() &#123;</span><br><span class="line">    for (d i = 1; i &lt; N; i++) &#123;         //外层遍历|a[k] − a[j]|，只要出现第一个，那一定就是最小，直接返回</span><br><span class="line">        for (d j = 1; j &lt; N; j++) &#123;</span><br><span class="line">            if (j &gt; i &amp;&amp; a[i] + a[j] &lt; a[j + 1]) break; //当j &gt; i时只要a[i] + a[j] &lt; a[j + 1]，那么a[i]+a[j + 1]一定小于a[j + 2],所以可以直接break跳出</span><br><span class="line">            if (zcy[a[i] + a[j]] &amp;&amp; zcy[2 * a[j] + a[i]]) &#123;</span><br><span class="line">                return a[i];                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ll ans = work();</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案是：<strong>5482660</strong></p><p>​    也就是当a[2167] - a[1020] = a[1912];   a[2167] + a[1020] = a[2395];时</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（四）</title>
      <link href="/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/"/>
      <url>/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/11/操作系统与系统编程-4/title.jpg" alt="title"></p><a id="more"></a><h3 id="系统调用的常用方法："><a href="#系统调用的常用方法：" class="headerlink" title="系统调用的常用方法："></a>系统调用的常用方法：</h3><p>一.系统调用方法用来运行不同的程序，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execve(const char* filename, char* const argv[], char* const envp[]);</span><br></pre></td></tr></table></figure><p>​        该方法以<code>argv</code>为参运行<code>filename</code>指向的可执行程序，并将<code>envp</code>存储的“变量=数值”对作为环境变量代入这个程序。<code>argv</code>的第一个参数必须与<code>filename</code>一致，真正的参数从第二个开始。</p><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h4><p>​    该方法会让<code>filename</code>的程序覆盖进程中正在运行的程序，因此该方法后的代码无法被执行（除非该方法运行失败）</p><p>二.在 Linux 系统中，比起系统调用更常使用以exec开头的六个函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execl(const char* path, const char* arg, ...);</span><br><span class="line">int execlp(const char* file, const char* arg, ...);</span><br><span class="line">int execle(const char* path, const char* arg,</span><br><span class="line">           ..., char* const envp[]);</span><br><span class="line">int execv(const char* path, char* const argv[]);</span><br><span class="line">int execvp(const char* file, char* const argv[]);</span><br><span class="line">int execvpe(const char* file, char* const argv[],</span><br><span class="line">            char* const envp[]);</span><br></pre></td></tr></table></figure><p>​    它们都具有系统调用功能，可将这些函数表示为：“exec + l/v + p/e/pe”，这六个函数主要有两处不同：</p><p>​    第一处不同（l/v）——“l<em>”类函数将所有参数作为一整个字符串代入，而“v</em>”类函数将参数分别放入一个字符串数组中，将数组作参代入函数运行</p><p>​    第二处不同（p/e/pe）——包含 p的函数可以模仿计算机中壳功能，在“file”中不含“/”时使用环境变量 PATH 中的目录来寻找可执行文件，包含 e的函数可以像<code>execve</code>一样将“变量=数值”对作为环境变量代入程序</p><p>三.用法</p><p>​    使用系统调用函数一般先调用fork()产生新进程，然后再新进程中用<code>exec()</code>类函数运行新程序。</p><p>​    可能大家有疑问，调用fork()会复制了全部父进程地址空间又弃置，会造成浪费。</p><p>​    其实， Linux 系统采用了 copy_on_write 技术，只有在某一数据被修改时那个数据才会被实际复制到子进程的地址空间。所以在<code>fork()</code>之后直接运行<code>exec()</code>时，父进程的地址空间不会被复制过来。</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int pid = fork();</span><br><span class="line">    if (pid==0)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        int pid2 = fork();</span><br><span class="line">        if (pid2 == 0)&#123;</span><br><span class="line">            char** argv = (char**) malloc(3*sizeof(char*));</span><br><span class="line">            argv[0] = &quot;echo&quot;;</span><br><span class="line">            argv[1] = &quot;Hello!&quot;;</span><br><span class="line">            argv[2] = NULL;</span><br><span class="line">            int pid3 = fork();</span><br><span class="line">            count++;</span><br><span class="line">            if (pid3 == 0)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                execvp(&quot;echo&quot;, argv);</span><br><span class="line">                printf(&quot;Count %d,&quot;,count);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                free(argv);</span><br><span class="line">                wait(NULL);</span><br><span class="line">                printf(&quot;%d,&quot;,count);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">            printf(&quot;%d,&quot;,count);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wait(NULL);</span><br><span class="line">        printf(&quot;%d.&quot;,count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后输出为：hello!</p><p>​                2,1,0.</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-038思维</title>
      <link href="/2018/10/11/Project-Euler-038/"/>
      <url>/2018/10/11/Project-Euler-038/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/11/Project-Euler-038/title2.jpg" alt="title2"></p><a id="more"></a><p>题意：</p><p>将192分别与1、2、3相乘：</p><blockquote><p>192 × 1 = 192<br>192 × 2 = 384<br>192 × 3 = 576</p></blockquote><p>连接这些乘积，我们得到一个1至9全数字的数192384576。我们称192384576为192和(1,2,3)的连接乘积。</p><p>同样地，将9分别与1、2、3、4、5相乘，得到1至9全数字的数918273645，即是9和(1,2,3,4,5)的连接乘积。</p><p>对于n &gt; 1，所有某个整数和(1,2, … ,n)的连接乘积所构成的数中，最大的1至9全数字的数是多少？</p><p>思路：</p><p>​    首先，我们需要需要想到的是确定范围。所求是对于n&gt;1来说，所以乘数最大是4位数（因为5位数的话，乘数✖️1得到一个5位数，乘数✖️2 最小是5位数，5+5大于9）</p><p>​    我们继续缩小范围：</p><p>​        当乘数是1位数的话，被乘数最多乘到9才能满足乘积是9位数</p><p>​        当乘数是2位数的话，被乘数最多乘到4才能满足乘积是9位数</p><p>​        当乘数是3位数的话，被乘数最多乘到3才能满足乘积是9位数</p><p>​        当乘数是4位数的话，被乘数最多乘到2才能满足乘积是9位数</p><p>​    因此我们只需要判断这样的数的乘积链接是否为全数字即可。对于链接，我们可以通过以下算式进行链接乘积：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res = res * (int)(pow(10, (int)log10(乘积))) + 乘积;   //res即链接后的9位数</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 10000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d book[10];         //用于标记</span><br><span class="line">d maxx = 0;         //存储最终结果</span><br><span class="line"></span><br><span class="line">//用于判断数字t，最长乘到n的链接数是否为全数字，如果是返回该全数字，不是返回0</span><br><span class="line">d chooes (d t, d n) &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    d res = 0;</span><br><span class="line">    d chang = 0;</span><br><span class="line">    for (d i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        d val = t * i;</span><br><span class="line">        d len = (int)log10(val) + 1;</span><br><span class="line">        d vall = val;</span><br><span class="line">        chang += len;</span><br><span class="line">        while (vall) &#123;</span><br><span class="line">            if (vall % 10 == 0 || book[vall % 10]) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            book[vall % 10] = 1;</span><br><span class="line">            vall /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * (int)(pow(10, len)) + val;</span><br><span class="line">        if (chang == 9) return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于遍历1，2，3，4位数</span><br><span class="line">void work(d len, d n) &#123;</span><br><span class="line">    d low = (int)pow (10, len - 1);</span><br><span class="line">    d high = (int)pow (10, len);</span><br><span class="line">    for (d i = low; i &lt; high; i++) &#123;</span><br><span class="line">        d val = chooes(i, n);</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            maxx = max(maxx, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    d p[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    d q[4] = &#123;9, 4, 3, 2&#125;;</span><br><span class="line">    for (d i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        work(p[i], q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, maxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：<strong>932718654</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（三）</title>
      <link href="/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89/"/>
      <url>/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>​                       <img src="/2018/10/11/操作系统与系统编程-三/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="（三）进程常用方法："><a href="#（三）进程常用方法：" class="headerlink" title="（三）进程常用方法："></a>（三）进程常用方法：</h3><p>可通过fork()创建进程，fork()函数格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p>​    fork()函数无参数，直接创建一个新进程，新进程为调用fork()的进程的子进程，返回一个进程标识ID(用于区分父进程与子进程，父进程中返回的标识ID是新创建的子进程ID，而子进程中返回的ID为0)</p><p>可通过exit()结束进程，exit()函数格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><p>​    参数status为进程结束时的状态，当调用该函数结束子进程时，status会作为父进程中wait()函数的第一个参</p><p>wait()函数格式为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t wait(int* stat_loc);</span><br></pre></td></tr></table></figure><p>​    stat_loc为等待的子进程结束状态值的指针（由子进程exit(int status)中的参数status提供，成功为0否则对应错误数字) ，当然，我们设为<code>NULL</code>，函数仍可正常运行。</p><p>​    <code>wait()</code>返回值是返回结束的子进程标识 ID；</p><p>​    <code>wait()</code>使父进程的状态变为等待态，直到父进程中任意一个子进程成功退出并返回结束状态值，父进程才可进入就绪态；</p><p>​    如果在<code>wait()</code>被调用时已经有可用的结束状态值，那么<code>wait()</code>会立即返回</p><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h4><p>​    （1）如果在等待过程中出现错误（如已经没有可等待的子进程），<code>wait()</code>将返回-1</p><p>​      （2）父进程不能直接等待子进程的子进程</p><p>wait函数作用：</p><p>​    1使子进程某些指令在执行父进程前完成</p><p>​    2 使用wait()让父进程等待所有子进程结束后结束，避免僵尸进程的出现</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int pid = fork();</span><br><span class="line">    if (pid != 0) &#123;</span><br><span class="line">        int status;</span><br><span class="line">        int result = wait (&amp;status);</span><br><span class="line">        if (result == -1 || status != 0) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, &quot;额，没收到儿子的回信&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, &quot;我是父亲&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int second_pid = fork();</span><br><span class="line">        if (second_pid != 0) &#123;</span><br><span class="line">            int new_status;</span><br><span class="line">            int new_result = wait (&amp;new_status);</span><br><span class="line">            if (new_result == -1 || new_status != 0) &#123;</span><br><span class="line">                printf(&quot;%s\n&quot;, &quot;额，没收到孙子的回信&quot;);</span><br><span class="line">                exit (-1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot;%s\n&quot;, &quot;我是儿子&quot;);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, &quot;我是孙子&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>waitpid()函数格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t waitpid (pid_t pid, int* stat_loc, int options);</span><br></pre></td></tr></table></figure><p>​    waitpid()可指定一个标识ID来等待指定进程（当pid &gt; 0时等待标识ID为pid的子进程，当pid == -1时等待任意子进程，当pid == 0时等待进程组标识ID与父进程相同的子进程，当pid &lt; -1时，等待任意进程组标识ID为pid绝对值的进程）</p><p>​    options代表特殊选项（目前Linux只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可用”|”运算符连接使用，当options为0时代表没有特殊选项）</p><p>​    关于特殊选项：</p><p>​    ——WNOHANG ：若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待，若结束，则返回该子进程的ID</p><p>​    ——WUNTRACED 若子进程进入暂停状态则马上返回，此时子进程的结束状态不予理会</p><p>​    所以，当pid = -1，options = 0时，waitpid()等价于wait()</p><p>​    说了以上四个有关进程的函数，它可以用在哪呢？</p><p>​    多进程的应用有很多，比如在网络编程中，每当服务器接收到一个请求，主进程就会用fork()产生一个新进程去处理那个请求，而父进程继续等待其它请求。大家可以自己去探索发现～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-035线性筛</title>
      <link href="/2018/10/10/Project-Euler-035/"/>
      <url>/2018/10/10/Project-Euler-035/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/Project-Euler-035/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="035题："><a href="#035题：" class="headerlink" title="035题："></a>035题：</h3><p>题意：</p><p>​    197被称为圆周素数，因为将它逐位旋转所得到的数：197，719和971都是素数。</p><p>​    小于100的圆周素数有十三个：2、3、5、7、11、13、17、31、37、71、73、79和97。</p><p>​    小于一百万的圆周素数有多少个？</p><p>类似的题还有037题，有空大家可以做一下～    </p><p>思路：</p><p>​    如果1～1000000所有数都逐位旋转复杂度太高，所以应该用线性筛筛选出全部的素数。</p><p>​    对于怎么逐位旋转，我们可以依据以下三点：</p><p>​        1.通过(int)log10(n) + 1来求n的位数</p><p>​        2.利用 n = n / 10 + (n % 10) * pow(10, (int)log10(n)) 来得到逐位旋转的值</p><p>​        3.利用线性筛使用的bool数组来判断逐位旋转的值是否位素数</p><p>​    看到这题网上有些人写了两百多行代码并且时间复杂度还高，觉得利用上述三点就可以缩短代码长度并提高运行效率～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 1000000</span><br><span class="line"></span><br><span class="line">d ans;            //存储满足条件的个数</span><br><span class="line">d prime[N + 5];   //筛选出100万内的全部素数，其中prime[0]为这些素数的个数</span><br><span class="line">bool book[N + 5]; //book[i]代表i是否为素数（0是，1不是）</span><br><span class="line"></span><br><span class="line">//初始化和预处理100万内的全部素数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(book);</span><br><span class="line">    ans = 0;</span><br><span class="line">    for (d i = 2; i &lt; N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            book[prime[j] * i] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断素数t是否满足条件</span><br><span class="line">bool chooes (d t) &#123;</span><br><span class="line">    d len = (int)log10(t);</span><br><span class="line">    d maxx = (int)pow(10, len);</span><br><span class="line">    for (d i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (t % 10 == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        t = t / 10 + (t % 10) * maxx;</span><br><span class="line">        if (book[t]) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历全部素数</span><br><span class="line">void work() &#123;</span><br><span class="line">    for (d i = 1; i &lt;= prime[0]; i++) &#123;</span><br><span class="line">        d t = prime[i];</span><br><span class="line">        if (chooes (t)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案是 <strong>55</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-032思维</title>
      <link href="/2018/10/10/Project-Euler-32/"/>
      <url>/2018/10/10/Project-Euler-32/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/Project-Euler-32/title3.jpg" alt="title3"></p><a id="more"></a><h3 id="032题："><a href="#032题：" class="headerlink" title="032题："></a>032题：</h3><p>题意：</p><p><strong>全数字的乘积</strong></p><p>​    如果一个n位数包含了1至n的所有数字恰好一次，我们称它为全数字的；例如，五位数15234就是1至5全数字的。</p><p>​    7254是一个特殊的乘积，因为在等式39 × 186 = 7254中，被乘数、乘数和乘积恰好是1至9全数字的。</p><p>​    找出所有被乘数、乘数和乘积恰好是1至9全数字的乘法等式，并求出这些等式中乘积的和。</p><p>​    注意：有些乘积可能从多个乘法等式中得到，但在求和的时候只计算一次</p><p>思路：</p><p>​    和之前一样，不讲暴力。我们想要满足被乘数、乘数和乘积恰好是1至9全数字的，必须保证乘数位数+被乘数位数+乘积位数 = 9</p><p>​    我们知道，乘积位数 = 乘数位数 + 被乘数位数  -  0或1；我们可进一步去重，保证乘数位数 &lt;= 被乘数位数</p><p>​    因此我们发现要想存在1～9全数字乘法等式，只有两种情况：</p><p>​        1.乘数是1位数，被乘数是4位数，乘积是4位数</p><p>​        2.乘数是2位数，被乘数是3位数，乘积是4位数</p><p>​    我们进一步优化，可用dfs+标记找出所有的位值不同的2位数，3位数,4位数,然后用筛选过的2位数乘3位数，看是否满足全数字；再用1位数乘4位数，看是否满足全数字。满足的乘积用map处理一下，第一次出现的累加到结果中</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d num[5][3500];   //num[i][j]表示预处理i位数每位不相同的数，其中num[i][0]代表i位这样的数的个数</span><br><span class="line">d book [15];      //标记数组</span><br><span class="line">d ans = 0;        //总结果</span><br><span class="line">map &lt;d, d&gt;zcy;    //用于映射满足条件的乘积</span><br><span class="line"></span><br><span class="line">void dfs(d n, d inx, d val) &#123;      //n代表位数，inx代表当前位, val代表数字的值</span><br><span class="line">    if (inx == n) &#123;</span><br><span class="line">        num[n][++num[n][0]] = val;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 1; i &lt;= 9; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            book[i] = 1;</span><br><span class="line">            dfs(n, inx + 1, val * 10 + i);</span><br><span class="line">            book[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">//预处理函数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(num);</span><br><span class="line">    zcy.clear();</span><br><span class="line">    num[1][0] = 8;</span><br><span class="line">    //预处理1,2,3,4位数每位不相同的数</span><br><span class="line">    for (d i = 2; i &lt;= 9; i++) &#123;</span><br><span class="line">        num[1][i - 1] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 2; i &lt; 5; i ++) &#123;</span><br><span class="line">        mem(book);</span><br><span class="line">        dfs (i, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于判断单个数字</span><br><span class="line">bool chooes1(d x, d *sum) &#123;</span><br><span class="line">    while (x) &#123;</span><br><span class="line">        if (book[x % 10] || (x % 10 == 0)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        *sum += 1;</span><br><span class="line">        book [x % 10] = 1;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于判断乘法算式是否为全数字</span><br><span class="line">void chooes(d x, d y, d z) &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    d sum = 0;</span><br><span class="line">    bool flag1 = chooes1(x, &amp;sum);</span><br><span class="line">    bool flag2 = chooes1(y, &amp;sum);</span><br><span class="line">    bool flag3 = chooes1(z, &amp;sum);</span><br><span class="line">    if (flag1 &amp;&amp; flag2 &amp;&amp; flag3 &amp;&amp; sum == 9) &#123;</span><br><span class="line">        if (!zcy[z]) &#123;</span><br><span class="line">            ans += z;</span><br><span class="line">            zcy[z] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work() &#123;</span><br><span class="line">    for (d i = 1; i &lt;= num[1][0]; i++) &#123;        //处理1位数*4位数</span><br><span class="line">        d x = num[1][i];</span><br><span class="line">        for (d j = 1; j &lt;= num[4][0]; j++) &#123;</span><br><span class="line">            d y = num[4][j];</span><br><span class="line">            d z = x * y;</span><br><span class="line">            chooes(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 1; i &lt;= num[2][0]; i++) &#123;        //处理2位数*3位数</span><br><span class="line">        d x = num[2][i];</span><br><span class="line">        for (d j = 1; j &lt;= num[3][0]; j++) &#123;</span><br><span class="line">            d y = num[3][j];</span><br><span class="line">            d z = x * y;</span><br><span class="line">            chooes(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后结果是<strong>45228</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（二）</title>
      <link href="/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C/"/>
      <url>/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/操作系统与系统编程-二/title.jpg" alt="title"></p><a id="more"></a><h3 id="（二）进程与线程"><a href="#（二）进程与线程" class="headerlink" title="（二）进程与线程"></a>（二）进程与线程</h3><p>1.关于进程：</p><p>​    ——进程在用户方面，包含了程序的运行状态和这个程序所用的抽象内存及存储数据。</p><p>​    ——进程在操作系统方面：包括：</p><p>​    (1)一个进程的运行状态(通过在进程中存储”状态寄存器、指令计数器、栈指针、通用寄存器“等代表进程目前运行状态的值实现)</p><p>​    (2)从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址及其存储的数据（通过分页存储、分段存储等方法来实现映射）</p><p>​    我们可以将进程笼统看成是一个或多个线程与一个地址空间的结合体</p><p>​    </p><p>2.关于进程的地址空间：</p><p>​    一个进程的全部内存地址和存储的数据，称为这个进程的地址空间</p><p>3.关于线程：</p><p>​    由于多核计算机程序可并发，因此一个进程可能同时包含多个不同的运行状态。为更好区分进程在一个处理器上的运行状态和进程本身的运行状态，于是引入“线程”这一概念。</p><p>​    </p><p>4.​进程控制块和线程控制块：</p><p>​    每个线程拥有一个线程控制块，用来存储“状态寄存器、指令计数器、栈指针、通用寄存器”等数值（也就是在该线程下的进程运行状态），同一进程的所有线程都共享同一个地址空间</p><p>​    进程控制块中包含实现地址转换信息和进程运行状态的线程信息，以及系统在调度进程时需要的信息（比如进程号、进程所处状态、进程优先级等）</p><h4 id="​-注意！！"><a href="#​-注意！！" class="headerlink" title="​    注意！！"></a>​    注意！！</h4><p>​    进程控制块只需存储从抽象内存地址获得实际物理地址的方法，而不会将整个地址空间中地址及其数据都存储</p><p>​    由于进程控制块中的信息是用户进程无权修改的，因此进程控制块存储在内核空间中</p><p>5.三态模型和五态模型</p><p>​    进程三态模型包括运行态（正在执行），就绪态（准备就绪，排入就绪队列等待执行），等待态（等待某一事件发生后才会变为就绪态）</p><p>​    五态模型还包括新建态（被创建尚未加入就绪队列的状态。内核建一个进程需要给它分配资源等，在这个过程中进程就处于新建态）和终止态（终止态对应进程结束但尚未被系统收回的状态，此时系统仍可以获得该进程结束时的信息）</p><p>​    新建态可避免一个新进程在未获得全部资源前就开始运行，终止态可避免一个进程运行完毕后即被系统收回而导致无法获取其信息（因为无法获取该进程信息而导致某一进程停滞不前，产生“僵尸进程”）</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（一）</title>
      <link href="/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
      <url>/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/操作系统与系统编程-一/title.jpg" alt="title"></p><a id="more"></a><p>​    对于操作系统和系统编程，自己学的迷迷糊糊懵懵懂懂，希望能够通过写博客梳理一下脉络，加深一下自己的理解～</p><h3 id="（一）操作系统的一些理解与概念"><a href="#（一）操作系统的一些理解与概念" class="headerlink" title="（一）操作系统的一些理解与概念"></a>（一）操作系统的一些理解与概念</h3><p>1.一般程序猿也不会参与系统编程，那么还有学习操作系统和系统编程的必要吗？                       </p><p>​    答案是肯定，因为理解操作系统可以更好地服务于编程，比如更深入的理解多线程等</p><p>2.操作系统的理解：</p><p>​    操作系统是应用程序和硬件间的抽象层，方便软件利用硬件资源，也可以避免软件直接与物理资源接触（防止恶意程序）</p><p>​    操作系统的抽象包括很多层面，包括文件和文件系统，基于进程的抽象等</p><p>3.操作系统的作用：</p><p>​    ——提供公共服务：如读写文件等（无需用户理解实现原理）</p><p>​    ——协调进程交互：操作系统负责给每个进程分配处理器时间、内存等。进程间同步和通信、进程切换过程中处理器和高速缓存器状态的变化等都属于操作系统的协调范围</p><p>​    ——管理与控制资源：将有限物理资源合理分配给不同的进程，提高资源利用率</p><p>​    以上称为操作系统内核，计算机启动时第一个运行的进程就是内核，所有用户进程都基于内核运行，所有资源管控、进程交互协调都由内核完成。也就是说处理器每隔一段时间就中断正在执行的用户进程，切回内核，让它重新分配物理资源，然后决定下一个运行的用户进程。</p><p>4.关于进程的理解：</p><p>​    我们知道，程序在处理器上运行是不连续的，因为硬件资源有限，不可能为所有程序提供全部处理器时间，同样计算机有限的内存迫使一个程序的部分内存留在磁盘上，只有部分数据存在系统内存中。所以系统处理程序的过程是非常复杂的</p><p>​    如果程序猿在编写程序的过程中需要考虑那么多，估计会累死吧。。所以，就有了“进程”这样一个概念。</p><p>​    我们把占用全部内存和处理器时间的程序（理想状态）抽象为“进程”。“进程”大大方便了多个程序同时在系统中运行（因为程序猿不需考虑在内存中所占大小和位置，也不需考虑上下文切换（从一个进程切换到另一个进程）时的复杂过程，只需考虑自己的程序在理想状态下的运行情况）</p><p>​    而且，每个进程都在抽象的内存空间中进行读写，不直接接触其它进程的内存，从而保护进程不受到其它恶意进程的侵害</p><p>5.关于内核与用户进程的理解：</p><p>​    内核和用户进程都是进程！内核就相当于一个指挥官，而用户进程就相当于小兵，指挥官决定小兵的资源分配以及小兵间的协调配合。</p><p>​    内核与用户进程使用不同的存储空间，防止用户进程获得内核信息（内核所在存储空间称为系统空间 用户进程所用空间称为用户空间）</p><p>6.用户进程到内核的方式</p><p>​    ——系统调用 （关于系统调用，会在8中的（1）里有详细描述）</p><p>​    ——中断（又称外中断或异步中断）包括时钟中断（即一个进程执行一段时间后，时钟发出中断信号使计算机进入内核态）、设备 I/O 中断。</p><p>​    ——异常（又称内中断或同步中断）可能源于程序的非法操作（如除数为0、超长度读取数组等）、硬件故障等，通过内核中对应的异常处理程序处理</p><p>7.关于双模式操作：</p><p>​    我们用两种不同模式来区分用户进程与内核的不同权限，这种区分被称为双模式操作</p><p>​    两种模式由处理器中一个位来区分，当处理器执行只允许内核态执行的操作时，它会通过位判断是否处于内核态，如果不是，处理器就会触发异常并终止该进程</p><p>8.一些疑问和答案：</p><p>（1）诸如文件读写啦，进程间通信啦，都是内核专属的权利，用户进程是没有权限的，那么平时用的软件是怎么实现该操作的呢？</p><p>​    操作系统提供了给用户进程的服务(即系统调用)，它可以使用户进程在固定位置进入系统空间并使用系统提供的服务，这样就可以解决文件读写之类的问题啦</p><p>​    所有系统调用的地址存放在系统调用表里（存储的是系统自带的系统调用的地址！！）</p><h3 id="​注意！！！"><a href="#​注意！！！" class="headerlink" title="​注意！！！"></a>​注意！！！</h3><p>​    编程中新建一个数组是用户进程使用自己已分配的一段内存，并不需要进入内核态！！！</p><p>​    而从磁盘中读取文件，写入文件，处理异常等操作都需进入内核态！！</p><p>（2）如果同时有多个中断发生时，处理器将怎么处理？</p><p>​    处理器会先处理优先级高的中断。如果在处理一个中断过程中出现另一个优先级更高的中断信号，那么处理器可能切换处理新的中断信号，这时会出现多重中断。</p><p>​    为避免中断耗费过多时间，在处理中断信号时会屏蔽某一优先等级的中断信号或某个单独的中断信号</p><p>​    </p><p>（3）怎么控制用户进程获取系统调用？</p><p>​    所有中断服务程序的地址按顺序存储在中断向量表中。向量表控制用户进程进入系统的地址，保护内核不被篡改。处理器可以利用中断向量表转入中断服务程序</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-031动态规划</title>
      <link href="/2018/10/10/Project-Euler-031/"/>
      <url>/2018/10/10/Project-Euler-031/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/Project-Euler-031/title.jpg" alt="title"></p><a id="more"></a><h3 id="031题："><a href="#031题：" class="headerlink" title="031题："></a>031题：</h3><p>题意：</p><p>​    英国的货币单位包括英镑£和便士p，在流通中的硬币一共有八种：</p><blockquote><p>1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), £2 (200p)</p></blockquote><p>​    以下是组成£2的其中一种可行方式：</p><blockquote><p>1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p</p></blockquote><p>不限定使用的硬币数目，组成£2有多少种不同的方式？</p><p>思路：</p><p>​    题目很简单～有一个坑点。</p><p>​    起初的DP推导式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0] = 1;//dp[i]代表当有i元时的组合方案数</span><br><span class="line">for (d i = 1; i &lt;= 200; i++) &#123;</span><br><span class="line">    for (d j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">        d t = i - money[j];</span><br><span class="line">        if (t &gt;= 0) &#123;</span><br><span class="line">            dp[i] += dp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码会造成重复，比如当i为5的时候，dp[4] = 5，它把1+1+1+1，2+1+1，1+2+1，1+1+2，2+2分别当成了一种。</p><p>​    我们知道，2+1+1，1+2+1，1+1+2它们三个应该算作一种，应当怎样避免这种重复呢？</p><p>​    我们可以通过创建二维数组dp【i】【j】（代表共有i元钱，其中最大的钱为money[j]的方案数）来解决（确定好最大的钱，以后添加的钱只能大于等于最大的钱，就可以避免重复问题，比如上面i为4时，只会出现1+1+1+1，1+1+2，2+2三种情况）。最后累加dp【200】【0】～dp【200】【7】,即是正确答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line"></span><br><span class="line">d dp[205][10]; //dp[i][j]代表共有i元钱，其中最大的钱为money[j]的方案数</span><br><span class="line">d money[8] = &#123;1, 2, 5, 10, 20, 50, 100, 200&#125;;//存储钱的种类</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d ans = 0;//存储总方案数</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (d i = 1; i &lt;= 200; i++) &#123;</span><br><span class="line">        for (d j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">            d t = i - money[j];</span><br><span class="line">            if (t &gt;= 0) &#123;</span><br><span class="line">                for (d p = 0; p &lt;= j; p++) &#123;//避免重复计算精髓</span><br><span class="line">                    dp[i][j] += dp[t][p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 0; i &lt; 8; i ++) &#123;</span><br><span class="line">        ans += dp[200][i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为：<strong>73682</strong>   Over～</p><p>—————————分割线————————</p><p>​    呃呃呃，上面二维DP数组可以简化为一维，就是完全背包了。。今天脑子不好使了～</p><p>​    推导式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0] = 1;//dp[i]代表当有i元时的组合方案数</span><br><span class="line">for (d j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">for (d i = 1; i &lt;= 200; i++) &#123;</span><br><span class="line">        d t = i - money[j];</span><br><span class="line">        if (t &gt;= 0) &#123;</span><br><span class="line">            dp[i] += dp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    没错。。就是将两个for循环的位置调换一下，就可解决重复问题，因为遍历钱的种类数在外层，就使得后面钱种类一定大于等于前面</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-014记忆化搜索</title>
      <link href="/2018/10/09/Project-Euler-014/"/>
      <url>/2018/10/09/Project-Euler-014/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/09/Project-Euler-014/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="014题："><a href="#014题：" class="headerlink" title="014题："></a>014题：</h3><p>​    今天做了将近10道Project Euler上的题，要么和之前写的题型类似，要么简单，吐血～</p><p>​    14题虽然简单些，但是胜在之前没说过，就一并讲一下吧。。。</p><p>题意：</p><p>​    在正整数集上定义如下的迭代序列：</p><p>​    n → n/2 （若n为偶数）<br>​    n → 3n + 1 （若n为奇数）</p><p>​    从13开始应用上述规则，我们可以生成如下的序列：</p><p>​    13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p><p>​    可以看出这个序列（从13开始到1结束）共有10项。尽管还没有被证明，但我们普遍认为，从任何数开始最终都能迭代至1（“考拉兹猜想”）。</p><p>​    从小于一百万的哪个数开始，能够生成最长的序列呢？</p><p>​    <strong>注：</strong> 序列开始生成后允许其中的项超过一百万</p><p>思路：</p><p>​    如果采用暴力的话，从1到1000000分别枚举，每个数再模拟一下它变成1的过程。时间复杂度估计会大到爆炸吧～</p><p>​    接下来我就想能不能逆推，推出最长的那个数。但是题上说允许迭代的过程中存在大于1000000的数，那么逆推暂时没有想到终止条件是什么。Orz～</p><p>​    好吧。。这题我只想到一种思路能在1s内算出来，就是采用记忆化搜索！由于每个数它的用dp[]数组来记录每个数的迭代步数(初始化dp[1] = 0)。</p><p>​    例如：3的迭代过程是：3-&gt;10-&gt;5-&gt;16-&gt;8-&gt;4-&gt;2-&gt;1</p><p>​    此时dp[2] = 1;dp[4] = 2; dp[8] = 3; dp[16] = 4; dp[5] = 5; dp[10] = 6;dp[3] = 7;</p><p>​     我们再看4的迭代时，直接可由dp[4] = 2得到步数为2；</p><p>​    以此类推，看5的迭代时，可由dp[5] = 5得到步数为5;</p><p>​    看6的迭代时，6-&gt;3，可由dp[3] + 1得到dp[6] = 7；</p><p>​    这样就省略了很多很多的中间过程，优化了效率，典型的用空间换取时间。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define N 1000000</span><br><span class="line"></span><br><span class="line">d dp[N + 5];        //记忆化数组</span><br><span class="line">d maxx = 0;         //记录最大步数</span><br><span class="line"></span><br><span class="line">d dfs (ll n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &lt;= N &amp;&amp; dp[n] != 0) &#123;         //该步就相当于剪枝</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &amp; 1) &#123;</span><br><span class="line">        d t = 1 + dfs(n * 3 + 1);</span><br><span class="line">        if (n &lt;= N) &#123;</span><br><span class="line">            dp[n] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        d t = 1 + dfs(n / 2);</span><br><span class="line">        if (n &lt;= N) &#123;</span><br><span class="line">            dp[n] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    ll ans;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (ll i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        d res = dfs(i);</span><br><span class="line">        if (maxx &lt; res) &#123;</span><br><span class="line">            maxx = res;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案为：<strong>837799</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-005短除法</title>
      <link href="/2018/10/09/Project-Euler-005/"/>
      <url>/2018/10/09/Project-Euler-005/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/09/Project-Euler-005/title.jpg" alt="title"></p><a id="more"></a><h3 id="005题："><a href="#005题：" class="headerlink" title="005题："></a>005题：</h3><p>题意：</p><p>​    2520是最小的能够被1到10整除的数。</p><p>​    最小的能够被1到20整除的正数是多少？</p><p>思路：</p><p>​    我们能够想到，既然是12的倍数，那么也一定会是1，2，3，4，6的倍数；既然是14的倍数，也一定会是7的倍数；既然是15的倍数，也一定是5的倍数；既然是16的倍数，也一定是8的倍数；既然是18的倍数，也一定是9的倍数；既然是20的倍数，那一定也是10的倍数</p><p>​    所以，我们只需要考虑11～20的最小公倍数即可</p><p>​    思路一：​    利用辗转相除法求11和12的最大公因子，进而通过<code>11*12/gcd(11,12)</code> 来求它们的最小公倍数，然后求最小公倍数和13的最小公倍数并更新最小公倍数，循环上述过程直到20</p><p>​    思路二：我们知道，两个数的最小公倍数，相比它俩相乘，缩小了它俩的公共因数倍。</p><p>​    类比到多个数，比如： 2，3， 6， 12，16：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 = 2； 3 = 3； 6 = 3*2； 12 = 3 * 2* 2；16 = 2 * 2 * 2 * 2；</span><br></pre></td></tr></table></figure><p>​    我们发现：</p><p>​    公因子2在2中存在1次，在6中存在1次，在12中存在2次，在16中存在4次</p><p>​    公因子3在3中存在1次，在6中存在1次，在12中存在1次</p><p>​    那么它们的最小公倍数，就是<code>pow（2，4）* pow（3，1）= 48</code></p><p>​    也就是说，每个因子找这些数中它出现的最大次数，其它数都是重复的，可以去掉，然后累乘每个因子的最大次数幂即为最小公倍数。</p><p>​    除了运算速度快之外，还可以避免辗转相除法取余1e9+7导致错误的尴尬（只有累乘不会出错，但是中途取余求gcd会造成错误）</p><p>​    兴冲冲的发现了这个规律后，结果一百度发现已经存在这个定理了，叫短除法。。哎，优队算法就这样没了。。。</p><p>代码：</p><p>​    和之前一样，暴力求法不写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d a[10];</span><br><span class="line">ll ans = 1;         //最终结果</span><br><span class="line">ll prime[8] = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125;;  //20以内的质数</span><br><span class="line"></span><br><span class="line">//用于存储11～20</span><br><span class="line">void init() &#123;</span><br><span class="line">    for (d i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        a[i] = 11 + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速幂函数</span><br><span class="line">ll quick (ll a, d b) &#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) res *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//短除法</span><br><span class="line">void short_division() &#123;</span><br><span class="line">    for (d i = 0; i &lt; 8; i ++) &#123;</span><br><span class="line">        d maxx = 0;                 //对于11～20，能够循环整除prime[i]的最大次数</span><br><span class="line">        for (d j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            d inx = 0;              //记录当前数能循环整除prime[i]的最大次数</span><br><span class="line">            while (a[j] % prime[i] == 0) &#123;</span><br><span class="line">                a[j] /= prime[i];</span><br><span class="line">                inx ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxx = max(maxx, inx);</span><br><span class="line">        &#125;</span><br><span class="line">        ans *= quick(prime[i], maxx);   //结果乘质因子的最大循环整除次数次幂</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);    //最后结果为11～20，也就是1～20的最小公倍数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    short_division();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：<strong>232792560</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-030思维</title>
      <link href="/2018/10/09/Project-Euler-030/"/>
      <url>/2018/10/09/Project-Euler-030/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/09/Project-Euler-030/title.jpg" alt="title"></p><a id="more"></a><p>跳题是因为有些题简单没有写的必要，或者难度大需要在后面写，循序渐进～</p><h3 id="030题："><a href="#030题：" class="headerlink" title="030题："></a>030题：</h3><p>该题与Project Euler-034和Project Euler-036类似，有时间的童鞋可以看一下那两道题</p><p>题意：</p><p>有三个数可以写成它们各位数字的四次幂之和：</p><blockquote><p>1634 = 1^4 + 6^4 + 3^4 + 4^4<br>8208 = 8^4 + 2^4 + 0^4 + 8^4<br>9474 = 9^4 + 4^4 + 7^4 + 4^4</p></blockquote><p>由于1 = 1^4不是一个和，所以这里并没有把它包括进去。</p><p>这些数的和是1634 + 8208 + 9474 = 19316。</p><p>找出所有可以写成它们各位数字的五次幂之和的数，并求这些数的和。</p><p>思路：</p><p>​    遇到这个题，我们首先需要确定它的上界是什么，不然暴力枚举都不知道终止条件。</p><p>​    对于每一位来说，9^5最大，因此我们通过每位都是9的数来确定它的上界。我们设上限为n</p><p>​    当n为二位数时，最大累计和为六位数;  当n为三位数时，最大累计和为六位数;  当n为四位数时，最大累计和为六位数;  当n为五位数时，最大累计和为六位数;  当n为六位数时，最大累计和为六位数; 当n为七位数时，最大累计和为六位数。</p><p>​    从上边就可以看出，当一个数为7位数及更大，它的最大累计和都不足该数的位数，说明n的上限为6位数。</p><p>​    因此，我有以下两个思路：</p><p>​    思路一：求出6个9^5的和为354294，然后遍历2～354294之间的数，只要满足条件就累加求和，时间复杂度为1e6</p><p>​    思路二：分别求出0～9的五次方（快速幂），然后遍历位数（从2～6），多少位就相当于取多少个数（利用dfs剪枝），只需判断这些数的五次方和是否为与位数相同且等同与这几个数，相同就累加，时间复杂度大概1e5（就相当于有10种球，每种球无限个，同时取2个，3个，4个，5个，6个的方案数，经计算只有7997种）</p><p>代码：</p><p>​    老规矩，暴力代码不写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int num[10];</span><br><span class="line">int ans;</span><br><span class="line">int book1[10], book2[10];</span><br><span class="line">int sss = 0;</span><br><span class="line">//快速幂函数</span><br><span class="line">int quick (int a, int b) &#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1)  res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//预处理0～9的五次方</span><br><span class="line">void init () &#123;</span><br><span class="line">    memset (num, 0, sizeof(num));</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        num[i] = quick (i, 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//dfs剪枝求当为n位数的不同数字组合</span><br><span class="line">void dfs(int now, int inx, int n, int val) &#123;</span><br><span class="line">    if (inx == n) &#123;</span><br><span class="line">        sss ++;       //计算枚举的个数</span><br><span class="line">        memset (book2, 0, sizeof(book2));</span><br><span class="line">        int vall = val, flag = 0;</span><br><span class="line">        while (vall) &#123;</span><br><span class="line">            book2[vall % 10] ++;</span><br><span class="line">            vall /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">            if (book1[i] != book2[i]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            ans +=val;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //剪枝精髓</span><br><span class="line">    for (int i = now; i &lt; 10; i++) &#123;</span><br><span class="line">        book1[i] ++;</span><br><span class="line">        dfs (i, inx + 1, n, val + num[i]);</span><br><span class="line">        book1[i] --;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ans = 0;</span><br><span class="line">    for (int i = 2; i &lt;= 6; i ++) &#123;</span><br><span class="line">        memset(book1, 0, sizeof(book1));</span><br><span class="line">        dfs(0, 0, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    //printf(&quot;%d\n&quot;, sss);  //真正枚举的个数，只有7997</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出答案为: <strong>443839</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-003思维+线性筛</title>
      <link href="/2018/10/08/Project-Euler-003/"/>
      <url>/2018/10/08/Project-Euler-003/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/08/Project-Euler-003/title.jpg" alt="title"></p><a id="more"></a><h3 id="003题："><a href="#003题：" class="headerlink" title="003题："></a>003题：</h3><p>题意：</p><p>​    13195的所有质因数为5、7、13和29。</p><p>​    600851475143最大的质因数是多少？</p><p>思路：</p><p>​    600851475143大概是6e11，如果纯暴力找它的每个因子，然后再判断每个因子是不是质数，时间复杂度大约是1e22，家用电脑估计一个小时也跑不完吧～</p><p>​    有些人继续优化，说可以用线性筛求[2,600851475143]范围内的质数，然后找最大满足是600851475143因子的质数。这样时间复杂度是1e11，家里电脑依然跑不完～而且线性筛需要开两个1e11的数组分别用来判断是否为质数和存质数，我们无法开这么大的数组。</p><p>​    这时候，我们就需要明白一点，600851475143的临界值是多少？嗯，这个数的临界值为（int）(sqrt(600851475143))，为什么呢？</p><p>​    仔细想一下，如果最大质因子小于等于(int)(sqrt(600851475143))，那么我们只需要线性筛前(int)(sqrt(600851475143))就可以找出它的最大质因子。</p><p>​    如果最大质因子大于(int)(sqrt(600851475143))，那么600851475143中不可能同时存在两个大于(int)(sqrt(600851475143))的质因子（如果存在，两个质因子相乘就大于600851475143啦），所以我们可以通过除以(int)(sqrt(600851475143))以内所有600851475143的质因子，最后剩下的数，就是大于(int)(sqrt(600851475143))的质因子。</p><p>​    而(int)(sqrt(600851475143))为<strong>775146</strong>,用线性筛求775146范围内的质数时间复杂度只有1e6左右，家用电脑一秒钟以内肯定能求出来～</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define len 775150</span><br><span class="line">ll n = 600851475143;</span><br><span class="line">//prime[]用于存素数</span><br><span class="line">d prime[len];</span><br><span class="line">//choose[i]用于判断i是否为素数,0是，1不是</span><br><span class="line">bool choose[len];</span><br><span class="line"></span><br><span class="line">ll init() &#123;</span><br><span class="line">    ll maxx = 0; //用来存储最大的质因子</span><br><span class="line">    prime[0] = 0; //用来记录质数个数</span><br><span class="line">    memset (choose, 0, sizeof(choose));</span><br><span class="line">    for (d i = 2; i &lt; len; i ++) &#123;</span><br><span class="line">        if (!choose[i]) &#123;</span><br><span class="line">        //如果i是素数就添加到prime中</span><br><span class="line">            prime [++prime[0]] = i;</span><br><span class="line">            //如果i是不断缩小的n的因子，则n循环累除i</span><br><span class="line">            if(n % i == 0) &#123;</span><br><span class="line">                while (n % i == 0) &#123;</span><br><span class="line">                    n /= i;</span><br><span class="line">                &#125;</span><br><span class="line">                //更新质因子的最大值</span><br><span class="line">                maxx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //线性筛的性质</span><br><span class="line">      for (d j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt; len; j++) &#123;     </span><br><span class="line">            choose[i * prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果此时n不为1，说明最大质因子大于(int)sqrt(600851475143)</span><br><span class="line">    if (n != 1) &#123;</span><br><span class="line">        maxx = n; //那么更新最大质因子</span><br><span class="line">    &#125;</span><br><span class="line">    return maxx;//最后返回值即为结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll ans = init();</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后输出答案为<strong>6857</strong> ，Over～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-002矩阵快速幂+二分</title>
      <link href="/2018/10/08/Project-Euler-002/"/>
      <url>/2018/10/08/Project-Euler-002/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/08/Project-Euler-002/title.jpg" alt="title"></p><a id="more"></a><h3 id="002题："><a href="#002题：" class="headerlink" title="002题："></a>002题：</h3><p>题意：</p><p>​    斐波那契数列中每一项都是前两项的和。由1和2开始生成的斐波那契数列前10项为：</p><p>​    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>​    考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和</p><p>思路：</p><p>​    本题也想到了两个思路：</p><p>​    思路一：由于斐波那契数列增长速度非常快，所以不超过四百万的斐波那契数顶多有100个，极限了。因此我们可以通过while(Fib[i] &lt;= 4e6) 循环查找出为偶数的项并累加求和</p><p>​    思路二（有点脱了裤子放屁的感觉～）：我们通过斐波那契数列的性质可知，对于该斐波那契数列：</p><p>​    1 2 3 5 8 13 21 34…..</p><p>​    有以下两个有用的性质：</p><p>​    1.  S(n) = Fib[n + 2] - 2     </p><p>​        //S(n)代表斐波那契数列前n项和 ，Fib[i]代表下标为i的斐波那契数</p><p>​    2.  对于前下角标为3的倍数 + 2个斐波那契数，项数为偶数的和等于项数为奇数的和 + 1</p><p>​    </p><p>​    因此我们可以通过二分法套矩阵快速幂来求取4e6以内的最大斐波那契数，并返回该数在斐波那契数中的下角标n，然后用矩阵快速幂求Fib[n + 2]，求的n + 2的下角标为3的倍数 + 2，所以偶数项的和为（Fib[n+2] - 1） / 2;</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">int N = 2;</span><br><span class="line">//用于矩阵相乘</span><br><span class="line">void multi(ll *a, ll *b) &#123;</span><br><span class="line">    ll c[N][N];</span><br><span class="line">    memset(c, 0, sizeof(c));</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            for (int k = 0; k &lt; N; k++) &#123;</span><br><span class="line">                c[i][j] += *(a + i * N + k) * *(b + k * N + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            *(a + i * N + j) = c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//矩阵快速幂</span><br><span class="line">void quick(ll *a, ll n) &#123;</span><br><span class="line">    ll ans[N][N];</span><br><span class="line">    memset(ans, 0, sizeof(ans));</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        ans[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        if (n &amp; 1) &#123;</span><br><span class="line">            multi(ans[0], a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">        multi(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            *(a + i * N + j) = ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//二分法找4e6以内最大斐波那契数，并返回该下角标</span><br><span class="line">int erfen(int l, int r, ll val) &#123;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">        ll root[N][N], a[N][N];</span><br><span class="line">        memset(root, 0, sizeof(root));</span><br><span class="line">        memset(a, 0, sizeof(a));</span><br><span class="line">        root[1][0] = 1;</span><br><span class="line">        a[0][1] = 1; a[1][0] = 1; a[1][1] = 1;</span><br><span class="line">        quick(a[0], mid);</span><br><span class="line">        multi(a[0], root[0]);</span><br><span class="line">        ll res = a[1][0];</span><br><span class="line">        if(res &lt;= val) &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//感觉不会超过100个啦，就二分的下标1到100</span><br><span class="line">    int res = erfen(1, 100, 4000000);</span><br><span class="line">    ll root[N][N], a[N][N], sum;</span><br><span class="line">    memset(root, 0, sizeof(root));</span><br><span class="line">    memset(a, 0, sizeof(a));</span><br><span class="line">    root[1][0] = 1;</span><br><span class="line">    a[0][1] = 1; a[1][0] = 1; a[1][1] = 1;</span><br><span class="line">    if (res % 3 == 2) &#123;</span><br><span class="line">        quick(a[0], res + 2);</span><br><span class="line">        multi(a[0], root[0]);</span><br><span class="line">        sum = (a[1][0] - 1 )/ 2;</span><br><span class="line">    &#125;else if(res % 3 == 1) &#123;</span><br><span class="line">        //由于满足res % 3 == 2 就不再考虑</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //由于满足res % 3 == 2 就不再考虑</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后求出结果为：<strong>4613732</strong></p><p>​    第二个想法虽好，但由于最后发现下角标的值才40多！！可能二分+矩阵快速幂比纯暴力还慢。。。就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-001容斥原理</title>
      <link href="/2018/10/08/Project-Euler-001/"/>
      <url>/2018/10/08/Project-Euler-001/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/08/Project-Euler-001/title.jpg" alt="title"></p><a id="more"></a><p>欧拉计划里面都是一些数学题，可以通过编程来解决它，只需要输入最后的结果即可。从简单到难，一点一点做，加油！</p><h3 id="001题："><a href="#001题：" class="headerlink" title="001题："></a>001题：</h3><p>题意：</p><p>​    如果我们列出10以内所有3或5的倍数，我们将得到3、5、6和9，这些数的和是23。</p><p>​    求1000以内（不包括1000）所有3或5的倍数的和</p><p>思路：</p><p>​    有两个：1.用暴力的方法遍历从1～999，只要是3或5的倍数就累加</p><p>​            2.利用容斥原理，用3的倍数的和 + 5的倍数的和 - 15的倍数的和</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int num3 = 999 / 3;//求出1000以内3的倍数的个数</span><br><span class="line">    int num5 = 999 / 5;//求出1000以内5的倍数的个数</span><br><span class="line">    int num15 = 999 / 15;//求出1000以内15的倍数的个数</span><br><span class="line">    //求出1000以内3的倍数的数的累加和</span><br><span class="line">    int ans3 = (1 + num3) * num3 / 2 * 3;</span><br><span class="line">    //求出1000以内5的倍数的数的累加和</span><br><span class="line">    int ans5 = (1 + num5) * num5 / 2 * 5;</span><br><span class="line">    //求出1000以内15的倍数的数的累加和</span><br><span class="line">    int ans15 = (1 + num15) * num15 / 2 * 15;</span><br><span class="line">    //通过容斥原理求得结果为233168</span><br><span class="line">    printf (&quot;%d\n&quot;, ans3 + ans5 - ans15);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Over～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十七)</title>
      <link href="/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%B8%83/"/>
      <url>/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/07/C语言查缺补漏-十七/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十七：指针空间补充与堆内存保存函数中的值"><a href="#忽略点十七：指针空间补充与堆内存保存函数中的值" class="headerlink" title="忽略点十七：指针空间补充与堆内存保存函数中的值"></a>忽略点十七：指针空间补充与堆内存保存函数中的值</h3><p>​    关于之前讲解就不再重复，点➡️ <a href="http://www.ivan-zcy.top/2018/10/02/C语言查缺补漏-6/">点我</a> 跳转</p><h4 id="补充1"><a href="#补充1" class="headerlink" title="补充1:"></a>补充1:</h4><p>​    除了之前讲的malloc和calloc外，还有一个特别重要的函数——realloc()，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* realloc (void* ptr, size_t size);</span><br></pre></td></tr></table></figure><p>​    realloc可以将已分配的堆内存扩充到size的大小，并返回扩充后的内存起始地址（注意！当第一个参数所指向的内存空间不够扩大到size时，realloc将会重新分配一段足够大的内存空间，将旧内存空间中的内容拷贝到新地址并释放旧内存空间）</p><h4 id="补充2"><a href="#补充2" class="headerlink" title="补充2:"></a>补充2:</h4><p>​    易错点：对于下面代码，会输出什么？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* test = &quot;test&quot;;</span><br><span class="line">test[0] = &apos;j&apos;;</span><br><span class="line">printf(&quot;%s\n&quot;, test);</span><br></pre></td></tr></table></figure><p>​    既不是”test”，也不是”jest”，也不是”j”， 由于”test”存在内存的常量区，因此不能修改</p><h4 id="补充3"><a href="#补充3" class="headerlink" title="补充3:"></a>补充3:</h4><p>​    由于函数执行完毕后会释放掉函数所占用的栈内存，所以在函数中定义的东西就会随栈内存的释放而消失。那么，我们怎么样才能保存函数中一些有用的信息呢？</p><p>​    我暂时就想到以下3种方法，欢迎大佬们补充：</p><p>​    ——利用返回值：</p><p>​    我们可以利用返回值把函数中的某一个值传入到main函数中，如果有多个值，我们也可以专门定义一个结构体，把多个值放到结构体中，返回该结构体（如果你们不嫌麻烦的话）例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int age;</span><br><span class="line">    char address[15];</span><br><span class="line">&#125;;</span><br><span class="line">node fun() &#123;</span><br><span class="line">    node t;</span><br><span class="line">    int age = 12;</span><br><span class="line">    char name[10] = &quot;Ivan&quot;;</span><br><span class="line">    char address[15] = &quot;Shan Dong&quot;;</span><br><span class="line">    t.age = age;</span><br><span class="line">    strcpy(t.name, name);</span><br><span class="line">    strcat(t.address, address);</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    node k = fun();</span><br><span class="line">    printf(&quot;%s\n&quot;, k.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ——利用静态变量</p><p>​    我们可以在函数中声明该变量为静态变量，这样变量就不会随着函数的结束而消失，而是直到整个程序结束后才会释放。但是声明静态变量有个局限性，就是该变量的作用域！！在函数内定义的静态变量，它虽然不会随着函数的消失而消失，但它只能作用于函数中！！例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">    static int a = 0;</span><br><span class="line">    a ++;</span><br><span class="line">    printf(&quot;%d\n&quot;, a);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    fun();//此时a输出1</span><br><span class="line">    fun();//此时a输出2 表明上次fun函数释放后a的值保存了下来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ——创建堆内存存储并返回指向堆内存空间的指针</p><p>​    感觉这是最好的解决办法了，专门声明一块堆内存空间，然后把函数中想保存的东西存到里面，然后返回指向该内存空间的指针。这样就不会随函数的消失而消失，而且无论什么情况下都可通过指针去调用。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* fun() &#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    int *p = (int *)malloc(5 * sizeof(int));</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        p[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int *k = fun();</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, k[i]);//输出为1 2 3 4 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ​        </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十六)</title>
      <link href="/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E5%85%AD/"/>
      <url>/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/07/C语言查缺补漏-十六/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十六：EOF-NULL-0的区别"><a href="#忽略点十六：EOF-NULL-0的区别" class="headerlink" title="忽略点十六：EOF NULL  \0的区别"></a>忽略点十六：EOF NULL  \0的区别</h3><h4 id="——关于EOF："><a href="#——关于EOF：" class="headerlink" title="——关于EOF："></a>——关于EOF：</h4><p>​    在C语言中，关于EOF的宏定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define EOF -1</span><br></pre></td></tr></table></figure><p>​    也就是说，EOF其实就是-1，由于ASCII代码值的范围是从0～255，不会存在-1的情况，因此可以用EOF作为文件(必须是文本文件)结束标志或输入结束标志！！例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (scanf (&quot;%d&quot;, &amp;a) != EOF) &#123;&#125;</span><br></pre></td></tr></table></figure><p>​    EOF结束在windows对应按键是CTRL+Z，在linux对应按键是CTRL+D    </p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="——关于NULL："><a href="#——关于NULL：" class="headerlink" title="——关于NULL："></a>——关于NULL：</h4><p>​    在C语言中，关于NULL的宏定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#undef NULL</span><br><span class="line">#if defined(__cplusplus)//如果存在__cplusplus这个宏定义</span><br><span class="line">#define NULL 0//NULL代表0</span><br><span class="line">#else//否则</span><br><span class="line">#define NULL ((void *)0)//NULL代表((void *)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    由于__cplusplus宏定义只存在于C++中，所以在C语言里，NULL代表的是值为0的void型指针，称为空地址；</p><p>​    空地址真的是空吗？我们通过下面代码来输出一下NULL指针的地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p=NULL;</span><br><span class="line">printf(&quot;%p\n&quot;,p);//输出结果为0x00000000</span><br></pre></td></tr></table></figure><p>​    也就是说，NULL是用来代表指针为空的，但NULL也有地址，它并不是真正意义的空！！！它的作用是用来防止出现野指针的。从下面代码中就可以看出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p;</span><br><span class="line">if(p == NULL) &#123;</span><br><span class="line">    printf(&quot;Ok\n&quot;);//不会执行，表明野指针并不为空</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%p\n&quot;, p);//输出为一个随机地址</span><br></pre></td></tr></table></figure><p>​    </p><p>​    我们可以使用NULL作为空指针常量使用，例如：<code>int<em> p = NULL;</em></code>也可以直接使用0作为空指针常量，例如：<code>int p = 0;</code> </p><p>​    所以NULL常常用于指代对象或指针为空。例如用在链表中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node* p = root;</span><br><span class="line">while (p -&gt; next != NULL) &#123;</span><br><span class="line">//前提条件是最后一个节点的next成员已经赋值为NULL，不然野指针并不为NULL</span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="——关于-0"><a href="#——关于-0" class="headerlink" title="——关于\0:"></a>——关于\0:</h4><p>​    ‘\0’是一个ASCII控制字符(转义字符)，它代表空字符，作为字符串结尾字符～</p><p>​    比如用在某个字符串的遍历中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char s[15] = &quot;hello ACM&quot;;</span><br><span class="line">int i = 0;</span><br><span class="line">while (s[i] != &apos;\0&apos;) &#123;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    至于为什么拿出这三个来讲，是因为有时在while()里面对字符串，文本文件，指针之类的操作，!= 后加什么有时候迷糊～</p><p>​    就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十五)</title>
      <link href="/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%BA%94/"/>
      <url>/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/07/C语言查缺补漏-十五/titile.jpg" alt="titile"></p><a id="more"></a><h3 id="忽略点十五：strtok-的使用"><a href="#忽略点十五：strtok-的使用" class="headerlink" title="忽略点十五：strtok()的使用"></a>忽略点十五：strtok()的使用</h3><p>​    在ACM中，常常使用字符串函数诸如：strlen求字符串长度，strcpy字符串复制，strcmp字符串比较，strcat字符串追加等等，但忽略了一个特别重要的函数——strtok()</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* strtok(char* str, const char* delimiters);</span><br></pre></td></tr></table></figure><p>​        它用于将字符串<code>str</code>用分隔符<code>delimiters</code>分为更短的字符串。<code>delimiters</code>是含多个字符的字符串，其中每个字符都是一个独立的分隔符。如<code>\n\t</code>中<code>\n</code>和<code>\t</code>都是分隔符。</p><p>​    需要注意！！<code>strtok</code>函数会改变源字符串<code>str</code>，返回值指向第一个由非分隔符字符的指针的分割片段；之后每次调用，都要把<code>NULL</code>作为第一个参数，如果调用成功就会返回下一个分割片段，如果已经到达<code>str</code>的末尾则会返回<code>NULL</code></p><p>​    具体使用如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char s[55] = &quot;hello,My name is Ivan,I&apos;m fifteen years|old&quot;;</span><br><span class="line">char s1[5] = &quot;, |&quot;;</span><br><span class="line">char *p = strtok(s, s1);  //利用s1中分隔符将s分隔开</span><br><span class="line">printf(&quot;%s\n&quot;, s);//输出hello</span><br><span class="line">printf(&quot;%ld\n&quot;, strlen(s));//输出5，代表s只剩分隔符分隔后的第一块</span><br><span class="line">while (p != NULL) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, p);</span><br><span class="line">    //循环输出每一块</span><br><span class="line">    //分别为hello,My,name,is,Ivan,I&apos;m,fifteen,years,old</span><br><span class="line">    p = strtok(NULL, s1);//循环的使用方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS High问题及解决方法(转载)</title>
      <link href="/2018/10/06/MacOS-High%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2018/10/06/MacOS-High%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/MacOS-High问题及解决方法-转载/title.jpg" alt="title"></p><a id="more"></a><h2 id="原文地址：https-blog-csdn-net-jackymvc-article-details-78256120"><a href="#原文地址：https-blog-csdn-net-jackymvc-article-details-78256120" class="headerlink" title="原文地址：https://blog.csdn.net/jackymvc/article/details/78256120"></a>原文地址：<a href="https://blog.csdn.net/jackymvc/article/details/78256120" target="_blank" rel="noopener">https://blog.csdn.net/jackymvc/article/details/78256120</a></h2><p><div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                                            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"><br>                        <div class="htmledit_views"><br>OSX的High Sierra正式版出来半个月有余，听着什么自媒体、科技媒体吹这系统多么牛B，手贱点了升级，好在升级过程中没有遇到各种坑还挺顺利的，但是我没有感觉多么好用的同时，却给我带来不大不小的麻烦。且听我一一道来……</div></div></p><p>10.13版本加强了权限的限制，尤其是对/usr/local目录，默认开通 SIP （System Intergrity Protection），它禁止了软件以root身份在Mac上运行，不管你是在终端中如何运行</p><p>MyMBP:~ Jacky$ sudo chown -R $(whoami) /usr/local ，返回给你的就是 chown: Operation not permitted，哪怕你是用root的身份。</p><p>有些软件在运行过程中需要对/usr/local下的文件读写，比如你更新ruby，起因是我要通过homebrew来安装zookeeper</p><p>brew install zookeeper</p><p>运行后下载了zookeeper，但是安装过程中，报了一个ruby的错误（原谅我没有截图），大意是ruby 2.3.0已经不被High Sierra支持了，看样子是要更新ruby</p><p>顺序做了一些操作，都没有起什么作用</p><p>rvm -v发现是1.19.3版本最新的已经到1.29.3了</p><p>ruby -v版本是2.3.0，最新已经到2.4.2了</p><p>rvm install 2.4.2也是由于权限问题安装不了</p><p>看来只有关掉SIP了</p><p>1.重启Mac，按住Command + R键直到Apple Logo出现，进入Recovery Mode模式（我感觉我是按了好半天）</p><p>2.点击工具里的Terminal（终端）</p><p>3.输入csrutil disable，之后回车</p><p>4.重启Mac</p><p>5.重启完成后，终端中输入sudo chflags norestricted /usr/local &amp;&amp; sudo chown -R $(whoami):admin /usr/local</p><p>成功执行，没有报操作不允许了</p><p>（如果想重新开启安全设置，则重复1、2步骤，输入csrutil enable就可以了）</p><p>更新rvm工具：curl -L get.rvm.io | bash -s stable</p><p>rvm install 2.4.2（这次可以正确安装ruby了，别问我为什么是2.4.2版本）</p><p>然后就是安装zookeeper</p><p>brew install zookeeper（这次也正确安装了）</p><p>后来又重启过一次，发现我的mysql不能开机启动了</p><p>在系统偏好设置最下方找到MySQL的图标，打开后发现mysql已经停止，且有一行警告：the /usr/local/mysql/data directory is not owned by the ‘mysql’ or ‘_mysql’ user</p><p>这个好办：sudo chown -R mysql /usr/local/mysql/data</p><p>然后就可以启动mysql了</p><p>自从长乔帮主走后，苹果办事越来越不上心了，哪怕是自己的OSX系统，伤心……估计还会有不少童鞋遇到我类似的情况，不妨一试</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十四)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-14/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-14/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-14/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="忽略点十四：gdb的使用"><a href="#忽略点十四：gdb的使用" class="headerlink" title="忽略点十四：gdb的使用"></a>忽略点十四：gdb的使用</h3><p>​    在Linux系统下如果想要调试一个项目，我们应该怎么做？</p><p>​    有些童鞋可能会说：IDE呀！</p><p>​    没毛病老哥～非常标准的答案。除此之外，我们还可以使用gdb，为什么使用gdb，它有什么优势呢？它可以在终端下使用，它短小精悍，功能强大～</p><p>​    嗯嗯嗯，我就是这样说服自己的～</p><p>​    要注意！！使用gdb前，我们在编译项目文件时需加<code>-g</code>作为一个编译参数(否则你将看不见函数名、变量名，而只能看到运行时的内存地址)，再通过gdb运行可执行文件，例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o program -g main.c</span><br><span class="line">gdb ./program</span><br></pre></td></tr></table></figure><p>​    执行完上述命令，会看到关于 gdb 的说明和如下所示的调试命令行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>​    </p><p>​    关于gdb的基本使用：</p><p>​        ——输入<code>l</code>（list 首字母)gdb 会列出10行代码，<code>l</code>后可加参数代表从第参数行开始列出（例如希望列出第 2 到11行时，我们可以写<code>l 2</code>）</p><p>​    ——输入<code>b</code>（breakpoint首字母），表示设置程序运行的断点，程序运行到断点处就会暂停运行。<code>b</code>后既可以加函数名作参数，使程序在调用某函数时暂停；也可以加行号作为参数，使程序在运行至某一行时暂停。</p><p>​    ——输入<code>d</code>（Delete breakpoint简写），对应b命令，用于删除断点</p><p>​    ——输入<code>i b</code> ：(info breakpoints简写), 用于查看断点信息</p><p>​    ——输入<code>r</code>（run 首字母），程序会开始运行，并在第一个断点处暂停</p><p>​    ——输入<code>q</code>  (quit首字母)，退出GDB调试环境</p><p>​    ——输入<code>help [cmd]</code> , 如果制定了cmd命令，则显示该命令说明 否则显示全部</p><p>​    ——直接回车：重复上一步命令</p><p>​    ——输入<code>p 表达式</code>（print 的首字母） 表示在当前断点处运行该表达式并查看它的值。例如<code>p ++age[0]</code>表示我们希望让<code>age[0]</code>自增并查看自增后的值（表达式会对之后程序运行造成影响）</p><p>​    ——输入<code>finish</code> ：结束函数</p><p>   ——输入<code>s</code> (step首字母) 程序会执行下一行代码，如果此行代码中有函数调用，则进入该函数</p><p>​    ——输入<code>n</code>（next 的首字母）程序会执行下一行代码，如果此行代码中有函数调用一并执行</p><p>​    ——输入<code>c</code>（continue 的首字母）程序会继续执行到下一个断点处并暂停（如果没有断点就会执行直到结束）</p><p>​    以上就是gdb的简单用法，具体用法请参考官方文档～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十三)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-13/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-13/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-13/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十三：文件操作"><a href="#忽略点十三：文件操作" class="headerlink" title="忽略点十三：文件操作"></a>忽略点十三：文件操作</h3><p>​    我们要想对文件进行读取或写入，需要有一个能够访问到该文件的文件指针（FILE类型）,这样我们就能通过文件指针对文件进行操作啦！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE *fp;//声明文件指针</span><br><span class="line">fp = fopen(文件路径, 访问模式);//指向文件，第一个参数为字符串</span><br></pre></td></tr></table></figure><p>​    关于访问模式：    ——只读：“r”   </p><p>​                    ——只写（覆盖）： “w” </p><p>​                    —— 文件末尾追加： “a”    </p><p>​                    ——可读可写： “r+”或“w+”</p><p>​                    ——二进制文件：“b”</p><p>​                    ——文本文件：“t”</p><p>​    //访问模式可以叠加，例如”rb”代表读取二进制文件</p><p>​    之后我们就可以对文件进行操作啦（如fgetc()函数（读取）和fputc()函数（写入））</p><p>​    ——关于读取：文件指针指向文件后，通过<code>fgetc(fp);</code>获得当前指针之后位置的一个字符，每获得一个字符指针就会自动向后移动一个字符（如果到达文件尾部则会返回<code>EOF</code>）</p><p>​        ——关于写入：通过<code>fputc(‘字符’, fp);</code>方式将字符写入到与<code>fp</code>关联的文件中</p><p>​    文件指针不再使用后需断开关联，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fclose(fp);//若不加此句，程序正常结束后系统会自动为打开的文件调用fclose</span><br></pre></td></tr></table></figure><p>​    举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//省略代码</span><br><span class="line">FILE *p1 = fopen(&quot;路径1&quot;, &quot;r&quot;);</span><br><span class="line">FILE *p2 = fopen(&quot;路径2&quot;, &quot;w&quot;);</span><br><span class="line">char c;</span><br><span class="line">while ((c = fgetc(p1)) != EOF) &#123;//把一个文件内容复制到另一个文件</span><br><span class="line">    fputc(c, p2);</span><br><span class="line">&#125;</span><br><span class="line">fclose(p1);</span><br><span class="line">fclose(p2);</span><br></pre></td></tr></table></figure><h4 id="注意！！！！"><a href="#注意！！！！" class="headerlink" title="注意！！！！"></a>注意！！！！</h4><p>​        在给文件指针命名时，不能使用 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 这三个名字，因为这三个名字是系统内置用于标准输入、标准输出、标准错误的文件指针名</p><p>​    我们可通过 <code>fgetc(stdin);</code> 获得来自标准输入的字符</p><p>​        通过 <code>fputc(ch, stdout);</code> 将 <code>ch</code> 字符输出到标准输出</p><p>​        通过 <code>fputc(ch, stderr);</code> 将 <code>ch</code> 字符输出到标准错误</p><p>​    </p><p>​    除<code>fgetc</code>和<code>fputc</code>外，我们还可以使用<code>fscanf</code>和<code>fprintf</code>函数</p><p>​    我们可以使用fscanf通过文件指针读取：</p><p>​    也可以使用fprintf通过文件指针写出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fscanf(p1, &quot;%c&quot;, &amp;a);//通过文件指针p1获取字符并存储到a中</span><br><span class="line">fprintf(p2, &quot;%c&quot;, a);//通过文件指针p2将字符a写入文件中</span><br></pre></td></tr></table></figure><p>​    这两个函数是不是感觉有点眼熟？对！大家熟悉的<code>scanf</code>和<code>printf</code> 和它们长得很像，那它们之间有关系吗？</p><p>​        答案是有的。<code>scanf</code>可以看作是 <code>fscanf</code>的特例</p><p>​                         <code>printf</code>可以看作是<code>fprintf</code> 的特例</p><p>​    至于为什么，看下面的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fscanf(stdin, &quot;%c&quot;, &amp;a);//等价于下一行</span><br><span class="line">scanf(&quot;%c&quot;, &amp;a);</span><br><span class="line"></span><br><span class="line">fprintf(stdout, &quot;%c&quot;, a);//等价于下一行</span><br><span class="line">printf(&quot;%c&quot;, a);</span><br></pre></td></tr></table></figure><p>​    嗯嗯，上面也说啦，stdin和stdout的实质也是文件指针，分别代表从控制台获取，输出到控制台。</p><p>​    当然啦，stdin和stdout也可以通过fclose关掉，大家可以试一下关掉后还能进行scanf和printf嘛～ 赶紧跑路hahaha</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十二)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-12/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-12/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-12/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十二：main函数参数"><a href="#忽略点十二：main函数参数" class="headerlink" title="忽略点十二：main函数参数"></a>忽略点十二：main函数参数</h3><p>​    大家都知道，main函数的完整格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这两个参数有什么用呢？</p><p>​    <code>main</code>函数第一个参数是整数型，代表命令行参数的个数（系统依据用户输入的参数个数自动生成，非手动输入），第二个参是<code>char *argv[]</code>，也就是char型指针数组，用于储存用户从命令行中传进来的参</p><p>​    例如：在命令行中输入<code>./main hello world</code></p><p>​    此时，<code>argc</code>为 <code>3</code>，<code>argv[0]</code>为<code>./main</code>，<code>argv[1]</code>为<code>hello</code>，<code>argv[2]</code>为<code>world</code></p><p>​    命令行参数默认是由空格分隔，但如果某个参数中含空格我们应该怎么办</p><p>这时我们在输入含空格的参数时要用引号将整个参数包裹起来，例如：</p><p>​    执行<code>./main “hello world” is my greet</code></p><p>​    此时，<code>argc</code>为 <code>5</code>，<code>argv[0]</code>为<code>./main</code>，<code>argv[1]</code>为<code>hello world</code>，<code>argv[2]</code>为<code>is</code>，<code>argv[3]</code>为<code>my</code>，<code>argv[4]</code>为<code>greet</code></p><h5 id="易错点！！！！"><a href="#易错点！！！！" class="headerlink" title="易错点！！！！"></a>易错点！！！！</h5><h5 id="int-main-int-arc-char-argv-中argc取的不是main函数的参数个数！！！"><a href="#int-main-int-arc-char-argv-中argc取的不是main函数的参数个数！！！" class="headerlink" title="int main(int arc, char **argv)中argc取的不是main函数的参数个数！！！"></a>int main(int arc, char **argv)中argc取的不是main函数的参数个数！！！</h5><p>​    main函数个数固定是2！！argc取的是命令行中键入的参数个数！！而不是main函数的参数个数</p><p>​    关于参数的使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;//**argv等价于*argv[]</span><br><span class="line">    for (int i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    main函数的参数也挺有用的，比如你可以设置进入一个软件的两种模式</p><p>​    比如当<code>strcmp(argv[1], “master”) == 0</code>时，进入该软件的管理员模式，其余情况或者无参时进入用户模式等等。</p><p>​    除了上述，main函数参还有很多黑科技！！！等待大家去发现，哈哈哈～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十一)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-11/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-11/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-11/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十一：make命令与Makefile文件"><a href="#忽略点十一：make命令与Makefile文件" class="headerlink" title="忽略点十一：make命令与Makefile文件"></a>忽略点十一：make命令与Makefile文件</h3><p>​    在讲make与Makefile之前，我们需要明白为什么它们的作用和优点是什么？</p><p>​    对于C/C++项目，在编译时我们需要把每个模块的代码都生成为目标文件，然后再将目标文件联编生成一个可执行文件。</p><p>​    编译要输入这么多命令，每次修改一点内容就要重新编译整个工程，是不是特别恶心！！！</p><p>​     这时候，上帝就出现了——<code>make</code>命令，它可以读取当前路径下的<code>Makefile</code>文件，并根据<code>Makefile</code>中的规则描述把源文件生成为可执行的程序文件</p><h5 id="注意，Makefile文件无后缀名！！"><a href="#注意，Makefile文件无后缀名！！" class="headerlink" title="注意，Makefile文件无后缀名！！"></a>注意，Makefile文件无后缀名！！</h5><p>​    <code>Makefile</code>文件中包含了一系列形式如下的规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标: 依赖1 依赖2 ...</span><br><span class="line">命令</span><br></pre></td></tr></table></figure><p>​    例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.o: a.c a.h#表示生成a.o文件需要依赖a.c与a.h</span><br><span class="line">gcc -c -o a.o a.c#生成a.o的命令</span><br></pre></td></tr></table></figure><h5 id="注意！！！每条规则的命令前，必须有一个制表符’-t‘"><a href="#注意！！！每条规则的命令前，必须有一个制表符’-t‘" class="headerlink" title="注意！！！每条规则的命令前，必须有一个制表符’\t‘"></a>注意！！！每条规则的命令前，必须有一个制表符’\t‘</h5><p>​    这样我们想编译生成a.o文件，只需要执行<code>make a.o</code>即可。（为了提高效率，该命令只有a.o不存在或者a.c与a.h中至少有一项变化时才会真正执行）</p><p>​    </p><p>​    对于Makefile文件中存在多条规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main: a.o m.o</span><br><span class="line">    gcc -o main a.o m.o</span><br><span class="line"></span><br><span class="line">m.o: m.c a.h</span><br><span class="line">    gcc -c -o m.o m.c</span><br><span class="line"></span><br><span class="line">a.o: a.c a.h</span><br><span class="line">    gcc -c -o a.o a.c</span><br></pre></td></tr></table></figure><p>​      我们想生成哪一个，就可以在<code>make</code>命令后加上需要生成的目标名称。</p><p>​     例如：<code>make a.o</code></p><h5 id="注意-！在我们执行make-main时，make命令发现a-o和m-o不存在，就会自动生成它们（没有a-o和m-o的规则也能生成）"><a href="#注意-！在我们执行make-main时，make命令发现a-o和m-o不存在，就会自动生成它们（没有a-o和m-o的规则也能生成）" class="headerlink" title="注意!！在我们执行make main时，make命令发现a.o和m.o不存在，就会自动生成它们（没有a.o和m.o的规则也能生成）"></a>注意!！在我们执行<code>make main</code>时，<code>make</code>命令发现<code>a.o</code>和<code>m.o</code>不存在，就会自动生成它们（没有<code>a.o</code>和<code>m.o</code>的规则也能生成）</h5><p>​    为什么没有a.o和m.o规则也能生成呢？因为makefile文件默认生成.o文件格式为：\$(CC)  \$(CFLAGS)  -c  -o 名.o  名.c         </p><p>​    而CC默认值为cc，CFLAGS默认值为空（可通过修改CC和CFLAGS来修改对应的编译环境与参数（如-std -Wall等等））</p><h5 id="执行makefile文件中的第一条规则可以在命令行中简写成make！！！"><a href="#执行makefile文件中的第一条规则可以在命令行中简写成make！！！" class="headerlink" title="执行makefile文件中的第一条规则可以在命令行中简写成make！！！"></a>执行makefile文件中的第一条规则可以在命令行中简写成make！！！</h5><p>​         例如上边代码中执行<code>make</code>相当于执行<code>make main</code></p><p>​    可以利用makefile规则添加删除功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -f a.o m.o main//rm命令表示删除，-f表示强制</span><br></pre></td></tr></table></figure><p>​    以上规则有一个Bug——就是当已经存在clean文件，rm命令就不执行了（而且执行一次<code>make clean</code> 就会产生clean文件，该命令最多只能执行一次）</p><p>​    这时我们可以通过 <code>.PHONY</code> 来声明clean为伪目标来解决上述问题（系统不会检查伪目标是否存在，且不会通过规则生成该目标文件）上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f array.o main.o main</span><br></pre></td></tr></table></figure><p>抛出一个较为完整的<code>Makefile</code> 栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 井号开头的行是一个注释</span><br><span class="line"># 设置 C 语言的编译器</span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"># -g 增加调试信息</span><br><span class="line"># -Wall 打开大部分警告信息</span><br><span class="line">CFLAGS = -g -Wall</span><br><span class="line"></span><br><span class="line"># 整理一下 main 依赖哪些目标文件</span><br><span class="line">MAINOBJS = main.o array.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">main: $(MAINOBJS)</span><br><span class="line">    $(CC) $(CFLAGS) -o main $(MAINOBJS)</span><br><span class="line">    #定义的变量可通过$(变量名)使用</span><br><span class="line"></span><br><span class="line">array.o: array.c array.h</span><br><span class="line">    $(CC) $(CFLAGS) -c -o array.o array.c</span><br><span class="line"></span><br><span class="line">main.o: main.c array.h</span><br><span class="line">    $(CC) $(CFLAGS) -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f $(MAINOBJS) main</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-05博客搭建进度</title>
      <link href="/2018/10/05/18-10-05%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/05/18-10-05%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>​                                            <img src="/2018/10/05/18-10-05博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器</p><p>​    ——新增主页博文出场特效</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让hexo博文被百度收录</title>
      <link href="/2018/10/04/%E5%A6%82%E4%BD%95%E8%AE%A9hexo%E5%8D%9A%E6%96%87%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/"/>
      <url>/2018/10/04/%E5%A6%82%E4%BD%95%E8%AE%A9hexo%E5%8D%9A%E6%96%87%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/04/如何让hexo博文被百度收录/title.jpg" alt="title"></p><a id="more"></a><p>​    建了博客，大家可能会发现，必须得进了博客主页后才能查看博文，没有办法通过百度搜索博文的方式，进入主页中对应的博文。</p><p>​    这样会导致很少人发现你的博文（除了真爱哈哈哈），这怎么能行呢！！！所以，我们需要让百度收录自己的博客，具体步骤如下：</p><h3 id="——Step1-让百度收录你的域名"><a href="#——Step1-让百度收录你的域名" class="headerlink" title="——Step1:让百度收录你的域名"></a>——Step1:让百度收录你的域名</h3><p>​    很简单，就是百度搜索自己的域名，如果搜索不到，会出现“很抱歉！没有找到xxxx相关的网页”，这时候底下会出现 “提交网址”给我们 的超链接，我们点进去</p><h3 id="——Step2-验证网站的所有权"><a href="#——Step2-验证网站的所有权" class="headerlink" title="——Step2:验证网站的所有权"></a>——Step2:验证网站的所有权</h3><p>​    登录<a href="https://ziyuan.baidu.com" target="_blank" rel="noopener">百度站长</a>平台 , 在站点管理中点击添加网站，然后输入你的域名地址（加前缀www）</p><p>​    在选择完网站的类型后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证,html标签验证和cname解析验证，使用哪一种方式都可以。具体流程在官方会有提示，就不再重复了</p><h3 id="——Step3-生成网站地图"><a href="#——Step3-生成网站地图" class="headerlink" title="——Step3:生成网站地图"></a>——Step3:生成网站地图</h3><p>​    我们先安装sitemap插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save12</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>​    再修改博客路径下的配置文件（非主题）中的url站点地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: #在这儿填写你的博客域名</span><br><span class="line">root: /</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>​    执行完之后就会在博客路径下生成sitemap.xml文件和baidusitemap.xml文件，可以通过<a href="http://此处填你的域名/baidusitemap.xml" target="_blank" rel="noopener">http://此处填你的域名/baidusitemap.xml</a>,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件 </p><h3 id="——Step4-向百度提交链接"><a href="#——Step4-向百度提交链接" class="headerlink" title="——Step4:向百度提交链接"></a>——Step4:向百度提交链接</h3><p>​    找到百度站长平台-&gt;网站支持-&gt;数据引入-&gt;链接提交，我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap</p><p>​    大家可以任选一种方式进行提交，具体流程官方会有提示和帮助，就不一一列举了。</p><p>​    然后，我们的博客就被百度收录啦，可以通过文章名百度一下就能找到对应的文章。（当然啦，这个需要一定的时间收录，以百度的速度，大概需要个半月吧 Orz～）</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十)</title>
      <link href="/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-10/"/>
      <url>/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-10/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/04/C语言查缺补漏-10/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十：-ifndef与-endif"><a href="#忽略点十：-ifndef与-endif" class="headerlink" title="忽略点十：#ifndef与#endif"></a>忽略点十：#ifndef与#endif</h3><p>​    印象中两者在C/C++项目创建头文件时自动添加，一直没有深究它的意义，决定跟大家讲一下它的用法，顺便也是对自己的查缺补漏</p><p>​    要将他们，首先要说一下项目，对于C语言项目来说，多文件中的每个文件的特殊全局变量，类型定义，函数可能需要在多个文件中被使用，这时可将这些全局变量，类型定义，函数声明单独写成一个头文件</p><p>​    这些头文件一般采用  源文件名.h  命名，在需要用到该头文件的文件中采用#include “源文件名.h” 引用（注意不是尖括号&lt;&gt;，而是””）,不仅源文件可以引用头文件，头文件也可以引用头文件。</p><p>​    这时候，会出现一种情况：源文件1.c中引用2.h和3.h头文件，而2.h头文件中也引用了3.h头文件。    这时3.h头文件被引用了两次，有可能会造成函数，变量的重复声明！！！</p><p>​    为了避免这一种情况的出现，我们可以在3.h中定义一个宏：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define 宏名</span><br></pre></td></tr></table></figure><p>​    只要这个宏定义过，就跳过整个3.h的整个内容</p><p>​    如何实现这一点呢？</p><p>​    对，就是利用#ifndef 宏名和#endif，格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef 宏名//判断是否声明过该宏名，如果声明过，直接跳到#endif</span><br><span class="line">#define 宏名//如果没有声明过，声明该宏名</span><br><span class="line">//.h文件内容</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    这样又会造成一个问题，若2.h的验证宏名为p（即#ifndef后声明的宏名），3.h的验证宏名也为p，那么先引用2.h，后引用3.h，会造成3.h引用不上。也就是说，必须得保证每个头文件的#ifndef后的宏名都不一样！！！</p><p>​    因此，此类宏名有一个固定格式，即：工程名 _ 路径名_ 文件名_ H_ </p><p>​    这样就能避免重名的风险</p><p>​    以上就是#ifndef和#endif的全部，Over！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(九)</title>
      <link href="/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-9/"/>
      <url>/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/04/C语言查缺补漏-9/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点九：共用体与枚举类型"><a href="#忽略点九：共用体与枚举类型" class="headerlink" title="忽略点九：共用体与枚举类型"></a>忽略点九：共用体与枚举类型</h3><p>​    共用体？What？它是什么，上了两年大学的我有点懵逼。共用体已然成了我C语言的盲区。</p><p>​    存在必然有它的意义，所以恶补了一下有关共用体的知识。</p><p>​    在我的理解里，共用体和上一篇博文所介绍的结构体，都是用来存储不同数据类型的“容器”。</p><p>​    那么他们两个的区别呢？从上上篇查缺补漏系列博文中 <a href="http://www.ivan-zcy.top/2018/10/03/C语言查缺补漏-7/">跳转至查缺补漏（七）</a>，我们知道结构体不同类型类型成员按照内存对齐规则，“排队”占用内存，而共用体，则是所有类型成员共用同一块内存（也就是说他们的起始位置都是从0开始）。</p><p>​    既然所占用内存都是从0开始，那么共用体有两个特征：</p><h3 id="——成员不会同时出现使用"><a href="#——成员不会同时出现使用" class="headerlink" title="——成员不会同时出现使用"></a>——成员不会同时出现使用</h3><p>后面出现的成员会覆盖掉之前成员的内容(也会相互影响)，因为两者的内存地址都是从0开始的，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union A &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">//省略代码</span><br><span class="line">A p1;</span><br><span class="line">p1.a = 1; p1.b = 2;</span><br><span class="line">printf(&quot;%d %d\n&quot;, p1.a, p1.b);//结果p1.a，p1.b输出都为2</span><br><span class="line">p1.a++;</span><br><span class="line">printf(&quot;%d %d\n&quot;, p1.a, p2.b);//结果p1.a, p1.b都输出为3</span><br></pre></td></tr></table></figure><h3 id="——收尾："><a href="#——收尾：" class="headerlink" title="——收尾："></a>——收尾：</h3><p> 共用体所占内存的总大小，必须是它内部最大成员所占内存大小的整数倍(像数组，结构体等成员在计算时按其成员的最大成员所占内存算)，不是要补齐</p><p>给大家上份代码理解一手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union A &#123;</span><br><span class="line">    int a;//所占内存地址为0~3</span><br><span class="line">    int b;//所占内存地址为0～3</span><br><span class="line">    char s[10]; //所占内存为0～9</span><br><span class="line">&#125;;//共用体A总共所占内存地址为0～11</span><br><span class="line"></span><br><span class="line">union B &#123;</span><br><span class="line">    double t;//所占内存地址为0～7</span><br><span class="line">    A a;//所占内存地址为0～11</span><br><span class="line">    int b[3];//所占内存内存地址0～11</span><br><span class="line">&#125;;//共用体B总共所占内存地址为0～15</span><br></pre></td></tr></table></figure><p>在共用体A中：</p><p>​    int类型a为4字节，所以占用0～3位置</p><p>​    int类型a为4字节，所以占用0～3位置</p><p>​    char型数组s中最大成员单个char为1字节，而数组长度为10，所以占用0～9位置</p><p>​    在共用体A中，最大成员为int型的4字节，所用占用内存大小为4的倍数，由于最大占用空间为10，所以共用体至少占用内存位置为0～11</p><p>在共用体B中：</p><p>​    double类型t为8字节，所以占用0～7位置</p><p>​    A类型a中最大成员为int类型为4字节，A类型总的内存占用为12字节，所以占用0～11位置</p><p>​    int型数组b中最大成员单个int为4字节，而数组长度为3，所以占用0～11位置</p><p>​    在共用体B中，最大成员为double型的8字节，所用占用内存大小为8的倍数，由于最大占用空间为12，所以共用体至少占用内存位置为0～15</p><p>​    </p><p>由于共用体特别节省内存，所以大家不能学我，它在C语言中是不容忽略的！！！（比如用于存储IPV4，IPV6地址，可用共用体来存储）</p><p>​    枚举类型大学期间使用次数仅仅比共用体好上那么一丢丢，举个枚举类型的栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum week &#123;</span><br><span class="line">    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday//注意，最后没有分号！！！！！</span><br><span class="line">&#125;;</span><br><span class="line">//省略代码</span><br><span class="line">week now = Sunday;</span><br></pre></td></tr></table></figure><p>关于枚举类型只要记住两点就可以：</p><h5 id="——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）"><a href="#——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）" class="headerlink" title="——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）"></a>——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）</h5><p>​    例如上边代码，默认Sunday的值为0，Monday的值为1，一直到Saturday的值为6</p><h5 id="——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此-1"><a href="#——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此-1" class="headerlink" title="——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此+1"></a>——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此+1</h5><p>​    例如以下代码中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum week &#123;</span><br><span class="line">    Sunday = 1, Monday, Tuesday, Wednesday = 0, Thursday, Friday, Saturday//注意，最后没有分号！！！！！</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    上边代码中，Sunday为1，Monday为2，Tuesday为3，Wednesday为0，Thursday为1，Friday为2， Saturday为3</p><p>​    好啦，共用体和枚举类型查缺补漏完毕！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-03博客搭建进度</title>
      <link href="/2018/10/03/18-10-03%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/03/18-10-03%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/03/18-10-03博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载)</p><p>​    ——提供博文百度搜索功能（需审核）</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名</p><p>​    ——代码托管从github转到coding，优化网速</p><p>​    ——修正主页博文标签跳转错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(八)</title>
      <link href="/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-8/"/>
      <url>/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/03/C语言查缺补漏-8/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点八：typedef的使用"><a href="#忽略点八：typedef的使用" class="headerlink" title="忽略点八：typedef的使用"></a>忽略点八：typedef的使用</h3><p>至于typedef，说起来实在是太丢人了！！这两年一直以为这个关键字是结构体的专属关键字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef 结构体类型 &#123;</span><br><span class="line">    //省略代码</span><br><span class="line">&#125; 类型别名</span><br><span class="line"></span><br><span class="line">类型别名 变量名//定义</span><br></pre></td></tr></table></figure><p>​    最近才发现，它不仅可以给结构体起别名，还可以给各种各样的类型起各种各样的别名，用法实在是太活了！</p><p>​    ——比如基本数据类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedefint size;</span><br><span class="line">size a;//等价于int a;</span><br></pre></td></tr></table></figure><p>​    ——比如数组：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int T[105];</span><br><span class="line">T a;//等价于 int a[105];</span><br></pre></td></tr></table></figure><p>​    </p><p>​    ——比如指针：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef char* ps;</span><br><span class="line">ps p1, p2;//等价于 char *p1, *p2;</span><br></pre></td></tr></table></figure><p>​    说到这儿，有一个代码大家需要注意：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* p1, p2;</span><br></pre></td></tr></table></figure><p>​    这里面的p1和p2分别是什么类型？</p><p>​    可能和大家想的不太一样（反正到时我是掉坑里了，尴尬），p1是char型指针，p2是char型。</p><p>​    ——用来定义与平台无关的东西：</p><p>​    比如定义一个叫Max_Double的浮点类型:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef long double Max_Double; //在一般平台的定义</span><br><span class="line">typedef double Max_Double;//在不支持long double平台的定义</span><br><span class="line">typedef float Max_Double;  //在不支持double平台的定义</span><br></pre></td></tr></table></figure><p>​    这样在跨平台时，只需要改一下Max_Double定义即可，比如之前博文写的通用long long写法 <a href="http://www.ivan-zcy.top/2018/09/30/C语言查缺补漏-3/">点这儿走你</a> 添加的&lt;inttype.h&gt;头文件就是采用了该方法。</p><p>​    要记住！！！typedef是定义了一种类型的新别名，不是简单的字符串替换！！比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int* T;</span><br><span class="line">int mystrcmp(const T);</span><br></pre></td></tr></table></figure><p>​    const T等同于什么？我当初不假思索地以为是const int<em> 。然后现实给了我狠狠的打嘴巴子，它实际上相当于int</em> const。<strong>原因在于const给予了整个指针本身以常量性，也就是形成了常量指针int* const</strong> (简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。)</p><p>​    说到const int<em> 和 int</em> const等几个的区别：</p><p>​    ——const int  *a; 表示a是一个指针，可以任意指向int型常量或变量</p><p>​    ——int const    <em>a： 同const int </em>a</p><p>​    ——int * const a; 表示a是一个指针常量，初始化时必须固定指向一个int变量，之后就不能再指向别的地方了</p><p>​    </p><p>​    除此之外，typedef不能影响对象的存储特性！！！例如以下代码会出错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef static int T;   //无法与之前的&apos;typedef&apos;声明说明符结合使用</span><br></pre></td></tr></table></figure><p>​    最后再总结一句：typedef作用是为类型起别名，但不同于#define的简单替换！而且不同于#define替换时不作正确性检查，typedef是在编译时处理的。</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(七)</title>
      <link href="/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-7/"/>
      <url>/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/03/C语言查缺补漏-7/titile.jpg" alt="titile"></p><a id="more"></a><h3 id="忽略点七-结构体内存对齐原则"><a href="#忽略点七-结构体内存对齐原则" class="headerlink" title="忽略点七:结构体内存对齐原则"></a>忽略点七:结构体内存对齐原则</h3><p>​    直到前几个星期做了一道选择题才知道，结构体元素的声明顺序可能影响结构体使用时所需的内存大小！！！</p><p>​    一查才知道，在C语言中结构体有内存对齐原则，这个原则可以总结为两点：</p><h5 id="——数据成员对齐规则："><a href="#——数据成员对齐规则：" class="headerlink" title="——数据成员对齐规则："></a>——数据成员对齐规则：</h5><p>​        结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个成员存储的起始位置为该成员大小（当该成员为基本类型时）或者该成员的最大子成员大小(当该成员为数组，结构体等时)的整数倍位置</p><h5 id="——收尾："><a href="#——收尾：" class="headerlink" title="——收尾："></a>——收尾：</h5><p>​        结构体所占内存的总大小，必须是它内部最大成员所占内存大小的整数倍(像数组，结构体等成员在计算时按其成员的最大成员所占内存算)，不是要补齐</p><p>​    </p><p>​    对于以上的文字，大家可能会不理解，给大家上份代码理解一手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bb &#123;</span><br><span class="line">    int id;     //所占内存位置为0～3</span><br><span class="line">    double weight;//所占内存位置为8～15</span><br><span class="line">    char s[10];//所占位置为16~25</span><br><span class="line">&#125;;//整个结构体bb所占内存位置为 0~31</span><br><span class="line"></span><br><span class="line">struct aa &#123;</span><br><span class="line">    char name[2]; //所占内存位置为0～1</span><br><span class="line">    bbb;//所占内存位置为8~39;</span><br><span class="line">    int age;//所占内存位置为40~43;</span><br><span class="line">&#125;;//整个结构体aa所占内存位置0~47</span><br></pre></td></tr></table></figure><p>在结构体bb中：</p><p>​    int类型id为4字节，所以占用0～3位置</p><p>​    double类型weight为8字节，它的起始位置必须是8的整数倍，所以它的起始位置为8，占用位置为8～15</p><p>​    char型数组s中最大成员单个char是1字节，所以char数组的起始位置必须是1的整数倍，所以它的起始位置为16，而数组长度为10，总占用字节为10，所以占用位置为16～25</p><p>​    在结构体bb中，最大成员为double型的weight（有同学会说char s[10]最大，为什么不是char s[10]？因为char s的最大成员所占内存为1，s按照1进行比较），所以结构体bb总占用内存必须为8的整数倍，所以结构体bb的总内存地址为0～31</p><p>在结构体aa中：</p><p>​    char型数组name数组长度为2，单个char占1字节，数组总共占两字节，所以占用位置为0～1</p><p>​    bb型结构体b中最大成员为double型的weight，所以bb类型的起始位置必须是8的整数倍，也就是8，而结构体bb总占用内存是32，所以占用b位置为8～39</p><p>​    int型age为4字节，所以起始位置必须是4的整数倍，也就是40,所以它占用的位置是40～43</p><p>​    在结构体aa中，最大成员是结构体b（它的最大成员weight占用内存为8），所以结构体aa总占用内存必须是8的整数倍，所以结构体aa的总内存地址为0～47</p><p>​    </p><p>而这样：</p><p>​    讲到这儿，我们会有一个疑问，C语言为什么要有对齐原则呢？多浪费空间呀！大家可能知道桶排这种算法，以空间换时间。对齐原则也不例外，以耗费空间为代价，来加快寻址速度。</p><p>​    至于原理：如果一个结构的最大成员字长为w，那么系统会假设在这种体系结构上字长为w的数据使用最频繁，优先提高对w位数据操作。所有的数据访问都以w位对齐，这样需要传输的地址位减少，寻址自然就可以加快。</p><p>​    那么我们可以自己设定对齐规则吗？在规定的范围内是可以的，例如：</p><p>​    在文件开头加 #pragma pack(1)            //不对齐</p><p>​                #pragma pack(2)            //支持1,2对齐 </p><p>​                #pragma pack(4)            //支持1,2,4对齐</p><p>​                #pragma pack(8)            //支持1,2,4,8对齐（默认）</p><p>​    也就是说pack是多少，结构体中的成员它的初始位置最多是多少的倍数</p><p>​    </p><p>​    嗯嗯，就酱紫~</p><p>​    <a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p><p>​                </p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(六)</title>
      <link href="/2018/10/02/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-6/"/>
      <url>/2018/10/02/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/02/C语言查缺补漏-6/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点六-内存空间，指针的指针"><a href="#忽略点六-内存空间，指针的指针" class="headerlink" title="忽略点六:内存空间，指针的指针"></a>忽略点六:内存空间，指针的指针</h3><p>​    介绍内存前，我们首先要知道一个由C/C++编译的程序占用的内存分为哪几个部分：</p><p>​    ——栈内存：C语言程序在编译时会被分配到内存的一片有限的连续区域，这部分内存会用于存储局部变量（函数中声明的变量），这部分连续区域被成为栈内存，由编译器自动分配和释放</p><p>​    ——堆内存：一般由程序员分配和释放，若程序员没有释放，则可能在程序结束时由操作系统回收（并不一定）。注意它与数据结构中的堆是两种东西！！</p><p>​    ——全局区(静态区，static)：程序的全局变量和静态变量都存放在这里， 初始化存放在一块区域，未初始化的放在相邻的另一块区域（BSS），程序结束后由系统释放。注意！它既不是栈内存，也不是堆内存！</p><p>​    ——文字常量区：也叫字面量池区。常量字符串就是放在这里，又系统释放。</p><p>​    ——程序代码区：存放函数体的区域</p><p>​    以下代码大家理解一手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1;     //全局初始化区</span><br><span class="line">int b;   //全局未初始化区</span><br><span class="line">int main() &#123;</span><br><span class="line">    char s[] = &quot;abc&quot;;     //栈区</span><br><span class="line">    char *p = &quot;abc&quot;;      //“abc”在文字常量区（“abc”不是变量，也不是指针变量），p在栈区</span><br><span class="line">    static c = 0;    //全局初始化区</span><br><span class="line">    char *q = (char *) malloc (sizeof(char)); //q为栈区，申请的内容为堆区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    关于栈内存与堆内存：</p><p>​        ——栈内存：内存大小由系统预先设定，且是一块连续的内存空间，如果超出范围就是造成栈溢出，由于是系统分配的，所以速度较快，但程序猿无法控制。</p><p>​        ——堆内存：内存大小由程序猿手动申请，不一定连续，无内存范围限制（当然啦，肯定不能超过系统的有效内存），由于是程序猿分配的，一般速度较慢，但是用起来方便。（当然，如果使用不当的话，会造成严重的内存泄漏！！！而栈内存由于编译器自动回收内存，所以不会出现泄漏问题）</p><p>​    我们由上边知道了堆内存是需要程序猿申请和释放的。那么通过什么方法申请呢？用什么头文件呢？</p><p>​    ——关于头文件，sodlib.h头文件与malloc.h都有封装的相关申请与释放堆内存的函数，所以两个选择任意一个即可</p><p>​    ——关于方法，申请有两个函数</p><h5 id="一个是malloc函数，它的格式为："><a href="#一个是malloc函数，它的格式为：" class="headerlink" title="一个是malloc函数，它的格式为："></a>一个是malloc函数，它的格式为：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p = (int *) malloc (n * sizeof (int));</span><br></pre></td></tr></table></figure><p>​    sizeof (int)表示n个整形变量所需内存空间大小</p><p>​    malloc (sizeof (int))表示申请该大小的内存空间，返回值为void型的指针</p><p>​    (int *)表示强制转换成int类型的指针</p><h5 id="另一个是calloc函数，它个格式为："><a href="#另一个是calloc函数，它个格式为：" class="headerlink" title="另一个是calloc函数，它个格式为："></a>另一个是calloc函数，它个格式为：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p = (int *) calloc (n, sizeof(int));</span><br></pre></td></tr></table></figure><p>​    该代码意义同malloc一致，至于两者的区别，malloc申请后不初始化，而calloc申请后全部初始化为0</p><p>​    ——释放有一个函数free，它的用法如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free(p);//将p所指向的堆内存空间释放回系统</span><br><span class="line">p = NULL;//为避免错误使用p指针碰触已释放的内存，应设置为 p = NULL</span><br></pre></td></tr></table></figure><p>​    以上就是内存空间的申请和释放，可能会有童鞋说还有new,delete，这些属于C++中的内容，等到C++查缺补漏时再总结～</p><p>​    前一篇博文探究了指针作参的情况，这篇博文来研究一下指针的指针</p><p>​    废话不多说，上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">int **q = &amp;p;</span><br></pre></td></tr></table></figure><p>​    在上面代码中：</p><p>​    对于第一行来说：a是int类型变量</p><p>​    对于第二行来说：p为变量a的地址(&amp;a)，而*p为a的值</p><p>​    对于第三行来说，q为指针变量p的地址，也就是&amp;p，而*q为p的值，也就是a的地址(&amp;a)</p><p>​    因此：*q = p = &amp;a           q = &amp;p</p><p>​    就是酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo加快访问速度</title>
      <link href="/2018/10/02/hexo%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/"/>
      <url>/2018/10/02/hexo%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/02/hexo加快访问速度/title.jpg" alt="title"></p><a id="more"></a><p>​    hexo+github访问速度超慢！！！这两天算是领悟到了它的龟速暴击。。。原因只有一个，托管网站的github是外网，访问外网慢是必然的。</p><p>​    有很多人博客采用hexo+github+coding方式，至于coding是什么？大家可以理解为中国版的github，如果把代码既托管到coding上，又托管到github上，让大陆的用户访问的是由coding托管的网站，歪果仁访问的是由github托管的网站，这样访问速度就能上去了。</p><p>​    hexo与github的步骤不再重复，全在之前的博客里 <a href="http://www.ivan-zcy.top/2018/09/30/Blog搭建流程-Mac系统完结帖/">点这里跳转</a> </p><p>​    完成上面步骤，我们接着往下走：</p><p>​    Step1:此时我们需要创建一个coding账号，然后添加一个项目，项目名为你的coding账号名，例如我的账号名是ivan-zcy，所以我新建的项目为ivan-zcy，注意要在初始化项目那一项打勾</p><p>​    <img src="/2018/10/02/hexo加快访问速度/1.png" alt="1"></p><p>​    </p><p>​    Step2:进入项目 -&gt; 设置 -&gt; 部署公匙 -&gt;新建部署公匙，给项目添加公匙SSH，ssh公匙获取方法和github一样，在之前博客 <a href="http://www.ivan-zcy.top/2018/09/30/Blog搭建流程-Mac系统完结帖/">点这里跳转</a>  第四步有详细的介绍。公匙名称可以不填，但是授予推送权限选项必须打勾，这样你才有写权限</p><p>​    Step3: 在你的域名管理平台中（比如阿里云，腾讯云之类的），域名 -&gt;管理-&gt; 解析域名，增加一条CNAME信息，记录值为 youruser.coding.me（youruser为你的coding用户名）例如我的：</p><p><img src="/2018/10/02/hexo加快访问速度/2.png" alt="2"></p><p>​    </p><p>Step4:等到第三步的解析生效（最长十分钟），在coding中，项目 -&gt; 代码 -&gt; Pages服务中，一键部署Pages。在Pages的设置里，自定义自己的域名并绑定（域名前加www.前缀）</p><p>Step5:在本地博客路径下，修改_config.yml下的deploy，改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">      github:</span><br><span class="line">        git@github.com:yourname/yourname.github.io.git,master</span><br><span class="line">      coding: </span><br><span class="line">        git@git.coding.net:yourname/yourname.git,master</span><br></pre></td></tr></table></figure><p>格式一定要正确！！！不然会报错！！！</p><p>Step6:</p><p>​    在本地博客路径下，执行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>Ok!这样本地博客就能同时同步到github和coding上了，访问你的域名会解析到coding平台上，速度比github快很多</p><p>最后！！！关于万恶的coding广告，每次跳转你的域名都会弹出coding的广告，有两个解决办法：</p><p>​    1.充钱即王道，198元包年。。。</p><p>​    2.在博客首页加入它的推广链接（只需要将以下代码加入到首页html任意位置即可），然后向官方申请去除广告（建议平民采用这种方法，大概一天审批时间，审批方法：主页头像 -&gt; 切换旧版 -&gt; 项目 -&gt; 代码 -&gt; Pages中）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个特别搞笑的故事哈哈</title>
      <link href="/2018/10/02/%E4%B8%80%E4%B8%AA%E7%89%B9%E5%88%AB%E6%90%9E%E7%AC%91%E7%9A%84%E6%95%85%E4%BA%8B%E5%93%88%E5%93%88/"/>
      <url>/2018/10/02/%E4%B8%80%E4%B8%AA%E7%89%B9%E5%88%AB%E6%90%9E%E7%AC%91%E7%9A%84%E6%95%85%E4%BA%8B%E5%93%88%E5%93%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/02/一个特别搞笑的故事哈哈/title.jpg" alt="title"></p><a id="more"></a><h3 id="分享一个特别长的程序猿的故事："><a href="#分享一个特别长的程序猿的故事：" class="headerlink" title="分享一个特别长的程序猿的故事："></a>分享一个特别长的程序猿的故事：</h3><p><img src="/2018/10/02/一个特别搞笑的故事哈哈/1.jpeg" alt="1"></p><p><img src="/2018/10/02/一个特别搞笑的故事哈哈/2.jpeg" alt="2"></p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(五)</title>
      <link href="/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-5/"/>
      <url>/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/01/C语言查缺补漏-5/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点五-指针作参"><a href="#忽略点五-指针作参" class="headerlink" title="忽略点五:指针作参"></a>忽略点五:指针作参</h3><p>​    平时比赛很少用到指针（链表，动态数组都有对应的STL，字典树也可以用数组模拟），业精于勤荒于嬉，C语言的指针就这样被我遗忘了。。</p><p>​    之前博文说过，C语言的优势之一就是在于能够直接访问物理地址，C语言的一大特色就是指针！！所以，学C语言舍弃指针是非常不明智的选择，终归是要还以前忽略的债。。苦笑～</p><p>​    关于指针，自己忽略的部分有很多，这一篇主要讲一下关于指针作参的用法：</p><h4 id="——对于函数来说："><a href="#——对于函数来说：" class="headerlink" title="——对于函数来说："></a>——对于函数来说：</h4><p>​    它不像变量那样可以进行值传递，我们在将函数作参进行传递时，需要传递它的地址，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int g (int (*f)(int), int a) &#123;//定义</span><br><span class="line">    return f(a);</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">g(函数名, int型变量); //调用</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="——对于一维数组来说："><a href="#——对于一维数组来说：" class="headerlink" title="——对于一维数组来说："></a>——对于一维数组来说：</h4><p>​    它的格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f (int *p) &#123;//定义</span><br><span class="line">    //省略代码</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[5];</span><br><span class="line">f (a);//调用</span><br></pre></td></tr></table></figure><p>​    关于这个a，我对它的理解是数组的初始位置，它等价于&amp;a[0]。因为我们在声明指针指向a数组时，是通过 int *p = a来实现的。</p><h4 id="注意点！！！！"><a href="#注意点！！！！" class="headerlink" title="注意点！！！！"></a>注意点！！！！</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f (int a[5]) &#123;//定义</span><br><span class="line">    //省略代码</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[5];</span><br><span class="line">f (a);//调用</span><br></pre></td></tr></table></figure><p>​    对于 void f(int a[5])，参数int a[5]就真的是数组吗？</p><p>​    答案是否定的，这里如果真的把数组作为函数参数的话，需要分配临时的栈区执行拷贝等操作，会特别麻烦。所以编译器对代码进行了优化，把数组退化成了指针。从调用传入的是a（指针）就可以看出。</p><h4 id="——对于二维数组来说："><a href="#——对于二维数组来说：" class="headerlink" title="——对于二维数组来说："></a>——对于二维数组来说：</h4><p>它的格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f (int *p) &#123;//定义</span><br><span class="line">    //省略代码</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[5][5];</span><br><span class="line">f (a[0]);//调用 由一维数组可知，a[0]等价于&amp;a[0][0]，也等价于*a</span><br></pre></td></tr></table></figure><p>​    a[0]等同于二维数组的首地址，也是二维数组下标为0行的首地址，同理a[1]为下标为1行的首地址，以此类推。</p><p>​    下面的问题没想明白，欢迎大佬来为我解惑。</p><p>​    我的认识（不一定正确）：那么二维数组的a是什么呢？从上边我们可以知道，a[0], a[1]等等都是地址信息，把他们整体来看，就是一个一维的指针数组。那么a为这个一维指针数组的首地址，而*a就是a[0]的值，也就是二维数组的首地址，从下面代码中也可以证实我的观点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f(int *p) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[2][2] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">f(*a);</span><br></pre></td></tr></table></figure><p>​    最后结果输出 1，2，3，4，说明了*a 等价于a[0]，也就是二维数组的首地址</p><p>​    按上面的逻辑，<em>a等价于a[0]，那么a就是存储a[0]指针地址的地址，所以a的值应该与a[0]不相同，也就是与 </em>a不相同，所以以下代码会报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f(int *p) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[2][2] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">f(a);</span><br></pre></td></tr></table></figure><p>可我通过以下代码输出发现，a的值等于 a[0]</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[2][2] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">printf(&quot;%p\n&quot;, a);</span><br><span class="line">printf(&quot;%p\n&quot;, *a);</span><br></pre></td></tr></table></figure><p>输出为：</p><p><img src="/2018/10/01/C语言查缺补漏-5/515E7E54-C1C3-4E2B-A854-93D2AAD5748D.png" alt="515E7E54-C1C3-4E2B-A854-93D2AAD5748D"></p><p>很迷茫。。。希望有大佬能为我解惑～</p><h4 id="——对于结构体来说："><a href="#——对于结构体来说：" class="headerlink" title="——对于结构体来说："></a>——对于结构体来说：</h4><p>​    结构体指针和变量指针作参类似，但它的指针可通过 -&gt;符指向它的成员，举个栗子(截取遍历链表代码的一部分)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    node *next;</span><br><span class="line">&#125;</span><br><span class="line">void f(node *root) &#123;</span><br><span class="line">    while (root -&gt; next != NULL) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, root -&gt; val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">node root = &#123;a, NULL&#125;;</span><br><span class="line">f(&amp;root);</span><br></pre></td></tr></table></figure><p>​    root -&gt; val等价于 (*root).val</p><p>​    只要捋清楚每个变量所代表的意义，指针作参就不会那么迷糊了，就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(四)</title>
      <link href="/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-4/"/>
      <url>/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/01/C语言查缺补漏-4/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点四-宏定义的使用与-、-用法"><a href="#忽略点四-宏定义的使用与-、-用法" class="headerlink" title="忽略点四:宏定义的使用与#、##用法"></a>忽略点四:宏定义的使用与#、##用法</h3><p>​    初学C语言时常常忽略宏定义的使用，因为觉得声明局部变量，全局变量，静态变量就够用了，所以忽略了宏定义的使用</p><p>​    上述想法完全是错误的，因为宏定义在系统编译时就将其全部替换，定义的变量不会在运行时候分配内存。所以它有无可替代的优点：效率特别高！！！不占用内存空间！！！</p><p>​    宏定义不仅可以定义变量，使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。</p><p>​    如果不使用宏定义，在发生函数调用时，需要保留调用函数的现场，以便子函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，当函数调用次数特别多的时候，这些时间的消耗是不可忽略的。</p><p>​    而使用宏定义就不会出现这个问题，因为它在预处理阶段即进行了宏展开，在执行时不需要转换。</p><p>宏定义有无参宏定义和带参数宏定义两种</p><h5 id="1-无参宏定义的一般形式为"><a href="#1-无参宏定义的一般形式为" class="headerlink" title="1.无参宏定义的一般形式为:"></a>1.无参宏定义的一般形式为:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define 宏名 字符序列    //宏名与字符序列之间用空格符分隔，用于替代后面的字符序列</span><br></pre></td></tr></table></figure><p>​    </p><p>​    ——每个宏定义都在源程序中单独占一行，换行符是宏定义的结束标志。如果一个宏定义一行不够时可采用续行的方法。续行是在按回车前先输入符号”/“</p><p>​    <strong>注意！！回车要紧接在符号”/“后，中间不能插入其它符号</strong></p><p>​    ——宏定义的有效范围称为辖域，辖域从定义开始到源文件末尾。可用预处理命令#undef终止宏定义名的辖域</p><p>​    ——宏名可被重复定义，重定义后会覆盖之前的字符序列</p><p>一般无参宏定义用于定义常量，比如定义数组长度（数组长度不能由变量定义，除了宏定义外，还可以使用const 关键字定义）</p><h5 id="2-带参宏定义的一般形式为"><a href="#2-带参宏定义的一般形式为" class="headerlink" title="2.带参宏定义的一般形式为:"></a>2.带参宏定义的一般形式为:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define 宏名(参数表) 字符序列  //参数间用逗号分隔，字符序列中应包含参数表中的参数</span><br></pre></td></tr></table></figure><p>​    <strong>注意！！宏名与左圆括号之间不允许有空白符</strong></p><h4 id="以下是易错点！！！！！！！！！！！！！"><a href="#以下是易错点！！！！！！！！！！！！！" class="headerlink" title="以下是易错点！！！！！！！！！！！！！"></a>以下是易错点！！！！！！！！！！！！！</h4><p>​    易错点一：大家要深入理解宏替换的“替换”两个字！例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define F(x) x * x</span><br></pre></td></tr></table></figure><p>​    如果a = 1, b = 2，那么F(a + b)为多少？</p><p>​    很多同学会认为是9，但是答案是5。</p><p>​    原因是替换！只是简单的替换！！！</p><p>​    F(x) = x <em> x = 1 + 2 </em> 1 + 2 = 5</p><p>​    就是酱紫。。所以代码需要改成#define F(x) (x) * (x) 才会输出9</p><p>​    在宏定义中，我们使用#把宏参数变为一个字符串</p><p>​    用##把两个宏参数连在一起（这里说的是在预处理是对源文件的操作）<br>​    例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define S(s)   #s </span><br><span class="line">#define F(a,b) int(a##e##b)</span><br></pre></td></tr></table></figure><p>​    </p><p>​    易错点二：</p><p>​    对于以下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define a 1e5</span><br><span class="line">const int b = 1e5;</span><br></pre></td></tr></table></figure><p>​    输出a和b的值，分别是多少呢？</p><p>​    a:   -272632256</p><p>​    b: 100000</p><p>​    所以，要想宏定义科学计数法，需：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define a int(1e5)</span><br></pre></td></tr></table></figure><p>​    此时a的值为100000</p><h3 id="关于宏中-和-的用法："><a href="#关于宏中-和-的用法：" class="headerlink" title="关于宏中#和##的用法："></a>关于宏中#和##的用法：</h3><p>在字符序列中：</p><p>​    用#可以把宏参数变为一个字符串</p><p>​    用##可以把两个宏参数连接在一起</p><p>例如下面代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define STR(s)     #s </span><br><span class="line">#define CONS(a,b) int(a##e##b)</span><br><span class="line">//...省略其余代码</span><br><span class="line">printf(STR(hello));           // 输出字符串&quot;vck&quot; </span><br><span class="line">printf(&quot;%d/n&quot;, CONS(1,5)); // 输出:100000</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(三)</title>
      <link href="/2018/09/30/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-3/"/>
      <url>/2018/09/30/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/C语言查缺补漏-3/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点三-空格规范以及通用long-long类型的定义"><a href="#忽略点三-空格规范以及通用long-long类型的定义" class="headerlink" title="忽略点三:空格规范以及通用long long类型的定义"></a>忽略点三:空格规范以及通用long long类型的定义</h3><p>​    大一大二两年时间都没有注意过空格的规范，导致自己写的代码奇丑无比，被队友同学诟病 冷汗！</p><p>​    直到我看到另一份比我更丑的代码后，我才意识到代码的规范有多重要！！</p><h5 id="尤其是空格的合理使用！！！！"><a href="#尤其是空格的合理使用！！！！" class="headerlink" title="尤其是空格的合理使用！！！！"></a>尤其是空格的合理使用！！！！</h5><p>​    为了避免后来难改这种陋习，建议从刚开始学C语言就贯彻空格的使用规范</p><p>​        ——逗号，分号后加空格</p><p>​        ——运算符前后都需要加空格</p><p>​        ——if，switch等关键字与左括号之间加空格</p><p>​        ——函数名与左括号之间加空格</p><p>​        ——左花括号前，右花括号后加空格</p><p>​        —— -&gt;或者.后不能加空格！！</p><p>​    为了避免同学同事幽怨的目光，请妥善使用空格哈哈哈！！！</p><p>​    在ACM竞赛中，官方会提前告诉我们对于long long类型，我们是用%lld输出(Linux系统)，还是用%I64d输出(Windows系统) </p><p>​    不过，我们有一种兼容的写法（这个特别重要！因为这种写法兼容性好，真需要代码移植的时候就不需要挨个手动改了)</p><h5 id="注意，需要加inttypes-h头文件！！！"><a href="#注意，需要加inttypes-h头文件！！！" class="headerlink" title="注意，需要加inttypes.h头文件！！！"></a>注意，需要加inttypes.h头文件！！！</h5><p>​    通用写法: int64_t a;</p><p>​             printf (“%”PRId64”\n”, a);   </p><p>​    其中PRId64为宏替换，在Linux下为lld，在Windows下为I64d</p><p>​    除了int64_t (long long类型)以外,还有int32_t (int类型)，int16_t (short类型), int8_t (char类型)，uint64_t (unsigned long long类型)，uint32_t (unsigned int类型)，uint16_t (unsigned short类型), uint8_t (unsigned char类型)等等，就不一一列举了，大家可以自行百度！ </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(二)</title>
      <link href="/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-2/"/>
      <url>/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/c语言查缺补漏-2/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点二：使用IED而忽略最基础的命令"><a href="#忽略点二：使用IED而忽略最基础的命令" class="headerlink" title="忽略点二：使用IED而忽略最基础的命令"></a>忽略点二：使用IED而忽略最基础的命令</h3><p>大一开始使用CodeBlocks来写C语言程序，后来用VS，再后来Xcode。最近才发现一个问题，自己竟然不会使用终端编译执行.C文件。这种最基本的东西，很遗憾在这两年学习中被我无情的忽略了。</p><p>​    第一步： cd到.c文件所在目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 路径地址</span><br></pre></td></tr></table></figure><p>​    第二步：编译源文件并生成可执行代码文件，举个例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc main.c//编译main.c文件，生成可执行文件(默认名a.out)</span><br><span class="line">$ gcc -o program main.c  //main.c为源文件，program为生成的可执行文件</span><br></pre></td></tr></table></figure><p>关于默认生成的a.out，它是临时性的可执行文件。如果同一路径下多个c语言源文件采用了默认编译，a.out中输出的内容为最后一个C语言源文件所执行的结果（也就是说之前源文件编译生成的a.out被覆盖掉了)</p><p>这时候就体现了 gcc -o 的-o的作用 它可以指定生成输出文件</p><p>以下到第三步之前是附加内容（除此之外</p><p>选项 -E 可以将test.c预处理输出（其中-E的功能是预处理test.c并输出到终端，不生成文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -E test.c -o test.i</span><br><span class="line">$ gcc -E test.c &gt; test.i        //其中&gt;为重定向符</span><br></pre></td></tr></table></figure><p>选项 -S 可以将test.c汇编成test.s文件（也就是从源文件-&gt;汇编代码)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -S  -o test.s test.c </span><br><span class="line">$ gcc -S test.c (简写 效果一样)</span><br><span class="line">$ gcc -S test.c &gt; test.s</span><br></pre></td></tr></table></figure><p>选项 -c 可将test.c编译输出到test.o文件 (编译过程中的中间文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c  -o test.o test.c </span><br><span class="line">$ gcc -c test.c (简写 效果一样)</span><br></pre></td></tr></table></figure><p>除此之外，还有选项 -g 用于增加调试信息，选项 -Wall用于打开大部分警告信息 ，-std=版本号用于选择标准（例如：-std=c99）等等，就不一一列举了，大家可以查相关文档</p><p>其中：    .i文件是进行预编译之后生成的文件，一般是引用头文件的内容和一些宏定义</p><p>​        .s文件是汇编语言源文件,一般是 .c 文件经过汇编器处理后的输出</p><p>​        .o文件程序编译中的目标文件（注意是编译中，不是最终！）里面包含了各个函数的入口标记与描述，程序执行还需要链接(link).链接就是把多个.o文件链成一个可执行文件。）</p><p>​    </p><p>​    第三步：执行可执行文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./program</span><br></pre></td></tr></table></figure><p>以上就是用命令行实现C语言的编译运行的全过程</p><p>对于项目（多文件），我们无法单个的编译运行，这时候我们应该怎么办呢？</p><p>​    第一步: 分别用-c命令编译每个.c文件(包括main函数文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c xxx.c</span><br></pre></td></tr></table></figure><p>我们会得到每个xxx.c文件的目标文件xxx.o</p><p>​    第二步:将主程序的目标代码与他们链接在一起</p><p>​    例如下面命令是将项目的所有目标代码xxx.o与main.o链接在一起，并输出了可执行文件program</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc main.o xxx.o xxx.o xxx.o -o program</span><br></pre></td></tr></table></figure><p>这样一个项目多文件代码就可以运行啦！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(一)</title>
      <link href="/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-1/"/>
      <url>/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/c语言查缺补漏-1/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点一：C语言能够干什么？它的优势在哪？"><a href="#忽略点一：C语言能够干什么？它的优势在哪？" class="headerlink" title="忽略点一：C语言能够干什么？它的优势在哪？"></a>忽略点一：C语言能够干什么？它的优势在哪？</h3><p>首先，这是我们在学C语言前就应该了解的。总觉得大学的课程缺少一个体系，学完了之后，不知道能用它来做什么，或者说不知道用它处理什么东西好。</p><p>这是我刚开始学C语言时所忽略的地方，现在回头想想这个东西其实挺重要的。</p><p>C语言的优势是什么？</p><p>​    ——快！快！快！！！！C语言允许直接访问物理地址，可以直接对硬件进行操作。这是高级语言所无法比拟的。所以，越是经常反复使用的代码，越需要用这类语言实现。可能调用一次两次差距不明显，但调用次数多了，两者的运算差距就大了。</p><p>​    ——生成目标代码质量高，程序执行效率高。其本质还是上边所讲的，快！C语言相比汇编语言可读性好，易于调试和移植，而效率只比汇编程序生成的目标代码低10%～20%</p><p>​    ——至于它的可移植性，虽不是最好，但也有较高的可移植性</p><p>我们就要紧紧抓住它的优势，让它的优势最大化，所以我们最好把它用在以下几个方面：</p><p>​    ——C语言可用与操作系统上的编程，比方说自己写个内存管理啦服务器之类的</p><p>​    ——C语言用来设计操作系统，大部分的操作系统内核就是用C语言写的</p><p>​    ——关于网络传输协议的设计与实现，离不开C语言</p><p>​    ——嵌入式系统编程大部分也依赖于C语言</p><p>​    ——很多编译器也是通过C语言实现的</p><p>​    ——现如今C/C++语言也常常用于游戏开发</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用网站汇总(持续更新)</title>
      <link href="/2018/09/30/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2018/09/30/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/实用网站汇总——持续更新/title.jpg" alt="title"></p><a id="more"></a><p>以下是这几年积攒的全部家底了，哈哈哈！</p><p>在线编程平台:</p><p>​    计蒜客  <a href="https://www.jisuanke.com" target="_blank" rel="noopener">传送门</a>    ——灰常好用</p><p>​    hackerrank <a href="https://www.hackerrank.com" target="_blank" rel="noopener">传送门</a> ——国外学习各类语言的在线编译平台 除网速慢 其它特别棒 白瞎全哥给我推荐了 几乎没用过</p><p>​    在线编译 <a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">传送门</a> ——能在线编译10多种语言</p><p>网上学习平台:</p><p>​    维基百科 <a href="https://www.wikipedia.org" target="_blank" rel="noopener">传送门</a>  —— 涵盖方方面面</p><p>​    stackoverflow <a href="https://stackoverflow.com" target="_blank" rel="noopener">传送门</a> ——与程序相关的IT技术问答网站</p><p>​    海贼科技 <a href="https://www.haizeix.com" target="_blank" rel="noopener">传送门</a> ——信海贼 得永生</p><p>​    哔哩哔哩 <a href="https://www.bilibili.com" target="_blank" rel="noopener">传送门</a> ——里面啥都有 不容反驳！！！</p><p>​    Github <a href="https://github.com" target="_blank" rel="noopener">传送门</a> ——开源大法好</p><p>​    coding <a href="https://coding.net/" target="_blank" rel="noopener">传送门</a>  —— 国语版的Github？</p><p>​    CSDN <a href="https://www.csdn.net" target="_blank" rel="noopener">传送门</a> ——个人感觉CSDN是目前为止对我帮助最大的平台了</p><p>​    博客园 <a href="https://www.cnblogs.com" target="_blank" rel="noopener">传送门</a> —— 如果还有的话，那就是博客园</p><p>​    计蒜客  <a href="https://www.jisuanke.com" target="_blank" rel="noopener">传送门</a>    —— 伴随式学习课程 方便学习</p><p>​    网易云课堂 <a href="https://study.163.com" target="_blank" rel="noopener">传送门</a> —— 感觉国内最好的视频学习平台了</p><p>​    慕课网 <a href="https://coding.imooc.com/?mc_marking=5931f8e07e353edf2b94a098f44a062c&amp;mc_channel=bdqdkj" target="_blank" rel="noopener">传送门</a> ——和计蒜客类似</p><p>​    菜鸟教程 <a href="http://www.runoob.com" target="_blank" rel="noopener">传送门</a> ——各种语言的学习文档</p><p>​    易百教程 <a href="https://www.yiibai.com" target="_blank" rel="noopener">传送门</a> ——和菜鸟教程差不多</p><p>​    简书 <a href="https://www.jianshu.com" target="_blank" rel="noopener">传送门</a> ——里边有很多IT文章 特别赞</p><p>C语言：<br>​    stack overflow <a href="https://stackoverflow.com" target="_blank" rel="noopener">传送门</a>  ——C语言界的“知乎”<br>​    cplusplus <a href="http://www.cplusplus.com" target="_blank" rel="noopener">传送门</a>    ——C语言文档</p><p>ACM：</p><p>​    小白菜OJ <a href="http://caioj.cn" target="_blank" rel="noopener">传送门</a> ——简单基础，带视频讲解</p><p>​    洛谷 <a href="https://www.luogu.org/training/mainpage" target="_blank" rel="noopener">传送门</a> ——灰常好玩</p><p>​    HUD <a href="http://acm.hdu.edu.cn" target="_blank" rel="noopener">传送门</a> ——个人认为国内现在最繁忙的OJ了吧</p><p>​    POJ <a href="http://poj.org" target="_blank" rel="noopener">传送门</a> ——北大OJ</p><p>​    Project Euler <a href="https://projecteuler.net" target="_blank" rel="noopener">传送门</a> ——国外一个纯数学编程题的网站</p><p>​    华中理工VJ <a href="https://vjudge.net" target="_blank" rel="noopener">传送门</a> ——可以很方便的从各大OJ拉题</p><p>​    CodeForce <a href="http://codeforces.com" target="_blank" rel="noopener">传送门</a> ——比赛特别多 不过大多数都在半夜！ 平时不需要翻墙 注册时需要翻墙才能收到验证码</p><p>​    数论 <a href="https://www.cnblogs.com/linyujun/category/784324.html" target="_blank" rel="noopener">传送门</a> ——看过最好的数论博客</p><p>​    大佬 <a href="http://zory.cf" target="_blank" rel="noopener">传送门</a> ——分享一个经常看的大佬博客</p><p>机器学习类:</p><p>​    吴恩达课程+笔记 <a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">传送门</a>  ——黄海广博士翻译</p><p>数学类：</p><p>​    OEIS <a href="http://oeis.org" target="_blank" rel="noopener">传送门</a> ——国外的在线整数数列查询网站 啥也不说了 OEIS大法好</p><p>​    WolframMathWorld <a href="http://mathworld.wolfram.com" target="_blank" rel="noopener">传送门</a> ——国外数学网站</p><p>Linux：</p><p>​    Linux命令大全 <a href="http://man.linuxde.net/sub/目录基本操作" target="_blank" rel="noopener">传送门</a> ——全中文呀</p><p>面试题：</p><p>​    猿圈 <a href="https://st.oxcoder.com" target="_blank" rel="noopener">传送门</a> ——有针对于面试笔试的题库</p><p>​    牛客网 <a href="https://www.nowcoder.com" target="_blank" rel="noopener">传送门</a> ——同猿圈一样​    </p><p>​    </p><p>云服务平台：</p><p>​    DNSPOD <a href="https://www.dnspod.cn/Login?r=/console/dns//ivan-zcy.com" target="_blank" rel="noopener">传送门</a> ——第三方域名解析平台</p><p>​    阿里云 <a href="https://account.aliyun.com" target="_blank" rel="noopener">传送门</a> ——云服务的集成平台</p><p>​    景安 <a href="https://nssp.zzidc.com" target="_blank" rel="noopener">传送门</a> ——为什么是景安？没错，是贫穷！</p><p>​    GoDaddy <a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">传送门</a> ——国外域名商 买完后悔了 现在法律规定必须备案才能使用 要备案必须得转到国内。。</p><p>工具：</p><p>​    在线工具 <a href="https://tool.lu" target="_blank" rel="noopener">传送门</a> ——特别全的在线工具集合</p><p>​    ProcessOn <a href="https://www.processon.com" target="_blank" rel="noopener">传送门</a> ——在线绘图平台</p><p>​    超级简历 <a href="https://www.wondercv.com" target="_blank" rel="noopener">传送门</a> ——在线简历制作</p><p>​    知页 <a href="https://www.zhiyeapp.com/?utm_source=baidu&amp;utm_medium=sem&amp;utm_term=83594555225&amp;utm_content=21611848941&amp;uc_pagenum=1&amp;uc_adposition=cl2" target="_blank" rel="noopener">传送门</a> ——同超级简历一样</p><p>​    印象笔记 <a href="https://www.yinxiang.com/?utm_source=b1&amp;utm_medium=b1&amp;utm_term=aydtn" target="_blank" rel="noopener">传送门</a> ——记事本 可同步移动端</p><p>​    </p><p>前端类:</p><p>​    Iconfont <a href="http://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.3" target="_blank" rel="noopener">传送门</a> ——许许多多美观的图标</p><p>​    Font Awesome <a href="http://fontawesome.dashgame.com" target="_blank" rel="noopener">传送门</a> ——简洁大方的图标字体库</p><p>​    设计导航 <a href="http://hao.shejidaren.com" target="_blank" rel="noopener">传送门</a> ——前端所需的汇总平台</p><p>​    jQuery插件库 <a href="http://www.jq22.com" target="_blank" rel="noopener">传送门</a>    ——里面有好多很棒的特效</p><p>​    W3school <a href="http://www.w3school.com.cn/h.asp" target="_blank" rel="noopener">传送门</a> ——前端语言学习文档</p><p>​    花瓣网 <a href="http://huaban.com" target="_blank" rel="noopener">传送门</a> ——图片素材</p><p>​    模版王 <a href="http://www.mobanwang.com/mb/" target="_blank" rel="noopener">传送门</a> ——有许许多多网站模版 不过坑好多</p><p>​    Layui <a href="https://www.layui.com/doc/element/color.html" target="_blank" rel="noopener">传送门</a> ——关于前端的使用 它的颜色设计感很棒</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog搭建流程(Mac系统完结帖)</title>
      <link href="/2018/09/30/Blog%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B-Mac%E7%B3%BB%E7%BB%9F%E5%AE%8C%E7%BB%93%E5%B8%96/"/>
      <url>/2018/09/30/Blog%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B-Mac%E7%B3%BB%E7%BB%9F%E5%AE%8C%E7%BB%93%E5%B8%96/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/Blog搭建流程-Mac系统完结帖/title.jpg" alt="title"></p><a id="more"></a><p>讲完这一篇hexo就算暂时性翻过去了 以后专注于算法和C++底层  加油加油！</p><h3 id="Step1-安装Node-js"><a href="#Step1-安装Node-js" class="headerlink" title="Step1 安装Node.js"></a>Step1 安装Node.js</h3><p>可通过以下两种方式在 Mac OS 上安装 node.js：</p><p>方式一： 在<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方下载网站</a>下载 pkg 安装包，直接点击安装即可</p><p>方式二： 使用 brew 命令来安装：</p><ul><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></li></ul><h3 id="Step2-安装Git"><a href="#Step2-安装Git" class="headerlink" title="Step2 安装Git"></a>Step2 安装Git</h3><p>首先查看电脑是否安装Git，终端输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure><p>安装过则会输出下表，然后跳过该步</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WMBdeMacBook-Pro:~ WENBO$ git</span><br><span class="line">usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]</span><br><span class="line">           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">These are common Git commands used in various situations:</span><br><span class="line"></span><br><span class="line">start a working area (see also: git help tutorial)</span><br><span class="line">   clone      Clone a repository into a new directory</span><br><span class="line">   init       Create an empty Git repository or reinitialize an existing one</span><br><span class="line"></span><br><span class="line">work on the current change (see also: git help everyday)</span><br><span class="line">   add        Add file contents to the index</span><br><span class="line">   mv         Move or rename a file, a directory, or a symlink</span><br><span class="line">   reset      Reset current HEAD to the specified state</span><br><span class="line">   rm         Remove files from the working tree and from the index</span><br><span class="line"></span><br><span class="line">examine the history and state (see also: git help revisions)</span><br><span class="line">   bisect     Use binary search to find the commit that introduced a bug</span><br><span class="line">   grep       Print lines matching a pattern</span><br><span class="line">   log        Show commit logs</span><br><span class="line">   show       Show various types of objects</span><br><span class="line">   status     Show the working tree status</span><br><span class="line"></span><br><span class="line">grow, mark and tweak your common history</span><br><span class="line">   branch     List, create, or delete branches</span><br><span class="line">   checkout   Switch branches or restore working tree files</span><br><span class="line">   commit     Record changes to the repository</span><br><span class="line">   diff       Show changes between commits, commit and working tree, etc</span><br><span class="line">   merge      Join two or more development histories together</span><br><span class="line">   rebase     Reapply commits on top of another base tip</span><br><span class="line">   tag        Create, list, delete or verify a tag object signed with GPG</span><br><span class="line"></span><br><span class="line">collaborate (see also: git help workflows)</span><br><span class="line">   fetch      Download objects and refs from another repository</span><br><span class="line">   pull       Fetch from and integrate with another repository or a local branch</span><br><span class="line">   push       Update remote refs along with associated objects</span><br><span class="line"></span><br><span class="line">&apos;git help -a&apos; and &apos;git help -g&apos; list available subcommands and some</span><br><span class="line">concept guides. See &apos;git help &lt;command&gt;&apos; or &apos;git help &lt;concept&gt;&apos;</span><br><span class="line">to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure><p>​    </p><p>​    如果没有显示上面内容，我们可以通过homebrew安装GIt，若未安装homebrew 则通过终端执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>​    随后执行一下命令进行Git的安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><h3 id="Step3-注册Github账号并新建仓库"><a href="#Step3-注册Github账号并新建仓库" class="headerlink" title="Step3 注册Github账号并新建仓库"></a>Step3 注册Github账号并新建仓库</h3><p>​    网站链接：<a href="https://github.com" target="_blank" rel="noopener">Github</a> </p><p>​    注册完账号后需新建一个仓库。注意！！新建的仓库名字必须是username.github.io。例如我username是ivan-zcy，那么仓库名字必须是ivan-zcy.github.io</p><h3 id="Step4-配置SSH-Key（可省略-建议配置）"><a href="#Step4-配置SSH-Key（可省略-建议配置）" class="headerlink" title="Step4 配置SSH Key（可省略 建议配置）"></a>Step4 配置SSH Key（可省略 建议配置）</h3><p>这一步能省略 但是配置后更新博客就不用每次都输入用户名密码了</p><p>步骤：<br>​    1 检查主机是否已存在SSH Key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .ssh</span><br><span class="line">ls -la</span><br></pre></td></tr></table></figure><p>若输出的文件列表中存在id_rsa.pub 或 id_dsa.pub 文件，则直接跳到第三小步</p><p>​    </p><p>​    2 创建SSH Key<br>在终端输入如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>按下回车 会让输入文件名，直接回车会创建默认文件名的文件  然后会提示输入两次密码(可为空)</p><p>​    3 添加SSH Key到Github</p><p>（如果之前在Github中添加过SSH 则跳过该步）</p><p>如果你没有指定文件名（也就是使用默认文件名），那么在.ssh文件夹下会有一个id_rsa.pub文件，打开该文件并复制里面的内容</p><p>登录Github，点击右上角头像右边的三角图标，点击Settings –&gt; SSH and GPG keys –&gt; New SSH key。Title 随便填一个，在Key栏中填入复制的内容，点击Add SSH key，就添加成功了</p><p>​    4 检验SSH Key是否配置成功<br>在终端输入如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果最后出现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>就说明SSH Key配置成功了</p><h3 id="Step5-安装Hexo"><a href="#Step5-安装Hexo" class="headerlink" title="Step5 安装Hexo"></a>Step5 安装Hexo</h3><p>使用npm命令安装Hexo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>接着在任意位置创建一个文件夹，如Blog，cd到该路径下执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>该命令会在目标文件夹内建立网站所需的基础文件</p><p>接着安装安装依赖包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>此时本地博客就搭建好了</p><p>执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>此时可在浏览器中输入<a href="https://link.jianshu.com/?t=http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>进行本地查看（其他人无法访问）</p><p>​    当然 此时可修改本地博客路径下的_config文件对博客进行全局设置，里边设置项挺多就不一一列举啦！自行百度</p><p>​    </p><h3 id="Step6-同步到远程Github仓库"><a href="#Step6-同步到远程Github仓库" class="headerlink" title="Step6 同步到远程Github仓库"></a>Step6 同步到远程Github仓库</h3><p>在本地Blog路径下找到_config.yml，把deploy节点修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>（其中 username为你的Github用户名）</p><p>为了能够使Hexo部署到GitHub上，需安装一个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这时候就可以在浏览器通过输入username.github.io就可以访问你的博客了</p><h3 id="Step7-配置主题"><a href="#Step7-配置主题" class="headerlink" title="Step7 配置主题"></a>Step7 配置主题</h3><p>​    前边写过配置主题的博文 抛出一个传送门：</p><p>​                    <a href="http://www.ivan-zcy.top/2018/09/28/hexo更换主题流程/">滴滴，我是传送门</a></p><p>​    （主题在github上 知乎上 hexo官网上有很多很多 适合自己就好）</p><p>​    </p><h3 id="注意点！！！！"><a href="#注意点！！！！" class="headerlink" title="注意点！！！！"></a>注意点！！！！</h3><p>一些主题的功能需要我们自己预先创建好对应的页面，例如标签tags 关于about等等等等</p><p>此时我们需要在本地Blog路径下</p><p>​    1 添加关于页面（可选）</p><p>使用：<code>hexo new page &quot;about&quot;</code>新建一个 关于我 页面。<br>主题的 <code>_config.yml</code>文件中的 <code>menu</code>中进行匹配</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类</span><br><span class="line">  archives: /archives   //归档</span><br><span class="line">  tags: /tags   //标签</span><br><span class="line">  about: /about   //关于                  （添加此行即可）</span><br></pre></td></tr></table></figure><p>​    也可在本地博客路径 –&gt; source  –&gt; about文件下，通过修改其中的index.md对其页面进行配置</p><p>​    2 添加标签页面（可选）</p><p>使用： <code>hexo new page tags</code>新建一个 标签 页面。<br>主题的 <code>_config.yml</code>文件中的 <code>menu</code>中进行匹配</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类</span><br><span class="line">  archives: /archives   //归档</span><br><span class="line">  tags: /tags   //标签                  （添加此行即可）</span><br><span class="line">  about: /about   //关于</span><br></pre></td></tr></table></figure><p>​    也可在本地博客路径 –&gt; source  –&gt; tags文件下，通过修改其中的index.md对其页面进行配置</p><p>​    </p><p>​    除了上边两个之外还有分类categories，自定义页面等等就不一一列举啦 自行百度吧！</p><h3 id="Step8-发布博文"><a href="#Step8-发布博文" class="headerlink" title="Step8 发布博文"></a>Step8 发布博文</h3><p>​    接着抛链接：</p><p>​            <a href="http://www.ivan-zcy.top/2018/09/28/hexo发表博客常用命令/">滴滴，我也是一个传送门</a></p><h3 id="Step9-绑定个人域名"><a href="#Step9-绑定个人域名" class="headerlink" title="Step9 绑定个人域名"></a>Step9 绑定个人域名</h3><p>​    步骤：</p><p>​    1 购买域名 </p><p>建议从<a href="https://account.aliyun.com/login/login.htm?oauth_callback=http%3A%2F%2Fnetcn.console.aliyun.com%2Fcore%2Fdomain%2Flist%3Fspm%3Da2c1d.8251892.0.0.4f0f52f2SzXZY4" target="_blank" rel="noopener">阿里云平台</a>啦之类的国内大型平台购买（这一步通常需要身份验证之类的 大概需要几天时间吧也记不清楚了 反正挺麻烦挺磨唧的）</p><p>​    2 配置DNS地址 </p><p>进入阿里云控制台 –&gt; 域名 –&gt; 域名列表 找到自己的域名 点击下图红圈圈的“管理”​    </p><p><img src="/2018/09/30/Blog搭建流程-Mac系统完结帖/1.png" alt="1"></p><p>​    </p><p>​    3 进行域名解析 </p><p>找到管理界面下的域名解析 在其中添加3条记录（username是github的用户名）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@          A             192.30.252.153</span><br><span class="line">@          A             192.30.252.154</span><br><span class="line">www      CNAME         username.github.io.</span><br></pre></td></tr></table></figure><p>​    4添加CNAME文件<br>新建一个名为CNAME的文件(无后缀)，内容为你的域名地址。将该文件放到本地博客的source文件夹里面，并更新到Github</p><p>​    这时候你的博客就建完啦！</p><p>​    最后附上主页地址： <a href="http://www.ivan-zcy.top">戳我</a>      </p><p>​    一起造作吧！！！！</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://segmentfault.com/a/1190000008040387" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008040387</a></p><p><a href="https://blog.csdn.net/ganzhilin520/article/details/79047249" target="_blank" rel="noopener">https://blog.csdn.net/ganzhilin520/article/details/79047249</a></p><p><a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">https://www.jianshu.com/p/e5f95eb990ad</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-09-29博客搭建进度</title>
      <link href="/2018/09/29/18-09-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/09/29/18-09-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/29/18-09-29博客搭建进度/man.jpg" alt="man"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找（感谢帮忙拍版的鹏飞）</p><p>​    ——新增返回顶部的小火箭</p><p>​    ——优化布局</p><p>​    ——新增巨巨们的友情链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo发表博客常用命令</title>
      <link href="/2018/09/28/hexo%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/28/hexo%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/28/hexo发表博客常用命令/man.jpg" alt="man"></p><a id="more"></a><h5 id="以下命令需要在本地Blog路径下执行"><a href="#以下命令需要在本地Blog路径下执行" class="headerlink" title="以下命令需要在本地Blog路径下执行"></a>以下命令需要在本地Blog路径下执行</h5><h3 id="Step1-创建文章"><a href="#Step1-创建文章" class="headerlink" title="Step1 创建文章"></a>Step1 创建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br><span class="line">$ hexo n <span class="string">"My New Post"</span>    //安装hexo-asset-image后可使用</span><br></pre></td></tr></table></figure><h3 id="Step2-编辑文章"><a href="#Step2-编辑文章" class="headerlink" title="Step2 编辑文章"></a>Step2 编辑文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文章头部加</span><br><span class="line">---</span><br><span class="line">title: //此处填写文章名</span><br><span class="line">date: //此处填写发布日期</span><br><span class="line">tags: </span><br><span class="line">  - //此处填写标签名(可多个)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>由于在首页中显示文章内容使用的是 <code>post.content</code> 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个 <code>&lt;!-- more --&gt;</code> 标记。添加了这个标记之后，<code>post.excerpt</code> 将会获取到标记之前的内容</p><p>之后的内容大家可以随意Diy啦</p><p>编辑md文件建议使用Typora软件 特别推荐！！！</p><h4 id="关于文章添加图片："><a href="#关于文章添加图片：" class="headerlink" title="关于文章添加图片："></a>关于文章添加图片：</h4><p>​    1 把本地Blog文件下的配置文件（非主题下）<code>_config.yml</code>里的<code>post_asset_folder:</code>选项设置为<code>true</code></p><p>​    2 在本地Blog路径下执行<code>npm install hexo-asset-image --save</code> （用于下载安装一个可以上传本地图片的插件）</p><p>​    3 运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文  </p><p>​       会发现在/source/_posts<code>文件夹中除了</code>xxxx.md`文件还生成了一个同名文件夹 </p><p>​    4最后在<code>xxxx.md</code>引入图片时，先把图片复制到xxxx文件夹中 然后在xxxx.md中按照markdown的格式引入图片：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx/图片名.jpg)</span><br></pre></td></tr></table></figure><h3 id="Step3-清除缓存-（可省略-建议使用）"><a href="#Step3-清除缓存-（可省略-建议使用）" class="headerlink" title="Step3 清除缓存 （可省略 建议使用）"></a>Step3 清除缓存 （可省略 建议使用）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 db.json 和已生成的静态文件 public  </p><p>当网站显示异常时可以执行这条命令试试</p><h3 id="Step4-生成静态文件"><a href="#Step4-生成静态文件" class="headerlink" title="Step4 生成静态文件"></a>Step4 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g      //简写</span><br></pre></td></tr></table></figure><p>这步骤就相当于程序的编译，如果有错误的话，在终端会有相应的提示信息</p><p>如果没有错误的话 可以继续往下执行</p><h3 id="Step5-启动本地服务器-（可省略）"><a href="#Step5-启动本地服务器-（可省略）" class="headerlink" title="Step5 启动本地服务器 （可省略）"></a>Step5 启动本地服务器 （可省略）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s      //简写</span><br></pre></td></tr></table></figure><p>用于预览主题，默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><h3 id="Step6-部署到远程站点"><a href="#Step6-部署到远程站点" class="headerlink" title="Step6 部署到远程站点"></a>Step6 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d       //简写</span><br></pre></td></tr></table></figure><p>上述步骤结束后 恭喜你 一篇博文完成啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo更换主题流程</title>
      <link href="/2018/09/28/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/09/28/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/28/hexo更换主题流程/man.jpg" alt="man"></p><a id="more"></a><h3 id="Step1-下载"><a href="#Step1-下载" class="headerlink" title="Step1: 下载"></a>Step1: 下载</h3><p>​    cd到本地博客路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 你的博客目录路径</span><br></pre></td></tr></table></figure><p>​    </p><p>​    用clone命令将想要的主题下载下来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone 主题链接</span><br></pre></td></tr></table></figure><p>​    注意 需要git到当地Glob文件夹下的theme文件夹内</p><h3 id="Step2-修改配置文件并安装"><a href="#Step2-修改配置文件并安装" class="headerlink" title="Step2: 修改配置文件并安装"></a>Step2: 修改配置文件并安装</h3><p>​    git克隆完成后，打开本地Blog下的“_config.yml”配置文件（非主题文件下）</p><p>​    找到theme配置选项(一般在文件的最后)  将theme选项配置为新下载的主题即可（“：”冒号之后空格不可少 空格后为新下载的主题名）</p><h3 id="Step3-修改主题配置文件"><a href="#Step3-修改主题配置文件" class="headerlink" title="Step3 修改主题配置文件"></a>Step3 修改主题配置文件</h3><p>​    打开主题路径下的“_config.yml”配置文件 按照作者要求进行相关配置</p><h3 id="Step4-调试，发布"><a href="#Step4-调试，发布" class="headerlink" title="Step4:调试，发布"></a>Step4:调试，发布</h3><p>​    在本地Blog路径下 输入调试命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server --debug</span><br></pre></td></tr></table></figure><p>​    </p><p>​    在浏览器中输入localhost:4000查看</p><p><img src="/2018/09/28/hexo更换主题流程/cmm.png" alt="cmm"></p><p>​    </p><p>​    在本地查看无误之后，输入生成和发布命令, 就可将新主题发布到自己的博客网站上了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>​    如出现缓存引起的异常，可在生成命令执行前执行清除缓存命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="Step5-自己DIY"><a href="#Step5-自己DIY" class="headerlink" title="Step5 自己DIY"></a>Step5 自己DIY</h3><p>​    如果主题没有想象中好 忍无可忍无需再忍 那就自己动手修改它的源码吧！（建议事先备份 推荐使用Webstrom）</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First Blog</title>
      <link href="/2018/09/28/First-Blog/"/>
      <url>/2018/09/28/First-Blog/</url>
      
        <content type="html"><![CDATA[<p>​    <img src="/2018/09/28/First-Blog/person.png" alt="person"></p><p>​    <a id="more"></a></p><p>​    距离明年秋招不到一年，有对未来的忐忑，也有期待。</p><p>​    不知道自己未来会怎样，但希望能像阿甘那样，永远不被挫折打倒。</p><p>​    今天搭建了个人博客，希望自己能坚持写下去，从一而终。</p><p>​    加油 坚持！</p><p>​    愿接下来的一年自己能收到满意的答卷！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
