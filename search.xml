<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux复习归纳3-特殊符号和命令]]></title>
    <url>%2F2019%2F05%2F16%2FLinux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B33-%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[LINUxlinux复习归纳3～ 特殊符号和命令ctrl+z​ 对程序进行挂起 bg​ 对挂起的命令后台运行 fg​ 可以将后台执行的命令转为前台 jobs​ 可以查看所有在后台执行和挂起的任务 &amp;​ 在命令后加&amp;代表后台执行 命令中如果包含另一个命令，则用``将它括起来，在执行时优先执行``中的子命令，然后将其结果带入父命令继续执行 重定向​ 具体有以下几种： &gt; 内容覆盖&gt;&gt; 内容追加&lt; 从文件到命令的重定向&lt;&lt; 结束符例如： cat &gt; a &lt;&lt; B //代表直到输入中存在&apos;B&apos;才会结束输入 通配符* 匹配任意多字符? 匹配任意一个字符[list] 匹配list中任意单个字符[!list] 匹配除list的任意单个字符[c1-c2] 匹配c1-c2中任意单个字符 元字符= 变量赋值，左右不能有空格`` 取命令的执行结果$ 变量值替换，为避免混淆，可使用$&#123;&#125;| 管道; 命令结束符! 执行历史记录中的命令 转义符&apos;&apos; 硬转义，内部所有的shell元字符、通配符都会被关掉&quot;&quot; 软转义，内部只允许出现特定的shell元字符($ ` \)\ 反斜杠，转义，去除后面紧跟着的元字符或通配符的特殊意义]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux复习归纳2-其它常用命令]]></title>
    <url>%2F2019%2F05%2F16%2FLinux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B32-%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux复习归纳2～ 查找和检索find​ find命令用于查找文件，格式为：find 路径 [选项] 内容，它有很多选项，比如： -name（按照名字查找，比如查找*.c文件，则为-name &quot;*.c&quot;）-type（按照类型查找，比如查找目录，则为 -type d）-size（按照大小查找，比如大于1M小于5M，则为-size +1M -size -5M）-maxdepth（用于规定查找的最深路径，如只查找当前直接路径下，则为-maxdepth 1） xargs​ 常常和管道连用，用于将管道前的输出作为参数传给后面的命令，例如显示查找到的文件的详细信息： find ./ -name &quot;*.c&quot; | xargs ls -al grep​ 用于检索和过滤，也常常和管道连用，例如检索普通文件类型中包含txt的文件： find ./ -type f | grep txt ​ 除此之外，还可以检索文件中的内容，具体格式为grep [选项] 内容 文件 （当然也可以cat 文件 | grep [选项] 内容），选项比如-w（精确查找），-c（统计查找到的次数），-i（忽略大小写），-n（带行号），-v（反向检索，也就是除内容以外的行） 压缩包管理zip和unzip​ zip用于压缩打包，具体用法为:zip -r 压缩文件.zip 目录或文件（可多个空格隔开） ​ unzip用于解压文件，具体用法为：unzip 压缩文件 ​ 除此之外，还有gzip与gunzip，rar a和rar x等压缩命令，分别生成.gz和.rar tar​ 最常用的打包工具，后缀一般是.tar.gz ​ tar命令常用的选项有-z（gz格式压缩，如果不加只是tar包，只打包不压缩），-c（代表压缩文件），-v（代表显示信息），-f（代表指定压缩包的名字），-x（代表解压文件） ​ 压缩文件格式为：tar zcvf 压缩文件.tar.gz 目录或文件 ​ 解压文件格式为：tar zxvf 压缩文件.tar.gz 安装brew或apt-get​ linux有apt-get，MacOS有brew等等不同的包管理工具，具体用法也不再重复，详细请看个人博客：跳转 源码安装​ 具体流程大概如下： 1. 解压源码代码包2. cd到解压后的目录3. ./configure //用于检测文件是否缺失并创建makefile，并检测编译环境4. make //用于编译源码，生成库和可执行程序5. sudo make install //把库和可执行程序安装到系统路径下6. sudo make distclean //删除和卸载软件 用户管理useradd​ 用于创建用户，常用选项有：-g（指定组），-d（指定用户家目录），-m（家目录不存在自动创建），-s（指定shell） groupadd​ 用户创建用户组 su​ 用于切换用户，加-带有环境变量的切换 userdel​ 用于删除用户，选项-r（连带删除家目录） 关于进程这些先简略占位，日后根据详细应用补～ who​ 查看登录设备 ps​ 查看进程信息，常用的有ps -aux(显示所有包含其他使用者的进程)` kill​ 用于杀死进程，常用的有kill 9 pid top​ 用于实时查看系统信息 关于网络这些先简略占位，日后根据详细应用补～ ifconfig​ 主要用于查看ip信息。除此之外，eth0代表本地第一块网卡 ping​ 用于检测主机，执行ping指令会使用icmp传输协议，发出要求回应的信息。若对方主机网络没问题，就会回应该信息，从而得知主机运行正常 nslookup​ 该命令用于通过域名得到ip 其它常用命令date​ 用于获取时间的指令，可自定义格式，例如：date +&quot;%Y-%m-%d&quot;等 echo​ 用于输出变量或字符 alias​ 用于对命令进行重命名，有以下几种用法： 用法1: alias //用于列出目前所有的别名设置用法2: alias 别名=&apos;指令&apos; //仅作用于本次终端登录用法3: 在~/.bashrc文件中写入用法2，永久作用于本用户用法4: 在/etc/profile中写入用法2，永久作用于本计算机中所有用户//用法3、4需要在写入后source一下 umask​ 用于指定创建文件时预设的权限掩码，umask与0777的补码&amp;666，得到的就是创建文件时预设的权限掩码（哈哈哈），可通过umask -S 权限掩码来设置]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux复习归纳1-文件和基本命令]]></title>
    <url>%2F2019%2F05%2F15%2FLinux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B31-%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[[TOC] Linux​ 把自己所学的linux整理归并一下～ 系统目录结构​ Linux一切皆文件！！！！ /bin 存放系统可执行程序/sbin 存放超级管理员可执行程序/boot 存放内核和启动程序相关文件/lib 存放库文件（动态共享库）/etc 存放系统配置文件,比如用户存放信息文件/etc/passwd/dev 存放设备文件/tmp 存放临时文件（关机清空）/home 存放用户的主目录/usr 应用会安装到此目录，比如软件安放到/usr/local下/proc 存储系统内存的映射（保留进程运行的信息）/media 挂载u盘光驱等外接设备（自动挂载）/mnt 手动挂载外接设备 常用命令​ 说命令之前需要说一个神键：自动补齐Tab键，简直不能再好用 与命令相关man​ 用于查询命令的用法(英文版)，MAC可按照这个教程-&gt; 跳转 去安装汉化版cman ​ 不懂就查，感觉这是最最最最最有用的命令了 tldr​ man真的是好长好长，如果是查询命令的简单应用，可以安装tldr命令来查看用法(too long don’t read，2333) history​ 在终端输出历史命令（当然也可以方向键），可使用!序号来执行指定历史编号的命令 sudo​ 该命令一般用于临时获取管理员权限，一般常用的： sudo su 切换为管理员sudo -i 切换为普通用户sudo !! 当上一条命令权限被拒绝时，可直接这 与目录相关ls​ list的缩写，用于查看指定目录下的所有文件和目录（支持通配符）。常用参数：-a(显示全部，包括隐藏)，-l（查看详细文件信息）-R（递归查看子目录文件），-t（按照文件修改时间排序） pwd​ 用于显示当前工作目录 tree​ 用于显示目录的树形结构 cd​ 用于切换路径（以/开头的路径为绝对路径，否则为相对路径） cd或cd ~或 cd $HOME 返回家目录cd - 返回上次目录cd .. 返回上级目录cd 绝对或相对路径 mkdir​ 用于创建目录，常用参数-p（可以用于递归创建目录） touch​ 用于创建文件（若文件已创建，则只是修改一下文件的访问时间，并不会新创建一个文件） rm​ rm命令用于删除目录或文件，常用参有-r(循环递归删除)，-f(强制删除) cp​ -r（用于递归拷贝） ​ 当目标为目录时，则将当前文件或目录拷贝到目标目录 ​ 若目标不是目录时，则在目标的上一层创建该目标并拷贝过去 scp​ 用于远程拷贝，具体格式为： scp file 用户名@ip地址:./path路径 mv​ 移动一个文件或文件到另一个目录下（也可用它来重命名），与mv用法差不多，只不过是移动 which​ 用于显示对应命令的所在路径 与文件相关​ 文件的详细信息包括：文件权限标志位（包括所属者、组、其它权限(rwx)以及文件类型）、硬连接数、所属者、所属用户、文件大小、时间、文件名 ​ 文件类型包括： - 普通文件d 目录文件c 字符设备文件（鼠标，键盘等）b 块设备（也就是硬盘）p 命名管道文件l link链接文件s socket套接字文件//隐藏文件以.开头 cat​ 将文件信息显示到终端 more和less​ 也是显示文件，可以分屏显示 ​ more会车是按行显示，空格按页显示 ​ less可以回车或者上下方向键可以反复查看文件内容 head和tail​ head是查看文件头，tail是查看文件尾（默认显示10行），可以通过参数-n更改显示行数 ​ 其中tail中-f可以一直跟踪文件尾部（比如用于查看实时日志啥的） ln​ 用于建立软或硬链接（硬链接实际上是两个文件映射同一磁盘地址上的内容；软连接就是创建了源文件的快捷方式，新文件映射到源文件） ln 文件 文件 对两个文件建立硬链接ln -s 文件 文件 对两个文件或文件夹进行软连接（不会增加硬链接计数） unlink​ 用于删除硬链接（当然也可以rm），感觉有点类似于智能指针的shard_ptr chmod​ 用于改变文件权限，大概格式如下： chmod [a|g|o|a] [+|-] [r|w|x] 文件名 //方法一chmod 数字表示法 文件名 //方法二 chown与chgrp​ chown用于改变所属用户和组，chgrp用于改变所属组（这两个命令需要管理员权限，chgrp有些鸡肋） sudo chown 用户 文件 //改变所属用户sudo chown 用户:组 文件 //改变所属用户和组sudo chgrp 组 文件 //改变所属组 与统计相关wc​ 该命令用于计数，分别输出行数（可单独-l）、单词数(可单独-w)、字节数(可单独-c) du​ 用于显示当前目录下文件的大小。可选参-h(human，适合人类观看模式) whoami​ 显示当前用户 who​ 显示当前登录系统的用户信息 df​ 显示当前系统的磁盘空间(使用情况)。可选参-h(human，适合人类观看模式) W​ 获取当前登录用户和正在执行的进程 uptime​ 获取系统运行时长和平均负载 uname​ 打印当前系统信息 last​ 显示用户最近登录信息]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 索引用于帮助我们快速找到想要的数据，Mysql的索引是B+树，Redis的索引是hash，HBase的索引是LSM树等等 ​ 没有最好的索引，只有最适合的索引。不同的索引是为了解决不同的问题而实现的 Hash​ 这里就不详细将Hash的原理了。Hash查询的时间复杂度是O（1）的，速度快。但是hash只适合随机查找，不适合范围查找，因为它是无序的，因此也不支持排序。 ​ 而且当key多到内存装不下的时候，hash索引必然有一部分会存储到磁盘上。而磁盘上hash的效率就特别慢了。 B+树​ B+树查找的时间复杂度为O(logn)，但它支持范围查找和排序 ​ 说B+树前，先说一下它的基石，对于平衡树中的各种细分的种类，它们的大概关系为： ​ 平衡树是对二叉搜索树的改进，红黑树是对平衡树的改进，B树是对红黑树的改进，B+树是对B树的改进。 ​ 对于二叉搜索树而言，它综合了数组和链表的优点，它无论是插入还是查找某个元素，平均复杂度都是O(logn) ​ 二叉搜索树可能造成最坏情况O（n）的复杂度（当成一条直线时），这时候我们对二叉搜索树进行改进，让其在插入元素后仍保持平衡（这样就可以维持O(logn)的时间复杂度），它们是通过左旋右旋操作实现的 ​ 红黑树相比平衡树，通过引入红黑节点变色操作。损失了一定的平衡性，但是减少了旋转操作的次数，增强了效率。 ​ 当数据量特别大的时候，就需要将数据存到磁盘上。由于磁盘的IO查找速度很慢，如果二叉树的层数很多，就需要多次转动磁盘，效率很低。如果我们允许一个节点存储多个元素（由于磁盘实际读取会读取一个磁盘快大小到内存，大概为4k，这样我们把一个节点的大小设置为4k刚好），这样就可以降低树的高度，减少IO磁盘转动的次数，这就是B树 ​ 我们可以在B树的基础上，尽可能更多的一个节点读取更多的信息，这就有了B+树。B+树在内部节点中只存储索引字段而不是数据内容，这样节点的存放数据量更多，树的高度更低，IO磁盘转动的次数更少。除此之外，sql中经常会有范围查找，B树只能遍历范围内的每个节点，然后挨个查找。而B+树会将叶子结点会通过指针链接起来。这样范围查找可以直接通过这条链表从范围的起始位置走到结尾。 ​ 大概1TB的内容只需要B+树的4层。在此基础上，我们可以一直把B+树的根节点保存在内存中减少一次IO操作。 ​ 当B+树面对海量数据的时候也会显得力不从心，毕竟每次写入数据前都先要查找数据应该写入的位置。而且当需要分库分表时（当数据超过两千万左右时，避免B+树的高度增加于是分库分表）特别麻烦。 LSM TREE​ 在NoSql数据库中（非关系型数据库）使用LSM Tree，它将磁盘的顺序写发挥到极致，适用于大规模数据量写入。 倒排索引​ 用于全文检索（例如搜索一个词，把所有出现这个词的网页都显示出来）。是通过分词和字典树来实现的。 ​ 它会把每个网页中的词都单独拿出来，扔到集合中，比如hashmap（这里的key是单词，value是包含这个单词的所有文章的编号列表） ​ 当数据量少的可以用hashmap或者平衡树，当数据量大的时候就可以使用字典树了（在字典树节点中存储这个单词所有文章的编号列表）]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持DB和缓存一致性]]></title>
    <url>%2F2019%2F05%2F13%2F%E4%BF%9D%E6%8C%81DB%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 对于维持DB和缓存的一致性，我们先假设更新数据库和更新缓存都可以成功的情况。 ​ 主要有以下几种方法： Cache Aside Pattern​ 对于一致性更新，先把数据存到数据库中，成功后再让缓存失效 ​ 这时，对于并发的更新和查询操作，并发查询操作拿到的是脏数据，而更新成功后的查询操作都是更新后的数据。 ​ 不过理论上也有一直出现脏读的可能性：并发读和写，读操作缓存不命中，读操作从数据库取数据。此时写操作修改完数据库，让缓存失效。然后之前读的操作把脏数据存入缓存，造成缓存中脏数据存在。（可能性特别低，因为写操作比读操作慢很多，读操作在写操作前进入数据库操作并在写操作结束后就结束可能性特别低） Read/Write Through Pattern​ 应用认为后端就是一个单一的存储，后台数据库自己维护缓存。其中Read Through Pattern策略是在查询时更新缓存（当缓存失效的时候，后台服务器自动加载），而Write Through Pattern策略是在更新时更新缓存（当有数据更新时，如果没有命中缓存，则更新数据库并发返回。否则更新缓存再由缓存更新数据库） Write Behind Caching Pattern​ 在更新数据的时候，只更新缓存，不更新数据库，然后缓存会异步地批量更新数据库。这样效率非常快。缺点是数据库和缓存不能保持强一致性，还可能造成数据丢失 mysql更新缓存方式​ 先更新缓存，然后异步把数据写到磁盘上。为了保证数据不丢失，采用WAL方法：数据进来后先把数据以log方式写到磁盘（由于是顺序写，所以很快）。写完后进行更新缓存操作，若出现死机等情况，重启后可以从log文件中重新把数据读出来然后再更新到缓存，最后异步更新到数据库。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务隔离级别、脏读、不可重复读、幻读]]></title>
    <url>%2F2019%2F05%2F13%2F%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 数据库隔离级别​ 事务隔离是多个事务同时进行时的隔离。它们之间的相互影响与隔离级别有关 ​ 数据库隔离级别数据库事务的隔离级别有4个，分别是读未提交（可能出现脏读、不可重复读、幻读）、读已提交（可能出现不可重复读、幻读）、可重复读（可能出现幻读）、可串形化。隔离级别越来越高，事务之间的影响越来越小，效率越来越低 读未提交​ 举个例子：两个窗口卖最后一张票，第一个窗口有一个人买票，但是该事务未提交。第二个窗口另一个人再买票发现票已经有人买，然后就离开了。结果第一个窗口的人不买了，于是回滚了事务并提交，最后票没卖出去。 ​ 上述情况中，第二个窗口的人读到的”票已经有人买了”是一个脏数据，它并不是最后事务提交的数据。因此读未提交可能会出现脏读的情况。 读已提交​ 它解决了上面脏读的情况 ​ 举个例子：A拿银行卡消费，查询卡里有100元钱。同时B将该卡的100元转走，在A之前提交了事务，当A进行消费时，扣款失败。 ​ 也就是说，A先读数据，B跟着更新了数据并提交了事务，当A再次读取数据时，数据已经发生变化，这就是所谓的不可重复读。Oracle默认为读已提交 可重复读​ 它保证同一事务中只会读取到当前事务对数据的修改，其它事务修改的数据不会影响当前事务的读取。（意为可重复读到相同的东西） ​ 也就是在上述情况下，当A拿银行卡消费时，B不能进行转账。 ​ 但是在这个级别下，还可能出现幻读的情况。 ​ 幻读的例子：比如当前有20元钱，A事务查询钱数得到20，此时B事务更新了钱数为0并提交了事务。然后A事务执行更新update操作，然后再查询钱数得到0。mysql默认为读已提交 可串形化​ 串形将所有的事务一个一个的进行，所以穿行化的事务隔离级别不会出现脏读、不可重复读、幻读等问题。代价就是性能特别低]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存]]></title>
    <url>%2F2019%2F05%2F13%2F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 之前也有说过缓存的三大问题及解决方案：可以 跳转 到这儿看一下 ​ 结合网上查阅的博文，整体说一下缓存的概念 缓存出现的原因​ 缓存出现的目的只有一个：缓冲不同介质IO速度，从而加快访问速度 ​ 对于不同介质之间的数据传输，速度快和速度慢的不匹配，会导致速度快的长时间处于等待状态，造成资源的浪费，最典型的例子就是CPU和磁盘之间的不匹配。 ​ 至于我们为什么选择磁盘而不选择速度更快的内存等进行大量存储。因为内存的不可靠性(断电不保存)以及受体积、价格因素的影响。既然不能在存储介质上做文章，那么聪明的人类又引入了缓存这个概念，来尽量匹配磁盘和CPU的工作效率。 ​ 缓存的概念就是：我们提前将可能将要使用的数据，从速度慢的介质里面放到速度快的介质里面。这样下次用到某个数据时，CPU就可以直接从速度快的介质中获取。其中，提前准备的数据就是缓存 ​ 可以说，缓存的技术无处不在。在操作系统、计算机网络、数据库中均有体现。 缓存模型​ 对于整个计算机而言： ​ 对于整个网络而言： 缓存数据的方法局部性原理缓存​ 局部性原理的核心在于赌用到某些数据，也会马上用到该数据相邻的数据。比如我们获取一个乒乓球拍信息，可能还会有很大概率获取乒乓球信息。我们获取一个用户的个人信息，可能还会有很大概率获取他的动态。于是，我们获取一个信息时，会一次性把与之相关的信息全部从磁盘读出来放到内存。 ​ 运用局部性原理，CPU会把相邻的指令一起从L1缓存读到寄存器。从磁盘读取数据时，也会一次性把所在磁盘扇区的数据全部读进来（前提是程序设计者在存储数据时把相关数据存在一起） 缓存淘汰算法​ 当缓存满时需要对已经缓存的数据进行替换，这时候就需要进行缓存数据的替换。常见的有先进先出（FIFO），LRU（最近最少使用，Java的LinkedHashMap，Redis，MySQL的BufferPool的缓存都是基于LRU实现的），OPT（最优置换，无法实现） ​ 对于mysql来说，系统上线后会先把常用的数据筛选一遍，找到热点数据放入MySQL的BufferPool中。除此之外还做了优化，把缓存划分成两部分，一部分用来存热点数据（永远不被淘汰），另一部分用来存可以被淘汰的冷数据，对冷数据部分进行LRU。当一些数据被频繁访问时，可以作为热数据存到第一部分中 缓存命中和缓存失效​ 失效：程序先从缓存中查找数据，没有找到然后在数据库中取数据，若成功则把数据加入到缓存当中 ​ 命中：程序从缓存中查找数据，成功后返回]]></content>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储介质]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 影响程序运行效率最大的两个因素：算法和IO快慢。其中影响IO快慢，就是各种存储介质的工作原理了。 内存​ 内存由晶体管和电容组成，晶体管是控制电容充放电的开关（电容充满电是0，放完电是1），一个基本单元可以存储1bit数据。内存单元按照一定顺序排列成矩阵，就是内存。然后给它们的每个单元编上号，这个编号就是内存地址。 ​ 从内存单元的构成可知，一旦断电，内存所存储的信息全部都会消失，所以内存是不安全的。 ​ 至于为什么断电后信息全部消失，是因为电容中的电荷会天然流失，需要每隔1～3ms进行充电补充电荷来维持0状态位。因此一旦断电，所有位都会变为1 结合实际​ 由于对于0状态位需要不断的进行充电来维持状态，因此运行占用内存大的程序，电脑的耗电会更多，比如玩游戏。（当然只是其中一个原因） 固态硬盘SSD​ SSD和内存一样，都是通过电容中的电荷量来模拟0和1状态位，相比内存，它多了两大功能： 1. 一个存储单元可以存储多个比特位，比如电荷容量在3/4～1时代表00，1/2～3/4代表01，1/4～1/2代表10，低于1/4代表11。可以表示的比特位越多，价格也就越贵 2. 相比内存&quot;晶体管+电容&quot;的结构，SSD增加了一层绝缘装置，断电后电荷不会流失，所以不需要持续充电。（当然电荷不流失不是绝对的，当绝缘层出问题的时候，可能就会造成数据的破坏） 为什么内存会被固态硬盘快​ 内存和固态硬盘的结构差不多，至于为什么内存更快，原因有以下几点： 1. 内存相比SSD，距离CPU更近 2. SSD的数据需要通过内存再到达CPU，而无法直接与CPU进行交互 3. 受限于SSD的SATA接口数据传输 磁盘​ 磁盘与内存和SSD存储原理不同，磁盘的表面是一层磁性涂料，整个磁盘表面被称为磁面，一圈一圈的同心环称为磁道，每个磁道又可以切分成一个个的扇区()，扇区里有一个个的存储单元被称为磁针。除此之外，还有磁臂支撑起的磁头，通过加电后对磁针进行磁化来实现写数据，通过不加电时感应小磁针磁场的作用来实现读数据。 ​ 其中，对同一磁道的不同扇区进行操作时，依靠磁盘的主轴转动（速度快）。对不同磁道的数据进行操作时，依靠磁盘的磁臂进行移动（速度慢），这时就引出了磁盘调度算法（包括电梯算法，先来先服务，最近优先等） ​ 被磁化的数据几乎可以持久保存（但是遇到高强度的磁场就会GG）]]></content>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唯一id生成算法]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 我们在很多情况下都需要用到一个唯一标识，比如一个用户id，一个订单号等等。因此，我们需要设计一种算法来保证标识的唯一性。 ​ 具体算法： UUID 和 GUID​ UUID含义是通用唯一识别码，让分布式系统中的所有元素，都能有唯一的辨识 数据库自增主键​ 这种实现方式特别简单，但是不能对数据库进行分表操作，否则id就会重复。 数据库自增主键优化​ 让数据库中不同的表从不同的下标开始，每次自增n（n为表的个数），这样就解决了重复问题。 ​ 但是不便于日后维护，因为以后再新扩建一个表就十分麻烦 数据库自增主键再优化​ 单独使用一张（或固定几张）数据库表专门来产生自增id。后序不再重新分表，数据量大时可以删除早一些时候产生的数据。 时间戳​ 用当前时间戳作为唯一id。这样有个缺点，在同一时间生成的id重复 snowflake​ 对于时间戳来说，如果同一时间有多个请求进来，可以在时间戳后接上一个数字（通过锁机制来实现每次递增，每毫秒清零重新计数） ​ 上述解决了高并发问题，而无法解决分布式环境下。我们可以在时间戳+计数的基础上拼接上机器的id。 ​ 但是可能在不同的数据中心，机器id编号相同，这样就可以继续拼接上数据中心的id。 ​ 这样做可以实现id的唯一性，且长度适中，算法较为简单。 算法为递增的优势​ 递增对IO友好，尽可能的使数据靠近在一起，就不需要频繁的抬起磁头，一直写会快很多。对于一些大型分布式数据库，比如HBase，ElasticSearch等都是利用顺序写来提高写性能。]]></content>
      <tags>
        <tag>算法之美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性哈希]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 一致性哈希​ 一致性哈希是一种特殊的哈希，当哈希表的大小发生变化的时候，平均只有n / m（n为key总数，m为哈希表的大小）个key值需要重新计算映射关系。解决了一般哈希算法，当hash表发生变化几乎所有key都要重新映射的问题。 实现方法1. 一致性hash通过一个hash环来实现，将环分为2^32份 2. 数据key经过hash函数得到的整型一定在环上，机器和用户（比如ip或者机器名）hash后得到的整型也一定在环上（因为整型的范围为2^32） 3. 如果key的hash值和机器的hash值映射在环上的同一个位置，那么就将key存在这个节点，否则就沿着环顺时针找第一个存在机器hash映射的位置，然后将key值映射到该位置处 4. 删除节点时，从被删除节点开始沿着环顺时针找第一个存在机器hash映射的位置，然后把被删除节点的所有key值映射到到该位置处 5. 增加节点时，把增加节点位置处到逆时针的前一个节点处的所有key值都映射新的节点位置处 改进和扩展​ 我们会发现，可能利用这种方式会照成数据分配严重不均的情况，比如只有两个机器，映射位置分别为1，3，那么2～3位置的key会在3中进行存储，而4～2^32范围和1都在1中存储。因此会造成数据分配的不均问题。 ​ 因此，我们可以通过在hash环中添加一些虚拟节点（分配均匀），然后使得可以key尽量均匀的分配到不同的虚拟节点当中，然后把虚拟节点的数据映射到真实节点即可。 应用​ 比如我们在做分布式存储的时候（将数据分片存储到多态机器上），我们通过hash来将数据进行映射到不同机器中。这时候我们可能会遇到机器出状况可能会挂掉一个，有时候数据量太大需要对机器数量进行扩大。 ​ 这时候机器数量一旦变动就需要对数据重新取模造成大量缓存失效，这时我们就可以用到一致性哈希来解决大量数据失效的问题了。]]></content>
      <tags>
        <tag>算法之美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 布隆过滤器​ 用于判断一个元素是否在某个集合中。相比hash，它不需要存储key值更加节省空间，而且由于不存储key值保密性更好。但是有一定概率判断出错，且无法删除集合中的元素。（以差错率换取空间） 算法内容：​ 它主要就是对hash的扩展和更改，牺牲了一部分的准确性来换取时空的效率。它的算法核心是： 添加时： ​ 1.开一个n比特的数组全部初始化为0 ​ 2.对一个key值分别映射到k个哈希函数，得到k个整型值 ​ 3.将这k个整数所对应的位设置为1 查询时： ​ 1.对一个key值分别映射到k个哈希函数，得到k个整形值 ​ 2.查询k个整数所对应的位是否全为1，如果全为1则认为存在（可能会有一定的误差） 布隆过滤器的概率推导：​ 对于一次hash函数映射，位数为m的数组某一位仍然为0的概率： (m - 1) / m ​ 对于k次hash映射，位数为m的数组某一位仍然为0的概率： ((m - 1) / m) ^ k ​ 插入n个元素，每个元素k次映射，位数为m的数组某一位仍为0的概率： ((m - 1) / m) ^ (kn) ​ 那么某一位为1的概率为： 1 - ((m - 1) / m) ^ (kn) ​ 因此我们查询一个key，它在k个映射位都为1的概率为： (1 - ((m - 1) / m) ^ (kn)) ^ k 推导结论​ 当固定key个数(n)和数组位数(m)，那么哈希函数个数k最好为： ln2 * m / n 应用场景：​ 我们可以用布隆过滤器来对数据进行过滤。比如通过设置布隆过滤器来避免缓存穿透，每次需要查询后端时，先判断key值是否在后端存在，就能避免频繁查询不存在的key值请求后端导致压力过大。除此之外，对于垃圾邮件的过滤等操作，也可以应用布隆过滤器]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法之美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态库和静态库相关]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 讲静态库和动态库之前，先说一下gcc的编译流程： ​ （图片来自室友男神，地址：跳转） ​ 至于静态库和动态库，他们的区别在于链接阶段的处理不同（一个静态链接方式，一个动态链接方式） 静态库​ 目标文件.o与静态库一起链接成可执行文件，对应的链接方式为静态链接。它和.o文件类似，可以简单看成是一组目标文件的集合（也就是多个目标文件压缩打包后的一个文件） ​ 静态库的命名规则：前缀时lib，后缀是.a 静态库特点1.静态库对函数库的链接是放在编译时期完成的，执行快2.发布应用时不需要发布库3.浪费空间和资源，所有的相关目标文件和牵扯的函数库被链接成可执行文件，体积大4.不利于程序的更新。如果静态库更新了，使用它的应用程序都需要重新编译发布 静态库的创建​ 1.先将代码文件编译成.o文件 ​ 2.通过ar命令将目标文件打包成.a静态库文件 ar -crv libtest.a *.o //.o文件可以有多个 静态库的查看​ 利用nm命令查看静态库的信息 nm libtest.a 静态库的使用​ 在编译的时候，利用-L选项指定静态库的搜索路径，利用-l指定静态库名(由于查找有隐含命名规则，因此无需在前加lib后加.a或.so) g++ p.cpp -L../Test -ltest 动态库​ 动态库命名规则：前缀是lib，后缀是.so 动态库特点​ 动态库可以解决静态库空间浪费的问题，也能解决静态库更新麻烦的问题。 ​ 动态库在程序编译时不回被链接到目标代码中，直到程序运行才被载入（避免了更新麻烦，用户只需要更新动态库即可）。不同的应用程序如果调用相同的库，那么在内存里只需要一份该共享库的实例（避免了空间浪费），也就是在栈区和堆区之间的共享库映射。 ​ 当然动态库的缺点，就是相对于静态库而言，速度较慢。且在发布应用的时候同时需要发布动态库 动态库的创建g++ -fPIC -c *.cpp //首先生成目标文件，注意需要加选项-fpic，它代表创建与地址无关的编译程序，以便能够在多个应用程序中共享g++ -shared -o libtest.so *.o //生成动态库，需要-shared选项指定生成动态链接库//上面两个命令可以合并为：g++ -fPIC -shared -o libtest.so *.cpp 动态库的使用​ 和静态库一样，在编译的时候，利用-L选项指定动态库的搜索路径，利用-l指定动态库名(由于查找有隐含命名规则，因此无需在前加lib后加.a或.so) g++ p.cpp -L../Test -ltest ​ 这样可能会出现动态链接没有找到动态库的问题，这时解决方法： 方法一：将libxxx.so在/lib下面做一个软连接。方法二：将库路径加到环境变量 LD_LIBRARY_PATH中方法三：编辑/etc/ld.so.conf文件，加入动态库文件所在目录的路径，然后运行ldconfig]]></content>
      <tags>
        <tag>C++</tag>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象内存模型]]></title>
    <url>%2F2019%2F05%2F08%2FC-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[[TOC] C++对象内存模型​ 一般来说，类成员变量存储顺序按照声明的顺序从低地址到高地址顺序存储。 ​ 对于类的静态成员变量，它单独存储在程序的.data段中，不与特定的对象相关联。 ​ 如果子类和父类的成员变量（或成员函数）同名，则父类的成员变量（或成员函数）会被隐藏（当然它可以通过类名受限的方式来访问），具体如下： class A &#123;public: int a; void f() &#123; printf(&quot;A f\n&quot;); &#125;&#125;class B : public A &#123;public: int a; void f() &#123; printf(&quot;B f\n&quot;); &#125;&#125;int main() &#123; B b; b.a = 0; // 访问的是 B::a b.f(); // 访问的是 B::f() b.A::a = 1; // 访问的是 A::a b.A::f(); // 访问的是 A::f() return 0;&#125; 多继承情况​ 对于下面情况来说： class A: public B, public C &#123; &#125; ​ 这时在A的对象中，由低地址到高地址依次存B的成员变量、C的成员变量、A的成员变量 虚继承情况​ ​ 关于虚继承，大概就是虚基类在子类中只保留一份成员变量，它是通过虚基类表来找到虚基类成员来实现的。 存在虚函数情况​ 存在虚函数的通过低地址的虚函数指针找到对应的虚函数表，来指向对应的虚函数地址。 虚函数多继承情况#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;class A &#123;public: virtual void a()&#123; printf("a\n"); &#125;&#125;;class B: public A &#123;public: virtual void b() &#123; printf("b\n"); &#125;&#125;;class C &#123;public: virtual void a() &#123; printf("c\n"); &#125; &#125;;class D: public B, public C&#123;public: virtual void d() &#123; printf("d\n"); &#125;&#125;;int main () &#123; C *a = new D(); a-&gt;a(); //输出c //((D *)a)-&gt;a(); //两个同名虚函数，报错 return 0;&#125; ​ 在这儿需要说明一下动态多态和静态多态。只有通过基类的引用或者指针调用虚函数时，才能发生动态绑定，如果使用对象来操作虚函数的话，仍然会采用静态绑定的方式 ​ 在存在虚函数的多继承情况下，会存在多个虚函数表。而父类指针指向子类对象时，父类指针只能得知父类有的虚函数表。因此上面第一个输出c，第二个会报错]]></content>
      <tags>
        <tag>C++</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++顺序内存模型]]></title>
    <url>%2F2019%2F05%2F08%2FC-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[强顺序内存模型​ CPU按照正确的指令顺序执行 弱顺序内存模型​ CPU为了性能提升，采用流水线技术，进一步挖掘指令的并行性，一段连续指令使用了不同的寄存器和内存地址，因此一些处理器可能会讲指令执行的顺序打乱执行。这就是弱顺序的内存模型。这种可能会导致错误发生，比如： int thread_1()&#123; int t = 1; a = t; b = 2;&#125;int thread_2&#123; while(b != 2); cout &lt;&lt; a &lt;&lt; endl;&#125; ​ 可能会导致输出的a为0 解决方案​ C++11之前，采用内存栅栏解决。C++11之后，可指定内存顺序： memory_order_relaxed 不对执行顺序做任何保证memory_order_consume 本线程所有后续有关本操作的必须在本操作完成后执行memory_order_acquire 本线程所有后续的读操作必须在本条操作完成才能执行memory_order_release 本线程所有之前的写操作完成后才执行本操作memory_order_acq_rel 同时包含acquire和releasememory_order_seq_cst 全部顺序执行 ​ 因此我们可以通过下面代码来避免该情况的发生： int thread_1()&#123; int t = 1 a.store(t,memory_order_relaxed); b.store(2,memory_order_release);&#125;int thread_2()&#123; while(b.load(memory_order_acquire) != 2); cout &lt;&lt; a.load(memory_order_relaxed);&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存模型]]></title>
    <url>%2F2019%2F05%2F08%2FC-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[[TOC] C++内存模型​ C++内存由高地址到低地址依次是栈区（向下增长，用于存放函数内的局部变量，形参和函数返回值。系统会自动管理栈区的内存分配与回收）、堆区（向上增长，由程序员主动申请和释放，容易造成内存泄漏）、静态区（也叫全局区，静态变量和全局变量的存储区域一样，静态区的内存直到程序完全结束才会被释放）、常量区（用于存放常量）、代码区（用于存放代码） 分成多个区的原因​ 通过对不同数据进行分类，可以方便访问、节约空间和方便管理。对于临时数据和多次使用的代码因为生命周期短，因此放入栈区。全局和静态变量可能在整个程序中都需要访问，因此需要单独管理。堆区可由用户自行分配方便管理 栈区​ 栈区内存由系统自动分配释放，栈区是先进后出原则，且栈区地址是向下增长的。 堆区​ 堆区是向上增长的，因此后申请的内存地址会依次增大 静态区（全局区）​ 静态全局变量、静态局部变量、全局变量都存储在静态区。若未初始化，那么系统会自动为其初始化为0。对于静态局部变量来说，多次调用函数编译器只会为第一次初始化分配内存。 常量区​ 用于存储常量，不可被修改。举个例子： char *p = &quot;abc&quot;;//此时指针变量p存储在栈区，而它指向存储在常量区的字符串常量&quot;abc&quot;，我们可以改变p的指向，但是不可以改变指向的内容char s[] = &quot;abc&quot;//定义了一个字符串数组s，存储在栈区，它的内容是通过字符串常量“abc”拷贝过去的。因此可以改变s中的内容 代码区​ 代码区的内存由系统控制，用于存放程序编译后的指令。函数的名称也是一个指针，可以通过查询函数名所处的内存地址，查询函数存放的地址]]></content>
      <tags>
        <tag>C++</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统杂谈-1]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[[TOC] 操作系统作为系统资源的管理者：比如打开QQ视频聊天： ​ 1.找QQ文件的时候，逐层打开文件夹，涉及到文件管理 ​ 2.打开QQ，系统会为其分配内存，涉及到内存管理 ​ 3.QQ开始运行，相应的进程被CPU处理，涉及到处理器管理 ​ 4.开始视频聊天，需要将摄像头资源分配给QQ进程，涉及到设备管理 操作系统为上层提供服务：1.命令接口允许用户直接使用（命令分批处理或者交互式） 2.程序接口允许用户通过程序间接使用（系统调用） 3.图形用户接口GUI（比如通过拖拽到垃圾桶删除） 操作系统为下层实现的功能：​ 实现对硬件机器的扩展，比如1.基于磁盘信息的抽象，管理磁盘数据2.防止程序直接与物理资源接触3.将物理资源抽象为进程，方便了多个程序在系统中同时运行 操作系统的四个特征：并发、共享、虚拟、异步。 并发：操作系统会负责协调多个程序交替运行，需要引入中断技术才能实现并发执行 共享：是指系统的资源可以供内存中多个并发执行的进程共同使用，分为互斥共享（摄像头）和同时共享（访问资源） 虚拟：把一个物理上的实体（实际存在的）变为若干逻辑上的对应物（用户感受到的）。分为时分复用（虚拟处理器）和空分复用（虚拟存储器） 异步：多个进程并发执行，由于资源有限，进程是以不可预知的速度交替执行的。 指令和代码的区别：指令是CPU能识别、执行的最基本命令，代码通过翻译可生成机器语言指令。由于指令权限很高，因此分为特权指令和非特权指令（用户态只能执行非特权指令，内核态可以执行非特权指令，CPU中有程序状态寄存器来识别，0用户态1内核态），因此程序叶分为内核程序和用户程序（内核程序在内核空间，应用程序运行在用户空间） 内核的核心：时钟管理（计时用于进程切换等）、中断处理、原语（最接近硬件的部分，具有原子性。有设备驱动、CPU切换等）、进程管理、存储器管理、设备管理等 大内核和微内核（其中后三个在有些操作系统中不将其定义为内核的核心，它属于对系统资源的管理功能，这就是大内核和微内核之分，大内核代码庞大，性能快；微内核结构清晰方便维护，但需要在内核态和用户态频繁切换） 中断：只要发生中断，就意味着需要操作系统介入（也就是从用户态到内核态）流程：比如CPU收到计时器部件发出的中断信号/或发出系统调用/或内中断信号等，然后切换为核心态对中断进行处理（因为特权指令只有内核态有权限） 用户态-&gt;内核态：通过中断实现；内核态-&gt;用户态：通过执行一个特权指令，将CPU中程序状态寄存器的标识位改为用户态 外中断的处理过程：CPU执行一个进程的多个指令，每执行完一个指令CPU都会检查是否有外部中断信号，若不存在继续执行，若存在保护进程的状态进行保存（通过状态寄存器、指令计数器等等），然后CPU根据中断信号的类型转入相应的中断处理程序（中断处理程序位于内核态 进程控制块：每个进程被创建时，系统会为其配置一个数据结构，称之为进程控制块（PCB），用于描述进程的各个信息（包括对内存地址的映射、进程切换时信息的存储（也就是各种寄存器值）、进程号和所属用户、状态（就绪、运行、阻塞）、优先级等），PCB是进程存在的唯一标示，位于内核态。创建进程实质是创建PCB，撤销进程实质是撤销PCB 进程的组织（也就是系统中对多个进程之间的组织）：分为链接方式（按进程状态分为多个队列，系统有指向各个队列的指针）和索引方式（按照进程状态的不同建立几张索引表，系统有指向各个索引表的指针） 进程控制：主要时实现进程状态的转换，通过原语实现。原语的特点是执行期间不可中断，运行前有关中断指令，结束后有开中断指令。在此期间外部中断信号是被忽略的。原语的功能：更新PCB的信息，将PCB插入合适的队列，分配回收资源 进程间通信：由于进程拥有的内存地址相互独立，因此一个进程不能直接访问另一个进程的地址空间。因此操作系统为保证安全性会提供一些方法让其进行通信。 通信之共享内存：两个进程对共享内存的访问必须互斥，操作系统负责提供共享空间和P、V操作 通信之管道：用于连接读写进程的一个共享文件（实质就是在内存中开辟一个固定大小的缓冲区，它是一个半双工通信，同一时间段只能单向）。广义上讲同步，两端必须各有一个进程，狭义上互斥，因为一端进程写的时候另一个端不能读。数据以字符流的形式写入管道，当管道写满，write()会被阻塞，然后等待读进程取走管道变空，然后读进程阻塞。循环这个过程 线程控制块和线程切换：也有线程控制块也有状态（就绪、阻塞、运行）。线程切换不一定进程切换，进程切换线程一定切换。 用户级线程和内核级线程。用户级线程由程序通过线程库来实现的。所有线程管理工作由应用程序负责（包括线程切换），因此线程切换可以在用户态下完成，操作系统意识不到线程的存在。 而内核级线程的管理工作是由操作系统内核完成。因此线程调度、切换等工作都由内核负责。操作系统能看到线程的存在 对于同时支持用户级线程和内核级线程的操作系统，可采用两者组合方式，将n个用户级线程映射到m个内核级线程（n&gt;=m），这时即使系统是四核，也最多只能有两个用户线程并行执行。（也就是说，内核级线程才是资源分配的单位） 用户级线程映射到内核级线程有几个模式：1.多对一（线程并发性低，线程切换无须到内核态，线程管理开销小） 2.一对一（线程并发性高，线程切换需要到内核态（因为涉及到内核级线程的切换），线程管理开销大） 3.多对多（集二者的优缺点） 高级调度（作业调度）：属于内存与外存之间的调度，每个作业只调入一次（调入时创建PCB），调出一次（调出时撤销PCB）。按一定原则从外存上处于后备队列的作业中挑选一个或多个作业，给他们分配内存等必要资源，并建立相应的进程，使他们获得竞争处理器的权利。（大概就是无-&gt;创建态-&gt;就绪态） 中级调度（内存调度）：也就是内存调度（详细自己想）就是决定把哪个处于挂起状态的进程重新调入内存，一个进程可能多次调入调出。暂时调到外存等待的进程状态为挂起状态，PCB不会被调到外存，而是常驻内存，只是把PCB放到挂起队列中。（这涉及到起状态模型，多了一个就绪挂起（和就绪态双向），一个阻塞挂起（和阻塞态双向），然后阻塞挂起可以到就绪挂起）（大概就是挂起态-&gt;就绪态） 低级调度（CPU调度）：也就是CPU调度（详细自己想）就是从就绪队列中选取一个进程变为运行态。它的发生频率最高（大概就是就绪态-&gt;运行态） 阻塞、就绪、运行态都在内存，而就绪挂起、阻塞挂起都在外存上 在什么时候不能进行进程间切换：1.处理中断的过程 2. 进程在操作系统内核程序临界区中 3.原子操作过程中 临界资源是指一个时间段只允许一个进程使用的资源，临界区是执行临界资源的代码 操作系统的性能指标CPU利用率：指CPU忙碌时间占总时间的比 系统吞吐量：总共完成多少道作业/总共 周转时间：作业从提交系统开始到完成结束所需时间 带权周转时间：周转时间/所需时间 平均周转时间：所有作业的平均值 CPU虚拟轮转法为什么优先I/O繁忙型进程：因为I/O设备可以和CPU并行工作，如果优先I/O繁忙型进程，更有可能让I/O设备尽早工作，资源利用率得到提高 管程：一种高级的进程互斥、同步机制。管程是一种特殊的软件模块（类似于类），它有对应的数据结构、对数据结构进行操作的函数、初始化语句以及管程的名字。因此管程的数据只能被管程的函数所访问，一个进程只能通过调用管程的函数才能访问管程的数据，每次只允许一个进程在管程中执行某个函数。编译器负责实现各进程互斥的进入管程中的过程 同步和异步同步：这些进程因为需要在某些位置上协调它们的工作次序而产生制约关系。而异步是多个进程并发执行，由于资源有限，进程是以不可预知的速度交替执行的。 实现进程互斥的方法：1单标志法，2双标志先检查，3双标志后检查，4.Peterson算法 单标志法：用于两个进程之间，一个进程在访问完临界区后会把权限转交给另一个进程。有一个标志位，标志为几就允许几号进程访问临界区（缺点是一个进程想访问，另一个进程不访问，而标志位在另一个进程，这时无法继续） 双标志先检查法：设置一个布尔数组，用来标记各进程想要进入临界区的意愿。如果没有其它的进程为true，它就把自己的所在位设为true，访问完临界区再修改为false（这种访问bug特别多，因为检查过程和设置true的过程不是原子操作） 双标志后检查法：先上锁后检查，避免双标志先检查法的bug，但是又有新的bug（两个进程都true，结果都在等待） Peterson算法：孔融让梨的思想，设置一个布尔型数组，用来标记各进程想要进入临界区的意愿，再设置一个单标志，用于优先哪个进程进入临界区。进程想要进入临界区时，会设置意愿为true，并礼让另一个 进程，把单标志设置为对方。如果对方有想进入的意愿且单标志位为对方，那么就等待，否则就进入临界区，出临界区把意愿设置为false 进程互斥的硬件实现方法：中断屏蔽，TestAndSet(TS指令)，Swap指令 中断屏蔽：就是先关中断，然后再开中断。1.它只是用于单核处理机。因为对于多核处理器来说，关中断开中断只对它所属的处理机有效，可能其它进程在另一个处理机处理。2.开关中断权限高，只适用于内核进程 Ts指令：通过硬件来实现的，执行的过程不允许被中断。（原理就是利用新旧bool，循环利用Ts函数检查新的bool是否为false，为true循环检测，为false则访问资源，访问完毕将新bool设置为false。在Ts函数中，若为true，则更新旧的为true，新的也为true，返回旧的；若为false，则更新旧的为false，新的为true，返回旧的） 信号量机制：用户进程可以通过一对原语（wait和signal）来对信号量进行操作。信号量其实就是一个变量，可以用来表示系统中某种资源的数量。分为整型信号量和记录型信号量 整型信号量；wait简易来说就是一个while循环直到变量&gt;0，然后进行—操作，signal建立来说就是进行++操作 记录型信号量；相比整型信号量多了一个等待队列，wait就是对信号量进行- -操作，若该值小于0，就把进程从运行态转变为阻塞态。signal就是对信号量进行++操作，若信号量值小于等于0，那么就唤醒等待队列中的一个进程（也就是让进程从阻塞态变为就绪态）]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker简单使用]]></title>
    <url>%2F2019%2F05%2F04%2FDocker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是docker？​ Docker是一个开源引擎，可以为应用创建一个轻量级的容器。我们在电脑上编译测试通过的容器可以批量在生产环境中部署。 什么是docker容器？​ docker容器可以理解为在沙盒中运行的进程，沙盒包含了该进程运行所必须的资源。包括文件系统、系统类库、shell环境等等。沙盒默认不运行任何程序，我们需要在沙盒中运行一个进程来启动某个容器。这个进程是该容器的唯一进程，当进程结束，容器也会完全停止 docker的用途 web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； docker的结构​ Docker系统有两个程序：docker服务端和docker客户端。 ​ docker服务端是一个服务进程，管理所有容器。 ​ docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。 ​ 大部分情况下，docker服务端和客户端运行在一台机器上。 docker的使用Step1:查找想使用的镜像​ 使用命令$docker search 镜像名查找想使用的镜像 Step2:下载镜像​ 使用命令$docker pull 用户名/镜像名。注意：大部分的镜像都是按照用户名/镜像名来存储的，还有一些ubuntu等基础镜像，可以直接用镜像名来检索到。 Step3:在镜像中运行命令​ 使用命令$docker run 用户名/镜像名 命令来运行，比如安装ping： $docker run learn/tutorial apt-get install -y ping Step4: 保存对容器的修改​ 我们可以先利用$docker ps -l命令获取安装完程序后容器的id。 ​ 利用$docker commit 容器id 保存路径，命令返回新版本镜像的id号 Step5：运行新镜像​ 利用$docker run 保存的路径 命令来运行 查看运行中的镜像​ 利用$docker ps查看所有正在运行中的容器列表，利用docker inspect 容器id查看某个容器更详细的信息 发布自己的映像​ 用docker images命令列出所有安装过的镜像 ​ 用docker push命令可以将一个镜像发布到官网（当然只是发布到自己的空间下面）]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题反思]]></title>
    <url>%2F2019%2F04%2F28%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8D%E6%80%9D%2F</url>
    <content type="text"><![CDATA[​ 自己好紧张啊。。。。紧张到我自己都不知道自己说什么，对方问的什么。。脑子像浆一样。。。挂了电话强行清醒了一下。。 ​ 第一个问题，给一个链表，问把其中的偶数逆序一下，要求O(1)空间复杂度。挂了电话想到一个方法，利用两个头指针把奇数的正序连接，偶数的逆序连接，再奇数-&gt;next偶数，发现不满足题意。暂时没想到除了数组更好的办法 ​ 第二个问题，给出一个字符串a，一个字符串b，问能否得到字符串c（不能改变a，b内部的顺序） int dp[1005][1005] = &#123;0&#125;;//假设字符串都是从1开始,str1的长度为n，str2的长度为m//dp[i][j]代表字符串c的前i个字符串，其中由j个字符串a组成，i - j 个字符串b组成。dp[0][0] = 1; //初始化前0个字符可以由0个字符串a，0个字符串b组成for (int i = 1; i &lt;= str3.size(); i++) &#123; for (int j = 0; j &lt;= i &amp;&amp; j &lt;= n; j++) &#123; if (str3[i] == str1[j] &amp;&amp; dp[i - 1][j - 1]) &#123; dp[i][j] = 1; &#125; else if (str3[i] == str2[i - j] &amp;&amp; dp[i - 1][j]) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = 0; &#125; &#125;&#125; ​ 这道题动态规划入门题。。。挂了电话就立刻想到了。。。冷静冷静，感觉自己应该5.1期间出去旅游走走放松放松。。自己面试心态太炸了，冷静，冷静，冷静！！！！]]></content>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode84]]></title>
    <url>%2F2019%2F04%2F24%2FLeetcode84%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode84.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 二 4/23 19:51:20 2019 ************************************************************************///求n个连续柱子组成的最大矩形面积//方法：单调栈来维护//方法一：class Solution &#123;private: stack&lt;int&gt;sta;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int len = heights.size(); int maxx = 0; for (int i = 0; i &lt; len; i++) &#123; if (sta.empty() || heights[sta.top()] &lt;= heights[i]) &#123; sta.push(i); &#125; else &#123; while(!sta.empty() &amp;&amp; heights[sta.top()] &gt; heights[i]) &#123; int inx = sta.top(); sta.pop(); int s = -1, e = i; if (!sta.empty()) &#123; s = sta.top(); &#125; maxx = max(maxx, (e - s - 1) * heights[inx]); &#125; sta.push(i); &#125; &#125; int e; if (!sta.empty()) &#123; e = sta.top(); &#125; while(!sta.empty()) &#123; int s = -1, inx = sta.top(); sta.pop(); if (!sta.empty()) &#123; s = sta.top(); &#125; maxx = max(maxx, (e - s) * heights[inx]); &#125; return maxx; &#125;&#125;;//方法二：int largestRectangleArea(int* heights, int heightsSize) &#123; int *stack = (int *)malloc(sizeof(int) * heightsSize); int *left = (int *)malloc(sizeof(int) * heightsSize); int *right = (int *)malloc(sizeof(int) * heightsSize); //找以该节点往左扩的长度 int top = -1; for (int i = 0; i &lt; heightsSize; i++) &#123; while (top != -1 &amp;&amp; heights[stack[top]] &gt;= heights[i]) --top; left[i] = (top == -1 ? i + 1 : i - stack[top]); stack[++top] = i; &#125; //找以该节点往右扩的长度 top = -1; for (int i = heightsSize - 1; i &gt;= 0; i--) &#123; while (top != -1 &amp;&amp; heights[stack[top]] &gt;= heights[i]) --top; right[i] = (top == -1 ? heightsSize - i : stack[top] - i); stack[++top] = i; &#125; //维护最大范围 int ans = 0; for (int i = 0; i &lt; heightsSize; i++) &#123; ans = fmax(ans, (left[i] + right[i] - 1) * heights[i]); &#125; free(stack); free(left); free(right); return ans;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode42]]></title>
    <url>%2F2019%2F04%2F24%2FLeetcode42%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode42.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 二 4/23 19:45:30 2019 ************************************************************************///给出n个宽度为1的柱子的高度，问最多存多少水//方法：利用单调栈来维护（只有保持V型才能存水，因此递减就添加到栈，递增就维护和//因此我们需要维护一个单调递减栈，在出栈的时候维护和）class Solution &#123;private: stack &lt;int&gt; sta;public: int trap(vector&lt;int&gt;&amp; height) &#123; int sum = 0; for (int i = 0; i &lt; height.size(); i++) &#123; //单调递减就增加 if (sta.empty() || height[sta.top()] &gt; height[i]) &#123; sta.push(i); &#125; else &#123; //出现递增就维护 while(!sta.empty() &amp;&amp; height[sta.top()] &lt;= height[i]) &#123; int inx = sta.top(); sta.pop(); //避免sta.top()访问错误 if (sta.empty()) break; int x = min(height[sta.top()] - height[inx], height[i] - height[inx]); int y = i - sta.top() - 1; sum += x * y; &#125; sta.push(i); &#125; &#125; return sum; &#125;&#125;;]]></content>
      <tags>
        <tag>结构数据</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode236]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode236%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode236.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 18:50:12 2019 ************************************************************************///二叉树求公共最近祖先//方法一：递归（最近祖先有一个特点，要么是左右点各有一个节点，要么是祖先是其中一个节点）//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || !p || !q) return NULL; if (root == p || root == q) &#123; return root; &#125; TreeNode *temp1 = lowestCommonAncestor(root -&gt; left, p, q); TreeNode *temp2 = lowestCommonAncestor(root -&gt; right, p, q); if (temp1 &amp;&amp; temp2) return root; if (temp1) return temp1; if (temp2) return temp2; return NULL; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode235]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode235%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode235.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 17:41:59 2019 ************************************************************************///二叉搜索树的最近公共祖先//方法一：递归从上往下，若都小于该节点递归左节点，若都大于递归右节点，否则直接返回//方法二：非递归//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || !p || !q) &#123; return NULL; &#125; if (root -&gt; val &lt; p -&gt; val &amp;&amp; root -&gt; val &lt; q -&gt; val) &#123; return lowestCommonAncestor(root -&gt; right, p, q); &#125; else if(root -&gt; val &gt; p -&gt; val &amp;&amp; root -&gt; val &gt; q -&gt; val) &#123; return lowestCommonAncestor(root -&gt; left, p, q); &#125; return root; &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: queue&lt;TreeNode*&gt;que;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || !p || !q) &#123; return NULL; &#125; que.push(root); while(!que.empty()) &#123; TreeNode *temp = que.front(); que.pop(); if (temp -&gt; val &lt; p -&gt; val &amp;&amp; temp -&gt; val &lt; q -&gt; val) &#123; if (temp -&gt; right) &#123; que.push(temp -&gt; right); &#125; &#125; else if (temp -&gt; val &gt; p -&gt; val &amp;&amp; temp -&gt; val &gt; q -&gt; val) &#123; if (temp -&gt; left) &#123; que.push(temp -&gt; left); &#125; &#125; else &#123; return temp; &#125; &#125; return NULL; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode226]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode226%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode226.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 15:52:44 2019 ************************************************************************///翻转二叉树//方法一：递归从上往下递归替换//方法二：非递归//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if (!root) return NULL; TreeNode *temp = root -&gt; left; root -&gt; left = invertTree(root -&gt; right); root -&gt; right = invertTree(temp); return root; &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: queue&lt;TreeNode *&gt;que;public: TreeNode* invertTree(TreeNode* root) &#123; if (!root) return NULL; que.push(root); while(!que.empty()) &#123; TreeNode *temp = que.front(); que.pop(); TreeNode *p = temp -&gt; left; temp -&gt; left = temp -&gt; right; temp -&gt; right = p; if (temp -&gt; left) que.push(temp -&gt; left); if (temp -&gt; right) que.push(temp -&gt; right); &#125; return root; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode114]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode114%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode114.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 11:28:59 2019 ************************************************************************///将二叉树转变为单向链表（前序规则）//方法一：递归，利用一个vec进行存进行前序遍历，然后设置//方法二：非递归//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: vector&lt;TreeNode *&gt;vec;public: void dfs(TreeNode *root) &#123; vec.push_back(root); if (root -&gt; left) dfs(root -&gt; left); if (root -&gt; right) dfs(root -&gt; right); &#125; void flatten(TreeNode* root) &#123; if (!root) return; dfs(root); for (int i = 0; i &lt; vec.size() - 1; i++) &#123; vec[i] -&gt; right = vec[i + 1]; vec[i] -&gt; left = NULL; &#125; vec[vec.size() - 1] -&gt; left = NULL; vec[vec.size() - 1] -&gt; right = NULL; return; &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: stack&lt;TreeNode *&gt;sta; vector&lt;TreeNode *&gt;vec;public: void flatten(TreeNode* root) &#123; if (!root) return; TreeNode *p = root; TreeNode *temp = new TreeNode(0); while(!sta.empty() || p) &#123; while(p) &#123; vec.push_back(p); sta.push(p); p = p -&gt; left; &#125; if(!sta.empty()) &#123; p = sta.top(); sta.pop(); p = p -&gt; right; &#125; &#125; for (int i = 0; i &lt; vec.size() - 1; i++) &#123; vec[i] -&gt; left = NULL; vec[i] -&gt; right = vec[i + 1]; &#125; vec[vec.size() - 1] -&gt; left = NULL; return ; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode111]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode111%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode111.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 10:11:38 2019 ************************************************************************///求二叉树的最小深度（最小深度是指从根节点到叶节点的最短距离）//方法一：递归，若节点存在左右节点，则该节点为左右节点深度的最小值+1；否则为左右节点深度的最大值+1//方法二：非递归层次遍历，遍历到第一个出现无左右节点的节点深度返回//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (!root) return 0; if (root -&gt; left &amp;&amp; root -&gt; right) &#123; return min(minDepth(root -&gt; left), minDepth(root -&gt; right)) + 1; &#125; return max(minDepth(root -&gt; left), minDepth(root -&gt; right)) + 1; &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: queue&lt;TreeNode*&gt;que;public: int minDepth(TreeNode* root) &#123; if (!root) return 0; int deep = 0; que.push(root); while(!que.empty()) &#123; deep ++; int len = que.size(); for (int i = 0; i &lt; len; i++) &#123; TreeNode *temp = que.front(); que.pop(); if (!temp -&gt; left &amp;&amp; !temp -&gt; right) &#123; return deep; &#125; if (temp -&gt; left) &#123; que.push(temp -&gt; left); &#125; if (temp -&gt; right) &#123; que.push(temp -&gt; right); &#125; &#125; &#125; return deep; &#125; &#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode113]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode113%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode113.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 10:53:18 2019 ************************************************************************///给出一个二叉树和一个目标和，找到所有根节点到叶子节点路径等于目标和的路径//方法：递归dfs，到根节点判断是否相同，相同就加进去//代码：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; vec; vector&lt;int&gt; temp;public: void dfs(TreeNode *root, int &amp;now, int &amp;sum) &#123; now += root -&gt; val; temp.push_back(root -&gt; val); //当节点为叶节点时 if (!root -&gt; left &amp;&amp; !root -&gt; right) &#123; if (now == sum) &#123; vec.push_back(temp); &#125; now -= root -&gt; val; temp.pop_back(); return; &#125; //当节点不为叶节点 if (root -&gt; left) &#123; dfs(root -&gt; left, now, sum); &#125; if (root -&gt; right) &#123; dfs(root -&gt; right, now, sum); &#125; now -= root -&gt; val; temp.pop_back(); return; &#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; if (!root) return vec; int now = 0; dfs(root, now, sum); return vec; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode110]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode110%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode110.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 09:50:46 2019 ************************************************************************///判断是否是平衡二叉树//方法一：对于每个节点的左右儿子进行dfs查找深度，然后再dfs左子树和右子树是否符合条件，三个同时满足返回真//方法二：引用传参代表深度，然后一次dfs判断是否为平衡二叉树即可//方法二代码：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool istrue(TreeNode* root, int &amp;h) &#123; if (!root) &#123; h = 1; return true; &#125; if(!istrue(root -&gt; left, h)) return false; int h1 = h; if(!istrue(root -&gt; right, h)) return false; int h2 = h; h = max(h1, h2) + 1; if (abs(h1 - h2) &lt;= 1) return true; return false; &#125; bool isBalanced(TreeNode* root) &#123; int h = 0; return istrue(root, h); &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode107]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode107%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode107.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 09:14:10 2019 ************************************************************************///二叉树层次遍历，从下往上//方法一：递归+交换（反转）//方法二：非递归+交换（反转）//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: vector &lt;vector&lt;int&gt;&gt; vec; int num = -1; public: void dfs(TreeNode* root, int deep) &#123; if (deep &gt; num) &#123; vec.push_back(vector&lt;int&gt;()); num ++; &#125; vec[deep].push_back(root -&gt; val); if (root -&gt; left) &#123; dfs(root -&gt; left, deep + 1); &#125; if (root -&gt; right) &#123; dfs(root -&gt; right, deep + 1); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; if (!root) &#123; return vec; &#125; dfs(root, 0); for (int i = 0; i &lt; (num + 1) / 2; i++) &#123; vector&lt;int&gt; temp = vec[i]; vec[i] = vec[num - i]; vec[num - i] = temp; &#125; return vec; &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; vec; vector&lt;int&gt; temp; queue&lt;TreeNode *&gt;que;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; if (!root) return vec; que.push(root); int deep = 0; while(!que.empty()) &#123; int len = que.size(); deep ++; for (int i = 0; i &lt; len; i++) &#123; TreeNode *k = que.front(); temp.push_back(k -&gt; val); if (k -&gt; left) &#123; que.push(k -&gt; left); &#125; if (k -&gt; right) &#123; que.push(k -&gt; right); &#125; que.pop(); &#125; vec.push_back(temp); temp.clear(); &#125; for (int i = 0; i &lt; deep / 2; i++) &#123; temp = vec[i]; vec[i] = vec[deep - 1 - i]; vec[deep - 1 - i] = temp; &#125; return vec; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode105]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode105%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode105.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/19 08:55:40 2019 ************************************************************************///根据前序、中序构造二叉树//递归方式，参数传6个（前序、中序数组，前序开始结尾下标，中序开始结尾下标），当开始&gt;结束为终止条件//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return dfs(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); &#125; TreeNode* dfs(vector&lt;int&gt;&amp; p, int ps, int pe, vector&lt;int&gt;&amp; q, int qs, int qe) &#123; if (ps &gt; pe || qs &gt; qe) return NULL; TreeNode *temp = new TreeNode(p[ps]); int inx = qs; for (int i = qs; i &lt;= qe; i++) &#123; if (q[i] == p[ps]) &#123; inx = i; break; &#125; &#125; //左个数：inx - qs, 右个数：qe - inx temp -&gt; left = dfs(p, ps + 1, ps + inx - qs, q, qs, inx - 1); temp -&gt; right = dfs(p, ps + inx - qs + 1, pe, q, inx + 1, qe); return temp; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode102]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode102%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode102.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 四 4/18 21:12:59 2019 ************************************************************************///二叉树的层次遍历//方法一：非递归遍历（利用一个变量deep记录深度，一个滚动数组num[2]记录每一层的个数）//方法二：递归遍历 (参数传深度deep，再用一个num记录当前最深的深度，只要deep &gt; num就再push一个vector一维数组)/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *///方法一：class Solution &#123;private: vector &lt;vector&lt;int&gt;&gt; vec; queue &lt;TreeNode *&gt; que;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (!root) return vec; vector&lt;int&gt; temp; que.push(root); int deep = 1; int num[2] = &#123;0, 1&#125;; while(!que.empty()) &#123; TreeNode *p = que.front(); que.pop(); temp.push_back(p -&gt; val); num[deep % 2] --; if (!num[deep % 2]) &#123; vec.push_back(temp); temp.clear(); &#125; if (p -&gt; left) &#123; que.push(p -&gt; left); num[(deep + 1) % 2]++; &#125; if (p -&gt; right) &#123; que.push(p -&gt; right); num[(deep + 1) % 2]++; &#125; if (!num[deep % 2]) deep ++; &#125; return vec; &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: vector &lt;vector&lt;int&gt;&gt; vec; int num = -1; public: void dfs(TreeNode* root, int deep) &#123; if (deep &gt; num) &#123; vec.push_back(vector&lt;int&gt;()); num ++; &#125; vec[deep].push_back(root -&gt; val); if (root -&gt; left) &#123; dfs(root -&gt; left, deep + 1); &#125; if (root -&gt; right) &#123; dfs(root -&gt; right, deep + 1); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (!root) &#123; return vec; &#125; dfs(root, 0); return vec; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode101]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode101%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode101.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 四 4/18 20:20:23 2019 ************************************************************************///判断对称二叉树//方法一：递归（函数包含两个参数）//方法二：非递归（注意存BFS的次序，还有根存两次）//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isTrue(TreeNode *l, TreeNode *r) &#123; if (!l &amp;&amp; !r) return true; if (!l || !r) return false; if (l -&gt; val != r -&gt; val) return false; return isTrue(l -&gt; left, r -&gt; right) &amp;&amp; isTrue(l -&gt; right, r -&gt; left); &#125; bool isSymmetric(TreeNode* root) &#123; if (!root) return true; return isTrue(root -&gt; left, root -&gt; right); &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: queue&lt;TreeNode*&gt; que;public: bool isSymmetric(TreeNode* root) &#123; if (!root) return true; que.push(root); que.push(root); while(!que.empty()) &#123; TreeNode *p = que.front(); que.pop(); TreeNode *q = que.front(); que.pop(); if ((p &amp;&amp; !q) || (!p &amp;&amp; q)) return false; if (p &amp;&amp; q) &#123; if (p -&gt; val != q -&gt; val) return false; que.push(p -&gt; left); que.push(q -&gt; right); que.push(p -&gt; right); que.push(q -&gt; left); &#125; &#125; return true; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode100]]></title>
    <url>%2F2019%2F04%2F19%2FLeetcode100%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode100.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 四 4/18 19:20:48 2019 ************************************************************************///判断两个树是否相同//方法一：递归判断//方法二：非递归判断//方法一：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == NULL &amp;&amp; q == NULL) return true; if (p == NULL || q == NULL) return false; if (p -&gt; val != q -&gt; val) return false; return isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q -&gt; right); &#125;&#125;;//方法二：/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: queue &lt;TreeNode *&gt; t1, t2;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; t1.push(p); t2.push(q); while(!t1.empty() &amp;&amp; !t2.empty()) &#123; TreeNode *temp1 = t1.front(); TreeNode *temp2 = t2.front(); t1.pop(); t2.pop(); if (temp1 -&gt; val != temp2 -&gt; val) return false; if (temp1 -&gt; left &amp;&amp; temp2 -&gt; left) &#123; t1.push(temp1 -&gt; left); t2.push(temp2 -&gt; left); &#125; else if (temp1 -&gt; left || temp2 -&gt; left) &#123; return false; &#125; if (temp1 -&gt; right &amp;&amp; temp2 -&gt; right) &#123; t1.push(temp1 -&gt; right); t2.push(temp2 -&gt; right); &#125; else if (temp1 -&gt; right || temp2 -&gt; right) &#123; return false; &#125; &#125; if (t1.empty() &amp;&amp; t2.empty()) return true; return false; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode232栈实现队列]]></title>
    <url>%2F2019%2F04%2F18%2FLeetcode232%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode232.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 四 4/18 18:54:37 2019 ************************************************************************///栈实现队列//方法一：两个队列，一个队列用于存，另一个队列用于反转（删除头，返回头操作），之后再反转回去//方法二：把队列反转，需要用一个临时队列//方法一代码：class MyQueue &#123;private: stack&lt;int&gt; p, q;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; p.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; while(!p.empty()) &#123; q.push(p.top()); p.pop(); &#125; int k = q.top(); q.pop(); while(!q.empty()) &#123; p.push(q.top()); q.pop(); &#125; return k; &#125; /** Get the front element. */ int peek() &#123; while(!p.empty()) &#123; q.push(p.top()); p.pop(); &#125; int k = q.top(); while(!q.empty()) &#123; p.push(q.top()); q.pop(); &#125; return k; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return p.empty(); &#125;&#125;;//方法二：class MyQueue &#123;private: stack&lt;int&gt; p, q;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; while(!p.empty()) &#123; q.push(p.top()); p.pop(); &#125; q.push(x); while(!q.empty()) &#123; p.push(q.top()); q.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int k = peek(); p.pop(); return k; &#125; /** Get the front element. */ int peek() &#123; return p.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return p.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode225队列实现栈]]></title>
    <url>%2F2019%2F04%2F18%2FLeetcode225%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode225.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 四 4/18 18:35:39 2019 ************************************************************************///用两个队列实现栈//方法：把队列反转即可，需要一个临时队列class MyStack &#123;private: queue &lt;int&gt; p, q;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; p.push(x); while(!q.empty()) &#123; p.push(q.front()); q.pop(); &#125; while(!p.empty()) &#123; q.push(p.front()); p.pop(); &#125; return; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int k = top(); q.pop(); return k; &#125; /** Get the top element. */ int top() &#123; return q.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return q.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode20括号匹配]]></title>
    <url>%2F2019%2F04%2F18%2FLeetcode20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode20.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 四 4/18 18:25:07 2019 ************************************************************************///一个字符串只包含()[]&#123;&#125;六种符号，判断字符串是否闭合//方法：使用一个栈来进行匹配操作class Solution &#123;private: stack&lt;char&gt;sta;public: bool isValid(string s) &#123; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;[&apos; || s[i] == &apos;&#123;&apos;) &#123; sta.push(s[i]); &#125; else &#123; if (sta.empty()) &#123; return false; &#125; if (s[i] == &apos;)&apos;) &#123; if (sta.top() != &apos;(&apos;) &#123; return false; &#125; sta.pop(); &#125; else if (s[i] == &apos;]&apos;) &#123; if (sta.top() != &apos;[&apos;) &#123; return false; &#125; sta.pop(); &#125; else &#123; if (sta.top() != &apos;&#123;&apos;) &#123; return false; &#125; sta.pop(); &#125; &#125; &#125; if (!sta.empty()) &#123; return false; &#125; return true; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[落谷P3379最近公共祖先]]></title>
    <url>%2F2019%2F04%2F17%2F%E8%90%BD%E8%B0%B7P3379%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目描述如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入输出格式输入格式： 第一行包含三个正整数N、M、S，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来N-1行每行包含两个正整数x、y，表示x结点和y结点之间有一条直接连接的边（数据保证可以构成树）。 接下来M行每行包含两个正整数a、b，表示询问a结点和b结点的最近公共祖先。 输出格式： 输出包含M行，每行包含一个正整数，依次为每一个询问的结果。 输入输出样例输入样例#1： 5 5 43 12 45 11 42 43 23 51 24 5 输出样例#1： 44144 说明时空限制：1000ms,128M 数据规模： 对于30%的数据：N&lt;=10，M&lt;=10 对于70%的数据：N&lt;=10000，M&lt;=10000 对于100%的数据：N&lt;=500000，M&lt;=500000 思路： ​ 一个lca算法求最近公共祖先的算法，查找时间复杂度O(logn)。中心思想就是利用一个二维数组数组gas[i][j]存储i节点向上2^k步后的节点。核心公式： gas[i][j] = gas[gas[i][j - 1]][j - 1]; 代码如下： /************************************************************************* &gt; File Name: cfsTree.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 六 4/13 18:33:07 2019 ************************************************************************/#include &lt;algorithm&gt; #include &lt;stdio.h&gt;using namespace std;#define MAX_M 1000000#define MAX_N 500000#define MAX_K 32//边的结构体struct Edge &#123; int to, next; //to为边的末尾，next为上一个相同起始点的边的下角标&#125; g[MAX_M + 5];//链式前向星int head[MAX_N + 5] = &#123;0&#125;; //head[i]代表以i为起始点的最后一个边的下角标//边的数量int cnt = 0;//链式前向星实现inline void add(int a, int b) &#123; g[++cnt].to = b; //我们将第cnt条边存到数组的cnt位置处，边的起点是a，终点是b g[cnt].next = head[a]; //那么以a为起点的上一个边的位置为head[a] head[a] = cnt; //然后更新head[a] return;&#125;//gas[i][j]用于存储节点i向上走2^j步到达的节点编号int gas[MAX_N + 5][MAX_K + 5] = &#123;0&#125;;int deep[MAX_N + 5] = &#123;0&#125;; //存储当前节点的深度//一次dfs维护gas数组和deep数组void dfs1(int fa, int inx) &#123; for (int i = 1; i &lt;= MAX_K; i++) &#123; gas[inx][i] = gas[gas[inx][i - 1]][i - 1]; &#125; for (int i = head[inx]; i != 0; i = g[i].next) &#123; if (g[i].to == fa) continue; int to = g[i].to; deep[to] = deep[inx] + 1; gas[to][0] = inx; dfs1(inx, to); &#125;&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) &#123; swap(x, y); &#125; for (int i = MAX_K; i &gt;= 0; i--) &#123; if (deep[gas[x][i]] &lt; deep[y]) continue; x = gas[x][i]; &#125; if (x == y) return x; for (int i = MAX_K; i&gt;= 0; i--) &#123; if (gas[x][i] == gas[y][i]) continue; x = gas[x][i], y = gas[y][i]; &#125; return gas[x][0];&#125;int main () &#123; int n, m, s, a, b; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); add(b, a); &#125; deep[0] = -1; dfs1(0, s); for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\n&quot;, lca(a, b)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 234]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-234%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_234.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 16:25:26 2019 ************************************************************************///判断链表是否为回文链表//方法一：遍历链表将元素存到数组中，然后判断数组是否为回文数组//方法二：递归遍历链表，将元素存到队列中，然后在递归后判断队头是否和当前节点val相同//方法三：将后半段或者前半段链表反转，然后用两个指针同时遍历，若相同则为回文链表//方法二/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: queue&lt;int&gt;que;public: bool isPalindrome(ListNode* head) &#123; if (head == NULL) return true; que.push(head -&gt; val); bool k = isPalindrome(head -&gt; next); if (que.front() != head -&gt; val) &#123; k = false; &#125; que.pop(); return k; &#125;&#125;;//方法三/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: //获取链表长度 int getlen(ListNode *head) &#123; int num = 0; while(head) &#123; num ++; head = head -&gt; next; &#125; return num; &#125; //反转链表 void r(ListNode *k, ListNode *p) &#123; ListNode *last = NULL, *q; while(p) &#123; q = p -&gt; next; p -&gt; next = last; last = p; p = q; &#125; k -&gt; next = last; &#125; bool isPalindrome(ListNode* head) &#123; //获取链表长度并特判 int len = getlen(head); if (len == 0 || len == 1) return true; int step = (len + 1) / 2 - 1; ListNode *p = head; while(step --) &#123; p = p -&gt; next; &#125; //反转后半段链表 r(p, p -&gt; next); //两个指针分别遍历前半段和后半段 ListNode *q = head; p = p -&gt; next; for (int i = 1; i &lt;= len / 2; i++) &#123; if(p -&gt; val != q -&gt; val) return false; p = p -&gt; next; q = q -&gt; next; &#125; return true; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 206]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-206%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_206.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 16:07:08 2019 ************************************************************************///反转链表//方法一 迭代法：设置一个虚拟指针指向当前节点的前一个节点，然后依此遍历链表的节点，让当前节点的next指向前一个节点//方法二//方法二 递归法：遇到当前节点或当前节点的next为空时，返回当前节点；否则递归下一个节点，递归后将当前节点的next-&gt;next设置为当前节点，然后当前节点的next设置为NULL//迭代法/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode temp(0); temp.next = NULL; ListNode *p = head; while(p) &#123; ListNode *q = p -&gt; next; p -&gt; next = temp.next; temp.next = p; p = q; &#125; return temp.next; &#125;&#125;;//递归法/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head -&gt; next == NULL) &#123; return head; &#125; ListNode *root = reverseList(head -&gt; next); head -&gt; next -&gt; next = head; head -&gt; next = NULL; return root; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 237]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-237%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_237.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 11:54:23 2019 ************************************************************************///只给定待删除节点，让你从链表中删除该节点，前提条件：该删除节点不是链表的最后一个节点//由于我们不知道待删除节点的前一个节点，因此我们可以把该节点的下一个节点的值赋值给待删除节点，然后让待删除节点的next指向下一个节点的下一个节点，这样我们删除待删除节点的下一个节点即可//代码实现/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; ListNode *p = node -&gt; next; node -&gt; val = p -&gt; val; node -&gt; next = p -&gt; next; delete(p); &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 202]]></title>
    <url>%2F2019%2F04%2F12%2FLeetCode-202%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_202.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 11:36:36 2019 ************************************************************************///对于一个整数，每次将该数替换为它每个位置的数字的平方和，若最终能得到1，就为快乐数，让我们判断一个数是否为快乐数//对于int型正整数1～2e9左右，因此转变完一次后最大为730（由1999999999得到），因此这个题的最大范围为730。它具备链表的性质（即通过一个状态能唯一的确定下一个状态）//方法一：我们只要转变次数超过730还没有得到1，那么2～730中必定存在重复的数，也就代表着一定成环，因此不是快乐数//方法二：利用map映射，若某个数经历变换之后某个状态出现两次，则不是快乐数//方法三：就是将其当作链表，利用快慢指针原理判断其是否存在环//方法一class Solution &#123;public: int add(int n) &#123; int sum = 0; while(n) &#123; int k = n % 10; sum += k * k; n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; int num = 0; while(n != 1) &#123; n = add(n); num++; if (num &gt; 730) return false; &#125; return true; &#125;&#125;;//方法二class Solution &#123;private: map&lt;int, int&gt;m;public: int add(int n) &#123; int sum = 0; while(n) &#123; int k = n % 10; sum += k * k; n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; while(n != 1) &#123; m[n]++; if (m[n] &gt; 1) return false; n = add(n); &#125; return true; &#125;&#125;;//方法三class Solution &#123;private: map&lt;int, int&gt;m;public: int add(int n) &#123; int sum = 0; while(n) &#123; int k = n % 10; sum += k * k; n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; int p = n; int q = n; do &#123; p = add(p); q = add(add(q)); &#125; while(p != q); return p == 1; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 160]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-160%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_160.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 10:50:18 2019 ************************************************************************///判断两个链表是否相交//方法一：对两个链表节点的哈希值映射一下，若存在映射关系则代表相交//方法二：对两个链表进行遍历确定两个链表的长度，然后进行第二次遍历：长的链表先走差值步，然后两个链表同时走，若存在相同，则代表相交//方法三：两个链表同时走，若第一个链表走到头，则第一个链表走第二个链表；若第二个链表走到头，则第二个链表走第一个链表。若存在相同，则代表相交//方法一/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: map&lt;ListNode *, int&gt;m;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; while(headA) &#123; m[headA] ++; headA = headA -&gt; next; &#125; while(headB) &#123; if (m[headB]) &#123; return headB; &#125; headB = headB -&gt; next; &#125; return NULL; &#125;&#125;;//方法三/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (headA == NULL || headB == NULL) return NULL; ListNode *p = headA; ListNode *q = headB; while(p != q) &#123; p = p -&gt; next; q = q -&gt; next; if (p == NULL) &#123; p = headB; headB = NULL; &#125; if (q == NULL) &#123; q = headA; headA = NULL; &#125; &#125; return p; &#125;&#125;;//方法三的技巧实现/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (headA == NULL || headB == NULL) return NULL; ListNode *p = headA; ListNode *q = headB; //当第二次遍历结束后，两者都变成了NULL while(p != q) &#123; if(!p) p = headB; else p = p -&gt; next; if(!q) q = headA; else q = q -&gt; next; &#125; return p; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 141]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-141%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_141.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 10:27:44 2019 ************************************************************************///判断是否存在环形链表//先设置虚拟头节点//方法一：对于每个节点的地址进行map映射，若已存在映射关系则证明成环//方法二：对于遍历过的节点把节点的next指向自己，遍历过程中若存在指向自己的节点则证明成环//方法三：利用快慢指针，慢指针一次走一个单位，快指针一次走两个单位，若出现快慢指针相同，则成环//方法一/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: map&lt;ListNode *, int&gt;m;public: bool hasCycle(ListNode *head) &#123; if (head == NULL) return false; if (m[head] &gt; 0) return true; m[head] ++; return hasCycle(head -&gt; next); &#125;&#125;;//方法二/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head == NULL) return false; if (head -&gt; next == head) return true; ListNode *p = head -&gt; next; head -&gt; next = head; return hasCycle(p); &#125;&#125;;//方法三/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (head == NULL) return false; ListNode temp(0); temp.next = head; ListNode *p = &amp;temp, *q = &amp;temp; while(q &amp;&amp; q -&gt; next != NULL) &#123; p = p -&gt; next; q = q -&gt; next -&gt; next; if (p == q) return true; &#125; return false; &#125;&#125;;]]></content>
      <tags>
        <tag>-数据结构 -链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 24]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-24%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_24.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 10:13:48 2019 ************************************************************************///两两交换链表中的节点//我们设置虚拟头节点//方法一：我们利用一个变量进行计数，若遇到奇数，若存在下一个节点，就和下一个节点进行数值的交换//方法二：我们可以利用两个临时指针（p用来指向要交换的两个节点的之前节点，q用来指向要交换的两个节点的第一个节点），来实现对实际节点的交换//方法二实现/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; //虚拟头节点 struct ListNode temp(0); temp.next = head; //两个临时指针 struct ListNode *p = &amp;temp, *q = temp.next; while(q &amp;&amp; q -&gt; next) &#123; p -&gt; next = q -&gt; next; q -&gt; next = p -&gt; next -&gt; next; p -&gt; next -&gt; next = q; p = q; q = q -&gt; next; &#125; return temp.next; &#125;&#125;;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 19]]></title>
    <url>%2F2019%2F04%2F12%2FLeetcode-19%2F</url>
    <content type="text"><![CDATA[/************************************************************************* &gt; File Name: Leetcode_19.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 五 4/12 09:19:32 2019 ************************************************************************///删除链表的倒数第N个节点//(1)为了避免删除第一个节点的特殊操作，我们可以设置一个虚拟头节点//方法一：我们可以第一次遍历得到链表的长度len，然后第二遍遍历找第len - N + 1个节点//方法二：我们可以使用递归的方式，参数为上一个节点的地址和当前节点，返回值为之后有多少个节点。若返回值 == N - 1，我们就删除该节点//方法三：利用两个指针，第一个指针走到N+1步，也就是走到N+2节点处，然后两个指针同时走，当第一个指针走到空后，第二个指针就是待删除节点的上一个位置，然后就可以删除下一个节点了//方法二代码：/* * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int dfs(ListNode *last, ListNode *now, int len) &#123; if (now == NULL) return 0; int k = dfs(now, now -&gt; next, len); if (k == len - 1) &#123; last -&gt; next = now -&gt; next; delete(now); &#125; return k + 1; &#125; ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if (head == NULL || n &lt;= 0) return NULL; //虚拟头指针 ListNode temp(0); temp.next = head; //遍历 dfs(&amp;temp, temp.next, n); return temp.next; &#125;&#125;;//方法三代码：/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123; //特判特殊情况 if (head == NULL || n &lt;= 0) return NULL; //设置虚拟指针 struct ListNode temp; temp.next = head; struct ListNode *p = &amp;temp, *q = &amp;temp; while(n &amp;&amp; p) &#123; p = p -&gt; next; n--; &#125; if (n != 0 || p == NULL) &#123; return temp.next; &#125; p = p -&gt; next; while(p) &#123; p = p -&gt; next; q = q -&gt; next; &#125; //删除节点 p = q -&gt; next; q -&gt; next = p -&gt; next; free(p); return temp.next;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构相关实现]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[​ 平时布置的数据结构作业代码实现，持续上传到Github中～ ​ Github地址：跳转 ​ 也可从博客中查看：跳转]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Contest 122 D We Like AGC]]></title>
    <url>%2F2019%2F04%2F04%2FAtCoder-Contest-122-D-We-Like-AGC%2F</url>
    <content type="text"><![CDATA[Problem StatementYou are given an integer N. Find the number of strings of length N that satisfy the following conditions, modulo 109+7: The string does not contain characters other than A, C, G and T. The string does not contain AGC as a substring. The condition above cannot be violated by swapping two adjacent characters once. NotesA substring of a string T is a string obtained by removing zero or more characters from the beginning and the end of T. For example, the substrings of ATCODER include TCO, AT, CODER, ATCODER and (the empty string), but not AC. Constraints 3≤N≤100 InputInput is given from Standard Input in the following format: N OutputPrint the number of strings of length N that satisfy the following conditions, modulo 109+7. Sample Input 13 Sample Output 161 There are 43=64 strings of length 3 that do not contain characters other than A, C, G and T. Among them, only AGC, ACG and GAC violate the condition, so the answer is 64−3=61. Sample Input 2Copy 4 Sample Output 2230 Sample Input 3100 Sample Output 3388130742 Be sure to print the number of strings modulo 109+7. ​ 题目大意就是字符串只能由A、C、G、T组成，然后子串中不能出现AGC，还有任意两个相邻的字符交换后不能出现AGC。也就是说排除一下几种情况： AGCACGGACAXGC //X代表A C G TAGXC ​ 所以我只需要定义dp[i][j][p][q]代表前i个字符，最后3个字符为j，p，q的方案数(0代表A，1代表C，2代表G，3代表T)。详细见代码 代码： #include &lt;stdio.h&gt;#define ll long long#define mod 1000000007ll dp[105][4][4][4] = &#123;0&#125;;bool pan(int a, int b, int c) &#123; if (a == 0 &amp;&amp; b == 2 &amp;&amp; c == 1) return false; if (a == 0 &amp;&amp; b == 1 &amp;&amp; c == 2) return false; if (a == 2 &amp;&amp; b == 0 &amp;&amp; c == 1) return false; return true;&#125;bool pan1(int a, int b, int c) &#123; if (a == 0 &amp;&amp; b == 2 &amp;&amp; c == 1) return false; return true;&#125;int main () &#123; int n; scanf(&quot;%d&quot;, &amp;n); if (n == 1) &#123; printf(&quot;4\n&quot;); &#125; else if(n == 2) &#123; printf(&quot;16\n&quot;); &#125; else &#123; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int p = 0; p &lt; 4; p++) &#123; if (pan(i, j, p)) &#123; dp[3][i][j][p] = 1; &#125; &#125; &#125; &#125; for (int k = 4; k &lt;= n; k++) &#123; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int p = 0; p &lt; 4; p++) &#123; //dp[k][i][j][p] if (pan(i, j, p)) &#123; for (int q = 0; q &lt; 4; q++) &#123; if (pan(q, i, j) &amp;&amp; pan1(q, j, p) &amp;&amp; pan1(q, i, p)) &#123; dp[k][i][j][p] = (dp[k][i][j][p] + dp[k - 1][q][i][j]) % mod; &#125; &#125; &#125; &#125; &#125; &#125; &#125; ll ans = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; for (int p = 0; p &lt; 4; p++) &#123; ans = (ans + dp[n][i][j][p]) % mod; &#125; &#125; &#125; printf(&quot;%lld\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(9)epoll函数]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9-epoll%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] epoll函数​ epoll用于在一段时间内同时等待多个产生I/O事件的文件 ​ 返回值为这段时间产生等待的I/O事件的文件数量，并允许我们通过一个指针遍历产生的所有事件 ​ 例如多个子进程向父进程建立通道，所有子进程向管道写入数据，那么在父进程端加入epoll()等待，它就会在一段时间后返回写入数据的子进程数量 epoll()创建#include &lt;sys/epoll.h&gt;int epoll_create(int size); ​ 参数size表示监控的文件描述符的总量（由于如今系统具备动态分配内存的能力，size参数自动忽略，但我们仍需要加入一个大于0的数保证兼容） ​ 若成功返回一个非零的文件描述符，代表一个epoll()实例 ​ 最后需要close()关闭epoll创建的对象 epoll()加入、删除、修改#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); ​ 第一个参是是epoll的实例的文件描述符，第二个参op代表有加入，删除，修改三个选项，第三个参是与I/O事件关联的文件，第四个参数指向我们需要监控的事件 ​ 关于event的结构体： typedef union epoll_data &#123; void* ptr; int fd; unsigned int u32; unsigned long long u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; epoll_data_t data;&#125;; ​ data可以自由使用，方便进程在事件发生后获取有关事件信息的。一般我们会将与事件关联的文件描述符存储在data.fd里，这样事件发生后我们才能知道事件是哪个文件产生的。 ​ events是由多个或运算连接在一起的事件（比如文件可读，可写，错误，挂起） 等待I/O事件发生int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); ​ 第一个参数是epoll实例的文件描述符，第二个参指向我们需要监控的事件，第三个参数为最多产生的事件数，第四个参数记录我们在timeout毫秒内产生的事件（当timeout为0立即返回，当&lt;0就是等到有事件发生时再返回） ​ 它的返回值是该时间实际产生的事件数，然后根据该数量遍历events的每一项]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(8)进程间通信之消息队列]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[消息队列​ 相比管道，消息队列不需要读取和写入进程同时出现，它就类似于邮箱，一个进程发送到邮箱，另一个进程看。消息队列可以和信号连用，然后每次来消息，就可以利用信号让收方得到通知。 #include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;mqueue.h&gt;mqd_t mq_open(const char* name, int oflag, mode_t mode, struct mq_attr* attr); ​ 第一个参数是消息队列的名字，它是通过名字来识别的。用相同的名字打开消息队列，它们就会打开同一个消息队列。消息队列的名字格式是以/开头，由空字符结尾，中间最多包含255个不是/的字符串 ​ 第二个参是访问消息队列的模式（只读、只写、可读可写，没有就创建），第三个参数第四个参分别代表消息队列的权限和性质（只有在创建的时候定义） ​ 其中第四个参数是一个结构体，里边存储最大消息数量、一个消息的最大长度、当前消息的数量等信息 ​ 它的返回值是一个消息队列描述符。我们可以利用这个消息队列描述符来对消息队列进行发送或接收 发送和接收#include &lt;mqueue.h&gt;int mq_send(mqd_t mqdes, const char* msg_ptr, size_t msg_len, unsigned msg_prio);ssize_t mq_receive(mqd_t mqdes, char* msg_ptr, size_t msg_len, unsigned* msg_prio); ​ 发送和接收函数的第一个参数代表消息队列描述符，第二个参数为发送/接收的消息，第三个参数为消息的长度，最后一个参数为存储消息优先等级的指针 获得新消息得到通知#include &lt;mqueue.h&gt;int mq_notify(mqd_t mqdes, const struct sigevent* sevp); ​ 第一个参数消息队列描述符，第二个参数为一个结构体，只要结构体中的sigev_notify的值为SIGEV_SIGNAL，每当有消息时，就可以让拥有标识符为mqdes的消息队列的进程获得信号提醒。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(7)进程间通信之信号]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[[TOC] 信号​ 在unix中，信号是由一个个整数表示，比较常用的信号比如SIGINT,SIGHUP,SIGILL等等，分别是ctrl+c，中断挂起或进程终止，非法指令。 ​ 每个信号系统都有自己的默认处理方法，我们可以利用sigaction()函数来更改信号的处理方式。 ​ 注意！！信号处理方式是在进程范围内有效，如果一个进程用fork()产生一个子进程，那么在父进程中被忽略的信号在子进程仍然会被忽略（子进程开辟进程空间并将父进程的状态等copy到子进程） 更改信号的处理方式sigaction()int sigaction(int signum, const struct sigaction* act, struct sigaction* oldact); ​ 第一个参数代表信号，第二个参数act为新的处理方式，第三个参数oldact是将旧的处理方式存到oldact signal()sighandler_t signal(int signum, sighandler_t handler); ​ signal()可以达到和sigaction()同样的目的（相当于sigaction的简化版），第一个参数为信号，第二个参数为收到该信号重写的函数。 ​ 由于它在不同的unix系统的实现不同，可能存在移植性问题，不建议使用 信号的接收kill()#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig); ​ 我们可以利用kill来实现发送信号。它的第一个参数为进程号，第二个参数为信号。 ​ 当pid &gt; 0，代表给某个指定进程发送；当pid == -1，会给除第一个进程（系统进程，所有用户的祖先）以外所有正在运行的进程发送（在linux下不给自己发）；当pid &lt; -1代表给所有进程组等于-pid的发送信号 ​ 当sig&gt;0，代表发送指定信号，sig==0不会发送任何信号，但是还会检查是否存在以pid为标识符的进程。常用于检查是否存在该进程（或组） ​ 返回值有成功时为0，错误时-1。有三种错误码：分别代表无效信号、无权发送、进程不存在 信号的接收​ 信号发出后会被内核检查到，然后内核调用do_signal()执行收到的信号。如果用户定义了某信号的处理方式，那么它可能会在用户空间内处理]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(6)进程间通信之共享内存]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[mmap共享内存​ 共享内存可用于进程间通信，而且还可以提高读写文件的效率。还可以方便我们对文件进行随机的读写 开启共享内存​ mmap能够通过将外存中的文件映射到一段内存中，使多个进程在其地址空间中共享一端内存。 #include &lt;sys/mman.h&gt;void *mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset); ​ 第一个参数addr为希望映射文件的大概位置（0则代表选择任意地址进行映射），第二参数代表映射内存的长度，第三个参数prot表示映射内存区的使用权限（可读、可写、可执行），第四个参flags决定了内存映射的模式（具体有四个），第五个参数fd是被映射文件对应的文件描述符，第六个参数offset代表映射的起始位置（相对于文件开头的偏移） ​ mmap()以页为单位分配映射内存区，因此它返回的大小一定是页的整数倍（若申请的不是整数倍，我们访问未被使用部分会返回SIGBUS产生错误） 关闭共享内存int munmap(void* addr, size_t length); ​ munmap用于关闭映射，参数addr必须是页面的整数倍，长度可以与一开始映射的内存大小不同。 ​ 注意，close(fd)并不能关掉映射，只有munmap()可以。 举例：char* window = (char*) mmap(0, 30, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);pid_t child = fork();if (!child) &#123; sprintf(window, &quot;Greeting from child.&quot;); exit(0);&#125;wait(NULL);printf(&quot;%s\n&quot;, window); //通过mmap()使父进程和子进程共享了这段内存]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(5)进程间通信之管道]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[[TOC] 通道匿名通道#include &lt;unistd.h&gt;int pipe(int pipefd[2]); ​ 作为进程间共享区，只用于通信，通信结束后就自动移除。它是一个单向的数据传输通道，参数第一个值为读取的文件描述符（对应输入），第二个值为写入的文件描述符（对应输出） ​ 它只能用于拥有公共祖先进程的进程（也就是必须继承同一个文件描述符表，保证它们的文件描述符必须指向同一文件） ​ 下面是匿名通道的实现 #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[]) &#123; //创建管道 int fd[2]; if (pipe(fd) == -1) &#123; perror(&quot;pipe faild&quot;); &#125; //创建进程 pid_t pid = fork(); if (pid == -1) &#123; perror(&quot;fork faild&quot;); &#125; if (!pid) &#123; //子进程 char *s = (char *)malloc(sizeof(char) * 100); strcpy(s, &quot;hello, ACM!&quot;); //关掉读取 close(fd[0]); //写入 write(fd[1], s, strlen(s) + 1); &#125; else &#123; //父进程 char buffer[100]; //关掉写入 close(fd[1]); //读取 read(fd[0], buffer, sizeof(buffer)); printf(&quot;%s\n&quot;, buffer); &#125; return 0;&#125; 命名管道#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;//创建命名管道，它采取先进先出的策略int mkfifo(const char* pathname, mode_t mode);//访问命名管道 ​ 参数一为文件路径，参数二表示这个命名管道的权限可被umask修改 ​ 命名管道可以任意进程间进行通信，且创建它的进程退出后它仍然存在，只有在被删除后才消失。它不同于一般文件在于读取和写入数据的进程必须同时出现（也就是说只有读或写，命名管道就会被阻塞）]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(4)关于文件]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4%2F</url>
    <content type="text"><![CDATA[[TOC] 文件描述符​ 每个进程控制块都有一个文件描述符表，可以把它看作一个数组，里面存储指向以打开文件地址的指针，这个数组的下角标就是文件描述符。每次open都会把新打开的文件地址存储到表中的某个空行，并返回下角标作为文件描述符。 ​ 其中0～2为特殊的文件描述符，分别为标准输入，标准输出，标准错误输出，这三个文件描述符在进程初始时自动打开，其中标准输出就是printf输出的对象 关于I/O的系统调用函数open()#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char* pathname, int flags, mode_t mode); ​ 相比fopen()处于系统的更低层，可以对文件进行更基础的操作，但是也失去了一些库函数的帮助 ​ 参数分别是被打开文件路径、进行的操作、创建文件时的使用权限（可省略） ​ 它的返回值为文件描述符 dup2()#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd); ​ 该函数可以使newfd指向oldfd指向的文件 dup()#include &lt;unistd.h&gt;int dup(int oldfd); ​ 该函数会选择最小的空闲文件描述符让它指向oldfd，并返回新的指向该文件的描述符 read()、write()#include &lt;unistd.h&gt;ssize_t read(int fd, void* buf, size_t count);ssize_t write(int fd, const void* buf, size_t count); ​ 参数分别为文件描述符，写入/读入的内容，写入/读入的最大长度。若调用成功返回实际读写的长度，否则返回-1 lseek()#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); ​ 参数分别为文件描述符，移动的长度，移动目标的起点。whence有3个常用值，SEEK_SET，SEEK_END，SEEK_CUR，分别代表开头，结尾和当前位置 fsync()int fsync(int fd); ​ 由于向磁盘写入数据很花时间，因此内核为了提高效率会推迟写入数据。而fsync()可以同步内存中所有已修改的文件写入到储存设备 close()int close(int fd); ​ 用于关掉文件，fd为文件描述符]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(3)进程的使用]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 进程的使用fork()pid_t fork(); ​ 函数位于unistd.h头文件中，它会直接创建一个新进程。新进程的返回值为0，父进程的返回值为子进程的pid。该函数会把父进程的处理器状态、地址空间直接拷贝到新进程，而新进程也会从fork()指令的开始处运行。 ​ 为了避免子进程不用拷贝的信息造成拷贝时间浪费，系统只有在其中一个数据被修改时才会把那个数据实际复制到子进程的地址空间。 exit()void exit(int status); ​ exit()是一个系统调用指令，它位于stdlib.h头文件中，用于让内核结束该进程。status是进程的结束状态信息（成功为0，否则为对应的错误数字），可返回作为wait()函数的第一个参 wait()pid_t wait(int *status); ​ wait()位于sys/wait.h头文件中，参数为该进程所等待进程的结束状态值，也可以把它设为NULL，函数返回值为已结束子进程的pid。 ​ 该函数会让父进程进入等待态，直到父进程所有子进程的一个成功返回结束状态值，父进程才可进入就绪态并再进入运行态。 ​ 注意点：如果wait()被调用时已经有可用的结束状态值，那么wait()会立刻返回。如果已经没有可等待的子进程，wait()会返回-1 waitpid()pid_t waitpid(pid_t pid, int *status, int options); ​ 它与wait()相比，可以通过指定进程pid来等待指定进程。当pid &gt; 0时等待指定pid子进程，当pid = -1时等待任意子进程，当pid == 0时等待所有进程组标识符与该进程相同的子进程，当pid &lt; -1时等待任何进程组标识为pid的绝对值的进程。options为特殊控制选项 execve()int execve(const char *filename, char* const argv[], char* const envp[]) ​ 系统调用函数，用于运行完全不同的程序并覆盖掉当前进程正在运行的程序。filename指向可执行程序，argv[]第一个参数与filename一致，从第二个以后为运行可执行程序的参，envp存储键值对作为环境变量代入程序 ​ 由于该函数会覆盖掉当前进程正在运行的程序，因此只有在函数调用失败后才会执行该进程函数后的代码。 ​ 除系统调用函数外，还有execve()六函数]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(2)进程]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2%2F</url>
    <content type="text"><![CDATA[[TOC] 进程、进程地址空间、进程控制块进程​ 进程作为运行程序的抽象，包含了一个程序的运行状态、所占用的抽象内存和存储的数据。 ​ （1）进程中必须包含进程运行状态的结构，使系统能够将进程的运行状态放入内存中，方便下次调用继续执行。 ​ 解决方法：通过存储处理器状态寄存器、指令计数器、栈指针、通用寄存器来代表进程目前的运行状态。 ​ （2）进程在用户一侧对内存进行了抽象，在系统一侧需要包含从抽象内存向实际内存和磁盘的映射，以便获得存储的数据。 ​ 解决方案：通过地址转换来实现虚拟内存到物理内存和磁盘的映射。主要方法有分页存储、分段存储等 进程地址空间​ 我们可以将一个进程可以使用的全部内存地址和存储的数据称为这个进程的地址空间。 进程控制块​ 为了能在进程开始运行时方便的加载转换地址和状态信息，我们引入进程控制块的概念。除此之外，进程控制块还包含进程号、进程优先级等信息。对内核来说，线程控制块是进程的唯一标识符 ​ 由于进程控制块包含了优先级还有地址转换的实际物理地址等用户进程无权修改的信息，所以进程控制存储在系统空间 进程的状态模型​ 新建态、就绪态、运行态、等待态、终止态 ​ 五态相比三态，新建态可以避免一个进程还没有加载完全部资源就进入就绪态再进入运行态，造成运行错误。终止态可以避免进程结束后直接被系统销毁，使得其它进程无法获取该进程的信息。但是终止态可能导致僵尸进程的出现]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉下心学操作系统(1)操作系统概念]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 以前觉得操作系统是一块难啃的骨头，自己不想去碰。然后问面试官，自己哪些地方需要学习一下，面试官说操作系统和内核等等，如果学会了，对自己的发展会更有帮助。因为越底层的东西懂得越多，才能对编程有更加深入的了解和体会。自己很赞同这个思想，不多说，沉下心来学操作系统吧，路一步步地走～ 操作系统概念​ 不同的电脑硬件设备不同，运行网络环境不同。为了避免对不同的硬件写不同的程序，因此需要在硬件和软件之间加一个抽象层，从而方便软件利用硬件资源。而这个抽象层就是操作系统 ​ （1）基于磁盘信息的抽象：操作系统帮我们管理了磁盘上的数据，能够将一次存储在多个位置的数据结合在一起命名为文件，方便我们直接读取磁盘上的信息 ​ （2）对物理资源的抽象：操作系统通过将物理资源抽象为进程，大大方便了多个程序在系统中同时运行，而程序设计者无需考虑其它软件的内存占用以及上下文切换，保留处理器状态等复杂过程 ​ （3）防止程序直接与物理资源接触，避免通过程序修改磁盘信息和对其它程序破坏的情况 内核与用户进程​ 我们一般把操作系统核心功能部分称为内核（包括物理资源管理，协调进程调度，构建虚拟机，公共服务等） ​ 一般把处理器运算时间分成两部分：一部分是内核在处理器运行，一部分是用户进程运行。有关两者： ​ （1）用户进程必须通过内核获取资源，并且不能接触除了自己以外的资源。 ​ （2）用户进程比内核拥有更少的权限和资源 ​ （3）内核与用户进程使用不同的存储空间，内核所用的空间为系统空间，用户进程所用的空间为用户空间 双模式操作​ 处理器中的一个位用于区分内核和用户进程，当处理器要执行某些只允许在内核态执行的特权操作时，它会先通过这个位判断当前是否处于内核态。若用户进程越权操作，处理器会触发异常，该进程被内核终止 用户态到内核态的三种方式： 系统调用 异常 中断 系统调用表​ 为了使用户进程在保证安全的情况下实现文件读写、进程间通信等“内核级操作”，操作系统给用户进程提供系统调度，允许用户进程在特定的位置进入系统空间并使用系统提供的服务。 ​ 而所有的系统调用程序地址都被存放在存储器的某一个位置，该位置称为系统调度表。 ​ 为了避免恶意进程通过空指针、超出缓冲区大小范围攻击内核。在实现系统调用时必须检查用户空间指针的合理性，再将参数复制到系统空间进行操作 异常​ 又被称为内中断或同步中断。是由于进程运行时的非法操作或者硬件故障导致，然后引起内核中对应的异常处理机制。 中断​ 又被称为外中断或异步中断，来自处理器外的中断信号。包括时钟中断、设备I/O中断 ​ 当同时出现多个中断时处理器会优先处理优先度高的中断。如果处理一个中断的过程中出现一个优先度更高的中断，处理器可能会切换到新的中断信号，从而造成多重中断。对此我们可以采用屏蔽方式处理]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二面遗漏点填坑]]></title>
    <url>%2F2019%2F03%2F23%2F%E4%BA%8C%E9%9D%A2%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 感觉自己答的普普通通，通过这次面试发现自己在基础上的不足。自己学习了一下当时有些迷糊的知识点，整理如下： 迷糊点1:char str[] = “hello!” ;char *p = str ;请写出下面输出的结果printf(&quot;%d\n&quot;,sizeof (str ) );printf(&quot;%d\n&quot;,sizeof ( p ); 对于sizeof()，在对数组名进行操作时，返回的大小为数组所占用的内存大小，而对指向数组的指针进行操作时，返回的大小为指针的大小（自己对指针返回的大小很犹豫，现在记住了，从这里也可以看出，数组名并不是完全等同于指针） ​ 关于上面的问题，自己学了数组名和指针的区别。（1）在本质上，数组名其实指代一种数据结构，这个数据结构就是数组的全体（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量！（3）和数组名不同，指向数组的指针则是另外一种变量类型，它用于存放数组的地址（4）如果数组名作函数行参时，在函数体内它就失去了本身的数据机构特性，仅仅只是一个指向改数组的指针 ​ 而且通过这个问题，自己查找了一下有关sizeof，发现自己一直以为它是一个函数，而它实质上是一个操作符（从sizeof(int)上就可以看出，因为函数接纳的形参不能是一个int的类型数据） 下面是辨析的几个例子： Test 1: char str[10]; char *pStr = str; cout &lt;&lt; sizeof(str) &lt;&lt; endl; //10(此时数组名表现为前面的性质(1)) cout &lt;&lt; sizeof(pStr) &lt;&lt; endl; //4(在32位系统下)Test 2: char str1[10] = &quot;hello&quot;; char str2[10]; strcpy(str2,str1); //此时数组名表现为前面的性质(2) Test 3: void arrayTest(char str[]) &#123; cout &lt;&lt; sizeof(str) &lt;&lt; endl; &#125; char str1[10] = &quot;hello&quot;; arrayTest(str1); //此时数组名表现为前面的性质(4) 迷糊点2fork();printf(&quot;#&quot;);fork();printf(&quot;#&quot;); ​ 当时自己回答的是6，结果电脑测出来是8。记得之前学到的子进程从fork()后开始执行，百思不得其解。。然后百度了一下，不得不说自己确实欠缺好多～ ​ 从网上整理了一下思路，大概就是说这是由printf的缓冲机制 + 进程间的继承机制造成的。因为操作系统只是把printf的内容放到了stdout缓冲队列里,并没有实际写到屏幕上。而再运行到fork时,缓冲里面的内容被子进程继承了，所以最后这4个进程一共输出了8次 ​ 但是只要系统看到\n就会立刻刷新stdout，或者我们用fflush()函数强制刷新缓冲区这两种方式，就会输出6个# ​ 具体辨析： Test 1: fork();printf(&quot;#&quot;); fflush(stdout); fork();printf(&quot;#&quot;); //输出6个 Test 2: fork();printf(&quot;#\n&quot;); fork();printf(&quot;#\n&quot;); //输出6行，每行1个 迷糊点3​ 由于迷糊点2的题没有答好，面试官问到关于进程间的继承问题，自己找了一个经典题理解了一下： pid_t pid1 = fork();pid_t pid2 = fork();printf(&quot;pid1:%d, pid2:%d\n&quot;, pid1, pid2); ​ 以前对于fork只停留在“新建一个进程，父进程返回一个子进程的pid，子进程返回一个0，然后系统就有两个进程，并开始向下执行内容”这个初步认识的阶段。 ​ 其实fork的新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是它是一个全新的进程并作为原进程的子进程 ​ 对于上面这个例子的有一下几个步骤： (1)首先有一个主进程root，执行完第一个fork()创建一个进程son1，son1继承root的所有变量，环境变量，计数器等，然后更新pid1，假设此时root的pid1为1001，那么son1的pid1为0 (2)root执行完第二个fork()创建一个进程son2，son2继承root的所有变量，环境变量，计数器等，然后更新pid2，假设此时root的pid2为1002，那么son2的pid2为0，它们两个的pid1都为1001 (3)son1执行完第二个fork()创建一个进程grandson，grandson继承son1的所有变量，环境变量，计数器等，然后更新pid2，假设此时son1的pid2为1003，那么grandson的pid2为0，它们两个的pid1都为0 迷糊点4​ 对于编程中常用的函数参数记忆不清。加强自己的记忆力吧，面试官问到listen()函数的第二个参是什么？当时给忘了，然后越想越着急，苦笑。。事后我说起这个第二个参，同学说不是最大连接数吗。。突然惊醒，感觉自己应该结合实际好好想想，其实这些东西也都不是死记硬背的。。 ​ 最后，就是感觉到了自己的不足。自己学的东西好像是一个空中楼阁，经不起实战的打磨。继续沉下心来磨砺自己吧，把以后的重心先放在操作系统入门与系统编程上。凡事都要讲求一个透彻明白吧。。。。]]></content>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈缓存三大问题]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%B5%85%E8%B0%88%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于缓存​ 大部分系统都存在缓存机制，防止过多直接对数据库的请求操作，增加系统的稳定性与效率。 ##可能导致的问题 ###问题一：缓存穿透 ​ 缓存穿透是指查询一个不存在的数据，由于缓存不存在该数据，因此该请求会直接去数据库查询（直接穿透了缓存层）。若有人恶意多次进行该操作可能导致数据库瘫痪 ####解决方案 把所有可能的查询生成一个类似于哈希表的结构，在进行数据库查询前会利用该结构进行过滤，如果不在其中直接过滤掉，从而减轻数据库层面的压力 在第一次查询不到某个key对应的val值时，我们把该key和空值存入缓存中 ###问题二：缓存雪崩 ​ 一般缓存都会有一个失效时间，如果所有缓存的实效时间相同，可能会导致在某一时刻同时失效后，所有请求都发送到数据库层从而导致数据库崩溃 ####解决方案 只让一个线程构建缓存，其它线程等待构建缓存的线程执行完毕后再重新从缓存中获取数据。 错开不同失效时间即可从一定长度上避免这种问题，因此我们设置缓存实效时间时可以在一个范围内取随机值 ###问题三：缓存击穿 ​ 缓存击穿是缓存雪崩的特例，缓存击穿是指某一个缓存失效后有大量请求发送到数据库层导致其崩溃。与雪崩相比，它只是一个点并不是全部（比如微博的一个热点缓存失效后依然有大量该热点信息的请求） ####解决方案 对热点数据进行二级缓存，并对不同级别的缓存设定不同的失效时间 采用LRU算法，即最近最少使用。依据“长期不被使用的数据，未来用到的概率也不大“，因此当内存达到阈值时，首先淘汰最近最少被使用的数据，具体实现过程为： （1）创建一个缓存哈希链表用于存储数据（相比哈希表多了一个指针用于链表排序） （2）添加新节点的时候，将新节点添加到链表尾部 （3）若该节点以存在，把该节点移动到链表的尾部 （4）当缓存链表已满时，添加新节点的时候，会把链表头部移除，然后将新节点添加到尾部]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈大小端]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%B5%85%E8%B0%88%E5%A4%A7%E5%B0%8F%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[大端和小端缘由​ 每个地址单元都对应一个字节，一个字节是8比特。除了char型是一个字节为，其余比如short是2字节，int4字节等等，他们的宽度大于1字节，就会存在多个字节安排顺序的规则。 ​ 根据不同计算机的字节顺序可以分为大端数据模式和小端数据模式 ​ 我们在不同端模式的主机进行数据传递时需要考虑端模式的不同，因此TCP/IP协议规定在网络上必须采用网络字节排序（大端模式） 概念​ 大端是数据的高字节保存在内存的低地址，数据的低字节保存在内存的高地址，类似于把数据当作字符串处理（像Mac是大端） ​ 小端是数据的高字节保存在内存的高地址，数据的低字节保存在内存的低地址（像windows，Linux都是小端） 测试大小端利用通用体： #include &lt;stdio.h&gt;union t&#123; int val; char s;&#125;;int main () &#123; t a; a.val = 1; if (a.s) &#123; printf(&quot;小端\n&quot;); &#125; else &#123; printf(&quot;大端\n&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux C实现线程池]]></title>
    <url>%2F2019%2F03%2F11%2FLinux-C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[[TOC] 池​ 池是一组资源的集合，这组资源在服务器启动之初就被创建和初始化，这称为静态资源分配。它避免了服务器对内核的频繁访问，提高了效率。 ​ 常见的池有进程池，线程池，内存池 内存池​ 先申请一定数量，大小相等的内存块备用。有新的内存需求时，就从内存池中分出一部分内存块，若内存不足则继续申请新的内存。内存池使内存分配效率得到提升 进程池​ 进程池线先由服务器创建一组子进程，子进程数量应和CPU数量差不多。所有子程序具有相同的属性，运行着同样的代码 线程池概念​ 在Linux中线程实际上是由轻量级进程实现的。线程的创建和清理都需要耗费时间和系统资源，当处理高并发时，线程池就有必要引入了。 ​ 线程池提升了多线程程序的性能，因为线程池中线程都是现成且可重复使用的。理想的线程池能够合理地动态调节池内线程数量 ​ 线程池是典型的生产者消费者同步问题，主程序不定时将任务任务添加到一个队列中。池中多个工作线程同时执行出队操作（需保证同一时刻只能一个线程出队成功）。这时候生产者是主程序（用于生产任务），消费者是工作线程（用于执行任务） 组成结构​ 线程池主要包括4个部分： 线程管理器：用于创建并管理线程池 工作线程：线程池中实际执行任务的线程，在创建线程池后会创建好固定数目的线程在池中 任务接口：每个任务必须实现的接口。当队列中有任务时，被池中线程执行，把任务抽象成一个接口，可以做到线程池与具体任务无关 任务队列：用于存放没有处理的任务 应用​ 主要应用于需要大量线程来完成任务且任务时间较短，例如Web服务器完成网页请求。或者是突发性的大量请求 代码实现test.h文件： #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;//任务接口(节点)struct Work &#123; void* (*func) (void *arg); void *arg; Work *next;&#125;;//线程池中线程执行的回掉函数void* thread_poll_func(void *arg);//线程池struct thread_poll&#123; //任务队列 Work *head; //线程指针 pthread_t *pd; //条件变量和锁 pthread_mutex_t mutex; pthread_cond_t cond; //线程池是否被销毁 bool shutdown; //线程池中线程的总量 int pthread_num; //当前任务队列中任务数量 int work_num; //初始化函数 thread_poll(int pthread_num) &#123; this -&gt; pthread_num = pthread_num; this -&gt; work_num = 0; this -&gt; shutdown = 0; pthread_mutex_init(&amp;this -&gt;mutex, NULL); pthread_cond_init(&amp;this -&gt; cond, NULL); this -&gt; head = NULL; pd = (pthread_t *)malloc(sizeof(pthread_t) * pthread_num); for (int i = 0; i &lt; pthread_num; i++) &#123; pthread_create(&amp;this -&gt; pd[i], NULL, thread_poll_func, this); &#125; &#125; //向线程池投递任务 void add_work(Work *work); //销毁线程池 int del();&#125;; test.cpp文件： #include &quot;test.h&quot;//线程池中线程执行的回掉函数void* thread_poll_func(void *arg) &#123; thread_poll *t = (thread_poll *)arg; while(1) &#123; //上锁 pthread_mutex_lock(&amp;t -&gt; mutex); //循环等待接收任务 while(!(t -&gt; work_num) &amp;&amp; !(t -&gt; shutdown)) &#123; pthread_cond_wait(&amp;t -&gt; cond, &amp;t -&gt; mutex); &#125; //如果线程池被销毁 if (t -&gt; shutdown) &#123; //解锁并退出线程 pthread_mutex_unlock(&amp;t -&gt; mutex); pthread_exit(0); &#125; //取出队首任务 t -&gt; work_num --; Work *p = t -&gt; head; t -&gt; head = p -&gt; next; //解锁 pthread_mutex_unlock(&amp;t -&gt; mutex); //执行任务回掉函数 (p -&gt; func)(p -&gt; arg); //释放该任务空间 free(p); &#125;&#125;//向线程池投递任务void thread_poll::add_work(Work *work) &#123; pthread_mutex_lock(&amp;this -&gt; mutex); //将任务加入到等待队列 Work *p = this -&gt; head; if (p == NULL) &#123; this -&gt; head = work; &#125; else &#123; while(p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = work; &#125; this -&gt; work_num ++; pthread_mutex_unlock(&amp;this -&gt; mutex); //唤醒一个等待线程 pthread_cond_signal(&amp;this -&gt; cond);&#125;//销毁线程池int thread_poll::del() &#123; if (this -&gt; shutdown) &#123; return -1; &#125; this -&gt; shutdown = 1; //唤醒所有线程 pthread_cond_broadcast(&amp;this -&gt; cond); //等待所有线程结束,避免僵尸线程 for (int i = 0; i &lt; this -&gt; pthread_num; i++) &#123; pthread_join(this -&gt; pd[i], NULL); &#125; //释放掉所有线程标识符 free(pd); //销毁任务队列的所有任务 Work *p = this -&gt; head; while(p != NULL) &#123; p = this -&gt; head; this -&gt; head = p -&gt; next; free(p); &#125; //销毁条件变量和锁 pthread_cond_destroy(&amp;this -&gt; cond); pthread_mutex_destroy(&amp;this -&gt; mutex); return 0;&#125;//任务的回掉函数void* myfunc(void *arg) &#123; printf(&quot;%d\n&quot;, *(int *)arg); return NULL;&#125;int main () &#123; thread_poll poll(3); int *nuu = (int *)malloc(sizeof(int) * 10); for (int i = 0; i &lt; 10; i++) &#123; nuu[i] = i; Work *work = (Work *)malloc(sizeof(Work)); work -&gt; next = NULL; work -&gt; func = myfunc; work -&gt; arg = (void *)&amp;nuu[i]; poll.add_work(work); &#125; sleep(5); poll.del(); free(nuu); return 0;&#125;]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>Linux</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈哈希表]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%B5%85%E8%B0%88%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[TOC] ##为什么要用hash？ ​ 在讲哈希表之前，我们来说说链表和数组的优缺点： 链表：​ 优点是链表长度可变，可以方便的进行链表的插入和删除 ​ 缺点是由于不是申请的一块连续地址空间，所以无法快速定位元素，只能通过遍历链表的方式获取其中元素，需要O(n)时间复杂度 数组：​ 优点是可以快速定位元素 ​ 缺点是数组长度固定，难以扩充大小。且数组中元素进行增删操作需要O(n)时间复杂度 ​ ​ 我们发现，链表和数组的优缺点正好互补，那么我们可不可以用一种新的数据结构来代替链表和数组，使其继承它们各自的优点呢？ ​ 于是，哈希表出现了。它的长度可变，可以快速定位，能够方便的进行增删改查，时间复杂度几乎为O(1) 哈希表与哈希函数​ 哈希表：是可以根据key值通过某种映射关系而直接访问的数据结构，用于存放记录 ​ 哈希函数：上述映射关系即为哈希函数 ​ 因此，在将哈希表之前，我们先来说一下哈希函数 哈希函数​ 哈希函数就像高中所学的函数f()，代表一种映射关系，它可以把字符串，数字等等映射为一个无符号整型，以便快速找到存储该元素信息的位置 ​ 注意！我们在自定义哈希函数时，要根据关键字key的长度，表长，关键字分布是否均匀等条件来相应的进行自定义！！ ​ 哈希函数的映射关系有很多，比较常用的有一下几种： 直接定址法​ 一般形式为f(x) = a * x + b，a，b为自定义常数，比如： unsigned val = 0;for (int i = 0; i &lt; strlen(s); i++) &#123; val = val * 33 + s[i];&#125; 平方取中法​ 线球关键值的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址，比如: unsigned val = 0;for (int i = 0; i &lt; strlen(s); i++) &#123; val = val * 33 + s[i];&#125;val = val * val / p % q; //p,q为常数 除留余数法​ 一般形式为：f(x) = x % p，其中p为不超过表长的质数（因为这样可以减少地址重复） 随机数法​ 一般形式为：f(x)=random(x) 哈希冲突​ 由上边的哈希函数我们可以看出，可能多个不同的key值通过哈希函数最后映射得到的值为同一个数，这样会导致哈希冲突。我们有一下两个常用的方法解决哈希冲突： 开放定址法​ 如果遇到哈希冲突，我们就找hash表中剩余的空间，然后将其插入（比如将值插入到下一位） 链地址法​ 上个方法有一个局限性，就是当表的内容已经填满时就无法进行插入，而该方法可以解决这个问题。这也是哈希表最常用的方法。 ​ 该方法如果遇到哈希冲突，他就会在原地址新建一个空间，然后以链表节点的形式插入到该空间。 哈希表的实现​ 我们以链地址法为例，代码如下： //哈希函数unsigned int hash(char *key) &#123; unsigned int val = 0; for (int i = 0; i &lt; strlen(key); i++) &#123; val = val * 33 + key[i]; &#125; return val % MAXN;&#125;//定义节点struct Node &#123; char *key; char *val; Node *next;&#125;//定义哈希表struct Hash &#123; Node *head[MAXN]; int len; Hash() &#123; for (int i = 0; i &lt; MAXN; i++) &#123; this -&gt; head[i] = NULL; &#125; this -&gt; len = 0; &#125;&#125;//查Node* query(Hash *h, char *key) &#123; unsigned inx = hash(key); Node *p = h -&gt; head[inx]; while(p != NULL) &#123; if(!strcmp(p -&gt; key, key)) &#123; return p; &#125; p = p -&gt; next; &#125; return NULL;&#125;//增或改void insert(Hash *h, char *key, char *val) &#123; Node *p = query(h, key); if (p == NULL) &#123; unsigned inx = hash(key); p = (Node *)malloc(sizeof(Node)); p -&gt; key = key; p -&gt; next = h -&gt; head[inx]; head[inx] = p; &#125; p -&gt; val = val;&#125;//删bool del(Hash *h, char *key) &#123; Node *p = query(h, key); if (p == NULL) return false; unsigned inx = hash(key); if (!strcmp(h -&gt; head[inx] -&gt; key, key)) &#123; h -&gt; head[inx] = p -&gt; next; free(p); return true; &#125; Node *q = h -&gt; head[inx]; while(q -&gt; next != NULL) &#123; if (!strcmp(q -&gt; next -&gt; key, key)) &#123; q -&gt; next = p -&gt; next; free(p); &#125; q = q -&gt; next; &#125; return true;&#125;]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式树莓派集群健康监控系统]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9B%86%E7%BE%A4%E5%81%A5%E5%BA%B7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[​ 最近两个星期打算写分布式树莓派集群健康监控系统，主要是对树莓派集群的健康状态进行实时监控。 ​ 实时更新中～ ​ 源码可以从Github 跳转 或者主页 跳转 的项目页面 进行查看 ​ 期待您的指正和贡献源码～]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>分布式</tag>
        <tag>多进程</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2120仓库建设]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%B4%9B%E8%B0%B7P2120%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[题目描述L公司有N个工厂，由高到底分布在一座山上。 工厂1在山顶，工厂N在山脚。 由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。 突然有一天，L公司的总裁L先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是L先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。 由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第i个工厂目前已有成品Pi件，在第i个工厂位置建立仓库的费用是Ci。 对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于L公司产品的对外销售处设置在山脚的工厂N，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送1个单位距离的费用是1。 假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据： 工厂i距离工厂1的距离Xi（其中X1=0）; 工厂i目前已有成品数量Pi; 在工厂i建立仓库的费用Ci; 请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。 输入输出格式输入格式： 第一行包含一个整数N，表示工厂的个数。接下来N行每行包含两个整数Xi, Pi, Ci, 意义如题中所述。 输出格式： 仅包含一个整数，为可以找到最优方案的费用。 输入输出样例输入样例#1： 30 5 105 3 1009 6 10 输出样例#1： 32 说明在工厂1和工厂3建立仓库，建立费用为10+10=20，运输费用为(9-5)*3 = 12，总费用32。 如果仅在工厂3建立仓库，建立费用为10，运输费用为(9-0)5+(9-5)3=57，总费用67，不如前者优。 对于20%的数据， N ≤500； 对于40%的数据， N ≤10000； 对于100%的数据， N ≤1000000。 所有的Xi, Pi, Ci均在32位带符号整数以内，保证中间计算结果不超过64位带符号整数。 思路： ​ 这是一道比较难的斜率优化变形题，我们可以设dp[i]代表前i个工厂的最小费用，那么： dp[i] = dp[j] + c[i] + [j+1, i]的所有工厂的p[k] * (x[i] - x[k])的和 我们可以设A[i]代表前i个工厂的p[i]和，B[i]代表前i个工厂的p[i]*x[i]和，那么化简上面的式子，得到： dp[i] = dp[j] + c[i] + x[i] * (A[i] - A[j]) - (B[i] - B[j]) 我们发现里边有不变量，变量以及混合值，所以这是一道典型的斜率优化问题 这时我们可以设k &lt; j且j结果优于k，那么化简得： dp[j] - x[i]A[j] + B[j] &lt; dp[k] - x[i]A[k] + B[k] 移项得： ((dp[j] + B[j]) - (dp[k] + B[k])) / (A[j] - A[k]) &lt; x[i] 我们设f[i] = dp[i] + B[i]，代入得： (f[j] - f[k]) / (A[j] - A[k]) &lt; x[i] 我们就得到了斜率，剩下的步骤所有题都雷同不再多说，直接上代码 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#define ll long long#define N 1000000ll x[N + 5] = &#123;0&#125;;ll c[N + 5] = &#123;0&#125;;ll A[N + 5] = &#123;0&#125;;ll B[N + 5] = &#123;0&#125;;ll f[N + 5] = &#123;0&#125;;ll dp[N + 5] = &#123;0&#125;;int q[N + 5] = &#123;0&#125;;int head = 0, tail = 0;double get(int j, int k) &#123; return 1.0 * (f[j] - f[k]) / (A[j] - A[k]);&#125;void set(int i, int j) &#123; dp[i] = dp[j] + c[i] + x[i] * (A[i] - A[j]) - (B[i] - B[j]); f[i] = dp[i] + B[i];&#125;int main () &#123; int n, p; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld%d%lld&quot;, &amp;x[i], &amp;p, &amp;c[i]); A[i] = A[i - 1] + p; B[i] = B[i - 1] + p * x[i]; &#125; q[tail++] = 0; q[tail++] = 1; set(1, 0); for (int i = 2; i &lt;= n; i++) &#123; while(tail - head &gt; 1 &amp;&amp; get(q[head + 1], q[head]) &lt;= x[i]) &#123; head++; &#125; set(i, q[head]); while(tail - head &gt; 1 &amp;&amp; get(i, q[tail - 1]) &lt;= get(q[tail - 1], q[tail - 2])) &#123; tail--; &#125; q[tail++] = i; &#125; printf(&quot;%lld\n&quot;, dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3195玩具装箱TOY]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%B4%9B%E8%B0%B7P3195%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY%2F</url>
    <content type="text"><![CDATA[题目描述P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为 1⋯N1⋯N 的 NN 件玩具，第 ii 件玩具经过压缩后变成一维长度为 CiC**i .为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第 ii 件玩具到第 jj 个玩具放到一个容器中，那么容器的长度将为 x=j−i+∑k=ijCkx=j−i+k=i∑jCk 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 xx ,其制作费用为 (X−L)(X−L)2 .其中 LL 是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 LL 。但他希望费用最小. 感谢@ACの666 提供的Latex题面 输入输出格式输入格式： 第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7 输出格式： 输出最小费用 输入输出样例输入样例#1： 5 434214 输出样例#1： 1 思路： ​ 这是一道斜率优化题，我们可以设dp[i]代表前i个玩具的最小费用值，那么我们可以得到： dp[i] = min(dp[j] + (i - j - 1 + [j+1, i]的Ck和 - L)^2) (j &lt; i) ​ 我们可以设sum[i]代表前i个玩具的Ck值的和，于是算式化简为： dp[i] = min(dp[j] + (i - j - 1 + sum[i] - sum[j] - L)^2) (j &lt; i) ​ 我们继续设不变量A[i] = i - 1 + sum[i] - L，变量B[j] = j + sum[j]，那么算式就化简为： dp[i] = min(dp[j] + (A[i] - B[j])^2) = min(dp[j] + A[i]^2 + B[j]^2 - 2*A[i]*B[j]) ​ 我们看到算式中存在不变量，变量，混合值，因此推断其为斜率优化题，于是我们可以设k &lt; j且 j比k更优，那么： dp[j] + A[i]^2 + B[j]^2 - 2*A[i]*B[j] &lt; dp[k] + A[i]^2 + B[k]^2 - 2*A[i]*B[k] ​ 最终化简，得到： ((dp[j] + B[j]^2) - (dp[k] + B[k]^2)) / (B[j] - B[k]) &lt; 2 * A[i] ​ 我们再设F[i] = dp[i] + B[i]^2，于是得： (F[j] - f[k]) / (B[j] - B[k]) &lt; 2 * A[i] ​ 我们得到了斜率，根据斜率优化的基操，剩下的通用步骤就不一一赘述，直接上代码 代码： #include &lt;stdio.h&gt;#define ll long long#define N 50000ll sum[N + 5] = &#123;0&#125;; ll A[N + 5] = &#123;0&#125;;ll B[N + 5] = &#123;0&#125;;ll F[N + 5] = &#123;0&#125;;ll dp[N + 5] = &#123;0&#125;;int q[N + 5] = &#123;0&#125;;int head = 0, tail = 0;double get(int j, int k) &#123; return 1.0 * (F[j] - F[k]) / (B[j] - B[k]);&#125;void set(int i, int j) &#123; dp[i] = dp[j] + (A[i] - B[j]) * (A[i] - B[j]); F[i] = dp[i] + B[i] * B[i];&#125;int main () &#123; int n, L, a; scanf(&quot;%d%d&quot;, &amp;n, &amp;L); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); sum[i] = sum[i - 1] + a; A[i] = i - 1 + sum[i] - L; B[i] = i + sum[i]; &#125; q[tail++] = 0; q[tail++] = 1; set(1, 0); for (int i = 2; i &lt;= n; i++) &#123; while(tail - head &gt; 1 &amp;&amp; get(q[head + 1], q[head]) &lt;= 2 * A[i]) &#123; head++; &#125; set(i, q[head]); while(tail - head &gt; 1 &amp;&amp; get(i, q[tail - 1]) &lt;= get(q[tail - 1], q[tail - 2])) &#123; tail--; &#125; q[tail++] = i; &#125; printf(&quot;%lld\n&quot;, dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1280尼克的任务]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%B4%9B%E8%B0%B7P1280%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[题目描述 尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入输出格式输入格式： 输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。 接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。 输出格式： 输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入样例#1： 15 61 21 64 118 58 111 5 输出样例#1： 4 思路： ​ 我们先按照任务开始时间排序，然后设dp[i]代表前i个任务（其中第i个任务一定执行）的最大空闲时间。可以得： dp[i] = max(dp[j] + task[i].star - task[j].end - 1); //需要保证j结束后第一个开始的任务是i ​ 我们再用一个数组book[i]判断第i个任务后面是否还有任务（0无1有），然后遍历所有任务，取dp[i] + n - task[i].end的最大值即可（i需要满足book[i] == 0且dp[i] != -1） 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int star, endd;&#125;task[10005];bool cmp(node A, node B) &#123; return A.star &lt; B.star;&#125;int dp[10005];bool book[10005];int main () &#123; int n, m, a, b; int ans = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); task[i].star = a; task[i].endd = a + b - 1; &#125; sort(task + 1, task + m + 1, cmp); memset(dp, -1, sizeof(dp)); memset(book, 0, sizeof(book)); for (int i = 1; i &lt;= m; i++) &#123; if (task[i].star != task[1].star) &#123; break; &#125; dp[i] = task[i].star - 1; &#125; dp[1] = task[1].star - 1; for (int i = 1; i &lt;= m; i++) &#123; if (dp[i] == -1) continue; int endd = task[i].endd; int flag = 0; for (int j = i + 1; j &lt;= m; j++) &#123; if (task[j].star &lt;= endd) continue; flag = 1; for (int p = j; p &lt;= m; p++) &#123; if (task[p].star != task[j].star) break; dp[p] = max(dp[p], dp[i] + (task[p].star - endd -1)); &#125; break; &#125; if (flag) &#123; book[i] = 1; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; if (dp[i] == -1 || book[i]) &#123; continue; &#125; ans = max(ans, dp[i] + n - task[i].endd); &#125; printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1272重建道路]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%B4%9B%E8%B0%B7P1272%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[​ 一场可怕的地震后，人们用N个牲口棚(1≤N≤150，编号1..N)重建了农夫John的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是惟一的。因此，牧场运输系统可以被构建成一棵树。John想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有P(1≤P≤N)个牲口棚的子树和剩余的牲口棚分离，John想知道这些道路的最小数目。 输入输出格式输入格式： 第1行：2个整数，N和P 第2..N行：每行2个整数I和J，表示节点I是节点J的父节点。 输出格式： 单独一行，包含一旦被破坏将分离出恰含P个节点的子树的道路的最小数目。 输入输出样例输入样例#1： 11 61 21 31 41 52 62 72 84 94 104 11 输出样例#1： 2 思路： ​ 一道树形dp题，用dp[i][j]来代表以i节点为根结点能形成j个节点的子树最少需要破坏的道路数（一定包含根节点）。那么我们可以得到： dp[i][1]一定等于子节点个数对于i的每个子节点，我们可以得到：dp[i][j] = min(dp[i][j], dp[k][p] + dp[i][j - p] - 1); //k为子节点，p为当前子节点保留的节点数，那么j-p就为父节点和其余节点保留的节点数那么结果就为dp[1][m]或者dp[i][m] + 1的最小值，(2 &lt;= i &lt;= n, m为目标子树节点，n为牲口棚总数)//至于为什么dp[i][m]需要+1，因为以i为节点需要把其与父节点的道路破坏 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector &lt;int&gt; v[155];int dp[155][155];int num[155] = &#123;0&#125;;void dfs(int inx, int father) &#123; int count = 0; for (int i = 0; i &lt; v[inx].size(); i++) &#123; if (v[inx][i] == father) continue; dfs(v[inx][i], inx); count ++; &#125; dp[inx][1] = count; num[inx] = 1; for (int i = 0; i &lt; v[inx].size(); i++) &#123; if (v[inx][i] == father) continue; int to = v[inx][i]; for (int p = num[inx] + num[to]; p &gt;= 2; p--) &#123; //??????? for (int q = min(p - 1, num[to]); q &gt;= 1; q--) &#123; if (p - q &gt; num[inx]) break; dp[inx][p] = min(dp[inx][p], dp[to][q] + dp[inx][p - q] - 1); &#125; &#125; num[inx] += num[to]; &#125; return;&#125;int main () &#123; int n, k, a, b; memset(dp, 0x3f, sizeof(dp)); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); v[a].push_back(b); v[b].push_back(a); &#125; dfs(1, 0); int ans = dp[1][k]; for (int i = 2; i &lt;= n; i++) &#123; ans = min(ans, dp[i][k] + 1); &#125; printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间同步:读者写者问题]]></title>
    <url>%2F2019%2F03%2F01%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下面讲的是读者写者问题中写者优先的实现过程 该问题需要满足： 读写互斥 写写互斥 读读不互斥 同时有读、写，写优先 需要用到两个全局变量，分别为： writeCount：写者人数 readCount：读者人数 需要用到5个全局信号量，分别为： mutex1：目的是控制每次只有一个写者进出写者队列。为1时，写者可以进或出队列，为0时，写者需等待 mutex2：目的是控制每次只有一个读者进出读者队列。为1时，读者可以进或出队列，为0时，读者需等待 mutex3：通过读者的RWMutex比mutex3后申请先释放，使得同种情况下写者比读者先获取RWMutex信号量（实现写者优先） RWMutex：目的是控制读写互斥。第一个写者需要等待申请RWMutex信号量，以后的写者无需申请直到写者为空释放。而读者每次都需要申请RWMutex信号量，因此会优先写者操作。 wrt：保证每次只有一种类型对文件进行操作（类型1:一个写 类型2:一个读或多个读） 为1时，代表可以对文件进行操作，为0时，代表已有一种类型对文件进行操作。第一个读者需要等待申请wrt信号量，以后的读者无需申请直到读者为空释放。而写者每次都需要申请wrt信号量，因此实现了每次只能有一个写者对文件进行操作，可以有多个读者同时对文件进行操作。 写者的流程： 1.申请mutex1信号量，等待进入写者队列 2.进入队列后writeCount++，若writeCount为1需等待申请RWMutex信号量 3.成功进入写者队列后释放mutex1信号量 4.申请wrt信号量等待写操作 5.进行写操作 6.写入完毕后释放wrt信号量 7.申请mutex1信号量，等待出写者队列 8.出队列后writeCount—，若writeCount为0需释放RWMutex信号量 9.成功出队后释放mutex1信号量 读者的流程： 1.申请mutex3信号，作用是同时等待读者写者，使得写者优先获取RWMutex信号 2.申请RWMutex信号 3.申请mutex2信号，等待进入读者队列 4.进入队列后readCount++，若readCount为1则申请wrt信号量 5.成功进入队列后释放mutex2信号量 6.释放RWMutex信号量 7.释放mutex3信号量 8.进行读操作 9.申请mutex2信号量，等待出读者队列 10.出队列后readCount—，若readCount为0则释放掉wrt信号量 11.成功出队后释放mutex2信号量 举个例子： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;int readCount, writeCount;sem_t mutex1, mutex2, mutex3, RWmutex, wrt;struct node&#123; int num, time1, time2;&#125;;void init() &#123; readCount = 0; writeCount = 0; sem_init(&amp;mutex1, 0, 1); sem_init(&amp;mutex2, 0, 1); sem_init(&amp;mutex3, 0, 1); sem_init(&amp;RWmutex, 0, 1); sem_init(&amp;wrt, 0, 1);&#125;void over() &#123; sem_destroy(&amp;mutex1); sem_destroy(&amp;mutex2); sem_destroy(&amp;mutex3); sem_destroy(&amp;RWmutex); sem_destroy(&amp;wrt);&#125;void* read_t(void *t) &#123; node *tt = (node *)t; sleep(tt -&gt; time1); printf(&quot;reader %d: start run\n&quot;, tt -&gt; num); //进读者队列 sem_wait(&amp;mutex3); sem_wait(&amp;RWmutex); sem_wait(&amp;mutex2); readCount ++; if (readCount == 1) &#123; sem_wait(&amp;wrt); &#125; sem_post(&amp;mutex2); sem_post(&amp;RWmutex); sem_post(&amp;mutex3); //读操作 printf(&quot;reader %d: start read\n&quot;, tt -&gt; num); sleep(tt -&gt; time2); printf(&quot;reader %d: end read\n&quot;, tt -&gt; num); //出读者队列 sem_wait(&amp;mutex2); readCount --; if (readCount == 0) &#123; sem_post(&amp;wrt); &#125; sem_post(&amp;mutex2); pthread_exit(0);&#125;void* write_t(void *t) &#123; node *tt = (node *)t; sleep(tt -&gt; time1); printf(&quot;writer %d: start run\n&quot;, tt -&gt; num); //进写者队列 sem_wait(&amp;mutex1); writeCount ++; if (writeCount == 1) &#123; sem_wait(&amp;RWmutex); &#125; sem_post(&amp;mutex1); //写操作 sem_wait(&amp;wrt); printf(&quot;writer %d: start write\n&quot;, tt -&gt; num); sleep(tt -&gt; time2); printf(&quot;writer %d: end write\n&quot;, tt -&gt; num); sem_post(&amp;wrt); //出写者队列 sem_wait(&amp;mutex1); writeCount --; if (writeCount == 0) &#123; sem_post(&amp;RWmutex); &#125; sem_post(&amp;mutex1); pthread_exit(0);&#125; int main () &#123; int num = 0; pthread_t pid; pthread_attr_t attr; pthread_attr_init(&amp;attr); init(); while(scanf(&quot;%d&quot;, &amp;num) != EOF) &#123; char chooes; int time1, time2; scanf(&quot;%c%d%d&quot;, &amp;chooes, &amp;time1, &amp;time2); node *t = (node *)malloc(sizeof(node)); t -&gt; num = num; t -&gt; time1 = time1; t -&gt; time2 = time2; if (chooes == &apos;R&apos;) &#123; printf(&quot;reader %d: start waiting\n&quot;, num); pthread_create(&amp;pid, &amp;attr, read_t, t); &#125; else if(chooes == &apos;W&apos;) &#123; printf(&quot;writer %d: start waiting\n&quot;, num); pthread_create(&amp;pid, &amp;attr, write_t, t); &#125; &#125; over(); return 0;&#125; 此时结果为： reader 1: start waitingwriter 2: start waitingreader 3: start waitingreader 4: start waitingwriter 5: start waitingreader 1: start runreader 1: start readwriter 2: start runreader 3: start runreader 4: start runwriter 5: start runreader 1: end readwriter 2: start writewriter 2: end writewriter 5: start writewriter 5: end writereader 3: start readreader 4: start readreader 3: end readreader 4: end read]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>进程间同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重定向输入输出流-freopen]]></title>
    <url>%2F2019%2F03%2F01%2F%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-freopen%2F</url>
    <content type="text"><![CDATA[##重定向 ​ freopen()函数用于重定向输入输出，也就是说可以把终端输入(stdin)指定到相应的文件，使得输入的内容从文件中进行读取。也可以把终端输出(stdout)指定到相应的文件，使得内容输出到相应的文件中 ​ 具体格式为： FILE *freopen(const char *filename, const char *mode, FILE *stream); ​ 第一个参数filename代表对应的文件，mode代表读取文件的格式（包括w,w+,r,r+,a,a+等），stream为被重定向的文件流 ​ 返回值为指向该输出流的文件指针，失败返回NULL 例如从in.txt读取数据计算a+b的和并输出到out.txt #include &lt;stdio.h&gt;int main () &#123; int a, b; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;a&quot;, stdout); while(scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF) &#123; printf(&quot;%d\n&quot;, a + b); &#125; fclose(stdin); fclose(stdout);&#125; ##恢复 ​ 将文件输入输出流重定向某个文件后如何恢复呢？对于linux用户，可以使用下面方法： freopen(&quot;/dev/tty&quot;, &quot;w&quot;, stdout);freopen(&quot;/dev/tty&quot;, &quot;r&quot;, stdin); ​ 对于windows用户来说： freopen(&quot;CON&quot;, &quot;w&quot;, stdout);freopen(&quot;CON&quot;, &quot;r&quot;, stdin); ##关闭 ​ 重定向用完可以利用fclose()函数关掉，当然，fclose()不仅可以关闭标准输入输出流，还可以关掉各种文件流。具体格式如下： int fclose(FILE *stream); ​ 若返回-1代表关闭失败，否则成功]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unix多线程]]></title>
    <url>%2F2019%2F02%2F28%2FC%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 关于多线程的使用，需要添加头文件pthread.h。 ​ 注意！！！由于其不是Linux系统默认库，因此编译时需要加上-lpthread参数以调用静态链接库。 ​ 关于其大体就是关于两个函数的应用，分别是pthread_create()和pthread_join()函数 ###pthread_create() ​ 该函数用来创建线程，它的函数原型是： #include &lt;pthread.h&gt;int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg); ​ 第一个参数tidp代表指向线程标识符的指针，第二个参数attr用来设置线程属性（可为空），第三参数start_rtn是线程所运行的回调函数，第四个参数是回掉函数的参数（可为NULL） ​ 它的返回值为0代表运行成功，否则返回出错编号 ​ 关于其回掉函数的格式: void *函数名(void *参数名); ###pthread_join() ​ 该函数用来等待指定线程的结束，它的函数原型是： int pthread_join(pthread_t thread, void **retval); ​ 其中第一个参数thread代表线程标识符，第二个参数retval用来存储回掉函数的返回值（可以为NULL），注意，第二个参数是二级指针 ​ 该函数如果成功运行返回0，否则返回错误编号 ###pthread_exit() ​ 在线程中使用，用于终止调用它的线程 ###注意点 ​ 系统默认创建的线程是非分离式的，在非分离式的情况下一个线程结束后其所占用的系统资源并没有真正的释放（也就是说线程并未真正结束），因为我们需要与pthread_join()函数联用才可以确保线程释放 ​ 或者采用方法二：设置线程属性为分离式，这样就可以保证线程结束后立即释放所占用的资源。注意！！！设置为分离式的线程不可以用pthread_join()函数等待！！ ​ 具体做法如下： #include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void *run(void *arg) &#123; printf(&quot;ok\n&quot;); pthread_exit(0);&#125;int main () &#123; pthread_t thread; pthread_attr_t attr; //获取默认信息 pthread_attr_init(&amp;attr); //再设置为分离式 pthread_attr_setdetachstate(&amp;attr, 1); //创建线程 pthread_create(&amp;thread, &amp;attr, run, NULL); sleep(1); return 0;&#125;]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级版聊天室]]></title>
    <url>%2F2019%2F02%2F27%2F%E5%8D%87%E7%BA%A7%E7%89%88%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[主要是利用所学网络编程来实现聊天室功能，包括客户端和服务端两个部分。 代码以上传至github，可通过github或者个人主页查看 客户端客户端的内容如下： 使用配置文件配置自己的监听端口，服务器的监听端口等信息 用户之间可以通过”@用户名 信息”来实现私聊 客户端在一个固定端口上监听服务器转发的来自其他用户的私聊、公聊以及系统信息 客户端所接受到的所有信息保存日志文件中，可利用tail -f 文件名获取实时聊天信息 客户端解析来自服务端的结构体，内容如下： struct Message&#123; char from[20]; int flag;//若flag为1则为私聊信息，0为公聊信息，2则为服务器的通知信息 char message[1024]; &#125;; 服务端 服务端在固定接口接收来自所有客户端的消息 每收到一条公聊消息，都转发给所有在线用户 每收到私聊消息，只转发给目标用户 当私聊用户不存在或下线，通过通知信息告知该用户 在用户上线的时候，发送欢迎信息并告知所有在线用户该用户上线 在收到用户信息#时，发送给该用户当前在线人数以及所有用户信息 具体效果如下： 用户界面： 服务端界面： 用户的log日志显示：]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>网络编程</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[踩坑:引用头文件导致重复定义问题-extern]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%B8%A9%E5%9D%91-%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98-extern%2F</url>
    <content type="text"><![CDATA[​ 今天在一个.h头文件中定义了一个全局变量，然后在两个.cpp文件中引用了该头文件，导致变量重复定义问题。 ​ 我们知道，变量有声明和定义，声明可以有多次，但是定义只能有一次。打个比方： //a.h文件int a; ​ 然后我们在b.cpp和c.cpp中引用a.h文件，这样就会出现重复定义。int a;会在每一个文件中重新定义一次 ​ 而我们如果再前边加上关键字extern，那么就代表extern int a为一个关于a的声明，此时并没有定义，这时我们就在b.cpp和c.pp中引用a.h不会报错，因为声明可以多次。 ​ 举个例子: //a.h#include &lt;stdio.h&gt;extern int avoid fun(); //a.cpp#include &quot;a.h&quot;void fun() &#123; printf(&quot;%d\n&quot;, a);&#125; #include &quot;a.h&quot;int a = 1; //有且只有一个引用a.h的cpp文件中定义全局变量aint main () &#123; printf(&quot;%d\n&quot;, a); a = 2; fun(); return 0;&#125; 此时输出结果为 12]]></content>
      <tags>
        <tag>收藏</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串-sprintf()函数]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-sprintf-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[​ 有时候我们需要格式化一个字符串的内容，这时侯使用sprintf()函数特别方便，它的使用格式如下： int sprintf( char *buffer, const char *format, [ argument] … ); ​ buffer代表字符串指针，format为格式化的样式，其余为参数。例如： char s[105];sprintf(s, &quot;hello, %s, Im %d years old\n&quot;, &quot;Zcy&quot;, 18); ​ 这样，s字符串就变为了”hello, Zcy, Im 18 years old\n” ​ 大概就是酱紫～]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC下brew安装、换源、使用以及坑]]></title>
    <url>%2F2019%2F02%2F25%2FMAC%E4%B8%8Bbrew%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9D%91%2F</url>
    <content type="text"><![CDATA[###安装 ​ 我们可以利用官方提供的网址进行brew安装：brew ​ 官网上就是让你复制下面这段内容到终端执行： /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 坑点一： ​ 有时候安装会告诉你该用户无法执行，这时候你需要切换到拥有管理员权限的用户，这时候你需要 sudo su 拥有管理员权限的用户 ​ 注意！！！不是root用户而是拥有管理员权限的用户！！ 坑点二： ​ 安装成功后切换回自己平常使用的用户后，使用brew update时，会报在/usr/local无权限执行，这时我们需要利用chomd命令让其拥有可读可写权限 sudo chmod 777 /usr/local ###换源 ​ 源是Linux操作系统的必备的概念，源解决的是软件之间的依赖关系。可以直观的把源堪称一个软件仓库。而默认的brew的源在境外，因此下载网速特别慢。因此，我们需要将源由国外的官方源改为大陆的镜像源，比如中科大的源 ​ 具体方法：中科大换源 ​ 按照上述方法换源成功后重新brew update即可 ###使用 1.更新brew软件仓库信息 brew update 2.安装某个程序 brew install xxx 3.检查所有已有程序是否有新版本 brew outdated 4.升级程序 brew upgrade //升级所有brew upgrade xxx //升级指定程序 5.搜索程序（既搜索本地该程序，也搜索brew库里该程序） brew search xxx 6.清理落后版本和缓存 brew cleanup 7.删除某程序 brew uninstall xxx 8.查询某程序的依赖关系 brew info xxx]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug小技巧]]></title>
    <url>%2F2019%2F02%2F24%2FDebug%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[​ 平时我们写程序需要Debug的时候，在自己觉得会出错的地方加上printf输出相关信息用于测试。当printf的行过多的时候，如果我们忘记了删除，会导致多余的输出。 ​ 这时候，一个非常好用的Debug技巧分享给大家 #include &lt;stdio.h&gt;#ifdef DEBUG //若有宏定义DEBUG #define DBG(...) printf(__VA_ARGS__) //则将DBG()替换为printf(),其中__VA_ARGS__代表可变参#else #define DBG(...) //否则将DBG()替换为空#endifint main () &#123; DBG(&quot;hello, %s!\n&quot;, &quot;zcy&quot;); DBG(&quot;hello, %d\n&quot;, 2019); DBG(&quot;hello, ACM!\n&quot;); return 0;&#125; ​ 如果我们g++编译的时候 -D DEBUG，就会输出DBG()的相关内容，如果直接g++编译，测试用的DBG不会输出。这样就非常方便的进行DEBUG啦 ​ 以下是运行效果图： 当然啦，宏定义的方式不唯一，比如这样定义也可以： #ifdef DEBUG #define DBG(a,b...) printf(a, ##b)#else #define DBG(a,b...)#endif]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[踩坑:父进程怎么知道子进程是否结束]]></title>
    <url>%2F2019%2F02%2F24%2F%E8%B8%A9%E5%9D%91-%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%93%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[​ 该方法主要是用于实现父子进程同时运行，且父进程能查看子进程是否结束 ​ 从网上看，大部分人都说在父进程中使用kill(pid, 0) (其中pid为子进程id)来获取子进程是否退出，若是0代表没退，-1代表退了。结果自己实验了几次，发现无论子进程是否退出，都返回0。。。 ​ 也就是说，单纯使用kill()函数无法检查子进程的状态。通过使用waitpid()和wait()函数的等待子进程结束后父进程继续运行的功能后，kill()函数就可以检查子进程的状态了。具体原因一直没有想明白。。。 ​ 学了进程间通信后，学到了一个函数：sign()函数，格式为：sign(int signum, void(*handler)(int))，其中signum代表某种信号，handler代表该信号得处理方式 ​ 我们知道在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，而系统默认将忽略此信号。此时，我们只需要利用handler函数，就可以判断子进程是否已经停止。具体方法如下： #include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void handler(int sig) &#123; if (sig == SIGCHLD) &#123; int status; waitpid(-1, &amp;status, WNOHANG); &#125;&#125; int main() &#123; int pid = fork(); if (pid&lt;0) &#123; perror(&quot;fork faild&quot;); &#125; if (!pid) &#123; sleep(5); printf(&quot;子：子进程over\n&quot;); exit(0); &#125; else &#123; signal(SIGCHLD, handler); while(1) &#123; sleep(1); int ret = kill(pid, 0); if (ret &lt; 0) &#123; printf(&quot;父：子进程已经结束\n&quot;); break; &#125; else &#123; printf(&quot;父：子进程还没有结束\n&quot;); &#125; &#125; &#125; printf(&quot;程序结束!\n&quot;);&#125;]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[printf输出带颜色]]></title>
    <url>%2F2019%2F02%2F24%2Fprintf%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[​ 要想让printf()函数输出的内容带颜色，格式为： printf("\033[背景颜色;字体颜色m你要输出的内容\033[0m");// \033[背景颜色;字体颜色m 代表你从这儿开始输出的内容选择某种背景颜色的某种颜色字体// \033[0m 代表自定义颜色结束，恢复系统默认 背景颜色范围： 40: 黑 41: 红 42: 绿 43: 黄 44: 蓝 45: 紫 46: 深绿 47: 白色 字体颜色范围： 30: 黑 31: 红 32: 绿 33: 黄 34: 蓝 35: 紫 36: 深绿 37: 白色 ​ 大概就是酱紫～]]></content>
      <tags>
        <tag>收藏</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1156垃圾陷阱]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%B4%9B%E8%B0%B7P1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[题目描述卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D(2≤D≤100)D(2≤D≤100)英尺。 卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。 每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。 假设卡门预先知道了每个垃圾扔下的时间t(0&lt;t≤1000)t(0&lt;t≤1000)，以及每个垃圾堆放的高度h(1≤h≤25h(1≤h≤25)和吃进该垃圾能维持生命的时间f(1≤f≤30)f(1≤f≤30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续1010小时的能量，如果卡门1010小时内没有进食，卡门就将饿死。 输入输出格式输入格式： 第一行为22个整数，DD和 G(1≤G≤100)G(1≤G≤100)，GG为被投入井的垃圾的数量。 第二到第G+1G+1行每行包括33个整数：T(0&lt;T&lt;=1000)T(0&lt;T&lt;=1000)，表示垃圾被投进井中的时间；F(1≤F≤30)F(1≤F≤30)，表示该垃圾能维持卡门生命的时间；和 H(1≤H≤25)H(1≤H≤25)，该垃圾能垫高的高度。 输出格式： 如果卡门可以爬出陷阱，输出一个整表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。 输入输出样例输入样例#1： 20 45 4 99 3 212 6 1013 1 1 输出样例#1： 13 思维： ​ 我们可以设dp[i][j]代表第第i个垃圾投入后奶牛所处高度为j的最大存活时间，初始化dp[0][0] = 10，其余为-1，那么我们可以得到： dp[i][j] = max(dp[i - 1][j] - (cow[i].t - cow[i - 1].t) + cow[i].f, dp[i - 1][j - cow[i].h] - (cow[i].t - cow[i - 1].t); ​ 由于一次投入的垃圾最多可以上升25，所以奶牛若有可能上来，最终所处位置为[h, h + 25)的集合，所以j的遍历范围为[h, h + 25)，最后遍历垃圾，若在[h, h + 25)存在非-1的数，那么奶牛上来的时间为所处垃圾的投入位置。否则奶牛就上不来 ​ 上不来我们只需要遍历垃圾，若dp[i][0]为-1，那么存活时间为dp[i - 1][0] + cow[i - 1].t，注意若遍历完垃圾还没有死，那么存活时间为dp[n][0] + cow[n].t ​ 注意一下细节和边界条件即可 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int t, f, h;&#125;lj[105];bool cmp(node A, node B) &#123; return A.t &lt; B.t;&#125;int dp[105][150];int main () &#123; int h, n, flag = 0; scanf(&quot;%d%d&quot;, &amp;h, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;lj[i].t, &amp;lj[i].f, &amp;lj[i].h); &#125; sort(lj + 1, lj + n + 1, cmp); lj[0].t = 0; memset(dp, -1, sizeof(dp)); dp[0][0] = 10; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; h + 25; j++) &#123; if (dp[i - 1][j] - (lj[i].t - lj[i - 1].t) &gt;= 0) &#123; dp[i][j] = max(dp[i - 1][j] - (lj[i].t - lj[i - 1].t)+ lj[i].f, dp[i][j]); //吃 &#125; if (j - lj[i].h &gt;= 0 &amp;&amp; dp[i - 1][j - lj[i].h] - (lj[i].t -lj[i - 1].t) &gt;= 0) &#123; dp[i][j] = max(dp[i - 1][j - lj[i].h] - (lj[i].t - lj[i - 1].t), dp[i][j]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = h; j &lt; h + 25; j++) &#123; if (dp[i][j] != -1) &#123; flag = 1; printf(&quot;%d\n&quot;, lj[i].t); break; &#125; &#125; if (flag) &#123; break; &#125; &#125; if (!flag) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (dp[i][0] == -1) &#123; flag = 1; printf(&quot;%d\n&quot;, dp[i - 1][0] + lj[i - 1].t); break; &#125; &#125; &#125; if (!flag) &#123; printf(&quot;%d\n&quot;, dp[n][0] + lj[n].t); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1103书本整理]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%B4%9B%E8%B0%B7P1103%E4%B9%A6%E6%9C%AC%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目描述Frank是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以Frank首先将书按高度顺序排列在书架上。但是Frank发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉k本书，使得书架可以看起来整齐一点。 书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有4本书： 1×21×25×35×32×42×43×13×1那么Frank将其排列整齐后是： 1×21×22×42×43×13×15×35×3不整齐度就是2+3+2=72+3+2=7 已知每本书的高度都不一样，请你求出去掉k本书后的最小的不整齐度。 输入输出格式输入格式： 第一行两个数字nn和kk，代表书有几本，从中去掉几本。(1≤n≤100,1≤k&lt;n1≤n≤100,1≤k&lt;n) 下面的nn行，每行两个数字表示一本书的高度和宽度，均小于200200。 保证高度不重复 输出格式： 一行一个整数，表示书架的最小不整齐度。 输入输出样例输入样例#1： 4 11 22 43 15 3 输出样例#1： 3 思路： ​ 我们先把书本从低到高排序，然后我们设dp[i][j]代表前i本书去掉j本（一定包含第i本）的最小不整齐度。我们初始dp[0][0] = 0，其余为无穷大，那么： if(j + 1 == i) dp[i][j] == 0;else dp[i][j] = min(dp[k][j - (book[i].h - book[k].h - 1)] + book[i].w - book[k].w) (1 &lt;= k &lt; i) ​ 最后dp[k][j - (n - k)]最小的即为答案 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;using namespace std;int dp[105][105]; //前i本书去掉j本的最小不整齐度，i本必取struct node &#123; int h, w;&#125;book[105];bool cmp(node A, node B) &#123; return A.h &lt; B.h;&#125;int main () &#123; int n, k, minn = 0x3f3f3f3f; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;book[i].h, &amp;book[i].w); &#125; sort(book + 1, book + n + 1, cmp); memset(dp, 0x3f3f3f3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= k &amp;&amp; j &lt; i; j++) &#123; if (i == j + 1) &#123; dp[i][j] = 0; continue; &#125; for (int p = 0; p &lt; i; p++) &#123; if (j - (i - p - 1) &gt;= 0) &#123; dp[i][j] = min(dp[p][j - (i - p - 1)] + abs(book[i].w - book[p].w), dp[i][j]); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (k - (n - i) &gt;= 0) &#123; minn = min(dp[i][k - (n - i)], minn); &#125; &#125; printf(&quot;%d\n&quot;, minn); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1681最大正方形2]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%B4%9B%E8%B0%B7P1681%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A22%2F</url>
    <content type="text"><![CDATA[题目背景忙完了学校的事，v神终于可以做他的“正事”：陪女朋友散步。一天，他和女朋友走着走着，不知不觉就来到了一个千里无烟的地方。v神正要往回走，如发现了一块牌子，牌子上有有一行小字和一张图，小字说道：“找到图上最大的交错正方形之后和我联系，这块地就是你的了。”在房价疯长的年代，v神当然不愿错过这个机会，于是开始找了起来……以v神的能力当然找不出来了，你能帮v神找出来吗？ 题目描述图上有一个矩阵，由N*M个格子组成，这些格子由两种颜色构成，黑色和白色。请找到面积最大的且内部是黑白交错（即两个相连的正方形颜色不能相同）的正方形。 输入输出格式输入格式： 第一行两个整数N和M，分别表示行数和列数。接下来有N行，每行M个数，0或1分别表示这个格子是黑色或白色。 输出格式： 仅有一行，表示满足条件最大正方形的 边长 输入输出样例输入样例#1： 3 30 1 01 0 01 1 1 输出样例#1： 2 说明样例解释： (1,1)到(2,2)这个正方形是满足条件的，它的边长是2 数据范围约定： 对于30%的数据，N &lt;= 20 对于60%的数据，N &lt;=300 对于100%的数据，N &lt;= 1500 思路： ​ 这道题可以h[i]代表i行中当前点往左扩的最长距离，l[j]代表i列中当前点往上扩的最长距离，dp[i][j]代表以(i, j)点为右下角的正方形最长边长。那么我们可以得到: dp[i][j] = min(dp[i - 1][j - 1] + 1, l[i], h[j]); ​ 我们用一个maxx维护dp[i][j]的最大值即为答案 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;bool maps[1550][1550];int h[1550], l[1550];int dp[1550][1550] = &#123;0&#125;;int main () &#123; int n, m, a, maxx = 1; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;maps[i][j]); if (i == 1) &#123; l[j] = 1; &#125; else &#123; if (maps[i][j] != maps[i - 1][j]) &#123; l[j] += 1; &#125; else &#123; l[j] = 1; &#125; &#125; if (j == 1) &#123; h[i] = 1; &#125; else &#123; if (maps[i][j] != maps[i][j - 1]) &#123; h[i] += 1; &#125; else &#123; h[i] = 1; &#125; &#125; dp[i][j] = min(min(h[i], l[j]), dp[i - 1][j - 1] + 1); maxx = max(dp[i][j], maxx); &#125; &#125; printf(&quot;%d\n&quot;, maxx); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C网络编程实现聊天室]]></title>
    <url>%2F2019%2F02%2F23%2FC%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[主要是利用所学的C语言网络编程来实现聊天室功能，包括客户端和服务端两个部分，common用于封装网络编程的相关函数。 ​ 客户端接收两个参数，分别是IP地址和端口号 ​ 代码已上传至github：跳转 ​ 或者从个人博客项目上查看：跳转 效果如下： 用户1的输入： 用户2的输入： 聊天室（服务器）的显示：]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1651塔]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%B4%9B%E8%B0%B7P1651%E5%A1%94%2F</url>
    <content type="text"><![CDATA[题目描述小明很喜欢摆积木，现在他正在玩的积木是由N个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？ 输入输出格式输入格式： 第一行为一个整数N，表示木块个数。 第二行是N个整数，表示N块木块的高度。 【数据规模】 对于100%的数据，N≤50，每块木块的高度h满足1≤h≤500000，所有木块的高度总和≤500000。 输出格式： 仅一个整数，表示能搭建的塔的最大高度，若不能搭建两座相同高度的塔，则输出“-1”。 输入输出样例输入样例#1： 32 3 5 输出样例#1： 5 思路： ​ 这道题我们可以设dp[i][j]代表用前i个木块拼出的塔相差j时的较低塔的高度，初始化dp[1][a[1]]=0;(使用第一个木块) dp[1][0]=0;(不使用第一个木块)，其余初始化为-1，这样这道题会有4种情况： 1.当不使用第i个木块：dp[i][j] = dp[i - 1][j];2.当使用第i个木块且将第i个木块加到较长木块上：dp[i][j] = dp[i - 1][j - a[i]];3.当使用第i个木块且将第i个木块加到较短木块，此时较短木块还是较短木块：dp[i][j] = dp[i - 1][j + a[i]] + a[i];4.当使用第i个木块且将第i个木块加到较短木块，此时较短木块称为较长木块：dp[i][j] = dp[i - 1][a[i] - j] + a[i] - j; ​ 要考虑周全每种情况，最后dp[n][0]即为答案，若dp[n][0] == 0 || dp[n][0] == -1时输出-1 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int a[55];int sum[55] = &#123;0&#125;;int dp[55][500005];int main () &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum[i] = sum[i - 1] + a[i]; &#125; memset(dp, -1, sizeof(dp)); dp[1][0] = 0; dp[1][a[1]] = 0; for (int i = 2; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= sum[i]; j++) &#123; dp[i][j] = dp[i - 1][j]; if (a[i] - j &gt;= 0) &#123; if (j + a[i] &lt;= sum[i - 1] &amp;&amp; dp[i - 1][j + a[i]] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j + a[i]] + a[i]); &#125; int t = a[i] - j; if (dp[i - 1][t] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][t] + t); &#125; &#125; else &#123; if (j + a[i] &lt;= sum[i - 1] &amp;&amp; dp[i - 1][j + a[i]] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j + a[i]] + a[i]); &#125; if (j - a[i] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i]] != -1) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i]]); &#125; &#125; &#125; &#125; if (dp[n][0] == 0) &#123; printf(&quot;-1\n&quot;); &#125; else &#123; printf(&quot;%d\n&quot;, dp[n][0]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本获取系统相关信息]]></title>
    <url>%2F2019%2F02%2F22%2Fshell%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[​ 这次布置了六个作业，分别是获取磁盘、内存、CPU、用户信息、系统运行概况以及恶意进程检测等六个方面的内容 ​ 具体如下： 磁盘：主要用于获取DISK磁盘信息，输出时间，每个分区的名称，总量，剩余量，占用比，以及磁盘总量，剩余量，占用比等 内存：大概就是写一个获取当前时间，内存总量，内存剩余量，内存占用比，占用比动态平均值的shell脚本。唯一参数代表上一次占用比动态平均值 CPU：该脚本主要负责CPU信息的获取，包括时间，负载（1分钟 5分钟 15分钟），CPU占用率（时间间隔0.5），当前温度以及警告 用户信息：该脚本主要用来实现用户信息的获取，包括查看用户总数（非系统用户），查看近期最活跃的三个用户，查看具有root权限的用户，以及当前登陆的用户及其相关信息等 系统运行概况：主要用于获取当前时间，主机名，OS版本及运行时间，平均负载，磁盘总量，磁盘已用百分比以及内存大小和内存已用百分比，磁盘报警级别，内存报警级别，CPU报警级别等 恶意进程检测：主要是用于恶意进程的检测（脚本将5s内占用CPU或内存资源超过百分之50的进程定义为恶意进程），通过脚本检测并输出恶意进程的进程名，PID，所属用户以及它的CPU占用，内存占用 ​ 代码已上传至Github：跳转 ​ 或者通过我个人主页的项目homework进行查看：跳转]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简单用法(三)]]></title>
    <url>%2F2019%2F02%2F20%2FGit%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 前面两个讲了Git的最基本用法，三稍微进阶一点，讲一下比较、标签以及一些问题 ##比较 ###比较修改的内容 ​ 当修改的文件还没有添加到内存缓冲区时： $ git diff ​ 当修改的文件添加到内存缓冲区时： $ git diff --cached ###比较分支 ​ 比较当前分支和另一分支差别： $ git diff 分支名 ​ 比较两个分支差别： $ git diff 分支一 分支二 ​ 比较当前分支和另一个分支某一个文件或目录的差别： $ git diff 分支名 文件名 ##Git标签 ###创建标签 ​ 我们可以利用git tag创建一个标签来指向某个提交 $ git tag 标签名 提交编号 ​ 提交编号可通过git log查看，很长，我们一般写前8位即可 ​ 如果想为标签添加注释或签名，那么就需要创建标签对象 查看标签​ 利用git tag来查看所有标签 ###标签对象 利用-a，-s或-u中任意一个都会创建一个标签对象并且需要-m或者-F为其添加标签消息（注释），例如： $ git tag -a 标签名 提交编号 -m &quot;注释&quot; ​ 这时标签对象被添加到Git对象库中，此时标签指向标签对象而不是一次提交 ###签名标签 ​ 签名标签可以让提交和标签更加完整可信，以下步骤的前提是配有GPG key ####通过-s来创建签名标签 ​ 我们要想通过$ git tag -s 标签名 提交编号创建签名标签，就需要以下两种方式之一进行配置： 方法一： ​ 在.git/config或~/.gitconfig里配置： [user] signingkey = &lt;gpg-key-id&gt; 方法二： ​ 通过命令行配置： $ git config (--global) user.signingkey &lt;gpg-key-id&gt; ####通过-u来创建签名标签 $git tag -u &lt;gpg-key-id&gt; 标签名 提交编号 ##问题 ###推送失败 ​ 当本地修改的同时远端仓库已经变化，这时推送会出现推送失败。这时我们需要先git pull合并远程最新的修改后，再进行git push]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简单用法(二)]]></title>
    <url>%2F2019%2F02%2F20%2FGit%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] ​ 接上次Git简单用法-一 跳转 ，二主要讲关于Git的分支用法和Git日志： Git分支​ 分支的主要用于多人开发，可以让开发人员在主线（master分支）之外进行代码提交，同时又不会影响主线。比如我负责项目的一个功能模块，我就创建一个分支，把这部分代码提交到这个分支中，而其它模块的同事 仍可以利用主线开发，我的提交不会对他们造成任何影响。直到我的功能模块完成通过测试后，最后把我创建的分支合并到主线 ###创建分支 ​ 利用$ git branch 分支名便可以创建一个分支 ###查看全部分支 ​ 利用$ git branch 可以查看全部分支，以及当前所在分支（带*） ###切换分支 ​ 利用$ git checkout 分支名来切换到其它分支 ###合并分支 切换到主分支(master)后，利用`$ git merge -m &quot;注释&quot; 分支名`来合并创建的分支 ​ 合并分支会出现两种情况： （一）当两个分支修改的文件不同时：自动合并，不会有冲突（二）当两个分支修改了相同文件时：系统将两个分支的修改都保存到了该文件中，通过&lt;&lt;&lt;&lt;,&gt;&gt;&gt;,===来分隔，此时我们根据需要手动更改该文件，然后去掉上述分隔符。然后使用git add和git commit命令来提交冲突的文件 撤销合并​ 利用$ git reset --hard HEAD^返回合并之前的状态 ###删除分支 ​ 利用$ git branch -d 分支名可以删除已经被主分支合并的分支 ​ 利用$ git branch -D 分支名可以强制删除某个分支 ###关于如何获取远程分支 ​ 我们通过$ git pull命令能够将远程的所有分支都拉过来，但是利用$ git branch 命令查看发现，当前显示的分支只有自己创建的还有主分支，而远程分支虽然拉下来了，但是无法切换 ​ 我们要想切换远程分支，只能退而求其次，先把远程分支的内容拷贝到自己新创建的分支上，然后在新分支进行操作，具体做法是： $ git checkout -b 新建分支名 origin/远程分支名 ​ 上一行命令就是创建一个新分支，然后把远程分支的内容拷贝到新分支中，我们只需要切换到新分支进行开发就可 Git可能出现的问题​ 当在本地创建了一个分支后，在该分支下我们无法实现$git pull 和$git push命令，我们要想在该分支下使用上面两个命令，必须与远程分支关联 $ git branch --set-upstream 分支名 origin/远程分支名 ​ 这时就Ok了 ##Git日志 ###查看日志 ​ 利用$ git log可以查看所有的提交 ###日志统计 ​ 利用$ git log --stat回显示详细的提交记录 ###日志格式化输出 ​ 利用$ git log --pretty=格式类型来指定格式输出日志，主要格式有oneline，short，medium，full，fuller，email，raw等，也可通过--pretty=format:&#39;自定义格式&#39;来输出日志 ###日志可视化输出 ​ 利用$ git log --graph可视化显示提交图 ###日志排序 ​ 默认按时间线逆序显示，可制定--topo-order参数来按自提交在父提交前显示的排序规则，或者--reverse参数时间线正序显示 ###其它 ​ 除此之外日志还有很多用法，具体可通过git help log来查看相应参数用法]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于zsh踩过的坑]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%85%B3%E4%BA%8Ezsh%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[​ 当时自己不知情稀里糊涂的从bash切换到了zsh还不自知，其它都还好。就是没次执行sql命令的时候都告诉我sql command not found，然后把/usr/local/mysql/bin添加到环境变量PATH中。然后sql就好用了。然后关掉终端重新打开，发现sql又not found了。。。。。 ​ 这时我才意识到，我原来这两个月一直用的是zsh。。。我这反射弧也没谁了～ ​ 只要你确定命令存在却找不到，解决这类问题共需要三步： 步骤一：检查是否添加到环境变量中，如果没有，请添加到环境变量，具体流程就是在家目录下（~）的.bash_profile文件下添加： PATH=对应命令的路径:$JAVA_HOME/bin:$PATH: //假如有Java环境的话，加$JAVA_HOME/binexport PATH 步骤二:让.bash_profile文件生效 source ~/.bash_profile 步骤三：若这时命令好使，但是重启终端发现命令又not found了，这时需要检查你用的是不是不是bash，如果时zsh的话，则需要在~/.zshrc文件最后增加一行： source ~/.bash_profile ​ 最后附上bash和zsh切换的命令： chsh -s /bin/bash //切换到bashchsh -s /bin/zsh //切换到zsh ​ 如果输入密码后提示no change made，那么命令前加上sudo获取临时管理员权限]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1131时态同步]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%B4%9B%E8%B0%B7P1131%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[题目描述小QQ在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字1,2,3…1,2,3….进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。 在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。 激励电流在导线上的传播是需要花费时间的，对于每条边ee，激励电流通过它需要的时间为tet**e，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小QQ有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？ 输入输出格式输入格式： 第一行包含一个正整数NN，表示电路板中节点的个数。 第二行包含一个整数SS，为该电路板的激发器的编号。 接下来N−1N−1行，每行三个整数a,b,ta,b,t。表示该条导线连接节点aa与节点bb，且激励电流通过这条导线需要tt个单位时间。 输出格式： 仅包含一个整数VV，为小QQ最少使用的道具次数。 输入输出样例输入样例#1： 311 2 11 3 3 输出样例#1： 2 说明对于40%40%的数据，N≤1000N≤1000 对于100%100%的数据，N≤500000N≤500000 对于所有的数据，te≤1000000t**e≤1000000 思路： ​ 由“都存在且仅存在一条通路”这句话我们可知这是树形结构。我们可以设f[i]代表以节点i为根结点到叶节点的最远距离，设dp[i]代表以节点i为根结点最少使用道具次数。 ​ 那么我们可以得到： f[i] = max(f[j] + c) //j为i的子节点，c为i到j的距离dp[i] += dp[j] + f[i] - (f[j] + c); //j为i的子节点 ​ 下面给大家提供一种通过树深度来实现非递归的求法 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define ll long longtypedef pair&lt;int, ll&gt;PIL;struct node&#123; vector&lt;PIL&gt; m; int sd;&#125;point[500005];int num[500005];ll dp[500005] = &#123;0&#125;;ll f[500005] = &#123;0&#125;;void dfs(int inx) &#123; for (int i = 0; i &lt; point[inx].m.size(); i++) &#123; int to = point[inx].m[i].first; if (point[to].sd == 0) &#123; point[to].sd = point[inx].sd + 1; dfs(to); &#125; &#125; return;&#125;bool cmp(int a, int b) &#123; return point[a].sd &gt; point[b].sd;&#125;int main () &#123; int n, c, s, e; ll v; scanf(&quot;%d%d&quot;, &amp;n, &amp;c); for (int i = 1; i &lt;= n; i++) &#123; num[i] = i; point[i].sd = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; scanf(&quot;%d%d%lld&quot;, &amp;s, &amp;e, &amp;v); point[s].m.push_back(PIL(e, v)); point[e].m.push_back(PIL(s, v)); &#125; point[c].sd = 1; dfs(c); sort(num + 1, num + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) &#123; int inx = num[i]; ll maxx = 0; for (int j = 0; j &lt; point[inx].m.size(); j++) &#123; int to = point[inx].m[j].first; if (point[to].sd &gt; point[inx].sd) &#123; maxx = max(maxx, f[to] + point[inx].m[j].second); &#125; &#125; f[inx] = maxx; for (int j = 0; j &lt; point[inx].m.size(); j++) &#123; int to = point[inx].m[j].first; if (point[to].sd &gt; point[inx].sd) &#123; dp[inx] += dp[to] + (maxx - (f[to] + point[inx].m[j].second)); &#125; &#125; &#125; printf(&quot;%lld\n&quot;, dp[c]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1220关路灯]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%B4%9B%E8%B0%B7P1220%E5%85%B3%E8%B7%AF%E7%81%AF%2F</url>
    <content type="text"><![CDATA[题目描述某一村庄在一条路线上安装了n盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。 为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。 现在已知老张走的速度为1m/s，每个路灯的位置（是一个整数，即距路线起点的距离，单位：m）、功率（W），老张关灯所用的时间很短而可以忽略不计。 请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。 输入输出格式输入格式： 文件第一行是两个数字n(1&lt;=n&lt;=50，表示路灯的总数)和c(1&lt;＝c&lt;=n老张所处位置的路灯号)； 接下来n行，每行两个数据，表示第1盏到第n盏路灯的位置和功率。数据保证路灯位置单调递增。 输出格式： 一个数据，即最少的功耗(单位：J，1J＝1W·s)。 输入输出样例输入样例#1： 5 32 103 205 206 308 10 输出样例#1： 270 思路： ​ 老张肯定经过某个路灯的时候顺手关掉，而不会出现跳着关灯的情况（否则一定不是最小）。因此，我们可以设dp[i][j]代表从第i盏灯到第j盏灯全部关掉的最小功率。这时会出现一个问题，此时老张是在i灯处还是j灯处，因此，我们需要设置一个三维数组来表示： dp[i][j][0]代表关掉区间[i, j]的灯且此时老张在i灯处的最小功率dp[i][j][0]代表关掉区间[i, j]的灯且此时老张在j灯处的最小功率将dp[c][c][0],dp[c][c][1]初始化为0，其余为无穷大我们会得到：dp[i][j][0] = min(dp[i + 1][j][0] + (l[i + 1] - l[i]) * W1, dp[i + 1][j][1] + (l[j] - l[i]) * W1);dp[i][j][1] = min(dp[i][j - 1][0] + (l[j] - l[i]) * W2, dp[i][j - 1][1] + (l[j] - l[j - 1]) * W2); ​ 最后再注意一下边界条件，最后min(dp[1][n][0], dp[1][n][1])即为答案 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int inx, val;&#125;box[55];int dp[55][55][2] = &#123;0&#125;;int w[55][55] = &#123;0&#125;;int val[4];int ww[55] = &#123;0&#125;;int main () &#123; int n, c; scanf(&quot;%d%d&quot;, &amp;n, &amp;c); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;box[i].inx, &amp;box[i].val); ww[i] = ww[i - 1] + box[i].val; &#125; w[c][c] -= box[c].val; memset(dp, 0x3f, sizeof(dp)); dp[c][c][0] = 0; dp[c][c][1] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; w[i][j] = ww[n] - ww[j] + ww[i - 1]; &#125; &#125; for (int i = c; i &gt;= 1; i--) &#123; for (int j = c; j &lt;= n; j++) &#123; if (i == c &amp;&amp; j == c) continue; memset(val, 0x3f, sizeof(int)); if (i != c) &#123; val[0] = dp[i + 1][j][0] + (box[i + 1].inx - box[i].inx) * w[i + 1][j]; val[1] = dp[i + 1][j][1] + (box[j].inx - box[i].inx) * w[i + 1][j]; dp[i][j][0] = min(val[0], val[1]); //printf(&quot;%d %d %s %d %d\n&quot;, i, j, &quot;左&quot;, dp[i][j][0], w[i + 1][j]); &#125; if (j != c) &#123; val[2] = dp[i][j - 1][0] + (box[j].inx - box[i].inx) * w[i][j - 1]; val[3] = dp[i][j - 1][1] + (box[j].inx - box[j - 1].inx) * w[i][j - 1]; dp[i][j][1] = min(val[2], val[3]); //printf(&quot;%d %d %s %d %d\n&quot;, i, j, &quot;右&quot;, dp[i][j][1], w[i][j - 1]); &#125; &#125; &#125; printf(&quot;%d\n&quot;, min(dp[1][n][0], dp[1][n][1])); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++定义模版]]></title>
    <url>%2F2019%2F02%2F12%2FC-%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[​ C++支持泛型编程（即独立于任何特定类型），而模版是泛型编程的基础，因此模版对于C++来说十分重要 ​ 定义模版分为函数模版定义和类模版定义 ##函数模版 对于函数模版定义，一般形式为： template &lt;typename type&gt; ret-type func-name(parameter list) &#123; &#125; ​ type 是函数所使用的数据类型的占位符名称，ret-type是返回值类型，func-name为函数名，parameter list为参数列表 ​ 例如： template &lt;typename T&gt; inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; return a &lt; b ? b:a; &#125; ##类模版 对于类模版的定义，一般形式为： template &lt;typename type&gt; class class-name &#123; &#125; ​ 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型 例如： template &lt;class T&gt; class Stack &#123; private: vector&lt;T&gt; elems; // 元素 public: void push(T const&amp;); // 入栈&#125;; template &lt;class T&gt; void Stack&lt;T&gt;::push (T const&amp; elem) &#123; elems.push_back(elem); // 追加传入元素的副本&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟栈实现逆波兰表达式]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%A8%A1%E6%8B%9F%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[​ 用C++模拟栈来实现逆波兰表达式求解算式～ /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;using namespace std;template &lt;typename type&gt; class S&#123;private: type *val; int head;public: void push(type val) &#123; this -&gt; head ++; this -&gt; val[this -&gt; head] = val; &#125; void pop() &#123; this -&gt; head --; &#125; bool empty() &#123; return this -&gt; head &lt; 0; &#125; type top() &#123; return this -&gt; val[this -&gt; head]; &#125; bool bj(char c) &#123; if ((c == &apos;+&apos; || c == &apos;-&apos;) &amp;&amp; (top() == &apos;*&apos; || top() == &apos;/&apos;)) &#123; return true; &#125; else if ((c == &apos;+&apos; || c == &apos;-&apos;) &amp;&amp; (top() == &apos;+&apos; || top() == &apos;-&apos;))&#123; return true; &#125; else if ((c == &apos;*&apos; || c == &apos;/&apos;) &amp;&amp; (top() == &apos;*&apos; || top() == &apos;/&apos;))&#123; return true; &#125; else &#123; return false; &#125; &#125; void init() &#123; this -&gt; val = (type *)malloc(sizeof(type) * 25); this -&gt; head = -1; &#125; void clear() &#123; free(this -&gt; val); free(this); &#125;&#125;;int jsx(char c, int a, int b) &#123; switch(c) &#123; case &apos;*&apos;: return a * b; break; case &apos;/&apos;: return a / b; break; case &apos;+&apos;: return a + b; break; default: return a - b; &#125;&#125;void js(S&lt;int&gt; *num, S&lt;char&gt; *ch) &#123; int b = num -&gt; top(); num -&gt; pop(); int a = num -&gt; top(); num -&gt; pop(); num -&gt; push(jsx(ch -&gt; top(), a, b)); ch -&gt; pop();&#125;int main () &#123; char *buffer = (char *)malloc(sizeof(char) * 25); scanf(&quot;%s&quot;, buffer); int val = 0; S&lt;int&gt; *num = (S&lt;int&gt; *)malloc(sizeof(S &lt;int&gt;)); S&lt;char&gt; *ch = (S&lt;char&gt; *)malloc(sizeof(S &lt;char&gt;)); num -&gt; init(); ch -&gt; init(); for (int i = 0; buffer[i]; i++) &#123; if (isdigit(buffer[i])) &#123; val = val * 10 + buffer[i] - &apos;0&apos;; &#125; else &#123; num -&gt; push(val); val = 0; while(!ch -&gt; empty() &amp;&amp; ch -&gt; bj(buffer[i])) &#123; js(num, ch); &#125; ch -&gt; push(buffer[i]); &#125; &#125; num -&gt; push(val); while(!ch -&gt; empty()) &#123; js(num, ch); &#125; printf(&quot;%d\n&quot;, num -&gt; top()); free(buffer); num -&gt; clear(); ch -&gt; clear(); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>模拟</tag>
        <tag>逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟队列]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[C++模拟队列的实现～ /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;template &lt;typename type&gt; class Que&#123;private: type *data; int head, tail;public: Que() &#123; head = 0; tail = -1; data = (type *)malloc(sizeof(type) * 105); &#125; ~Que() &#123; free(this -&gt; data); &#125; void add(type data) &#123; tail++; this -&gt; data[tail] = data; return; &#125; void pop() &#123; if (!empty()) &#123; head++; &#125; return; &#125; bool empty() &#123; return head &gt; tail; &#125; void output() &#123; for (int i = head; i &lt;= tail; i++) &#123; printf(&quot;%d%c&quot;, data[i], i == tail? &apos;\n&apos;: &apos; &apos;); &#125; return; &#125; int gethead() &#123; return head; &#125; int gettail() &#123; return tail; &#125;&#125;;int main () &#123; int n, m, val; Que&lt;int&gt; que; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;val); que.add(val); &#125; scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; que.pop(); &#125; que.output(); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-01-31博客搭建进度]]></title>
    <url>%2F2019%2F01%2F31%2F19-01-31%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[​ 特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间（11.13更新） ​ ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新） ​ ——新增动态背景(11.28更新) ​ ——修改网站图片外链至本地（11.28更新） ​ ——博文尾部自动添加声明（11.29更新） ​ ——实现博文字数统计（11.29更新） ​ ——添加顶部加载条（11.29更新） ​ ——添加简历页 (11.30更新) ​ ——调整底部布局 (12.02更新) ​ ——新增小游戏——见缝插针 (12.02更新) ​ ——修复音乐弹出、小火箭移动端错误问题 （12.04更新） ​ ——更新“关于我”页面特效（12.04更新） ​ ——主页新增搜索博文功能 （01.31更新）]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟链表]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[​ 主要是用C++实现了链表的增删改查以及反转、遍历等功能，具体实现请看代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;iostream&gt;#define ERROR 0#define OK 1using namespace std;template &lt;typename Type&gt; class Point &#123;public: Type data; Point&lt;Type&gt; *next; Point() &#123; this -&gt; next = NULL; &#125; Point(Type data) &#123; this -&gt; data = data; this -&gt; next = NULL; &#125;&#125;;template &lt;typename Type&gt; class Train &#123;private: Point&lt;Type&gt; *head; int len;public: Train() &#123; head = NULL; len = 0; &#125; ~Train() &#123; Point&lt;Type&gt; *p = this -&gt; head; while(p != NULL) &#123; Point&lt;Type&gt; *old = p; p = p -&gt; next; free(old); &#125; &#125; void set(int len) &#123; this -&gt; len = len; &#125; int get() &#123; return this -&gt; len; &#125; bool insert(Point&lt;Type&gt; *t, int inx) &#123; if (inx &lt; 0 || inx &gt; this -&gt; len) &#123; return ERROR; &#125; if (this -&gt; head == NULL) &#123; this -&gt; len ++; this -&gt; head = t; return OK; &#125; if (inx == 0) &#123; t -&gt; next = this -&gt; head; this -&gt; head = t; this -&gt; len ++; return OK; &#125; Point&lt;Type&gt; *p = this -&gt; head; int tot = 0; while(tot &lt; inx - 1) &#123; p = p -&gt; next; tot++; &#125; t -&gt; next = p -&gt; next; p -&gt; next = t; this -&gt; len ++; return OK; &#125; int query(Type val) &#123; if (this -&gt; head == NULL) &#123; return -1; &#125; Point&lt;Type&gt; *p = this -&gt; head; int tot = 0; while(p != NULL) &#123; if (p -&gt; data == val) &#123; return tot; &#125; p = p -&gt; next; tot++; &#125; return -1; &#125; void output() &#123; if (this -&gt; head == NULL) &#123; return; &#125; Point&lt;Type&gt; *p = this -&gt; head; int tot = 0; while(p != NULL) &#123; cout &lt;&lt; tot++ &lt;&lt; &quot;:&quot; &lt;&lt; p -&gt; data &lt;&lt; &quot; &quot;; p = p -&gt; next; &#125; cout &lt;&lt; endl; &#125; bool del(int inx) &#123; if (inx &lt; 0 || inx &gt;= this -&gt; len) &#123; return ERROR; &#125; Point&lt;Type&gt; *p = this -&gt; head; int tot = 0; if (inx == 0) &#123; this -&gt; head = this -&gt; head -&gt; next; free(p); this -&gt; len --; return OK; &#125; while(tot &lt; inx - 1) &#123; p = p -&gt; next; tot++; &#125; Point&lt;Type&gt; *del = p -&gt; next; p -&gt; next = del -&gt; next; free(del); this -&gt; len --; return OK; &#125; void reverse() &#123; if (this -&gt; head == NULL) &#123; return; &#125; Point&lt;Type&gt; *p = head -&gt; next; head -&gt; next = NULL; while(p != NULL) &#123; Point&lt;Type&gt; *p2 = p -&gt; next; p -&gt; next = head; head = p; p = p2; &#125; &#125;&#125;;int main(int argc, char const *argv[])&#123; Train&lt;int&gt; trian; int m, a, b, t; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; t; switch (t) &#123; case 1: &#123; cin &gt;&gt; a &gt;&gt; b; Point &lt;int&gt; *p = (Point &lt;int&gt; *)malloc(sizeof(Point &lt;int&gt;)); p -&gt; data = b; p -&gt; next = NULL; if(trian.insert(p, a)) &#123; cout &lt;&lt; &quot;success&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl; &#125; break; &#125; case 2: &#123; trian.output(); break; &#125; case 3:&#123; cin &gt;&gt; a; if (trian.del(a)) &#123; cout &lt;&lt; &quot;success&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl; &#125; break; &#125; case 4:&#123; cin &gt;&gt; a; int inx = trian.query(a); if (inx != -1) &#123; cout &lt;&lt; inx &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl; &#125; break; &#125; default: trian.reverse(); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟动态数组]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[​ 大概就是用数组模拟动态数组吧，功能包括插入，查询，删除，遍历。可以进行初始化，动态扩容，以及最后释放掉内存 ​ 代码如下： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 0#define OK 1typedef struct Vector &#123; int len, size; int *q;&#125; Vector;void init(Vector *a, int size) &#123; a -&gt; q = (int *)malloc(sizeof(int) * size); a -&gt; len = 0; a -&gt; size = size; return;&#125;void expand(Vector *a) &#123; a -&gt; size *= 2; int *old = a -&gt; q; a -&gt; q = (int *)malloc(sizeof(int) * a -&gt; size); for (int i = 0; i &lt; a -&gt; len; i++) &#123; a -&gt; q[i] = old[i]; &#125; free(old); return;&#125;int insert(Vector *a, int inx, int val) &#123; if (inx &lt; 0 || inx &gt; a -&gt; len) return ERROR; if (a -&gt; len &gt;= a -&gt; size) &#123; expand(a); &#125; for (int i = a -&gt; len; i &gt; inx; i--) &#123; a -&gt; q[i] = a -&gt; q[i - 1]; &#125; a -&gt; q[inx] = val; a -&gt; len++; return OK;&#125;int search(Vector *a, int val) &#123; for (int i = 0; i &lt; a -&gt; len; i++) &#123; if(a -&gt; q[i] == val) return OK; &#125; return ERROR;&#125;int delete_node(Vector *a, int inx) &#123; if (inx &lt; 0 || inx &gt;= a -&gt; len) return ERROR; for (int i = inx + 1; i &lt; a -&gt; len; i++) &#123; a -&gt; q[i - 1] = a -&gt; q[i]; &#125; a -&gt; len--; return OK;&#125;void print(Vector *a) &#123; for (int i = 0; i &lt; a -&gt; len; i++) &#123; printf(&quot;%d%c&quot;, a -&gt; q[i], i == a -&gt; len - 1? &apos;\n&apos;: &apos; &apos;); &#125; return;&#125;void clear(Vector *a) &#123; free(a -&gt; q); free(a);&#125;int main() &#123; Vector *a = (Vector *)malloc(sizeof(Vector)); init(a, 20); int m, t, p, q; scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;t); switch (t) &#123; case 1: scanf(&quot;%d%d&quot;, &amp;p, &amp;q); if (insert(a, p, q)) &#123; printf(&quot;success\n&quot;); &#125; else &#123; printf(&quot;failed\n&quot;); &#125; break; case 2: scanf(&quot;%d&quot;, &amp;p); if(delete_node(a, p)) &#123; printf(&quot;success\n&quot;); &#125; else &#123; printf(&quot;failed\n&quot;); &#125; break; case 3: scanf(&quot;%d&quot;, &amp;p); if(search(a, p)) &#123; printf(&quot;success\n&quot;); &#125; else &#123; printf(&quot;failed\n&quot;); &#125; break; default: print(a); &#125; &#125; clear(a); return 0;&#125;]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷3994高速公路]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%B4%9B%E8%B0%B73994%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[题目背景C国拥有一张四通八达的高速公路网树，其中有n个城市，城市之间由一共n-1条高速公路连接。除了首都1号城市，每个城市都有一家本地的客运公司，可以发车前往全国各地，有若干条高速公路连向其他城市，这是一个树型结构，1号城市（首都）为根。假设有一个人要从i号城市坐车出发前往j号城市，那么他要花费Pi*（i城市到j城市的距离）+Qi元。由于距离首都越远，国家的监管就越松，所以距离首都越远，客运公司的Pi（单位距离价格）越大，形式化的说，如果把高速路网看成一棵以首都为根的有根树，i号城市是j号城市的某个祖先，那么一定存在Pi&lt;=Pj。 题目描述大宁成为了国家统计局的调查人员，他需要对现在的高速路网进行一次调查，了解从其他每一个城市到达首都1号城市所花费的金钱(路径必须是简单路径)。 因为有非常多转车（或不转车）的抵达首都的方法，所以人工计算这个结果是十分复杂的。大宁非常的懒，所以请你编写一个程序解决它。 输入输出格式输入格式： 第 1 行包含1个非负整数 n,表示城市的个数。 第 2 到 n 行，每行描述一个除首都之外的城市。其中第 i 行包含4 个非负整数 Fi,Si,Pi,Qi，分别表示 i号城市的父亲城市，它到父亲城市高速公路的长度，以及乘车价格的两个参数。 输出格式： 输出包含 n-1 行，每行包含一个整数。 其中第 i 行表示从 i+1号城市 出发，到达首都最少的乘车费用。 输入输出样例输入样例#1： 61 9 3 01 17 1 91 1 1 64 13 2 154 9 2 4 输出样例#1： 272674324 说明对于前40%的数据1&lt;=n&lt;=1000。 对于另外20%的数据 满足从第i（i≠1）个城市出发的高速公路连向第i-1个城市。 对于所有的数据1&lt;=n&lt;=1000000，0&lt;=Pi，Qi&lt;=2^31-1，保证结果不会大于2^63-1。 思路： ​ 这道题我们可以设S[i]代表首都到i城市的距离， dp[i]代表第i个城市到首都最少乘车费用，那么我们可以得到递推式： dp[i] = min(dp[j] + P[i] * (S[i] - S[j]) + Q[i]) (0 &lt;= j &lt; i) ​ 上面这个式子的时间复杂度为O(n ^ 2)，由于n的范围为1e6，因此我们必须优化为O(n)的做法，我们发现，该式符合斜率优化的特征： dp[j]为变量，P[i] * S[i]和Q[i]为不变量，而P[i]*S[j]为混合量 ​ 我们开始将混合量去掉： 第一步：由于该题所有城市组成一棵树，1号首都为根结点。我们设j 为 k的子节点（不一定是直接子节点）且对于求dp[i]，j比k优，那么： dp[j] + P[i] * (S[i] - S[j]) + Q[i] &lt; dp[k] + P[i] * (S[i] - S[k]) + Q[i]dp[j] - P[i] * S[j] &lt; dp[k] - P[i] * S[k](dp[j] - dp[k]) / (S[j] - S[k]) &lt; P[i] ​ 其中(dp[j] - dp[k]) / (S[j] - S[k])就为求解的斜率 第二步 ​ 设P(p, q)为点p和点q之间的斜率，那么假设j, p, q都是i的祖宗节点且q是j的祖宗节点，p是q的祖宗节点且P(p, q) &gt; P(q, j)。我们讨论所有的情况 (1) P[i] &lt; P(q, j) &lt; P(p, q)此时，q优于j，p优于q，因此p是最优解(2) P(q, j) &lt; P[i] &lt; P(p, q)此时，j优于q，p优于q，因此j,p中的一个是最优解(3) P(q, j) &lt; P(p, q) &lt; P[i]此时，j优于q，q优于p，因此j是最优解 我们会发现，在满足该种的情况下，无论如何，q都不是最优解，也就是中间的那个永远不是最优，因此，我们可以用单调队列来维护斜率上升的队列来O(1)的求解dp[i] 第三步： ​ 因为这是一个树，在遍历树的时候，遍历完子节点回溯到父节点的时候需要对队列进行还原，我们发现手动模拟的队列数组q虽然tail，head改变，但是存储的内容只有一个位置发生改变，其余改变的只有head和tail，数组中的东西依旧保存。因此我们只需要维护每次的head，tail和改变的那个值即可，详细请看代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;ctype.h&gt;#define ll long longusing namespace std;//快速读inline int read() &#123; int num=0; char ch=0; while (!isdigit(ch)) &#123; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48); ch = getchar(); &#125; return num;&#125;//快速读inline ll readl() &#123; ll num=0; char ch=0; while (!isdigit(ch)) &#123; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48); ch = getchar(); &#125; return num;&#125;struct node&#123; int inx; ll val; void set(int ninx, ll nval) &#123; inx = ninx; val = nval; &#125;&#125;;ll P[1000005] = &#123;0&#125;, Q[1000005] = &#123;0&#125;, dp[1000005] = &#123;0&#125;, s[1000005] = &#123;0&#125;;vector&lt;node&gt; v[1000005];int q[1000005];void set(int j, int i) &#123; dp[i] = dp[j] + P[i] * (s[i] - s[j]) + Q[i];&#125;double getp(int j, int i) &#123; return 1.0 * (dp[i] - dp[j]) / (s[i] - s[j]);&#125;void dfs(int inx, int tail, int head) &#123; while (head + 2 &lt;= tail &amp;&amp; getp(q[head], q[head + 1]) &lt;= P[inx]) head++; set(q[head], inx); while (head + 2 &lt;= tail &amp;&amp; getp(q[tail - 1], inx) &lt;= getp(q[tail - 2], q[tail - 1])) tail--; int flag = q[tail]; q[tail++] = inx; for (int i = 0; i &lt; v[inx].size(); i++) &#123; node t = v[inx][i]; s[t.inx] = s[inx] + t.val; dfs(t.inx, tail, head); &#125; q[tail - 1] = flag; return;&#125; int main () &#123; int n, father; ll x; node t; n = read(); for (int i = 2; i &lt;= n; i++) &#123; father = read(); x = readl(); P[i] = readl(); Q[i] = readl(); t.set(i, x); v[father].push_back(t); &#125; q[1] = 1; dfs(1, 1, 1); for (int i = 2; i &lt;= n; i++) &#123; printf(&quot;%lld\n&quot;, dp[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
        <tag>斜率优化</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-7]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-7%2F</url>
    <content type="text"><![CDATA[之前系列讲了动态规划优化的去除冗余状态，重新定义状态，或者单调栈或单调队列优化等关于动态规划的优化问题。 接下来讲的就比较难了，属于动态规划的斜率优化问题 具体我们用例题来详细说明 例题：古老的打印机 有一台古老的打字机和一篇待打印的文章，文章中有 n 个字符，每个字符会有一个消耗值 Ci, 打字机工作一次会打印若干连续的 k 个字符，同时打字机会有磨损，打字机的单次磨损计算公式为： (∑i=1kCi)2+M 其中 M 是打字机启动一次的固定磨损值，现在给你 n 个字符的消耗值，问你打字机顺序打印出这 n 个字符的最小磨损值为多少？ 输入第一行输入两个数字，n,M(1≤n≤106,1≤M≤104) 代表文章中字符数量和打字机单次启动的固定磨损值。 第二行输入 n 个数字，第 i 个数字代表文章中第 i 个字符的磨损值 Ci(1≤Ci≤100)。 输出输出一个整数，代表打字机顺序打完 n 个字符的最小磨损值 样例输入16 403 3 6 5 1 2 样例输出1256 思路： ​ 对于这类问题，我们设s[i]为前i个字符的Ci的和， dp[i]代表前i个字符的最小磨损值，那么我们可以得到: dp[i] = min(dp[j] + (s[i] - s[j])^2 + M) (0 &lt;= j &lt; i) ​ 由上面的递推公式可知，这样的时间复杂度为O(n^2)，而n的范围是1e6，所以肯定1s内跑不完，因此我们需要把它优化为O(n)的时间复杂度 ​ 我们展开上面的式子： dp[i] = min(dp[j] + (s[i] - s[j])^2 + M) = min(dp[j] + s[i]^2 + s[j]^2 - 2 * s[i] * s[j] + M)我们单拿出dp[j] + s[i]^2 + s[j]^2 - 2 * s[i] * s[j] + M来看其中s[i]^2，M是固定值，dp[j]，s[j]^2是变化值，2 * s[i] * s[j]是两者的混合值 如果只有固定值和变化值，我们可以通过一个变量维护前i的s[j]^2 + dp[j]的最大值来O(1)的求出dp[i]，可是由于混合值的出现，导致我们无法这样求出 记住一点：只要看到混合值的出现，就要想办法对其进行斜率优化！！ 具体步骤是 1.假设j &gt; k且dp[j] + (s[i] - s[j])^2 + M优于dp[k] + (s[i] - s[k])^2 + M，那么： dp[j] + (s[i] - s[j])^2 + M &lt; dp[k] + (s[i] - s[k])^2 + M等价于：dp[j] + s[j]^2 - 2 * s[j] * s[i] &lt; dp[k] + s[k]^2 - 2 * s[k] * s[i]等价于：(dp[j] + s[j]^2) - (dp[k] + s[k]^2) &lt; 2 * s[i] * (s[j] - s[k])等价于：(dp[j] + s[j]^2) - (dp[k] + s[k]^2) / (s[j] - s[k]) &lt; 2 * s[i]我们假设f(i) = dp[i] * s[i]^2那么：f(j) - f(k) / (s[j] - s[k]) &lt; 2 * s[i] 至于为什么叫斜率优化，当我们把s[i]看作x，f(i)看作y，那么f(j) - f(k) / (s[j] - s[k])就是斜率了 也就是说，只要满足f(j) - f(k) / (s[j] - s[k]) &lt; 2 * s[i]且j &gt; k，那么j就一定优化k 2.我们设P(x, y)代表点x，y之间的斜率，对i中的p, q, j进行分析（p &lt; q &lt; j &lt; i且P(p, q) &gt; P(q, j)），那么斜率会有三种情况： (1) 2 * s[i] &lt; P(q, j) &lt; P(p, q)此时，q优于j，p优于q，因此p是最优解(2) P(q, j) &lt; 2 * s[i] &lt; P(p, q)此时，j优于q，p优于q，因此j,p中的一个是最优解(3) P(q, j) &lt; P(p, q) &lt; 2 * s[i]此时，j优于q，q优于p，因此j是最优解 ​ 我们会发现，在p(p, q) &gt; p(q, j)且 p &lt; q &lt; j &lt; i的情况下，无论如何，q都不是最优解，也就是中间的那个永远不是最优，因此，我们可以用单调队列来维护斜率上升的队列来O(1)的求解dp[i]，具体做法见代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#define ll long longll sum[1000005] = &#123;0&#125;;ll dp[1000005] = &#123;0&#125;;int q[1000005] = &#123;0&#125;;int n, M, a, tail, head;void set(int j, int i) &#123; dp[i] = dp[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + M;&#125;double getp(int j, int i) &#123; double p1 = (dp[i] + sum[i] * sum[i]) - (dp[j] + sum[j] * sum[j]); double p2 = sum[i] - sum[j]; return p1 / p2;&#125;int main () &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;M); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); sum[i] = sum[i - 1] + a; &#125; head = tail = 1; set(0, 1); q[tail++] = 0; q[tail++] = 1; for (int i = 2; i &lt;= n; i++) &#123; while(head + 2 &lt;= tail &amp;&amp; getp(q[head], q[head + 1]) &lt;= 2 * sum[i]) head++; set(q[head], i); while(head + 2 &lt;= tail &amp;&amp; getp(q[tail - 1], i) &lt;= getp(q[tail -2], q[tail - 1])) tail--; q[tail++] = i; &#125; printf(&quot;%lld\n&quot;, dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海贼OJ57有趣的序列]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B5%B7%E8%B4%BCOJ57%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[有趣的序列题目描述现在生成一个包含所有自然数的序列 123456789101112131415... 其中 d12 是数字 1 输入输入三个数字 x,y,z(1≤x,y,z≤1,000,000) 输出输出一个整数，代表dx×dy×dz 的结果 思路： ​ 因为x，y，z范围是1e6，因此我们可以先预处理出sum[i]代表i位数共占多少位置，并预处理出start[i]代表i位数的起始数组 ​ 这样，我们传入位置后，若位置&gt;sum[i]，就用位置-=sum[i]并查找下一位，若等于sum[i]，就返回9（因为每位数的最后一个数字的最后一位都是9），若小于sum[i]，就判断是第该位的哪一个数字的哪一位，并把该数返回即可 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;int sum[7] = &#123;0, 9, 180, 2700, 36000, 450000, 5400000&#125;;int start[7] = &#123;0, 1, 10, 100, 1000, 10000, 100000&#125;;int quick(int a, int b) &#123; int ans = 1; while(b) &#123; if(b &amp; 1) &#123; ans *= a; &#125; b &gt;&gt;= 1; a *= a; &#125; return ans;&#125;int getinx(int inx) &#123; for (int i = 1; i &lt;= 6; i++) &#123; if (inx &gt; sum[i]) &#123; inx -= sum[i]; &#125; else if (inx == sum[i]) &#123; return 9; &#125; else &#123; int cs = inx / i; int ys = inx % i; if (ys == 0) &#123; cs = cs + start[i] - 1; cs %= 10; return cs; &#125; else &#123; cs = cs + start[i]; int ttt = quick(10, i - ys); int kkk = cs / ttt; kkk %= 10; return kkk; &#125; &#125; &#125; return -1;&#125;int main () &#123; int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); // for (int i = 1; i &lt;= 1000; i++) &#123; // printf(&quot;%d&quot;, getinx(i)); // &#125; int xx = getinx(x); int yy = getinx(y); int zz = getinx(z); printf(&quot;%d\n&quot;, xx * yy * zz); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1757通天之分组背包]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B4%9B%E8%B0%B71757%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[题目背景直达通天路·小A历险记第二篇 题目描述自01背包问世之后，小A对此深感兴趣。一天，小A去远游，却发现他的背包不同于01背包，他的物品大致可分为k组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。 输入输出格式输入格式： 两个数m,n，表示一共有n件物品，总重量为m 接下来n行，每行3个数ai,bi,ci，表示物品的重量，利用价值，所属组数 输出格式： 一个数，最大的利用价值 输入输出样例输入样例#1： 45 310 10 110 5 150 400 2 输出样例#1： 10 说明1&lt;=m&lt;=1000 1&lt;=n&lt;=1000 组数t&lt;=100 思路： ​ 分组背包入门题，没啥好说的～ 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;string.h&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;zcy[1005];int v[1005], w[1005];int dp[1050] = &#123;0&#125;;int main () &#123; int m, n, group; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;w[i], &amp;group); zcy[group].push_back(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!zcy[i].size()) break; for (int k = m; k &gt;= 0; k--) &#123; for (int j = 0; j &lt; zcy[i].size(); j++) &#123; int vv = v[zcy[i][j]]; int ww = w[zcy[i][j]]; if (k - vv &lt; 0) continue; dp[k] = max(dp[k - vv] + ww, dp[k]); &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[m]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>分组背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1064金明的预算方案]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B4%9B%E8%B0%B71064%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[题目描述金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有00个、11个或22个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的NN元。于是，他把每件物品规定了一个重要度，分为55等：用整数1−51−5表示，第55等最重要。他还从因特网上查到了每件物品的价格（都是1010元的整数倍）。他希望在不超过NN元（可以等于NN元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第jj件物品的价格为v[j]v[j]，重要度为w[j]w[j]，共选中了kk件物品，编号依次为j1,j2,…,jkj1,j2,…,j**k，则所求的总和为： v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]v[j1]×w[j1]+v[j2]×w[j2]+…+v[j**k]×w[j**k]。 请你帮助金明设计一个满足要求的购物单。 输入输出格式输入格式： 第11行，为两个正整数，用一个空格隔开： NmN**m （其中N(&lt;32000)N(&lt;32000)表示总钱数，m(&lt;60)m(&lt;60)为希望购买物品的个数。） 从第22行到第m+1m+1行，第jj行给出了编号为j−1j−1的物品的基本数据，每行有33个非负整数 vpqvpq （其中vv表示该物品的价格（v&lt;10000v&lt;10000），p表示该物品的重要度（1−51−5），qq表示该物品是主件还是附件。如果q=0q=0，表示该物品为主件，如果q&gt;0q&gt;0，表示该物品为附件，qq是所属主件的编号） 输出格式： 一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大（&lt;200000&lt;200000）。 输入输出样例输入样例#1： 1000 5800 2 0400 5 1300 5 1400 3 0500 2 0 输出样例#1： 2200 解析：因为这道题每个主件可以有0， 1， 2个附件，因此有两种解决方案： 方案一：我们把有从属关系的一个或多个物品当作一类物品，若只有主件，那么共有2种组合方案（0，主件）。若有一个附件，那么有4种组合方案（0，主件，附件，主见附件），若有两个附件，那么有8种组合方案。我们只要把全部组合方案的价格，重要程度列出来，然后用分组背包的思维就可以做了。 方案二：因为附件数少，因此我们可以用求全部方案数将其转化为分组背包。若附件多怎么办呢？这时，我们可以设置dp[i][j]代表第i类商品总价不超过j元的最大价值（有所属关系的归位一种），然后每次copydp[i-1]数组，并对主件商品强制购买，附件商品进行01背包。最后和原dp[i - 1]数组每位比较取较大值，即为dp[i]数组，最后dp[商品种类][最大钱数]即为答案 代码如下： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;string.h&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;zcy[65];map&lt;int, int&gt;maps;int v[65], w[65];int dp[32050] = &#123;0&#125;, temp[32050] = &#123;0&#125;;int main () &#123; int V, m, tot = 0, father; scanf(&quot;%d%d&quot;, &amp;V, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;w[i], &amp;father); if (father == 0) &#123; tot++; maps[i] = tot; zcy[tot].push_back(i); &#125; else &#123; zcy[maps[father]].push_back(i); &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; memcpy(temp, dp, sizeof(int) * (V + 5)); int vv = v[zcy[i][0]]; int ww = w[zcy[i][0]] * vv; for (int j = V; j &gt;= vv; j--) &#123; temp[j] = temp[j - vv] + ww; &#125; for (int j = 1; j &lt; zcy[i].size(); j++) &#123; int vvv = v[zcy[i][j]]; int www = w[zcy[i][j]] * vvv; for (int p = V; p &gt;= vv + vvv; p--) &#123; temp[p] = max(temp[p - vvv] + www, temp[p]); &#125; &#125; for (int j = 0; j &lt;= V; j++) &#123; dp[j] = max(dp[j], temp[j]); &#125; &#125; printf(&quot;%d\n&quot;, dp[V]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>特殊背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1858多人背包]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B71858%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[题目描述求01背包前k优解的价值和 输入输出格式输入格式： 第一行三个数K、V、N 接下来每行两个数，表示体积和价值 输出格式： 前k优解的价值和 输入输出样例输入样例#1： 2 10 53 127 202 45 61 1 输出样例#1： 57 说明对于100%的数据,K≤50,V≤5000,N≤200 思路： ​ 这道题本身不算特别难，设置一个二维数组dp[i][j]代表背包容量为i的时候第j优解的价值。V的范围是5000，N的范围是200，如果按照01背包求最优解的话时间复杂度为1e6 ​ 可是由于是求第k优，k的范围为1～50，因此我们得在1e6的循环中，用O(k)的复杂度求出前k优，这时候，我们就需要用到归并排序取前50大 ​ 这道题太毒瘤了，条件里也没交代说必须正好装满V。。。结果最后答案必须是正好装满V的答案。。。 ​ 答案见代码： 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int dp[5005][55] = &#123;0&#125;;int main () &#123; int K, V, N, v, w; scanf(&quot;%d%d%d&quot;, &amp;K, &amp;V, &amp;N); dp[0][0] = 1; //正好装满初始化dp[0][0] = 1, 若是类似01背包可以不必装满的话，就是初始化dp[i][0] = 1 (0 &lt;= i &lt;= V) for (int i = 1; i &lt;= N; i++) &#123; scanf(&quot;%d%d&quot;, &amp;v, &amp;w); for (int j = V; j &gt;= v; j--) &#123; int p1 = 1, p2 = 1; int c[55] = &#123;0&#125;; while(p1 &lt;= dp[j][0] || p2 &lt;= dp[j - v][0]) &#123; if (p2 &gt; dp[j - v][0] || (p2 &lt;= dp[j - v][0] &amp;&amp; p1 &lt;= dp[j][0] &amp;&amp; dp[j][p1] &gt;= dp[j - v][p2] + w)) &#123; c[++c[0]] = dp[j][p1]; p1++; &#125; else &#123; c[++c[0]] = dp[j - v][p2] + w; p2++; &#125; if (c[0] &gt;= K) break; &#125; for (int ppp = 0; ppp &lt;= c[0]; ppp++) &#123; dp[j][ppp] = c[ppp]; &#125; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= K; i++) ans += dp[V][i]; printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>背包第k优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1541乌龟棋]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B71541%E4%B9%8C%E9%BE%9F%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[题目背景小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 题目描述乌龟棋的棋盘是一行NN个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第NN格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中MM张爬行卡片，分成4种不同的类型（MM张卡片中不一定包含所有44种类型的卡片，见样例），每种类型的卡片上分别标有1,2,3,41,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入输出格式输入格式： 每行中两个数之间用一个空格隔开。 第11行22个正整数N,MN,M，分别表示棋盘格子数和爬行卡片数。 第22行NN个非负整数，a1,a2,…,aNa1,a2,…,a**N，其中aia**i表示棋盘第ii个格子上的分数。 第33行MM个整数，b1,b2,…,bMb1,b2,…,b**M，表示M张爬行卡片上的数字。 输入数据保证到达终点时刚好用光MM张爬行卡片。 输出格式： 11个整数，表示小明最多能得到的分数。 输入输出样例输入样例#1： 9 56 10 14 2 8 8 18 5 171 3 1 2 1 输出样例#1： 73 思路： ​ 刚开始我是设的dp[i][j][p][q][k]代表第一种卡片i个，第二种卡片j个，第三种卡片p个，第四种卡片q个，走到第k个格子的最大得分。后来发现，我既然得到ijpq了，肯定k是固定的。。。然后就灰溜溜的缩减为了四维dp ​ 我们设了dp[i][j][p][q]后，由于题目上说正好把M张卡片用完，因此我们只需要用一个数组c存每种卡片的张数，那么dp[c[1]][c[2]][c[3]][c[4]]极为答案 ​ 这个题有个坑点，就是起始位置是1而不是0，自己在这里傻逼了好久～ ​ 废话不说，上代码 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int a[355];int c[5] = &#123;0&#125;;int dp[125][125][125][125] = &#123;0&#125;;int main () &#123; int n, m, b; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d&quot;, &amp;b); c[b]++; &#125; dp[0][0][0][0] = a[1]; for (int i = 0; i &lt;= c[1]; i++) &#123; for (int j = 0; j &lt;= c[2]; j++) &#123; for (int p = 0; p &lt;= c[3]; p++) &#123; for (int q = 0; q &lt;= c[4]; q++) &#123; if (i != 0) dp[i][j][p][q] = max(dp[i - 1][j][p][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]); if (j != 0) dp[i][j][p][q] = max(dp[i][j - 1][p][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]); if (p != 0) dp[i][j][p][q] = max(dp[i][j][p - 1][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]); if (q != 0) dp[i][j][p][q] = max(dp[i][j][p][q - 1] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]); &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[c[1]][c[2]][c[3]][c[4]]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1158导弹拦截]]></title>
    <url>%2F2019%2F01%2F25%2F%E6%B4%9B%E8%B0%B7P1158%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[题目描述经过 11年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 0时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。 某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。 输入输出格式输入格式： 第一行包含 4个整数x1、y1、x2、y2，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为(x1,y1)、(x2,y2)。 第二行包含1个整数N，表示有 N颗导弹。接下来N行，每行两个整数 x,y，中间用 一个空格隔开，表示一颗导弹的坐标(x,y)。不同导弹的坐标可能相同。 输出格式： 一个整数，即当天的最小使用代价。 输入输出样例输入样例#1： 0 0 10 02-3 310 0 输出样例#1： 18 输入样例#2： 0 0 6 05-4 -2-2 34 06 -29 1 输出样例#2： 30 【数据范围】 对于10%的数据，N=1 对于20%的数据，1≤N≤2 对于40%的数据，1≤N≤100 对于70%的数据，1≤N≤1000 对于100%的数据，1≤N≤100000，且所有坐标分量的绝对值都不超过1000。 题解： ​ 这道题百分之百的数据范围N为1e5，那么说明题目所需的复杂度最大为NlogN，我们可以把所有导弹对第一个拦截系统的距离进行由大到小排序（复杂度为NlogN） ​ 由于已经是按照对第一个拦截系统的距离进行由大到小排序了，我们假设从[i, n]的导弹由第一个拦截，那么第一个拦截系统的最小半径为第i个对于第一个拦截系统 的距离，那么剩下的[1, i - 1]由第二个拦截系统拦截，我们可以在遍历的时候记录一下前i个对于第二个拦截系统的距离的最大值，这样我们只需要求flag + daodan[i].d1的最小值即为正确答案 代码： /************************************************************************* &gt; File Name: p.cpp &gt; Author: Zcy &gt; Mail: 296763002@qq.com &gt; Created Time: 三 1/23 18:16:17 2019 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int x, y; int j1, j2; void set(int x1, int y1, int x2, int y2) &#123; j1 = (x - x1) * (x - x1) + (y - y1) * (y - y1); j2 = (x - x2) * (x - x2) + (y - y2) * (y - y2); &#125;&#125;point[100005];bool zcy(node A, node B) &#123; return A.j1 &gt; B.j1;&#125;int main () &#123; int x1, y1, x2, y2, n; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;point[i].x, &amp;point[i].y); point[i].set(x1, y1, x2, y2); &#125; sort(point, point + n, zcy); int ans = 0x3f3f3f3f; int k = 0; for (int i = 0; i &lt; n; i++) &#123; ans = min(ans, point[i].j1 + k); k = max(point[i].j2, k); &#125; ans = min(ans, k); printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1028数的计算]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%B4%9B%E8%B0%B71028%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目描述我们要求找出具有下列性质数的个数(包含输入的自然数nn): 先输入一个自然数nn(n≤1000n≤1000),然后对此自然数按照如下方法进行处理: 不作任何处理; 在它的左边加上一个自然数,但该自然数不能超过原数的一半; 加上数后,继续按此规则进行处理,直到不能再加自然数为止. 输入输出格式输入格式： 11个自然数nn(n≤1000n≤1000) 输出格式： 11个整数，表示具有该性质数的个数。 输入输出样例输入样例#1： 6 输出样例#1： 6 说明满足条件的数为6，16，26，126，36，136 思路： ​ 做这个题主要是想用优化的思想来做，这道题我们可以用三层for，两层for，一层for来AC。我把我想到的这三种都说一下，主要是给大家提供更多的思路，毕竟解题的道路是灵活的～ 三层 for： ​ 我们可以设dp[i][j]代表从左边数第i个整数为j的方案数，那么我们就可以得到： 初始化dp[1][j] = 1; (1 &lt;= j &lt;= n)for (int i = 1; quick(2, i) &lt;= n; i++) &#123; //quick(2, i)为2^i int j = quick(2, i); for (; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= j / 2; k++) &#123; dp[i + 1][j] += dp[i][k]; &#125; &#125;&#125;这样全部满足条件的dp[i][n]的和即为答案 两层for： ​ 我们可以设dp[i]代表最右边为数字i有多少种方案，则: dp[1] = 1;for (int i = 2; i &lt;= n; i++) &#123; dp[i] = 1; for (int j = 1; j &lt;= i / 2; j++) &#123; dp[i] += dp[j]; &#125;&#125;//dp[n]即为答案 一层for： ​ 和上面一样，我们设置dp[i]代表最右边为数字i有多少种方案，并用变量sum来记录和，则： dp[1] = 1;sum = 0;for (int i = 2; i &lt;= n; i++) &#123; dp[i] = 1; if (!(i &amp; 1)) s += dp[i / 2]; dp[i] += s;&#125;//dp[n]即为答案 ​ 大概就是这样，Over]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++简易实现Linux命令-待完善]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Linux%E5%91%BD%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[​ 两天前老师布置了一个作业，让用C++简易实现linux的ls（包括ls -l，ls -a等）和cd命令，感觉效果不错，挂到了Github上，有时间再继续完善完善其它功能吧～ ​ Github地址：跳转 ​ 当然也可以通过主页 -&gt; 项目进行查看：跳转]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简单用法(一)]]></title>
    <url>%2F2019%2F01%2F21%2FGit%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[[TOC] Git1.安装Git​ 输入下面命令查看git是否已经安装 $ git --version ​ 若没有安装，则输入下面命令 $ sudo apt-get install git -y#如果是Mac用户，则：$ brew install git#brew和apt-get都可以看作软件管理工具，Liunx下用apt-get，Mac下用brew，若没有它就先下它 2.配置用户名与邮箱##若想设置为全局生效，就添加--global参数$ git config --global user.name &quot;用户名&quot;$ git config --global user.email &quot;邮箱名&quot; 3.基本流程 初始化新的仓库或远程Clone仓库 创建或修改文件 使用git add命令将修改后的文件添加到本地缓存（索引库） 使用git commit命令提交改动到本地代码库 使用git push命令推送到远程仓库 4.基本使用4.1克隆远程仓库到本地或者在本地初始化仓库4.1.1克隆远程仓库到本地(前提条件是本地已与远程仓库SSH关联)​ 在自己远程仓库中（比如自己的Github仓库）点击clone or download，选择Use SSH，然后复制链接。 ​ 然后在本地中输入命令： $ cd 存储的路径$ git clone 之前复制的链接 4.1.2克隆远程仓库到未关联SSH的主机​ 在远程仓库中点击clone or download，选择Use HTTPS，然后复制链接。 ​ 然后在本地中输入命令： $ cd 存储的路径$ git clone 之前复制的链接 4.1.3本地初始化新仓库​ 创建代码目录并初始化， 通过git init命令进行初始化 $ cd 想要放置的位置$ mkdir project$ cd project$ git init ​ 对于三者的区别，前两者已经同远程仓库建立连接，第一个从本地向远程仓库push更新的时候不用账号密码，第二个需账号密码。而第三个没有同远程仓库建立连接 4.2查看4.2.1本地git仓库状态​ 利用git status命令查看当前本地仓库的状态信息 4.2.2比较改动前后文件的区别​ 利用git status只能查看本地仓库的状态信息，比如某个文件以被改动，新增或者删除了某个文件等等。但如果想获取修改了某个文件的具体内容，需要通过git diff命令来查看 git diff //会显示当前你所有已做的但没有加入到索引里的修改git diff --cached //显示缓存区中哪些文件被修改了 ​ 4.3添加文件到索引库以下操作都需要在克隆到本地的仓库目录下进行： 4.3.1添加/修改​ 把一个文件添加或更新内容到本地索引，可以使用git add命令 ​ 例如创建一个新的txt文件，并往文件内写入“hello world”，并用git add命令添加到本地索引库中： $ echo &quot;hello world&quot; &gt; newfile.txt$ git add newfile.txt ​ 可利用$ git add *命令将全部修改过的文件自动添加 4.3.2删除​ 把仓库里的文件删掉，可以使用git rm命令 ​ 例如删除新创建的newfile.txt文件 $ git rm newfile.txt ​ 对于删除文件，需要git commit一下，版本库中文件才可以完全被删除 4.3.3撤销​ 把仓库里的改动撤销回到刚克隆下来的状态，可以使用git reset命令 #git reset命令有三种方式$ git reset -mixed #git reset默认方式，退回到某个版本，只保留源码，回退commit和index信息$ git reset -soft #回退到某个版本，只回退commit信息。如果还要提交，直接commit即可$ git reset -hard #彻底退回某个版本，本地的源码也会变为上一个版本的内容#用法为：#回退所有内容到上一个版本 $ git reset HEAD^#回退newfile.txt这个文件的版本到上一个版本 $ git reset HEAD^ a.py#向前回退所有内容到第3个版本 $ git reset HEAD~3#回退到某个版本 git reset 版本名 4.4提交仓库的改动​ 仓库的每次改动操作后，推送同步到远程仓库前，都需要对这一次或这一批次的操作做提交，命令为git commit，只有完成提交，才可以推送改动到远程仓库 ​ 例如提交本次改动： git commit -m &quot;我的注释&quot; ​ 如果加上-a，则无需add便可以直接 commit所有的更新 git commit -a -m &quot;我的注释&quot; 4.5推送到远程仓库​ 提交仓库改动后就可以开始推送改动的内容到远程仓库了，命令为git push，用法是git push -u origin 分支名，其中分支名默认为master。第一次推送可以使用-u参数（会绑定此时的仓库分支名，这样下次推送就无需加分支名了） $ git push -u origin master 4.6当远程仓库被修改，如何同步到本地4.6.1查看仓库改动通过git fetch命令查看有哪些新改动，用法为： $ git fetch origin 4.6.2同步到本地通过git pull命令实现同步到本地，具体用法是git pull origin 分支名，分支名默认为master git pull origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现SSH免密登陆]]></title>
    <url>%2F2019%2F01%2F21%2F%E5%AE%9E%E7%8E%B0ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[####SSH是什么？ ​ SSH是建立在应用层基础上的安全协议，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。 ​ 当数据到达目的地时，SSH自动对加密数据进行解密。整个过程都是透明的，使用OpenSSH工具将会增进系统的安全性 ​ 除此之外，SSH传输的数据是经过压缩的，所以可以加快传输的速度。SSH还有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的通道。 ####SSH连接的原理 ​ 假设A主机想要连接到B主机： A主机向B主机发送连接请求 B主机向A主机发送公钥 A主机用公钥将密码信息加密并发送给B B主机用私钥解密并验证密码信息，信息合法就建立连接 免密登录的原理​ 由于上面的方式A主机必须得输入密码信息发送进行验证，也就是说我们每次进行连接都得需要输入密码，超级麻烦～ ​ 因此，我们就可以通过免密登录来实现无密码进行链接。 ​ 至于实现的原理是什么？假设A主机想要免密连接到B主机： 在A主机上生成公钥私钥 将A中的公钥拷贝给到B主机中的authorized_keys（也就相当于把A加入到B的白名单中） A向B发送连接请求 B得到请求后，在authorized_key中查找是否有对应用户名和IP。如果有则随机生成一个字符串并用A的公钥进行加密并发送给A A得到B发来的消息后用私钥进行解密，然后将解密后的字符串发送回B。B进行对比，若一致则允许免密登录 ####如何实现免密登录 步骤一：​ A主机若已经生成了公钥私钥，则跳过此步（因此一个主机在同一时间下只能拥有一对公钥私钥，再次随机生成会覆盖掉之前的公钥私钥，但不建议这么做，因为可能在其它主机上存储了A主机之前的公钥，如果A主机再次生成公钥私钥的话会导致之前做过免密登录的主机失效） ​ 若无公钥私钥，则A主机通过$ ssh-keygen -t rsa -P 就可以在家目录下的.ssh文件夹中生成id_rsa(私钥)和id_rsa.pub(公钥)两个文件 步骤二：​ 把A中的id_rsa.pub(也就是公钥)中的内容追加到B主机中家目录下的.ssh/authorized_keys中（若B主机没有该路径和文件则先创建），这样就实现了加入白名单 ​ 这样，已有A向B发起连接就可以无需输入密码了～]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啥是佩奇源码]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%95%A5%E6%98%AF%E4%BD%A9%E5%A5%87%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[​ 感谢GIthub上提供的源码，地址：跳转 ​ 大家熟悉了Python内置的turtle后可以随意DIY，超棒的Python内置绘制图形库！！ 源码： from turtle import*def nose(x,y):#鼻子 pu() goto(x,y) pd() seth(-30) begin_fill() a=0.4 for i in range(120): if 0&lt;=i&lt;30 or 60&lt;=i&lt;90: a=a+0.08 lt(3) #向左转3度 fd(a) #向前走a的步长 else: a=a-0.08 lt(3) fd(a) end_fill() pu() seth(90) fd(25) seth(0) fd(10) pd() pencolor(255,155,192) seth(10) begin_fill() circle(5) color(160,82,45) end_fill() pu() seth(0) fd(20) pd() pencolor(255,155,192) seth(10) begin_fill() circle(5) color(160,82,45) end_fill()def head(x,y):#头 color((255,155,192),&quot;pink&quot;) pu() goto(x,y) seth(0) pd() begin_fill() seth(180) circle(300,-30) circle(100,-60) circle(80,-100) circle(150,-20) circle(60,-95) seth(161) circle(-300,15) pu() goto(-100,100) pd() seth(-30) a=0.4 for i in range(60): if 0&lt;=i&lt;30 or 60&lt;=i&lt;90: a=a+0.08 lt(3) #向左转3度 fd(a) #向前走a的步长 else: a=a-0.08 lt(3) fd(a) end_fill()def ears(x,y): #耳朵 color((255,155,192),&quot;pink&quot;) pu() goto(x,y) pd() begin_fill() seth(100) circle(-50,50) circle(-10,120) circle(-50,54) end_fill() pu() seth(90) fd(-12) seth(0) fd(30) pd() begin_fill() seth(100) circle(-50,50) circle(-10,120) circle(-50,56) end_fill()def eyes(x,y):#眼睛 color((255,155,192),&quot;white&quot;) pu() seth(90) fd(-20) seth(0) fd(-95) pd() begin_fill() circle(15) end_fill() color(&quot;black&quot;) pu() seth(90) fd(12) seth(0) fd(-3) pd() begin_fill() circle(3) end_fill() color((255,155,192),&quot;white&quot;) pu() seth(90) fd(-25) seth(0) fd(40) pd() begin_fill() circle(15) end_fill() color(&quot;black&quot;) pu() seth(90) fd(12) seth(0) fd(-3) pd() begin_fill() circle(3) end_fill()def cheek(x,y):#腮 color((255,155,192)) pu() goto(x,y) pd() seth(0) begin_fill() circle(30) end_fill()def mouth(x,y): #嘴 color(239,69,19) pu() goto(x,y) pd() seth(-80) circle(30,40) circle(40,80)def body(x,y):#身体 color(&quot;red&quot;,(255,99,71)) pu() goto(x,y) pd() begin_fill() seth(-130) circle(100,10) circle(300,30) seth(0) fd(230) seth(90) circle(300,30) circle(100,3) color((255,155,192),(255,100,100)) seth(-135) circle(-80,63) circle(-150,24) end_fill()def hands(x,y):#手 color((255,155,192)) pu() goto(x,y) pd() seth(-160) circle(300,15) pu() seth(90) fd(15) seth(0) fd(0) pd() seth(-10) circle(-20,90) pu() seth(90) fd(30) seth(0) fd(237) pd() seth(-20) circle(-300,15) pu() seth(90) fd(20) seth(0) fd(0) pd() seth(-170) circle(20,90)def foot(x,y):#脚 pensize(10) color((240,128,128)) pu() goto(x,y) pd() seth(-90) fd(40) seth(-180) color(&quot;black&quot;) pensize(15) fd(20) pensize(10) color((240,128,128)) pu() seth(90) fd(40) seth(0) fd(90) pd() seth(-90) fd(40) seth(-180) color(&quot;black&quot;) pensize(15) fd(20)def tail(x,y):#尾巴 pensize(4) color((255,155,192)) pu() goto(x,y) pd() seth(0) circle(70,20) circle(10,330) circle(70,30)def zcy(x, y): pu() goto(x, y) pendown() setheading(0) forward(20) right(135) forward(80) left(135) forward(55) pu() goto(x + 65, y - 22) pendown() seth(120) a = 0.5 for i in range(40): a = a + 0.07 if i &gt;= 37: lt(20) elif i &gt;= 30: lt(7) else: lt(6) fd(a) pu() goto(x + 90, y - 22) pendown() seth(-65) forward(38) pu() goto(x + 130, y - 22) pendown() seth(235) forward(100)def setting(): #参数设置 pensize(4) hideturtle() colormode(255) color((255,155,192),&quot;pink&quot;) setup(840,500) speed(0)def main(): setting() #画布、画笔设置 nose(-100,100) #鼻子 head(-69,167) #头 ears(0,160) #耳朵 eyes(0,140) #眼睛 cheek(80,10) #腮 mouth(-20,30) #嘴 body(-32,-8) #身体 hands(-56,-45) #手 foot(2,-177) #脚 tail(148,-155) #尾巴 #zcy(206, -148) #牵着尾巴的署名 done() #结束main()]]></content>
      <tags>
        <tag>收藏</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-6]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-6%2F</url>
    <content type="text"><![CDATA[例五：矩形问题 ​ 在一个n✖️m的黑白相间的矩形中，问有多少个全白色的子矩形（0代表黑色，1代表白） ​ 最暴力的方法就是挨个子矩形都去判断，这样的时间复杂度为O(n^2✖️m^2)，在这里就不说了。 ​ 我们可以优化，设dp[i][j]代表以(i, j)为右下角的子矩形的个数，再通过l[i][j]数组记录第i行j列向上有多少个连续的白矩形。这样就可以把题目优化到O(n✖️m^2)，伪代码如下： for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; minn = l[i][j]; for (int k = j; k &gt;= 1; k--) &#123; minn = min(minn, l[i][k]); if (!minn) break; ans += minn; &#125; &#125;&#125; ​ 但是如果n和m的取值范围都是1e3怎么办？这时，我们就可以通过转移优化中的单调栈优化来进一步进行优化 ​ 我们创建一个单调栈数组sta[i]代表第i行的单调栈。保持单调栈递增，那么就可以将题目优化到O(n✖️m)了，详情请看代码： #include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;stack&gt;#define ll long longusing namespace std;inline int read() &#123; int num=0; char ch=0; while (!isdigit(ch)) &#123; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48); ch = getchar(); &#125; return num;&#125;struct node &#123; int inx, val, sum; node(int x, int y, int z) &#123; inx = x; val = y; sum = z; &#125;&#125;;stack&lt;node&gt;que[1005];int l[1005][1005] = &#123;0&#125;;int main () &#123; int n, m, a; ll ans = 0; n = read(); m = read(); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; a = read(); if (a) &#123; l[i][j] = l[i - 1][j] + 1; &#125; while (!que[i].empty()) &#123; if (que[i].top().val &gt;= l[i][j]) &#123; que[i].pop(); &#125; else &#123; break; &#125; &#125; node sta(j, l[i][j], 0); if (que[i].empty()) &#123; sta.sum = j * l[i][j]; &#125; else &#123; sta.sum = que[i].top().sum + (j - que[i].top().inx) * l[i][j]; &#125; que[i].push(sta); ans += sta.sum; if (ans &gt;= 100007) &#123; ans %= 100007; &#125; &#125; &#125; printf(&quot;%lld\n&quot;, ans); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-5]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-5%2F</url>
    <content type="text"><![CDATA[例四：扔鸡蛋问题 ​ 定义鸡蛋的硬度为 k，则代表鸡蛋最高从 k 楼扔下来不会碎掉，现在给你 n 个硬度相同的鸡蛋，楼高为 m，问最坏情况下最少测多少次，可以测出鸡蛋的硬度。 ​ 我们假设有2个鸡蛋，100层楼。那么我们应该如何扔在最坏情况下测的次数最少呢？ 1.二分法：刚开始我傻傻的以为是二分法，第一个鸡蛋在第50层扔，但是如果一个鸡蛋在第50层碎了，那么第二个鸡蛋只能从第1层扔直到第49层，才能测出鸡蛋的硬度（在最坏情况为49层时），这样最坏情况下需要测50次 2.平方根法：我们继续优化，我们每10层测一次，第10层若碎了，第二个鸡蛋就从1层测到9层。若没碎继续测第20层…以此类推，最坏情况是第99层时，这时我们需要测10 + 9 = 19次 3.假设法：方法二一定是最优解吗？我们可以假设一下，设2个鸡蛋100层楼在最坏情况下最多测x次，那么第一个鸡蛋应该放在第x层最合适（如果第一个鸡蛋放在是x + i层，如果碎了最坏情况下最多测x + i次，比x次多；如果第一个鸡蛋放在x - i层，如果没碎的话，由于x - i比x小，所以它剩余测的次数一定 &gt;= x） ​ 因此，我们第一次放在x层（碎了话最多测x次，没碎的话第二次放在2 x - 1层，碎的话最多测x次，没碎的话第三次放在3 x - 3层，碎的话最多测x次，没碎的话第四次放在4 * x - 6层…依次类推），我们只要保证x + (x - 1) + (x - 2) … + 1 &gt;= 100即可，这样解出最优答案为14 ​ 好了，以上是推理，我们可以用dp的方法来求出正确的答案。我们可以假设dp[i][j]代表i个鸡蛋j层楼最少测多少次。这样我们可以得到： 初始化：dp[1][j] = k (1 &lt;= j &lt;= m) //一个鸡蛋j层楼最坏情况下最少需要测j次dp[i][1] = 1 (1 &lt;= i &lt;= n) //i个鸡蛋1层楼最坏情况下最少需要测1次这样我们可以得到dp转移式：dp[i][m] = min(max(dp[i - 1][j - 1], dp[i][m - j])) (1 &lt;= j &lt;= m) ​ 那么，当n范围为1e2，m范围为1e9的时候，我们怎么办呢？ ​ 数组肯定开不下那么大，而且上面算法的时间复杂度为O(n(m^2))，会直接爆掉的。这时我们就可以进行重新定义状态信息来优化算法。 ​ 我们可以假设dp[i][j]代表i个鸡蛋测j次最多能测多少层楼。这样我们可以得到： //初始化：dp[1][j] = j //一个鸡蛋测j次最多可以测j层楼dp[i][1] = 1 //i个鸡蛋测1次最多可以测1层楼我们假设第i个鸡蛋测k次最多测n层楼，那么在测n层楼的情况下，第一次需要测的位置应该是i-1个鸡蛋测k - 1次最多测的层数+1(只有满足这个条件，在第m层碎了测的次数最坏情况才为k)若在第m层没碎，那么往上最多能测的层数应该是i个鸡蛋测k - 1次最多的层数因此，dp[i][k] = dp[i - 1][k - 1] + dp[i][k - 1] + 1我们只要找第一个dp[n][j]大于m的j即是正确答案 ​ 最后上AC代码： #include &lt;stdio.h&gt;#define ll long longll dp[35][100005] = &#123;0&#125;;int main () &#123; ll n, m; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); if (n == 1) &#123; printf(&quot;%lld\n&quot;, m); &#125; else &#123; for (int i = 1; i &lt;= 100000; i++) &#123; dp[1][i] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; dp[i][1] = 1; &#125; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= 100000; j++) &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] + 1; &#125; &#125; for (int j = 1; j &lt;= 100000; j++) &#123; if (dp[n][j] &gt;= m) &#123; printf(&quot;%d\n&quot;, j); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-4]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-4%2F</url>
    <content type="text"><![CDATA[例三：多重背包 ​ 多重背包问题我们经常能碰到，就是给出n种物品，每种物品有a[i]个，占用空间为v[i]，价值为w[i]，背包容量为K，问背包所能装下的物品的最大价值 方法一： ​ 我们一般的求法就是开一个dp[k]数组代表空间容量为i时的最大价值。然后遍历每种物品的每件，通过递推公式： dp[k] = max(dp[k], dp[k - v[i]] + w[i]); ​ 这时时间复杂度为O(n * m * K)(其中n为种类数，m为每种物品的数量，K为背包容量) ​ 但是，当m特别大时，我们应该怎么办呢？ 方法二： ​ 我们会发现，每种的物品，它们的v[i]和w[i]是相同的。假如某种物品有15种，我们上面那种方法的做法，由于是遍历该种的每一件物品，因此也就是将{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}任意组合。我们会发现组合会有很多重复，因此我们可以这样进行优化： ​ 对于集合{1, 2, 4, 8}，我们也可以通过这四个数组合成1～15个的任意一个。这样我们只需要求每种物品的n件物品优化成logn种物品，这样时间复杂度就可以优化为O(n * log(m) * K) ​ 注意点！！！！如果一种物品有n件，所选的集合必须只能组成[1, n]，比如13:{1, 2, 4, 6} ​ 这种方法的代码如下： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int dp[10005] = &#123;0&#125;;int main () &#123; int n, K, v, w, num; scanf(&quot;%d%d&quot;, &amp;K, &amp;n); //K代表背包容量，n代表物品种类数 for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;num); //v,w,num分别代表每种物品的体积，价值，数量 int val = 1; //val为集合所有元素的和，初始化为1 int j = 1; //j为集合为集合中的元素，初始化为1 while (val &lt;= num) &#123; int vv = v * j; //此时把j个该种物品看作一个物品进行dp，也就是01背包 int ww = w * j; for (int p = K; p &gt;= vv; p--) &#123; dp[p] = max(dp[p], dp[p - vv] + ww); &#125; j = val + 1; val += j; &#125; val -= j; //该操作保证所求集合确保正好组成[1, num] j = num - val; if (j &gt; 0) &#123; int vv = v * j; int ww = w * j; for (int p = K; p &gt;= vv; p--) &#123; dp[p] = max(dp[p], dp[p - vv] + ww); &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[K]); return 0;&#125; ​ 方法二时间复杂度为O(n * logm * K)，还不可以继续优化呢？答案是可以的，我们可以利用单调队列对多重背包问题进行优化到O(n * K)。大家可以先自己考虑一下如何去做再往下看 方法三： ​ 方法三看了好多好的题解才搞懂。。只能说自己太笨了Orz～以下是我的理解，希望能对大家有些帮助 ​ 我们单拿出一种物品来看，比如体积为5，价值为6，数量为3，再假如K为22。那么我们单拿出全部%5 == 2的容量来看： dp[2] = dp[2];dp[7] = max(dp[2], dp[7] - 6) + 6;dp[12] = max(dp[2], dp[7] - 6, dp[12] - 12) + 12;dp[17] = max(dp[2], dp[7] - 6, dp[12] - 12, dp[17] - 18) + 18;dp[22] = max(dp[7] - 6, dp[12] - 12, dp[17] - 18, dp[22] - 24) + 24;//这一步没看懂的同学看这里！！比如dp[22] = max(dp[7] - 6, dp[12] - 12, dp[17] - 18, dp[22] - 24) + 24中，dp[7] - 6若是最大值，dp[7] - 6 + 24等价于dp[22] = dp[7] + 18，也就是用3个该种物品dp[12] - 12若是最大值，dp[12] - 12 + 24等价于dp[22] = dp[12] + 12，也就是用2个该种商品dp[17] - 18若是最大值，dp[17] - 18 + 24等价于dp[22] = dp[17] + 6，也就是用1个该种商品dp[22] - 24若是最大值，dp[22] - 24 + 24等价于dp[22] = dp[22]，也就是不用该种商品 ​ 至于最多选用几个的数量s，它等于s = min(s, K / v)。这样，我们就可以将题目转化为下面的代码形式（伪代码）： for (循环遍历每种商品) &#123; for (循环遍历全部余数d[0, v)) &#123; for (循环遍历K以内全部余数为d的容量k*v+d) &#123; for (循环遍历s个上一种物品的状态并更新最大值) &#123; &#125; &#125; &#125;&#125; 我们从伪代码可以看出时间复杂度为O(n * K * s) （第二层和第三层for相乘为K），和上一种方法复杂度差不多甚至在某些情况下还要更高。我们可以用单调队列维护最大值且区间差值小于等于s来优化该算法，此时复杂度为O(n * K) ​ 比如说： 将dp[2] - 0 * 6加入单调队列并维护最大值，然后用队列最大值 + 0 * 6即为新的dp[2]将dp[7] - 1 * 6加入单调队列并维护最大值，然后用队列最大值 + 1 * 6即为新的dp[7]将dp[12] - 2 * 6加入单调队列并维护最大值，然后用队列最大值 + 2 * 6即为新的dp[12]将dp[17] - 3 * 6加入单调队列并维护最大值，然后用队列最大值 + 3 * 6即为新的dp[17]将dp[22] - 4 * 6加入单调队列并维护最大值，然后用队列最大值 + 4 * 6即为新的dp[22]//注意单调队列的维护需要注意的两点(1.若q[tail] &lt;= val则循环tail--直到满足条件为止 2.若q[tail]与q[head]相差数量大于s则循环head++直到满足条件为止) ​ 下面给出这道题单调队列优化的代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;//dp[i]存储当前状态下容量为i的最大价值//q[i]用于模拟优先队列//inv[i]用于存储优先队列中位置为i的使用该种商品的物品数int dp[10005] = &#123;0&#125;, inv[10005] = &#123;0&#125;, q[10005] = &#123;0&#125;;int main () &#123; int K, n, v, w, s; scanf(&quot;%d%d&quot;, &amp;K, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s); s = min(K / v, s); //代表能用的该种物品的最大数量 for (int mod = 0; mod &lt; v; mod++) &#123; int head = 1, tail = 1; //相当于清空队列 for (int j = 0; j &lt;= (K - mod) / v; j++) &#123; int val = dp[j * v + mod] - j * w; while (head &lt; tail &amp;&amp; q[tail - 1] &lt;= val) &#123; tail--; //该操作保证队列单调 &#125; q[tail] = val; inv[tail++] = j; while (head &lt; tail &amp;&amp; j - inv[head] &gt; s) &#123; head++; //该操作用于维护数量上限 &#125; //此时队列的头（即最大值）就是我们需要使用该种商品的数量 dp[j * v + mod] = max(q[head] + j * w, dp[j * v + mod]); &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[K]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-3]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-3%2F</url>
    <content type="text"><![CDATA[例2:切割回文串 ​ 给出一个字符串s，对字符串最少切几刀，可以使得切完后的每一段字符串都是回文串（单一字符也是回文串）？ ​ 这道题我们首先能想到用区间dp来做，设置dp[i][j]代表字符串区间[i, j]最少切多少刀使得每一段字符串都是回文串，这时我们就可以得到递推方程： //当[i, j]是回文数的时候，dp[i][j] = 0;//当[i, j]不是回文数的时候，dp[i][j] = min(dp[i][k] + dp[k + 1][j] + 1) //其中i &lt;= k &lt; j//而对于[i, j]是否为回文数，需要利用bool数组maps[i][j]来记录和预处理 ​ 上面方法的空间复杂度是O(n ^ 2)，时间复杂度是O(n ^ 3)，预处理时间复杂度也为O(n^3)，因此当n为1e5左右时直接爆炸。 ​ 和上一篇文章一样。大家先在这里停住，考虑一下如何将上面的思路，缩减为空间复杂度为O(n)，时间复杂度为O(nlogn)再继续往下看 ​ 对于空间复杂度。我们需要一个数组maps[i][j]用来记录字符串区间[i, j]是否为回文串，对于这个二维数组，我们可以怎么优化呢？对，把它变为一个动态数组maps[i]，用于存储以i结尾的回文串的起始位置。（由于出题人生成的都是随机数据，所以1e5个字符全是相同的那种极限样例根本不可能出现，出现的概率不亚于天天中大乐透～Orz） ​ 这时，maps数组从O(n ^ 2)优化成了O(k)（k为回文串的个数），我们就需要来考虑预处理回文串的时间复杂度优化问题了。由于极限数据根本不可能出现，因此我们可以通过便利中点i，让起点star和终点endd从i向两边扩，若s[star] != s[endd]时即跳出循环，并把全部符合条件的star加入到maps[endd]中，这样预处理的时间复杂度就为O（nlogn） ​ 考虑完预处理，接下来我们开始考虑dp数组的空间优化和状态转移的时间优化～ ​ dp数组上面方法中是二维的，因此我们需要优化成一维数组。用dp[i]来代表前i个字符串最少切的刀数。 ​ 优化成一维数组后，我们紧跟着推出递推方程： dp[i] = dp[j] + 1; //[j + 1, i]必须是回文字符串 ​ 由于数据是随机的，因此满足条件的j不会特别多。由于maps[i]中存了全部满足条件的j，因此dp的时间复杂度大概也为O(nlogn)。 ​ 因此，第二种方法总的空间复杂度为O(nlogn)，时间复杂度为O(nlogn)。这样数据范围就能从1e2提升到1e5了 ​ 以上就是这道题动态规划优化的全部思维，下面附上代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;char s[500005];int dp[500005] = &#123;0&#125;;vector &lt;int&gt; zcy[500005];int main () &#123; scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); for (int i = 1; i &lt;= n; i++) &#123; zcy[i].push_back(i); if (i + 1 &lt;= n &amp;&amp; s[i + 1] == s[i]) zcy[i + 1].push_back(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; int p, q; for (p = i + 1, q = i - 1; p &lt;= n &amp;&amp; q &gt;= 1; p++, q--) &#123; if (s[p] == s[q]) &#123; zcy[p].push_back(q); &#125; else &#123; break; &#125; &#125; if (s[i] == s[i + 1]) &#123; for (p = i + 2, q = i - 1; p &lt;= n &amp;&amp; q &gt;= 1; p++, q--) &#123; if (s[p] == s[q]) &#123; zcy[p].push_back(q); &#125; else &#123; break; &#125; &#125; &#125; &#125; memset(dp, 0x3f, sizeof(dp)); dp[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; int flag = 0; for (int j = 0; j &lt; zcy[i].size(); j++) &#123; if (zcy[i][j] == 1) &#123; flag = 1; break; &#125; &#125; if (flag) &#123; dp[i] = 0; continue; &#125; for (int j = 0; j &lt; zcy[i].size(); j++) &#123; dp[i] = min (dp[i], dp[zcy[i][j] - 1] + 1); &#125; &#125; printf(&quot;%d\n&quot;, dp[n]); return 0;&#125; ​ ​]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-2]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-2%2F</url>
    <content type="text"><![CDATA[例一：墙壁涂色问题： ​ 共有n面墙壁围成一圈，共有k种颜色，相邻墙壁不能涂同一种颜色，问共有多少种涂色方案？ ​ 我们可以想到利用dp[i][j]代表第i面墙涂第j种颜色的方案数，初始化dp[1][1] = 1，利用递推公式dp[i][j] += dp[i - 1][k] (其中k != j)，最后ans += dp[n][k] (其中k != 1)，ans *= k 即为答案 ​ 按照上面的思路，我们发现它需要开二维数组，空间复杂度为O(n * k)，时间复杂度也为O(n * k) ​ 如果题目中n * k的数据范围超过1e7该怎么办呢？ ​ 这时，我们就可以通过重新定义状态以去掉那些冗余项来对其进行优化，大家可以先考虑考虑如何进行优化成时间和空间复杂度均为O(n)再接着往下看～ ​ 这时，我们可以设dp[i]代表第i面墙与第一面墙成环的方案数，初始化dp[1] = 1, dp[2] = k - 1, dp[3] = (k - 2) * dp[2] 。 ​ 我们可以发现，第i面墙与第一面墙成环，那么需要保证第i面墙与第1面颜色不同，也与第i - 1面墙颜色不同。由于dp[i - 1]代表i - 1面墙成环的方案数，因此i - 1面墙与第一面墙颜色不同，所以当第i - 1面墙与第一面墙颜色不同的情况下，dp[i]有dp[i - 1] * (k - 2)种方案。 ​ 除此之外，第i - 1面墙也可以与第一面墙相同。这时假若第i - 1面墙与第一面墙颜色相同，那么前i - 1面墙的方案数为dp[i - 2]，由于第一面和第i - 1面墙颜色相同，因此在该种情况下第i面墙的方案数为dp[i - 2] * (k - 1)。 ​ 这两种情况的总和就是dp[i]的方案总数，即当i &gt; 3时：dp[i] = dp[i - 1] * (k - 2) + dp[i - 2] * (k - 1) ​ 最终dp[n] *= k即为答案 ​ 给出这道题的解题代码（由于数据范围爆longlong因此用大数）： #include &lt;stdio.h&gt;int dp[1005][2005] = &#123;0&#125;;int main () &#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); dp[1][0] = dp[2][0] = dp[3][0] = dp[1][1] = 1; dp[2][1] = k - 1; dp[3][1]= (k - 2) * dp[2][1]; if (dp[3][1] &gt;= 10) &#123; dp[3][0]++; dp[3][2] = dp[3][1] / 10; dp[3][1] %= 10; &#125; for (int i = 4; i &lt;= n; i++) &#123; dp[i][0] = dp[i - 1][0]; for (int j = 1; j &lt;= dp[i][0]; j++) &#123; dp[i][j] = (k - 2) * dp[i - 1][j] + (k - 1) * dp[i - 2][j]; &#125; for (int j = 1; j &lt;= dp[i][0]; j++) &#123; if (dp[i][j] &gt;= 10) &#123; dp[i][j + 1] += dp[i][j] / 10; dp[i][j] %= 10; &#125; &#125; int j = dp[i][0] + 1; while(dp[i][j]) &#123; dp[i][0]++; if (dp[i][j] &gt;= 10) &#123; dp[i][j + 1] = dp[i][j] / 10; dp[i][j] %= 10; &#125; j++; &#125; &#125; for (int i = 1; i &lt;= dp[n][0]; i++) &#123; dp[n][i] *= k; &#125; for (int i = 1; i &lt;= dp[n][0]; i++) &#123; if(dp[n][i] &gt;= 10) &#123; dp[n][i + 1] += dp[n][i] / 10; dp[n][i] %= 10; &#125; &#125; if (dp[n][dp[n][0] + 1]) dp[n][0]++; for (int i = dp[n][0]; i &gt; 0; i--) &#123; printf(&quot;%d&quot;, dp[n][i]); &#125; printf(&quot;\n&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划优化问题-1]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-1%2F</url>
    <content type="text"><![CDATA[​ 动态规划的题目，有时可能你推出了递推式，但是由于时间复杂度过高，或者dp数组过大，而导致TLE或MLE。这时，我们就需要用到动态规划优化 ​ 优化有两种，分别是状态优化和转移优化 ​ 状态优化用于优化空间，有两种方法，一是去除冗余的状态，二是重新定义状态。去除冗余状态最简单的例子比如滚动数组求解，重定义状态最简单的例子就是01背包，dp{i}{j}代表第i个物品在空间大小为j的背包下能装的最大价值，我们可以状态优化为dp{i}代表空间大小为i的背包能装下的最大价值。 ​ 而转移优化是用来优化时间，有以下四类题：一是最长上升子序列O(nlogn)求法，二是单调（队列/栈）优化，三是斜率优化，四是四边形不等式 ​ 这时候我们就可以根据不同的题目要求，选择相应的方式进行求解。 ​ 具体对应例题将在本博客的后续进行详细解答～]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言碎碎念]]></title>
    <url>%2F2019%2F01%2F11%2FC%E8%AF%AD%E8%A8%80%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[对于if判断句，一些情况下可以进行如下简写： if (falg) &#123; printf(&quot;ok\n&quot;);&#125;//可简写成以下格式：flag &amp;&amp; printf(&quot;ok\n&quot;); 结构体的比较与复制： struct node &#123; int a, b;&#125;node temp1[4];node temp2[105][15];//结构体数组比较memcmp(temp1, temp2[0], sizeof(temp1)); //代表temp1从temp[0]开始，temp2从temp2[0][0]开始，比较它们的前sizeof(temp1)个字节//再比如：memcmp(temp1 + 1, temp2[2] + 2, sizeof(node)); //代表temp1[1]和temp2[2][2]进行比较//结构体复制：memcpy(temp1, temp2[0], sizeof(temp1)); //代表将temp2的前sizeof(temp1)个字节复制给temp1 函数数组与函数指针的使用 int f (int n) &#123; return n * (n + 1) / 2;&#125;int g (int n) &#123; return n * n;&#125;//函数数组int (*Func[2])(int) = &#123; f, g&#125;;//函数指针作参int k (int (*t)(int), val) &#123; return t(val);&#125;//函数数组指针作参void k (int (*p[2])(int), int val) &#123; for (int i = 0; i &lt; 2; i ++) &#123; printf(&quot;%d\n&quot;, p[i](val)); &#125;&#125;k (Func, 3); //即可实现调用 函数和数组的关系 函数就相当于一个映射，而数组a[i] = t也相当于一个映射 因此，函数是压缩的数组，数组是展开的函数。 函数比数组更省空间，数组相当于记录式函数]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网--服务器搭建]]></title>
    <url>%2F2019%2F01%2F10%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[​ 平时用个百度查东西总是出来一堆广告，这时候就无比怀念谷歌。 ​ 这里是电脑版搭建服务器实现科学上网的方法，感谢亦泽的教程！！不光电脑版，对于手机安卓，亦泽大佬努力帮助我们科学上网，学习交流请加群972084185 ​ 以下为pdf文件，仅支持电脑浏览]]></content>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件体系风格]]></title>
    <url>%2F2019%2F01%2F10%2F%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[管道/过滤器体系结构风格：构件被称为过滤器，负责对数据进行加工；连接件被称为管道，是输入数据流和输出数据流之间的通路。每个过滤器是一个独立的个体元素，各个过滤器互不相关；每个过滤器独立完成自己的任务，不同过滤器之间不需要交互。数据输出的最终结果与各个过滤器的执行顺序无关。 优点：简单性、支持复用、系统具有可扩展性和可进化性、系统并发性、便于系统分析 缺点：系统处理过程时采用批处理方式；不适合用来设计交互式应用系统；因为没有通用的数据传输标准，导致每个过滤器都要花费时间进行添加和去除因解析输入数据和合成数据产生的标记，降低了系统性能，增加了过滤器设计的复杂性；难以进行错误处理 使用实例：传统的编译器 面向对象体系结构风格：充分体现了软件工程的模块化、信息隐藏、抽象和重用原则。在这种风格中，对象是一种被称为管理器的构件，负责保持资源的完整性。在对象与对象之间，通过函数调用和过程调用来进行交互。对象抽象可以使构件之间通过黑盒方式进行操作。该结构支持信息隐藏。利用封装技术使对象结构和实现方法对外透明，并将属性和方法包装在一起由对象统一管理 优点：对象向外界隐藏自己的详细信息，改变一个对象不影响其他部分； 低耦合高内聚使系统更容易分解既相互作用又相互独立的对象集合 继承和封装方法为对象复用提供了技术支持 缺点：一个对象的标识发生改变，必须修改所有显示调用该对象的程序语句； ​ 会因为一个对象的标识发生改变而产生连锁反应 事件驱动体系结构风格：基本思想是系统对外部的行为表现可以通过它对事件的处理来实现。在这种体系结构中构件不再调用过程，而是声明事件。触发一个事件会引起其他构件的过程调用。 优点：事件声明者不需要知道哪些构件会响应事件；提高了软件复用能力； ​ 便于系统升级 缺点：构件放弃了对计算的控制权，完全由系统决定；存在数据传输问题； 解释器体系结构风格：主要用于构建虚拟机，弥合程序语义和计算机硬件之间的缝隙。适用于系统和用户之间的交互非常复杂的情况。解释器结构包括一个执行引擎和三个储存器。即被解释的程序，执行引擎，被解释程序的当前状态和执行引擎的当前状态四部分组成 优点：能够提高应用程序的移植能力和编程语言的跨平台移植能力。 实际测试工作可能非常复杂，测试代价高，具有风险性 缺点：由于使用了特定语言和自定义操作规则，增加了系统运行的开销 ​ 难以设计和测试 ​ 使用实例：java的编译器；专家系统领域的prolog语言；脚本语言； 客户机/服务器体系结构风格（C/S） 优点：客户机构件和服务器构件分别运行在不同的计算机上，利于分布式数据的组织和处理 构件之间的位置相互透明，不必考虑对方的实际存储位置 客户机侧重数据的显示和分析,服务器则注重数据的管理 构件之间彼此独立且隔离,软硬件环境的配置灵活性高 系统功能扩展性强 将大规模业务逻辑分布给网络连接的低成本计算机以降低系统开销 缺点：开发成本较高。 大部分开发工作都集中在客户机程序的设计,增加了设计的复杂度。 信息内容和形式单一 ；维护费用高 两层C/S结构都采用单一服务器,以局域网为中心,数据安全性不高。 浏览器/服务器体系结构风格：B/S是C/S的一种实现方式，主要包括浏览器、web服务器和数据库服务器。 优点：客户端只需要安装测览器,操作简单,能发布动态信息和静态信息 运用HTTP标准协议和统一客户端软件,能够实现跨平台通信。 开发成本比较低,只需要维护Web服务器程序和中心数据库。 缺点：个性化程度比较低,所有客户端程序的功能都是一样的 数据提交一般以页面为单位,动态交互性不强,不利于在线事务处理 B/S体系结构的可扩展性比较差,系统安全性难以保障。 B/S结构的应用系统查询中心数据库,其速度要远低于C/S体系结构 客户端的数据处理能力差,加重了Web服务器的工作负担,影响系统的整体性能 MVC体系结构（模型-视图-控制器）：被广泛的应用于用户交互程序的设计中用于开发具有人机界面的软件系统。 模型：应用程序的核心，封装了问题的核心数据、逻辑关系和计算功能。 视图：模型的表示，从模型中获取数据并提供交互界面为用户显示模型信息。 控制器：负责处理用户与系统之间的交互，为用户提供操作接口。 分离模型、视图和控制器，能够提高设计和使用的灵活性 ​ 优点：多个视图与一个模型相对应。变化一传播机制确保了所有相关视图都能及时的获取模型变化信息，从而使所有视图和控制器同步，便于为维护。 ​ 良好的移植性。模型独立于视图，可以方便的实现不同部分的移植 ​ 系统被分割为独立的三部分，功能发生变化时，改变任意一部分就能满足要求。 ​ 缺点：增加了系统设计和运行的复杂性； ​ 视图与控制器过于紧密，妨碍了两者的独立重用； ​ 视图访问模型效率比较低； 分层体系结构风格：将系统划分层次结构，每一层都具有高耦合低内聚的性质。上层通过下层的接口使用下层的功能，下层不能使用上层的功能。利用接口隐藏下层实现细节，有助于抽象设计 优点：可以通过将系统分解为一个增量的步骤序列来完成复杂的业务逻辑； 每一层的交互和功能影响只存在于上下两层，便于系统功能的扩展； ​ 可以通过相邻层的相同接口用不同的方法实现每一层，支持软件资源的复用 缺点：并非所有系统都能按照层次进行划分； ​ 很难找到一种合适和正确的层次划分方法； ​ 传输数据时需要经过多个层次导致系统性能下降 ​ 多层结构难以调试，往往需要通过一系列的跨层次调用来实现 使用实例：分层通信协议、计算机网络协议TCP/IP、操作系统和数据库系统 C2体系结构风格：基于构件和消息的体系结构风格，包括构件和连接件两种元素，构件之间只能通过连接件相连。核心思想是有限可视化，即构件只能使用上层构件提供的服务而不能感知下层构件的存在。消息只能单项传递，这样有利于系统的维护和发展 优点：可以使用任何编程语言来开发构件；具有一定的扩展能力； ​ 构件不需要共享地址空间，避免了共享全局变量造成的复杂关系； 具有良好的适应性；能够动态的更新系统的框架设计 基于层次消息总线的体系结构风格（HMB）：构件之间通过消息总线进行通信，支持构建的分布式存储和并发运行。包括构建件和消息总线两种软件元素。消息总线包括消息登记、消息分派和传递及消息过滤。 HMB体系风格结构支持运行时的系统演化，体现在动态删除和删除构件；动态改变构件所响应的消息；消息过滤 正交体系结构风格：以垂直线索构件为基础的层次化结构，包括组织和线索。基本思想：按照功能的正交相关性，将系统垂直划分为若干个子系统，每个子系统用一条线索表示，每条线索由多个具有不同层次功能和抽象级别的构件组成。 优点：结构清晰、便于修改与维护、易于重用 实例：汽修服务管理的设计方案 公共对象请求代理体系结构风格(CORBA)：由对象管理组织提出，是一套完整的对象技术规范，其核心包括标准语言、接口和协议。在异构分布式环境下，可以实现应用程序之间的交互操作 优点：实现了客户端程序与服务器程序的分离； 将分布式计算模式与面向对象技术结合起来，提高软件复用率； 提供了软件总线机制； 支持各种编程语言和操作系统，在开发时能更好利用已有的开发成果 数据共享体系结构风格(仓库风格):有两种软件元素：一种是中央数据单元( 资源库)，用于表示系统的当前状态；另一种是相互依赖的构建组，用于对中央数据单元实施操作。两者可以进行信息交互。 数据共享体系结构可以分为传统的数据库和黑板。 ​ 黑板是数据共享体系结构的一个特例，用以解决状态冲突并处理可能存在的不确定性知识源，经常被用于信号处理（语音和模式识别），在自然语言处理领域也有广泛应用（机器翻译和句法分析） ​ 一个典型的黑板系统包括三个部分： ​ 知识源：系统设计的关键，主要的信息来源 ​ 中央数据单元：黑板系统的运行完全依赖与中央数据单元的状态变化。 ​ 控制单元：控制单元是由中央数据单元的状态驱动的 ​ 优点：便于多客户共享大量数据 ​ 便于将构建作为知识源添加到系统中来 ​ 缺点：对共享数据结构，不同知识源要达成一致 ​ 需要同步机制和枷锁机制来保证数据的完整性和统一性，增大了系统设计的复杂度。 反馈控制环体系结构风格：反馈控制环是一种特定的数据流结构，包括过程，数据元素，控制器。过程控制是连续的，可以利用各种构件和相关规则来设计反馈控制系统，实现各种功能 典型实例：机器学习]]></content>
      <tags>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件体系结构复习]]></title>
    <url>%2F2019%2F01%2F10%2F%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[软件复用技术的出发点是在开发应用系统时不再采用一切从零开始的模式，而是以已有工作为基础，充分利用过去应用开发过程中所积累的经验与知识，将开发的重点集中于当前应用的特有部分 软件复用根据复用对象的类型不同，分为代码复用、设计复用、分析复用和测试复用 代码复用：分为目标代码复用和源代码复用。 目标代码复用级别最低，历史也最久。目前大多数编程语言的运行支持环境都提供了链接和绑定功能来支持这种复用。 源代码复用的级别略高于目标代码复用，程序员在编程时可以将一些想要复用的代码段复制到自己的程序中，但这样做往往会产生一种新老代码不匹配的现象。因此，大规模的实现源程序复用只能依靠构件库。构件库包含了大量的可复用构件。例如对象链接及嵌入技术(OLE)，OLE既能在源程序级别上定义构件构造新系统，又能使这些构件在目标代码级别上仍然时一些独立的可复用构件，能够在运行时被灵活的组合到不同的应用系统中。 设计复用比源程序复用的级别更高。设计复用受实现环境的影响较小，因此被复用的机会更多，所需的修改也更少。设计复用的途径有三种： (1)从现有系统的设计结果中提取一些可复用的设计元素用于新系统的设计过程中 (2)把现有系统的全部设计文档在新的软、硬件平台上重新实现，即一个设计用于多个具体实现 (3)独立于任何具体应用，有计划的开发一些可复用的设计元素 分析复用比设计复用的级别更高，可复用的分析成分是针对问题域的某些事物或某些问题所给出的具有普遍意义的解法。分析复用的途径有三种： (1)从现有系统的分析结果中提取可复用的分析成分用于分析新系统 (2)根据完整的分析文档来产生针对不同软硬件平台和其他实现条件的多项设计结果 (3)独立于具体应用问题，开发专门用于复用的分析成分 测试复用分为测试用例复用和测试过程复用。测试复用无法和代码复用、设计复用、分析复用进行级别上的比较，但从信息的形态上来看，大体与代码复用的级别相当 软件复用根据信息复用的方式不同，可以分为黑盒复用和白盒复用。 黑盒复用是指对已有软件结构不做任何修改，直接进行复用，是最理想的复用方式 白盒复用是指已有软件结构不能完全满足用户要求，需要进行适应性修改后才能使用。是最常用的复用方式 软件复用的实现技术一般包括组装和生成两种类型 在组装技术中，软件构件是复用的基石。构件在软件开发过程中类似于硬件中的芯片，通过组装可以形成更大的构件。构件是对某一函数、过程、子程序、数据类型及算法等可复用软件成分的抽象。对构件进行描述时应选择即不依赖具体硬件平台也不依赖具体编程语言的抽象描述语言，这样可以避免开发的构件因机器和语言的限制导致复用性降低 在生成技术中，由程序生成器完成对软件结构模式的复用。生成器导出的模式相当于种子，从中可生长出新的专用软件构件。生成技术利用可复用模式，通过生成程序产生一个新的程序或程序段，产生的程序即是模式的实例。可复用的模式分为代码模式和规则模式。 基于构件的软件开发 基本思想：将用户需求分解为一系列的子功能构建，在开发过程中不必重新设计这些基本功能模块，只需要从现有构件库中寻找合适的构件来组装应用系统 优点：(1)大大提高软件的可复用性和开发效率 (2)使产品在客户需求吻合度、上线时间和质量上领先于同类产品 (3)使产品的开发与维护变得简单 (4)客户可以随时应对商业环境和IT技术的变化，以实现快速定制 基本目标：以组装的方式生成新应用系统，组装以形式上独立的构件服务为基础进行 具备要素：构件组装的应用程序、独立服务、公共构件基础设施和通用服务 软件构件技术的发展历程 20世纪60年代初：提出了结构化分析与设计方法。意为通过工程化方法，规范开发过程，使软件系统具有良好的结构，即产生可拼装和裁剪的模块化结构。 20世纪80年代末：出现了面向对象编程技术。其基本思想使使用对象来描述客观事物，对象封装了属性和操作方法。 20世纪90年代：软件构件技术得到迅速发展。强调开发过程应融入构件化技术和体系结构技术，要求开发的系统具备易理解，自适应，互操作，可扩展和可复用的特点。 为什么要建立软件体系结构：建立软件体系结构是整个开发过程的关键性步骤，设计一个完整的框架结构和一套构造规则是项目开发成功的关键。软件体系结构的设计对于大型项目开发的成败起着举足轻重的作用。 软件体系结构研究在整个开发过程中占有重要地位的原因是/为什么要研究软件体系结构 (1)软件体系结构可以作为项目开发的指导方针 (2)软件体系结构是设计过程的开端，体现了系统最早期的设计决策，对软件生命周期的影响很大 (3)软件体系结构具有可复用性 (4)促进系统的理解 (5)软件体系结构描述除了提供清晰精确的文档之外，还对文档进行了一致性分析和依赖性分析，暴露其中隐藏的各种问题 (6)构件复用是建立体系结构良好的软件系统的出发点 (7)软件体系结构规定了系统演化的方向，提供了系统管理的有效手段 (8)软件体系结构对系统演化具有重要的意义 (9)软件体系结构影响着开发组织和维护组织的结构 领域设计 步骤：(1)将依赖关系从现实中分离，使之容易辨认和修改，以适应新的需求 ​ (2)分层框架，使软件资源可以按照特定应用、操作系统及硬件平台的 要求分层 ​ (3)在每一层寻找适合领域设计框架的通用软件资源，并以此为基础寻 ​ 找其他基础性资源 复用元素的选择原则： (1)在软件开发和维护过程中，使用最频繁的元素 ​ (2)提供最大利益的元素 ​ (3)用于创建和维护对本公司具有重要意义的策略性软件元素 ​ (4)复用消费者所需要的软件元素 软件产品线包括核心资源开发，软件项目开发和技术协调组织管理 核心资源开发被称为领域工程，利用核心资源的软件项目开发被称为应用工程。核心资源开发的目的是创建软件项目批量生产和大粒度复用的基础设施。核心资源开发的输出包括三点：产品线范围、核心资源、开发计划 软件项目开发活动依赖于核心资源开发活动的输出结果(产品线范围、核心资源和开发计划)以及各个项目的实际需求。软件项目开发活动的输入包括四点：项目实际需求、产品线范围、用于创建该项目的核心资源、开发计划。 技术协调和组织管理对于软件产品线的成功至关重要。技术协调负责监视核心资源开发活动和软件项目开发活动。组织管理必须建立合适的组织机构，确保各组织单位得到充足的资源。此外还需要建立一个实时性的调整计划，并对开发活动中涉及的档案进行有效的管理。尤其是开发进度和预算计划 三者的关系：核心资源开发与软件项目开发之间存在反馈循环，核心资源促进了应用系统的创建，新应用系统的开发又更新了核心资源，从应用系统个性中总结出的共性知识又将丰富产品线的核心资源。核心资源开发和软件项目开发都需要人力财力物理的投入，因此需要持久、强力有远见的组织管理。在产品线开发过程中，三大活动不断进行迭代循环，促进产品线的基础设施不断完善，开发的应用系统的质量不断提高，提高了领域开发的效率。 场景：是对于风险承担者与系统进行交互的简短描述。在评估过程中，使用场景可以将那些模糊的、不适用于分析的质量属性需求描述转换为具体的、易于理解的表达形式 场景分为直接场景和间接场景。直接场景在设计体系结构到系统构造的过程中使用，代表系统的外部视角和观点。间接场景在对现有体系结构进行改变和演化的过程中使用 ​ 场景的作用： (1)场景可以覆盖系统的若干需求，并使抽象的需求可操作化 ​ (2)在系统开发的早期，场景可以用来构造软件体系结构的雏形 ​ (3)场景可以指导从软件体系结构到系统实际建造的过渡过程 ​ (4)场景提供了对需求更深刻的理解，帮助用户认识软件产品并做出采 购决策。还可以帮助用户完善软件文档，在软件体系结构层面实现软 件的可跟踪性 ​ (5)场景在系统建造过程中，可用来控制系统风险并对质量目标具体化 ​ (6)软件体系结构在一个系统的软件生命周期中可能需要变动，场景成为分析变动的必要性及评估体系结构在更新后的合理性等方面的基础]]></content>
      <tags>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件质量与保证复习]]></title>
    <url>%2F2019%2F01%2F10%2F%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第一章 1、软件质量保证(SQA)是一种应用于整个软件过程的保护性活动，它包括、 (1)一种质量管理方法 (2)有效的软件工程技术 (3)在整个软件过程中采用的正式技术复审 (4)一种多层次的测试策略 (5)对软件文档及其修改的控制 (6)保证软件遵从软件开发标准的流程 (7)度量和报告机制 2、我们应该从哪几个方面考虑软件质量 (1)软件结构方面 (2)功能与性能方面 (3)开发标准与文档方面 3、IEEE对软件质量的定义 (1)系统、部件或过程满足规定需求的程度 (2)系统、部件或过程满足顾客或客户需要或期望的程度 该定义相对客观，强调了产品（或服务）和客户/社会需求的一致性 4、ANSI关于软件质量的定义 与软件产品满足规定的和隐含的需求的能力有关的特征和特性的全体 (1)软件产品中能满足用户给定需求的全部特性的集合 (2)软件具有所期望的各种属性组合的程度 (3)用户主观得出的软件是否满足其综合期望的程度 (4)决定所用软件在使用中将满足其综合期望程度的软件合成特性 5、软件质量保证的目的： (1)通过对软件产品和活动进行评审和审计来验证软件是否符合标准 (2)软件质量保证组在项目一开始时就一起建立计划、标准和过程，这些使软件项目满足机构方针的需求 6、软件测试是使用人工或自动手段来运行或测定某个系统的过程，检验他是否满足规定的需求或者弄清预期结果与实际结果之间的差别。 第二章 7、软件质量控制是一组由开发组织使用的程序和方法，使用他可在规定的资金投入和时间限制的条件下，提供满足客户质量要求的软件产品并持续不断地改善开发过程和开发组织自身，以提高将来生产高质量软件产品的能力。 8、软件质量控制的基本方法：目标问题度量法、风险管理法 第三章 9、软件过程度量中的常见问题：度量太多太频繁、度量太少太迟、度量了不正确的事物和属性、度量的定义不精确、收集了数据却没有利用、错误的解释度量数据、自动化工具欠缺 10、软件配置管理是一种标识、组织和控制修改的技术。作为CMM2级的一个关键域，在整个软件的开发活动中占有重要位置，是贯穿于整个软件过程中的保护性活动。用于标识变化、控制变化、保证变化被适当的实现、向其他可能有兴趣的人员报告变化 11、一个软件研发项目可以划分为三阶段：计划阶段、开发阶段和维护阶段 第四章 12.软件可靠性评价准则 (1)模型拟合性 (2)模型预计程度 (3)模型偏差 (4)模型偏差趋势 (5)模型噪声 注：345指标值越小，模型的适应性越好 13、提高软件可靠性的方法和技术 (1)建立以可靠性为核心的质量标准。软件质量分为产品质量(软件质量、文档质量)和过程质量。确定划分的个开发过程的质量度量 (2)选择开发方法 (3)软件重用，包括开发过程重用、软件构件重用、知识重用 (4)使用开发管理工具 (5)加强测试，测试方法包括走查、机器测试、程序证明或交替程序显示、模拟测试、设计审查 (6)容错设计：容错设计可以避免故障，不让差错和缺陷潜入软件 第五章 14、能力成熟度模型CMM为软件过程改进提供了一个框架，将整个软件改进过程分为5个成熟度等级，用于定义一个有序的尺度，用于衡量组织软件过程成熟度评价其软件过程能力 等级 特征 关键域 初始级 软件过程混乱无序、对过程几乎没有定义、依靠个人才能成功、反应式管理方式 可重复级 建立基本的项目管理、制定必要的项目管理、能利用以前的类似项目取得成功 需求管理、项目计划、项目跟踪和监控、软件子合同管理、软件配置管理、软件质量保证 已定义级 将软件管理和过程文档化标准化、综合成标准软件过程并用于所有的软件开发 组织过程定义、组织过程焦点、培训大纲、软件集成管理、软件产品工程、组织协调、专家评审 已管理级 通过收集软件过程、产品质量的详细度量对两者进行理解和控制 定量的软件过程管理 定量的产品质量管理 优化级 软件过程的量化反馈和新的思想和技术促进过程的不断改进 缺陷预防、过程变更、 技术变更管理 15、CMM/CMMI在质量保证中的四个目标，质量保证实现的具体实施方法 目标：(1)软件质量保证活动是有计划的‘ ​ (2)软件产品和活动与适用的标准、规程和需求的符合性要得到客观验证 (3)相关的小组和个人要被告知软件质量保证的活动和结果 (4)高级管理者处理在软件项目内部不能解决的不符合问题 具体实施方法：(1)定义项目类型和软件周期 ​ (2)建立SQA计划，确定项目审计内容 (3)生成SQA报告 (4)审计SQA报告 (5)独立汇报 第六章 16、为什么需要软件评审 (1)提高项目的生产率，早期发现错误，减少返工时间，减少测试时间 (2)改善软件的质量 (3)在评审过程中，使开发团队的其他人员更熟悉产品和开发过程 (4)通过评审，标志着软件开发一个阶段的完成 (5)生产出更加容易维护的软件，增加对所开发软件的理解 17、评审的方法：特别检查、轮查、走查、团队评审、检视 18、评审的内容：管理评审、技术评审、文档评审、过程评审 19、文档评审的内容和检查列表、 内容：需求评审、设计评审、代码评审、质量验证评审 检查列表：正确性、完整性、一致性、有效性、易测性、模块化、清晰性、可行性、可靠性、可追溯性 20、评审会议流程 (1)准备评审会议，提前发送通知让成员对会议内容有所准备，确保会议召开 (2)召开评审会议，流程为评审预备、评审开始、评审决议、评审结束 (3)跟踪和分析评审结果，验证作者是否恰当的解决了会议上列出的问题，修改的过程中有没有注入新的缺陷，测量评审的效果 第七章 21、全面质量管理和ISO 9000的异同 相同之处 (1)两者的管理理论和统计理论一致，即产品质量形成于产品全过程，质量体系贯穿于质量形成的全过程 (2)实现方法相同，都是PDCA质量环运行模式 (3)两者都要求对质量实施系统化的管理，都强调一把手对质量的管理 (4)两者的最终目的一致，都是为了提高产品质量，满足顾客的需求，都强调任何一个过程都是可以不断改进和改善的 不同之处 (1)两者的期间目标不一致：全面质量管理的目标是改变现状，其作业只限一次。ISO9000的目标是维持标准现状，目的是尽量减少实际结果与标准值的偏差。 (2)二者的工作中心不同。全面质量管理以人为中心，ISO9000以标准为中心。 (3)两者执行标准和检查方式不同。实施全面质量管理的企业所制定的标准是企业结合滋生特点制定的自我约束的管理体制，其检查方主要是企业内部人员，检查方法是考核和评估。ISO9000系列标准是国际公认的质量管理体系标准，它是世界各国共同遵守的准则。 22、质量屋结构图 23、6σ是寻求同时增加顾客满意和企业经济增长的经营战略途径，一种全新的管 理企业。核心是追求零缺陷生产，防范产品责任风险、降低成本、提高生产率和市场占有率、提高顾客满意度和忠诚度 24、6σ管理的优点 (1)提升企业管理的能力：降低管理流程浪费，简化管理流程，降低材料成本 (2)节约企业运营的成本 (3)增加顾客价值 (4)改进服务水平 (5)形成积极向上的企业文化 25.DMAIC模式的5步循坏改进法 (1)定义：明确问题、目标和流程 (2)评估：找到导致问题产生的关键原因，明确问题的核心所在 (3)分析：对原因进行进一步分析，确认他们之间是否存在因果关系 (4)改进：挑选最理想的改进方案付诸实施 (5)控制：根据控制标准，及时解决各种问题，使改进过程不偏离预定的轨道 第九章 26、软件测试的原则 (1)在整个软件开发过程中尽早地和不断地进行软件测试 (2)在开始测试时，不应默认程序中不存在错误 (3)设计测试用例，要给出测试的预期结果 (4)测试工作应避免由系统开发人员或开发机构本身来测试 (5)对合理和不合理的输入都要进行测试 (6)重点测试错误群集的程序区段 (7)除检查系统是否完备外，还要检查程序功能是否有多余 (8)用穷举测试是不可能的 (9)长期完整保留测试用例和测试文件，直至该软件产品被废弃为止 27、软件测试过程：单元测试-集成测试-系统测试-验收测试-回归测试贯穿整个测试过程 第十二章 28、软件缺陷是存在于软件之中的那些不希望或不可接受的偏差 29、软件缺陷的产生原因：程序编写错误、未按照规定编写代码、软件越来越复杂、开发人员的态度、沟通问题、需求变更过于频繁、进度压力、管理失误 30、软件缺陷特征：缺陷的发生都是有原因的、缺陷的重现性、缺陷的积累性放大性、缺陷的修复可能引进新的缺陷 31、软件缺陷属性：缺陷标识、缺陷类型、缺陷严重程度、缺陷优先级、缺陷状态、缺陷起源、缺陷来源、缺陷根源 32、报告软件缺陷的基本原则：软件缺陷的尽快报告、有效的描述软件缺陷 第十三章 33、集成测试与单元测试和系统测试的区别 (1)范围不同 单元测试主要关注模块的内部 集成测试主要关注穿越接口的数据、信息是否正确，是否会丢失 集成测试仅针对软件系统展开测试 系统测试包括软件系统以及与软件系统交互的所有硬件和软件平台 (2)依据不同 单元测试针对详细设计做测试，依据是详细设计说明书 集成测试针对概要设计做测试，依据是概要设计说明书 系统测试针对需求做测试，依据是需求规格说明书及行业标准 34、几种集成测试实施方案的比较 (1)非增量式集成测试：先分散测试，然后集中起来再一次完成集成测试。 缺点：如果模块的接口处存在错误，会在集成测试时一下子暴露出来； 难以判断出错的原因和位置，改正错误时容易引入新的错误。 (2)自顶向下的优点：逐步求精，一开始便能让测试者看到系统的框架。 缺点:被调用的模拟子模块可能不能反映真实情况，导致测试行不充分。 (3)自底向上的优点：即使数据流没有完全形成，测试数据也很容易生成。 缺点：只有模块全部被装进去，才能看到整个系统的框架。 (4)三明治集成测试：自底向上和自顶向下相结合，有助于尽早发现缺陷和提高工作效率。 (5)核心系统先行集成测试：能保证一些重要功能和服务的实现，对于快速软件开发很有效果。但要求系统明确区分核心部件和外围软件部件。 (6)高频集成测试：特点是集成次数频繁，必须借助自动化工具来实现。 35、集成测试的过程分为三个阶段 (1)计划阶段：完成集成测试计划，制订集成测试策略 (2)计划实现阶段：建立继承测试环境，完成测试计划和开发 (3)执行评估阶段：执行集成测试用例，记录和评估测试结果 第十四章 36、系统测试主要方法：性能测试、强度测试、安全性测试、兼容性测试、恢复测试、用户图形界面测试、安装测试、可靠性测试、配置测试、可用性测试、文档资料测试、网站测试 37、性能测试就是对软件的运行性能指标进行测试，判断系统集成之后在实际的使用环境下能否稳定可靠的运行。 性能测试中主要考虑时间性能和空间性能两方面 目标：判断被测系统是否满足预期的性能需求；判断系统的性能表现 第十五章 38、测试文档的撰写 (1)测试计划：分为作为产品的测试计划和作为工具的测试计划 ​ 测试计划包括：概要、目标和标准、测试的领域、测试方法描述、 测试进度表、测试资源、配置范围、测试工具 (2)测试规范：包括背景信息、测试特性、功能考虑、测试考虑 (3)测试案例和测试报告 (4)软件缺陷报告：包括软件缺陷名称、待测软件版本、优先级与严重性、 详细测试步骤、缺陷造成的后果、预计结果、其他信息 39、一个好的文档具有以下三点：提高可用性、提高可靠性、降低支持费用 40、调试方法：蛮力法、回溯法、原因排除法]]></content>
      <tags>
        <tag>软件质量保证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究rand()随机数]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%8E%A2%E7%A9%B6rand-%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[####关于srand()函数 ​ srand（）函数用于设置随机种子，一般参数为time（0）作为随机种子 关于time()函数​ time（0）函数返回当前时间戳（以秒为单位，从1900.01.01开始，时间戳是32位整数，所以2036年就会失效） ####关于rand()函数 ​ rand（）会随机生成一个整型(实质是一套算法，若种子相同，一套算法算出来的东西也相同) 关于rand()函数的随机性​ 由于rand()函数也是一种算法，传入相同的随机种子，生成的数也是相同的，所以广义上来说，随机数并不是真正的随机，是一种伪随机。 ​ 一个随机算法，需要保证在规定的范围内的每一个数都有可能出现且出现的概率是相同的，根据传入的随机种子不同，随机数也不同。 ####rand()函数算法如何实现0～2^32 - 1均匀随机的出现？ ​ 利用费马定理：如果p是一个素数，a^(φ(p)) % p = 1(当a与p互素时) ​ 具体见代码 #include &lt;iostream&gt;using namespace std;#define MAX_N 100000//100000以内的素数数组int prime[MAX_N + 5] = &#123;0&#125;;//my_seed是一个随机种子，rand()算法核心的两个参数a_num, b_num,//利用my_seed = my_seed * a_num % b_num能够保证my_seed在1～b_num - 1均匀的出现static int my_seed = 37, a_num, b_num;//自定义rand()函数int my_rand() &#123;#define i my_seed do &#123; //rand()算法的核心，该算式能够保证i在1～9999均匀的出现 i = i * a_num % b_num; &#125; while (i &gt; 10000); return i;#undef i&#125;//至于a_num和b_num如何得到，下面是求解过程//预处理全部素数void init_prime() &#123; for (int i = 2; 2 * i &lt;= MAX_N; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0]; j++) &#123; if (i * prime[j] &gt; MAX_N) break; prime[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125; return ;&#125;//快速幂函a^b % cint quick_mod(int a, int b, int c) &#123; int ans = 1, temp = a % c; while (b) &#123; if (b &amp; 1) ans *= temp; temp *= temp; temp %= c; ans %= c; b &gt;&gt;= 1; &#125; return ans;&#125;//由于b为质数且a,b互质，根据费马定理小定理a^(φ(p)) % p = 1，也就是a^(p - 1) % p = 1//因此我们只需要确定p - 1的全部约数不为1，即确定a^i是循环节为p - 1的算式int get_len(int a, int b) &#123; for (int i = 1; i &lt; b - 1; i++) &#123; if ((b - 1) % i) continue; if (quick_mod(a, i, b) == 1) return i; &#125; return b - 1;&#125;void get_a_and_b(int *a, int *b) &#123; //找到一个大于13000的素数b_num for (int i = 1; i &lt;= prime[0]; i++) &#123; *b = prime[i]; if (prime[i] &gt; 13000) break; &#125; //根据b_num找到符合条件的a_num for (int i = 2; i &lt; *b; i++) &#123; if (get_len(i, *b) != *b - 1) continue; *a = i; break; &#125; return ;&#125;//对a（也就是a_num），b(也就是b_num)进行验证void check(int a, int b) &#123; a_num = a, b_num = b; int vis[10001] = &#123;0&#125;; for (int i = 0; i &lt; 10000; i++) &#123; int temp = my_rand(); if (vis[temp]) &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; exit(0); &#125; vis[temp] = 1; &#125; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; OK&quot; &lt;&lt; endl; return ;&#125;int main() &#123; init_prime(); int a, b; get_a_and_b(&amp;a, &amp;b); check(a, b); return 0;&#125;]]></content>
      <tags>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euler56]]></title>
    <url>%2F2019%2F01%2F01%2FEuler56%2F</url>
    <content type="text"><![CDATA[题意： 一古戈尔（10100）是一个巨大的数字：一后面跟着一百个零。100100则更是无法想像地巨大：一后面跟着两百个零。然而，尽管这两个数如此巨大，各位数字和却都只有1。 若a, b &lt; 100，所有能表示为ab的自然数中，最大的各位数字和是多少？ 思路： ​ 一道考验基操的题——大数乘法。打一遍当热热手～ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define ll long longusing namespace std;void mul (int *num, int val) &#123; for (int i = 1; i &lt;= num[0]; i++) &#123; num[i] *= val; &#125; for (int i = 1; i &lt;= num[0]; i++) &#123; if (num[i] &gt;= 10) &#123; num[i + 1] += num[i] / 10; num[i] %= 10; &#125; &#125; while(num[num[0] + 1]) &#123; num[0] ++; num[num[0] + 1] = num[num[0]] / 10; num[num[0]] %= 10; &#125;&#125;int main () &#123; int mx = 0; for (int i = 1; i &lt;= 100; i++) &#123; int num[205] = &#123;1, 1&#125;; for (int j = 1; j &lt;= 100; j++) &#123; int k = 0; mul(num, i); for (int p = 1; p &lt;= num[0]; p++) &#123; k += num[p]; &#125; if (k &gt; mx) &#123; mx = k; &#125; &#125; &#125; printf(&quot;%d\n&quot;, mx); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>模版</tag>
        <tag>大数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euler53]]></title>
    <url>%2F2019%2F01%2F01%2FEuler53%2F</url>
    <content type="text"><![CDATA[题意： 从五个数12345中选择三个恰好有十种方式，分别是： 123、124、125、134、135、145、234、235、245和345 在组合数学中，我们记作：5C3 = 10。 一般来说， nCr=n!r!(n−r)!n!r!(n−r)!，其中r ≤ n，n! = n×(n−1)×…×3×2×1，且0! = 1。 直到n = 23时，才出现了超出一百万的组合数：23C10 = 1144066。 若数值相等形式不同也视为不同，对于1 ≤ n ≤ 100，有多少个组合数nCr超过一百万？ 思路： ​ 由于当n的取值范围小于等于100，因此可以利用杨辉三角来做～，开两个二维数组，当值小于1000000时，用dp【n】【m】来存储C（n，m）的值，当值大于1000000时，直接用book【n】【m】=1标记一下，推导方程见代码 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define ll long longusing namespace std;ll dp[105][105] = &#123;0&#125;;bool book[105][105] = &#123;0&#125;;int main () &#123; int sum = 0; for (int i = 0; i &lt;= 100; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (j == 0 || j == i) dp[i][j] = 1; else &#123; if (book[i - 1][j - 1] || book[i - 1][j]) &#123; sum ++; book[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; if (dp[i][j] &gt; 1000000) &#123; book[i][j] = 1; sum++; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, sum); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euler93]]></title>
    <url>%2F2019%2F01%2F01%2FEuler93%2F</url>
    <content type="text"><![CDATA[题意： 使用集合{1, 2, 3, 4}中每个数字恰好一次以及(+, −, *, /)四则运算和括号，可以得到不同的正整数。 例如， 8 = (4 (1 + 3)) / 214 = 4 (3 + 1 / 2)19 = 4 (2 + 3) − 136 = 3 4 * (2 + 1) 注意不允许直接把数字连起来，如12 + 34。 使用集合{1, 2, 3, 4}，可以得到31个不同的数，其中最大值是36，以及1到28之间所有的数。 若使用包含有四个不同数字a &lt; b &lt; c &lt; d的集合可以得到从1到n之间所有的数，求其中使得n最大的集合，并将你的答案写成字符串：abcd。 思路： ​ 由于有（）所以不知道如何插空，因为后缀表达式不含括号，这时候我们可以将算式转化为后缀表达式。只要满足前i位运算符 &lt; 数字个数这一条件，把全部组合计算一遍即可 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#define ll long longusing namespace std;int vis[10005] = &#123;0&#125;;double calc (char * result, int n) &#123; stack&lt;double&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (result[i] &lt;= &apos;9&apos; &amp;&amp; result[i] &gt;= &apos;0&apos;)&#123; s.push(result[i] - &apos;0&apos;); continue; &#125; double a = s.top(); s.pop(); double b = s.top(); s.pop(); switch(result[i]) &#123; case &apos;+&apos;: &#123; s.push (a + b); break; &#125; case &apos;-&apos;: &#123; s.push (b - a); break; &#125; case &apos;*&apos;: &#123; s.push (a * b); break; &#125; case &apos;/&apos;: &#123; s.push (b / a); break; &#125; &#125; &#125; return s.top();&#125;#define EPS 1e-7void dfs(char * result, int k, int a, int b, int *num) &#123; if (k == 7) &#123; double ret = calc (result, 7); if (ret &gt; 0 &amp;&amp; fabs(ret - floor(ret)) &lt;= EPS) &#123; vis[(int)ret] = 1; &#125; return; &#125; if (b + 1 &lt; a) &#123; result[k] = &apos;+&apos;; dfs(result, k + 1, a, b + 1, num); result[k] = &apos;-&apos;; dfs(result, k + 1, a, b + 1, num); result[k] = &apos;*&apos;; dfs(result, k + 1, a, b + 1, num); result[k] = &apos;/&apos;; dfs(result, k + 1, a, b + 1, num); &#125; if (a &lt; 4) &#123; result[k] = num[a] + &apos;0&apos;; dfs(result, k + 1, a + 1, b, num); &#125;&#125;int main () &#123; int mx = 0; int flag = 0; for (int i = 0; i &lt; 10; i++) &#123; for (int j = i + 1; j &lt;10; j++) &#123; for (int p = j + 1; p &lt; 10; p++) &#123; for (int q = p + 1; q &lt; 10; q++) &#123; memset(vis, 0, sizeof(vis)); int num[4] = &#123;i, j, p, q&#125;; char result[7] = &#123;0&#125;; do &#123; dfs(result, 0, 0, 0, num); &#125;while(next_permutation(num, num + 4)); int tt = 1; for (; vis[tt]; tt++); if (mx &lt; tt) &#123; mx = tt; flag = i * 1000 + j * 100 + p * 10 + q; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, flag); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euler72]]></title>
    <url>%2F2019%2F01%2F01%2FEuler72%2F</url>
    <content type="text"><![CDATA[题意： 考虑形如n/d的分数，其中n和d均为正整数。如果n &lt; d且其最大公约数为1，则该分数称为最简真分数。 如果我们将d ≤ 8的最简真分数构成的集合按大小升序列出，我们得到： 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8 可以看出该集合中共有21个元素。 d ≤ 1,000,000的最简真分数构成的集合中共有多少个元素？ 思路： ​ 就是求前1000000项的欧拉函数和，套用线性筛模版求欧拉函数即可。记住三个原理：1.当n为素数，φ(n) = n - 1 ​ 2.当p为素数且p，q互素，φ(p✖️q） = φ(p)✖️φ(q) ​ 3.当p为素数且p，q不互素，φ(p✖️q） = p✖️φ(q) 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 1000000#define ll long longint prime[N + 5] = &#123;0&#125;;int book[N + 5] = &#123;0&#125;;void init() &#123; for (int i = 2; i &lt;= N; i++) &#123; if (!book[i]) &#123; book[i] = i - 1; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt;= N; j++) &#123; if (i % prime[j] == 0) &#123; book[i * prime[j]] = book[i] * prime[j]; break; &#125; else &#123; book[i * prime[j]] = book[i] * book[prime[j]]; &#125; &#125; &#125;&#125;int main () &#123; init(); ll sum = 0; for (int i = 2; i &lt;= N; i++) &#123; sum += book[i]; &#125; printf(&quot;%lld\n&quot;, sum); return 0;&#125; ​ 答案为303963552391]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Euler61]]></title>
    <url>%2F2019%2F01%2F01%2FEuler61%2F</url>
    <content type="text"><![CDATA[三角形数、正方形数、五边形数、六边形数、七边形数和八边形数统称为多边形数。它们分别由如下的公式给出： 三角形数 P3,n=n(n+1)/2 1, 3, 6, 10, 15, … 正方形数 P4,n=n2 1, 4, 9, 16, 25, … 五边形数 P5,n=n(3n−1)/2 1, 5, 12, 22, 35, … 六边形数 P6,n=n(2n−1) 1, 6, 15, 28, 45, … 七边形数 P7,n=n(5n−3)/2 1, 7, 18, 34, 55, … 八边形数 P8,n=n(3n−2) 1, 8, 21, 40, 65, … 由三个4位数8128、2882、8281构成的有序集有如下三个有趣的性质。 这个集合是循环的，每个数的后两位是后一个数的前两位（最后一个数的后两位也是第一个数的前两位）。 每种多边形数——三角形数（P3,127=8128）、正方形数（P4,91=8281）和五边形数（P5,44=2882）——在其中各有一个代表。 这是唯一一个满足上述性质的4位数有序集。 存在唯一一个包含六个4位数的有序循环集，每种多边形数——三角形数、正方形数、五边形数、六边形数、七边形数和八边形数——在其中各有一个代表。求这个集合的元素和 思路： ​ 模块1：找出全部1000～9999的x边形数n，并把n存到g【x】【n / 100】动态数组中 ​ 模块2：对数组{3, 4, 5, 6, 7, 8}进行全排列，并进行dfs ​ 详细见代码 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int Triangle (int n) &#123; return n * (n + 1) / 2;&#125;int Square(int n ) &#123; return n * n;&#125;int Pentagonal (int n ) &#123; return n * (3 * n - 1) / 2;&#125;int Hexagonal (int n )&#123; return n * (2 * n - 1);&#125;int Heptagonal (int n) &#123; return n * (5 * n - 3) / 2;&#125;int Octagonal (int n) &#123; return n * (3 * n - 2);&#125;int (*FuncList[6])(int) = &#123; Triangle , Square, Pentagonal, Hexagonal,Heptagonal, Octagonal&#125;;vector&lt;int&gt;g[10][105];vector&lt;int&gt;gg[10];void model1 () &#123; for (int i = 1; ; i++) &#123; int flag = 0; for (int j = 0; j &lt; 6; j++) &#123; int t = FuncList[j](i); if (1000 &lt;= t &amp;&amp; t &lt; 10000) &#123; g[j][t / 100].push_back(t); gg[j].push_back(t); &#125; else if(t &gt;= 10000) &#123; flag ++; &#125; &#125; if (flag == 6) &#123; break; &#125; &#125;&#125;bool dfs(int *num, int t, int now, int k, int sum) &#123; if (k == 6) &#123; if (now % 100 == t / 100) &#123; printf(&quot;%d\n&quot;, sum); return true; &#125; return false; &#125; int m = now % 100; for (int i = 0; i &lt; g[num[k]][m].size(); i++) &#123; int tt = g[num[k]][m][i]; bool flag = dfs(num, t, tt, k + 1, sum + tt); if(flag) return true; &#125; return false;&#125;void model2() &#123; int num[6] = &#123;0, 1, 2, 3, 4, 5&#125;; bool flag = 0; do &#123; for (int i = 0; i &lt; gg[num[0]].size(); i++) &#123; int t = gg[num[0]][i]; flag = dfs(num, t, t, 1, t); if (flag) &#123; break; &#125; &#125; &#125;while(next_permutation(num, num + 6) &amp;&amp; !flag);&#125;int main () &#123; model1(); model2(); return 0;&#125; ​]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷2719搞笑世界杯]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%B4%9B%E8%B0%B72719%E6%90%9E%E7%AC%91%E4%B8%96%E7%95%8C%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[题目描述随着世界杯小组赛的结束,法国,阿根廷等世界强队都纷纷被淘汰,让人心痛不已. 于是有人组织了一场搞笑世界杯,将这些被淘汰的强队重新组织起来和世界杯一同比赛.你和你的朋友欣然去购买球票.不过搞笑世界杯的球票出售方式也很特别,它们只准备了两种球票.A 类票——免费球票 B 类票——-双倍价钱球票.购买时由工作人员通过掷硬币决定,投到正面，的买A类票, 反面的买B类票.并且由于是市场经济,主办方不可能倒贴钱,所以他们总是准备了同样多的A类票和B类票.你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置. 这时工作人员开始通过硬币售票.不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了,因为剩下的这两张票全是免费票。 你和你的朋友在欣喜之余,想计算一下排在队尾的两个人同时拿到一种票的概率是多少(包括同时拿A 类票或B类票) 假设工作人员准备了2n 张球票,其中n 张A类票,n 张B类票,并且排在队伍中的人每人必须且只能买一张球票(不管掷到的是该买A 还是该买B). 输入输出格式输入格式： 输入文件仅一行,包含球票数2n . 其中,0&lt;n&lt;=1250 ，n 为整数。 输出格式： 输出文件只包含一个数,为拿到同一种票的概率,精确到小数点后4 位。 输入输出样例输入样例#1： 256 输出样例#1： 0.9500 思路： ​ 概率dp的入门题，我们设dp【i】【j】代表A类票有i张，B类票有j张最后两张相同的概率。我们初始化dp【i】【0】= 1（2 &lt;= i &lt;= n），dp【0】【i】 = 1（2 &lt;= i &lt;= n），其余为0.然后利用dp【i】【j】= dp【i - 1】【j】✖️0.5 + dp【i】【j-1】✖️0.5，最后dp【n】【n】即为答案 代码： #include &lt;stdio.h&gt;double dp[1300][1300] = &#123;0&#125;;int main () &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 2; i &lt;= n / 2; i++) &#123; dp[i][0] = dp[0][i] = 1; &#125; for (int i = 1; i &lt;= n / 2; i++) &#123; for (int j = 1; j &lt;= n / 2; j++) &#123; dp[i][j] = dp[i - 1][j] * 0.5 + dp[i][j - 1] * 0.5; &#125; &#125; printf(&quot;%.4f\n&quot;, dp[n / 2][n / 2]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1140相似基因]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%B4%9B%E8%B0%B71140%E7%9B%B8%E4%BC%BC%E5%9F%BA%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[题目描述两个基因的相似度的计算方法如下： 对于两个已知基因，例如AGTGATG和GTTAG，将它们的碱基互相对应。当然，中间可以加入一些空碱基-，例如： 这样,两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示： 那么相似度就是：(−3)+5+5+(−2)+(−3)+5+(−3)+5=9。因为两个基因的对应方法不唯一，例如又有： 相似度为：(−3)+5+5+(−2)+5+(−1)+5=14。规定两个基因的相似度为所有对应方法中，相似度最大的那个。 输入输出格式输入格式： 共两行。每行首先是一个整数，表示基因的长度；隔一个空格后是一个基因序列，序列中只含A,C,G,T四个字母。1≤1≤序列的长度≤100。 输出格式： 仅一行，即输入基因的相似度。 输入输出样例输入样例#1： 7 AGTGATG5 GTTAG 输出样例#1： 14 思路： ​ 我们设dp【i】【j】为第一个基因的1～i位和第二个基因的1～j位的最大相似值，那么可以得到递推公式dp【i】【j】=max（dp【i-1】【j】+ maps【i】【-】，dp【i】【j-1】 + maps【-】【j】，dp【i - 1】【j - 1】+ maps【i】【j】） 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;int maps[5][5] = &#123; 5, -1, -2, -1, -3, -1, 5, -3, -2, -4, -2, -3, 5, -2, -2, -1, -2, -2, 5, -1, -3, -4, -2, -1, 0&#125;;char s1[105], s2[105];int dp[105][105] = &#123;0&#125;;map&lt;char, int&gt;zcy;int main () &#123; int n, m; zcy[&apos;A&apos;] = 0; zcy[&apos;C&apos;] = 1; zcy[&apos;G&apos;] = 2; zcy[&apos;T&apos;] = 3; scanf(&quot;%d%s&quot;, &amp;n, s1 + 1); scanf(&quot;%d%s&quot;, &amp;m, s2 + 1); for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = dp[i - 1][0] + maps[zcy[s1[i]]][4]; &#125; for (int i = 1; i &lt;= m; i++) &#123; dp[0][i] = dp[0][i - 1] + maps[4][zcy[s2[i]]]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] = max(max(dp[i - 1][j] + maps[zcy[s1[i]]][4], dp[i][j - 1] + maps[4][zcy[s2[j]]]), dp[i - 1][j - 1] + maps[zcy[s1[i]]][zcy[s2[j]]]); &#125; &#125; printf(&quot;%d\n&quot;, dp[n][m]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1436棋盘分割]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%B4%9B%E8%B0%B71436%E6%A3%8B%E7%9B%98%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[题目描述将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的两部分中的任意一块继续如此分割，这样割了(n-1)次后，连同最后剩下的矩形棋盘共有n块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行) 原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成n块矩形棋盘，并使各矩形棋盘总分的平方和最小。 请编程对给出的棋盘及n，求出平方和的最小值。 输入输出格式输入格式： 第1行为一个整数n(1 &lt; n &lt; 15)。 第2行至第9行每行为8个小于100的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。 输出格式： 仅一个数，为平方和。 输入输出样例输入样例#1： 31 1 1 1 1 1 1 31 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 01 1 1 1 1 1 0 3 输出样例#1： 1460 思路： ​ 主要是考验思维吧，只要想到用五维dp就可以很快的推出dp推导式。dp【i】【j】【p】【q】【m】代表左上角坐标（i，j），右下角坐标（p，j）的矩形切m刀的最大值。 然后dp推导式在代码中 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int maps[10][10];int sum[10][10] = &#123;0&#125;;int dp[10][10][10][10][15] = &#123;0&#125;;int main () &#123; int n; scanf(&quot;%d&quot;, &amp;n); memset(dp, 0x3f3f3f3f, sizeof(dp)); for (int i = 1; i &lt;= 8; i++) &#123; for (int j = 1; j &lt;= 8; j++) &#123; scanf(&quot;%d&quot;, &amp;maps[i][j]); sum[i][j] = sum[i][j - 1] + maps[i][j]; &#125; &#125; for (int i = 1; i &lt;= 8; i++) &#123; for (int j = 1; j &lt;= 8; j++) &#123; for (int p = i; p &lt;= 8; p++) &#123; for (int q = j; q &lt;= 8; q++) &#123; int suu = 0; for (int o = i; o &lt;= p; o++) &#123; suu += sum[o][q] - sum[o][j - 1]; &#125; dp[i][j][p][q][0] = suu * suu; &#125; &#125; &#125; &#125; for (int o = 1; o &lt; n; o++) &#123; for (int i = 1; i &lt;= 8; i++) &#123; for (int j = 1; j &lt;= 8; j++) &#123; for (int p = i; p &lt;= 8; p++) &#123; for (int q = j; q &lt;= 8; q++) &#123; for (int k = i; k &lt; p; k++) &#123; dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][k][q][o - 1] + dp[k + 1][j][p][q][0]); dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][k][q][0] + dp[k + 1][j][p][q][o - 1]); &#125; for (int k = j; k &lt; q; k++) &#123; dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][p][k][o - 1] + dp[i][k + 1][p][q][0]); dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][p][k][0] + dp[i][k + 1][p][q][o - 1]); &#125; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[1][1][8][8][n - 1]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1481魔族密码]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%B4%9B%E8%B0%B71481%E9%AD%94%E6%97%8F%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目描述风之子刚走进他的考场，就…… 花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花） 风之子：我呕……（杀死人的眼神）快说题目！否则……-_-### 花花：……咦好冷我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉^_^）。魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含1个字母，至多75个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链： i int integer 但下面的单词不组成词链： integer intern 现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。 风之子：密码就是最长词链所包括的单词数阿…… 花花：活活活，还有，看你长得还不错，给你一个样例吧： 输入输出格式输入格式： 这些文件的格式是，第一行为单词表中的单词数N（1&lt;=N&lt;=2000），下面每一行有一个单词，按字典顺序排列，中间也没有重复的单词咧！！ 输出格式： 你要提交的文件中只要在第一行输出密码就行啦^^ 输入输出样例输入样例#1： 5iintintegerinterninternet 输出样例#1： 4 思路： ​ 依次将每个单词加入字典树中，并计算建树过程中（路径上）节点的最大值，该节点即为【节点】.num=max（【节点】.num，【最大节点】.num+1），最后num最大的节点即位所求 代码： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int num = 0; node *son[26];&#125;;struct tree &#123; node *head;&#125;head;int n;char s[105];int ans = 0;void add(node *point, int ceng, int maxx, int len) &#123; if (ceng == len) &#123; maxx = max(maxx, point -&gt; num); point -&gt; num = maxx + 1; if (ans &lt; point -&gt; num) ans = point -&gt; num; return; &#125; int k = s[ceng] - &apos;a&apos;; maxx = max(maxx, point -&gt; num); if (point -&gt; son[k] == NULL) &#123; point -&gt; son[k] = (node *) malloc(sizeof(node)); add(point -&gt; son[k], ceng + 1, maxx, len); &#125; else &#123; add(point -&gt; son[k], ceng + 1, maxx, len); &#125;&#125;void Delete(node *point) &#123; for (int i = 0; i &lt; 26; i++) &#123; if (point -&gt; son[i] == NULL) continue; Delete(point -&gt; son[i]); &#125; free(point);&#125;int main () &#123; scanf(&quot;%d&quot;, &amp;n); head.head = (node *)malloc(sizeof(node)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, s); int len = strlen(s); add(head.head, 0, 0, len); &#125; printf(&quot;%d\n&quot;, ans); Delete(head.head); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1507NASA的食物计划]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%B4%9B%E8%B0%B71507NASA%E7%9A%84%E9%A3%9F%E7%89%A9%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[题目背景NASA(美国航空航天局)因为航天飞机的隔热瓦等其他安全技术问题一直大伤脑筋,因此在各方压力下终止了航天飞机的历史,但是此类事情会不会在以后发生，谁也无法保证,在遇到这类航天问题时,解决方法也许只能让航天员出仓维修,但是多次的维修会消耗航天员大量的能量,因此NASA便想设计一种食品方案,让体积和承重有限的条件下多装载一些高卡路里的食物. 题目描述航天飞机的体积有限,当然如果载过重的物品,燃料会浪费很多钱,每件食品都有各自的体积、质量以及所含卡路里,在告诉你体积和质量的最大值的情况下,请输出能达到的食品方案所含卡路里的最大值,当然每个食品只能使用一次. 输入输出格式输入格式： 第一行 两个数 体积最大值(&lt;400)和质量最大值(&lt;400) 第二行 一个数 食品总数N(&lt;50). 第三行－第3+N行 每行三个数 体积(&lt;400) 质量(&lt;400) 所含卡路里(&lt;500) 输出格式： 一个数 所能达到的最大卡路里(int范围内) 输入输出样例输入样例#1： 320 3504160 40 12080 110 240220 70 31040 400 220 输出样例#1： 550 思路： ​ 01背包的变形题，题目有三个量v（体积），w（重量），val（价值），因此我们可以开一个二维dp数组dp【i】【j】代表最大体积是i，最大重量是j条件下的最大价值，最后dp【V】【W】即为答案 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int v[55], w[55], val[55];int dp[405][405] = &#123;0&#125;;int main () &#123; int V, W, n; scanf(&quot;%d %d&quot;, &amp;V, &amp;W); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;v[i], &amp;w[i], &amp;val[i]); for (int p = V; p &gt;= v[i]; p--) &#123; for (int q = W; q &gt;= w[i]; q--) &#123; dp[p][q] = max(dp[p - v[i]][q - w[i]] + val[i], dp[p][q]); &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[V][W]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1137旅行计划]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%B4%9B%E8%B0%B71137%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[题目描述小明要去一个国家旅游。这个国家有N个城市，编号为1至N，并且有M条道路连接着，小明准备从其中一个城市出发，并只往东走到城市i停止。 所以他就需要选择最先到达的城市，并制定一条路线以城市i为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。 现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的i，都需要你为小明制定一条路线，并求出以城市i为终点最多能够游览多少个城市。 输入输出格式输入格式： 第1行为两个正整数N,M。 接下来M行，每行两个正整数x,y，表示了有一条连接城市x与城市y的道路，保证了城市x在城市y西面。 输出格式： N行，第i行包含一个正整数，表示以第i个城市为终点最多能游览多少个城市。 输入输出样例输入样例#1： 5 61 21 32 32 43 42 5 输出样例#1： 12343 说明均选择从城市1出发可以得到以上答案。 对于20%的数据，N≤100； 对于60%的数据，N≤1000； 对于100%的数据，N≤100000,M≤200000 思路： ​ 这道题利用拓扑排序找到所有能够从i节点到达的节点j，令dp【j】 = dp【i】+ 1，最后dp数组就是所求 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int n, m;int ru[100005] = &#123;0&#125;;int dp[100005] = &#123;0&#125;;vector&lt;int&gt;zcy[100005];queue&lt;int&gt;que;void tupo() &#123; for (int i = 1; i &lt;= n; i++) &#123; dp[i] = 1; if (!ru[i]) &#123; que.push(i); &#125; &#125; while(!que.empty()) &#123; int t = que.front(); que.pop(); for (int i = 0; i &lt; zcy[t].size(); i++) &#123; int k = zcy[t][i]; dp[k] = max(dp[k], dp[t] + 1); ru[k] --; if (!ru[k]) que.push(k); &#125; &#125;&#125;int main () &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); zcy[a].push_back(b); ru[b]++; &#125; tupo(); for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d\n&quot;, dp[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷1108低价购买]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%B4%9B%E8%B0%B71108%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[题目描述“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(216216范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。 这里是某支股票的价格清单： 日期 1,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,12 价格68,69,54,64,68,64,70,67,78,62,98,8768,69,54,64,68,64,70,67,78,62,98,87 最优秀的投资者可以购买最多44次股票，可行方案中的一种是： 日期 2,5,6,102,5,6,10 价格 69,68,64,6269,68,64,62 输入输出格式输入格式： 第1行: N(1≤N≤5000)N(1≤N≤5000)，股票发行天数 第2行: NN个数，是每天的股票价格。 输出格式： 两个数:最大购买次数和拥有最大购买次数的方案数(≤231≤231)当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。 输入输出样例输入样例#1： 1268 69 54 64 68 64 70 67 78 62 98 87 输出样例#1： 4 2 思路： ​ 这道题有两问，一问是求最长下降子序列，一个是求最长下降子序列的个数。我们可以先举个例子来看一下：设置f数组为最长下降子序列的长度，g数组为最长下降子序列的个数，对于样例： val数组：3 7 6 4 5 5 3 f数组：1 1 2 3 3 3 4 g数组：1 1 1 1 0 1 2 ​ 也就是说，g数组有三个规则： 1. 当f【i】为1的时候，g【1】 = 1 2. 当f【i】==f【j】+1&amp;&amp;val【i】&lt; val【j】时，g【i】+= g【j】 3. 当f【i】== f【j】&amp;&amp;val【i】==val【j】时，g【i】= 0 最后max（f【i】）即是最长长度，所有f【i】==最长长度的g【i】的和即为个数 代码： #include &lt;iostream&gt;#include &lt;algorithm&gt;using std::cin;using std::cout;using std::endl;int val[5005] = &#123;0&#125;;int dp[5005][2] = &#123;0&#125;;int main () &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; val[i]; dp[i][0] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; if (val[j] &gt; val[i]) &#123; dp[i][0] = std::max(dp[i][0], dp[j][0] + 1); &#125; &#125; if (dp[i][0] == 1) &#123; dp[i][1] = 1; &#125; for (int j = 1; j &lt; i; j++) &#123; if (dp[i][0] == dp[j][0] + 1 &amp;&amp; val[j] &gt; val[i]) &#123; dp[i][1] += dp[j][1]; &#125; if (dp[i][0] == dp[j][0] &amp;&amp; val[j] == val[i]) &#123; dp[i][1] = 0; &#125; &#125; &#125; int maxx = 1, sum = 0; for (int i = 1; i &lt;= n; i++) &#123; maxx = std::max(dp[i][0], maxx); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (dp[i][0] == maxx) &#123; sum += dp[i][1]; &#125; &#125; cout &lt;&lt; maxx &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces1096DEasy Problem]]></title>
    <url>%2F2018%2F12%2F29%2FCodeForces1096DEasy-Problem%2F</url>
    <content type="text"><![CDATA[题意： Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length 𝑛n consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence hard; otherwise the statement is easy. For example, hard, hzazrzd, haaaaard can be considered hard statements, while har, hart and drah are easy statements. Vasya doesn’t want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the ambiguity of the statement is 00, and removing 𝑖i-th character increases the ambiguity by 𝑎𝑖ai (the index of each character is considered as it was in the original statement, so, for example, if you delete character r from hard, and then character d, the index of d is still 44 even though you delete it from the string had). Vasya wants to calculate the minimum ambiguity of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it! Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Input The first line contains one integer 𝑛n (1≤𝑛≤1051≤n≤105) — the length of the statement. The second line contains one string 𝑠s of length 𝑛n, consisting of lowercase Latin letters — the statement written by Vasya. The third line contains 𝑛n integers 𝑎1,𝑎2,…,𝑎𝑛a1,a2,…,an (1≤𝑎𝑖≤9982443531≤ai≤998244353). Output Print minimum possible ambiguity of the statement after Vasya deletes some (possibly zero) characters so the resulting statement is easy. Examples input 6hhardh3 2 9 11 7 1 output 5 input 8hhzarwde3 2 6 9 4 8 7 1 output 4 input 6hhaarr1 2 3 4 5 6 output 0 ​ 翻译成汉语，就是给你一个n个字符的字符串，每个字符都有一个权制，问你删除最小的权值，使得剩下的字符串里不包含子序列hard。问最小删除的字符的权值和是多少？ 思路： ​ 求最小删除的字符权值和，我们可以转化为求剩余不包含子序列hard的字符串的最大权值。我们可以设dp{i}{j}代表第i个字符为第j种状态的最大权值（状态共有5种，0代表0～i全部子序列都不包含h，1代表0～i全部子序列最多包含h，2代表0～i全部子序列最多包含ha，3代表0～i全部子序列最多包含har，4代表0～i全部子序列最多包含hard，最后dp{n}{0～3}的最大值即为答案） 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;char s[100005];long long dp[100005][5];long long val[100005];int main() &#123; int n; memset(dp, 0, sizeof(dp)); scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s + 1); long long sum = 0; for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;val[i]), sum += val[i]; for(int i = 1; i &lt;= n; i++) &#123; if (s[i] == &apos;h&apos;) &#123; dp[i][0] = dp[i - 1][0]; dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]) + val[i]; for (int j = 2; j &lt; 5; j++) &#123; dp[i][j] = dp[i - 1][j] + val[i]; &#125; &#125; else if (s[i] == &apos;a&apos;) &#123; dp[i][0] = dp[i - 1][0] + val[i]; dp[i][1] = dp[i - 1][1]; dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + val[i]; for (int j = 3; j &lt; 5; j++) &#123; dp[i][j] = dp[i - 1][j] + val[i]; &#125; &#125; else if (s[i] == &apos;r&apos;) &#123; dp[i][0] = dp[i - 1][0] + val[i]; dp[i][1] = dp[i - 1][1] + val[i]; dp[i][2] = dp[i - 1][2]; dp[i][3] = max(dp[i - 1][2], dp[i - 1][3]) + val[i]; for (int j = 4; j &lt; 5; j++) &#123; dp[i][j] = dp[i - 1][j] + val[i]; &#125; &#125; else if (s[i] == &apos;d&apos;) &#123; dp[i][0] = dp[i - 1][0] + val[i]; dp[i][1] = dp[i - 1][1] + val[i]; dp[i][2] = dp[i - 1][2] + val[i]; dp[i][3] = dp[i - 1][3]; dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]) + val[i]; &#125; else &#123; for (int j = 0; j &lt; 5; j++) &#123; dp[i][j] = dp[i - 1][j] + val[i]; &#125; &#125; &#125; long long mx = 0; for(int i = 0; i &lt; 4; i++)&#123; mx = max(mx, dp[n][i]); &#125; printf(&quot;%lld\n&quot;, sum - mx); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb复习(三)]]></title>
    <url>%2F2018%2F12%2F26%2FJavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[[TOC] 三 创建和部署MVC Web应用3.1 一个简单应用的组成​ 一个简单Web应用包括html表单、servlet控制器、一个模型（普通Java类）、一个xml部署描述文件、一个jsp视图 3.2 步骤3.2.1 分析用户视图以及高层体系结构 3.2.1.1对于访问链接：根据上图： ​ 1:客户请求访问页面 ​ 2.容器找到html页面 ​ 3.容器把页面返还给浏览器 3.2.1.2 对于访问servlet：根据上图： ​ 4:客户把请求数据发送给容器 ​ 5.容器根据url找到对应的servlet，并把请求传递给这个servlet ​ 6.servlet调用模型（普通java类） ​ 7.类返回一个结果，servelet把回答增加到请求对象 ​ 8.servlet把请求转给jsp ​ 9.jsp从请求对象得到答案 ​ 10.jsp为生成容器生成页面 ​ 11.容器把页面返回给用户 3.3.2 创建项目的开发环境​ MVC项目的标准层级结构 3.3.3 创建项目的部署环境​ Tomcat的层级结构： 3.3.4 对Web应用各组件进行迭代开发和测试3.3.4.1 构建和测试html表单3.3.4.1.1 构建：​ 举个例子： &lt;html&gt; &lt;body&gt; &lt;h1&gt;填写表单&lt;/h1&gt; &lt;!--html认为/login就是要调用的servlet(客户知道的url名)，在项目目录结构中并不存在--&gt; &lt;form name="haha" method="POST" action="/login"&gt; 姓名：&lt;input type="text" name="name"&gt; &lt;br&gt; 性别：&lt;input type="radio" name="sex" value="men"&gt;男 &lt;input type="radio" name="sex" value="women"&gt;女 &lt;br&gt; &lt;input type="SUBMIT"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 3.3.4.1.2:部署和测试​ 1.在开发环境中创建html，然后保持在项目名/web下 ​ 2.把html文件的副本放在tomcat/webapps/项目名中 ​ 3.创建web.xml文档，保存在开发环境项目名/etc下 &lt;!--该部署文件的主要目的是定义逻辑名与实际类文件之间的映射--&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;部署名&lt;/servlet-name&gt; &lt;servlet-class&gt;类文件的完全限定名&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;部署名&lt;/servlet-name&gt; &lt;!--.do只是一个约定--&gt; &lt;url-pattern&gt;/用户可知的url名.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ​ 4.把web.xml文件的副本放在/tomcat/webapps/项目名/WEB-INF目录下 ​ 5.启动tomcat（cd到tomcat主目录，然后运行/bin/startup.sh） ​ 6.测试页面（输入http://localhost:8080/项目名） 3.3.4.2 构建控制器servlet第一个版本3.3.4.2.1 编写servlet​ 利用html表单测试这个控制器（确保html页面能适当调用servlet，且servlet能正确接收html参数） package com.webimport java.io.*;import javax.servlet.*;import javax.servlet.http.*;pulbic class TestServlet extends HttpServlet &#123; //重写doPost方法 public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("haha&lt;br&gt;"); //获取表单中的name信息（根据html标记中的name属性匹配） String s = request.getParameter("name"); out.println("he is " + s); &#125;&#125; 3.3.4.2.2 编译servlet​ 命令如下： //切到项目目录下cd project//路径根据不同的存放目录是不同的，tomcat之后是相同的//-d用来告诉编译器，.class文件放在适当包结构中的clases目录下javac -classpath /路径/tomcat/common/lib/servlet-api.jar:classes:. -d classes src/com/web/testServlet.java 3.3.4.2.3 部署servlet​ 创建.class文件副本，把它移到tomcat/项目/WEB-INF/classes/com/web下 3.3.4.2.4 测试servlet​ 重启tomcat然后访问网页即可 3.3.4.3 为模型类构建测试类，构建并测试模型类​ 例如： package com.model;public class Test&#123; public String getName(String name) &#123; String s = &quot;hello, &quot;; s = s + name; return s; &#125;&#125; 3.3.4.4 servlet升级到第二版3.3.4.4.1 改写​ 可以调用模型类,如下： package com.webimport com.model.*;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;pulbic class TestServlet extends HttpServlet &#123; //重写doPost方法 public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; //新补充的内容： String s = request.getParameter(&quot;name&quot;); Test t = new Test(); String s1 = t.getName(s); response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;haha&lt;br&gt;&quot;); //获取表单中的name信息（根据html标记中的name属性匹配） out.println(s1); &#125;&#125; 3.3.4.4.2 部署​ 1.编译servlet ​ 2.将servlet文件的副本替换到之前的/tomcat/wabapps/项目/WEB-INF/classes/com/web下 ​ 3.把模型的class文件移动到/tomcat/wabapps/项目/WEB-INF/classes/com/model下 ​ 4.重启tomcat ​ 5.打开浏览器浏览 3.3.4.5 构建jsp，servlet升级到第三版​ 可以把表示分派到jsp完成 ​ jsp代码如下： &lt;%@ page import="java.util.*" %&gt;&lt;html&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;!-- &lt;% %&gt;标记里有一些标准Java代码--&gt; &lt;% &lt;!--从这里从请求对象得到一个styles属性--&gt; String s = (String)resquest.getAttribute("styles"); out.print("&lt;br&gt;" + s); %&gt; &lt;/body&gt;&lt;/html&gt; ​ 然后将jsp文件保存在项目目录/web下 ​ 将它的副本移动到tomcat/项目名下 ​ servlet代码修改为： package com.webimport com.model.*;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;pulbic class TestServlet extends HttpServlet &#123; //重写doPost方法 public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; //新补充的内容： String s = request.getParameter(&quot;name&quot;); Test t = new Test(); String s1 = t.getName(s); //response.setContentType(&quot;text/html&quot;); //PrintWriter out = response.getWriter(); //out.println(&quot;haha&lt;br&gt;&quot;); //获取表单中的name信息（根据html标记中的name属性匹配） //out.println(s1); //为请求对象增加styles属性，供jsp使用 request.setAttribute(&quot;styles&quot;, s1); //为jsp实例化一个请求分派器 RequestDispatcher view = request.getRequestDispatcher(&quot;test.jsp&quot;); //使用请求分派器要求容器准备好jsp，并向jsp发送请求和响应 view.forward(request, response); &#125;&#125; ​ 重新部署servlet即可，重启tomcat查看]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb复习(二)]]></title>
    <url>%2F2018%2F12%2F25%2FJavaWeb%E5%A4%8D%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 二.web应用体系结构2.1 web容器​ Servlet没有main()方法，它受控于另一个Java应用，这个Java应用被称为Web容器，Tomcat就是这样一个容器。 ​ 对于每个请求，Web容器可以实例化servlet（或至少建一个新线程），可以调用servlet的doPost()或doGet()方法，把方法的重要参数(http请求和http响应对象)交给servlet，可以管理servlet的生死以及servlet的资源 2.1.1 指向某servlet请求的流程​ Web服务器应用得到指向某servlet请求后，此时服务器将请求交给部署该servlet的容器，由容器向servlet提供http请求和响应，并且由容器调用servlet的方法（如doPost()、doGet()） ​ 最后线程结束，容器把响应对象转换为一个http响应，并把它返回浏览器，然后删除请求和响应对象 2.1.2 容器的作用​ 1.通信支持：利用容器提供的方法，可以让servlet和Web服务器对话，无需自己建立ServerSocket、监听端口、创建流等 ​ 2.生命周期管理：它能负责加载类、实例化和初始化Servlet、调用servlet方法以及垃圾回收。有了容器的控制，就不用太多考虑资源管理 ​ 3.多线程支持：容器会自动为它接受的每个servlet请求创建一个新的线程。servlet已经运行完相应的http方法，线程就会自动结束 ​ 4.声明方式实现安全：利用容器，可以使用xml部署描述文件来配置安全性，而不必将其硬编码写到servlet类代码中 ​ 5.JSP支持：容器可以将JSP代码翻译成真正的Java ​ 因此说，有了容器我们可以更专注自己的业务逻辑，而不用过多考虑线程管理、安全性和网络通信等底层服务 2.2 关于Servlet名称2.2.1 Servlet的三个名字​ 1.客户知道的URL名（虚拟的名字，完全为客户提供） ​ 2.部署servlet人员定义的部署名（虚拟的内部名，只用于部署Servlet） ​ 3.实际的文件名（开发人员的Servlet类拥有一个完全限定名，包括类名和包名） 2.2.2 Servlet多个名字的好处​ 1.灵活性高，移动文件而不必担心后期维护 ​ 2.安全性高，对客户隐藏了服务器的目录结构 2.3 关于部署文件​ 部署文件会告诉容器如何运行servlet和jsp： ​ 1.可以使用两个xml元素把url映射到servlet &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; version=&quot;2.4&quot;&gt; &lt;!--一个部署描述文件可以声明多个servlet--&gt; &lt;!--servlet-name把servlet和servlet-mapping元素绑定在一起--&gt; &lt;!--servlet元素告诉容器哪个类文件属于一个特定Web应用--&gt; &lt;1--servlet-name是部署名--&gt; &lt;servlet&gt; &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt; &lt;!--servlet-class是java类,也就是类的完全限定名--&gt; &lt;servlet-class&gt;testServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt; &lt;!--url-pattern是客户所用的请求名，也就是用户知道的url名--&gt; &lt;url-pattern&gt;/Serv1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ​ 2.对Web应用的安全角色、错误页面、标记库、初始配置信息等方面进行定制 ​ 也就是说，利用部署描述文件，可以利用一种声明方式修改应用，而无需修改源代码 2.4 MVC设计模式​ 若不使用mvc设计模式，那么流程图servlet请求的流程图如下： ​ 我们发现业务逻辑与表示之间有很强的联系，因为我们需要在两者之间放别的东西，使得业务逻辑本身就能作为一个可重用的Java类。 ​ 因此，我们引入模型-视图-控制器（MVC）设计模式，它的核心就是把业务逻辑从servlet中抽出来，放到一个模型中（模型就是可重用的普通java类，它是业务数据和处理该数据的方法组合） 2.5 J2EE​ J2EE是一种超级规范，它结合了sevlets、jsp、ejb规范。一个完全兼容j2EE应用服务器必须有一个web容器和一个ejb容器。 ​ tomcat是一个web容器，而不是一个完整的j2EE应用服务器]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb复习(一)]]></title>
    <url>%2F2018%2F12%2F24%2FJavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[​ [TOC] 一：概述1.1 web应用​ 一个JavaWeb应用：java+servlet+jsp 1.2 流程​ web服务器用于接受客户需求，然后向客户返回一些结果 ​ 浏览器就是一个软件，它可以与服务器通信，能够解释html代码，并将web页面呈现给用户 ​ 流程如下： ​ web上浏览器和服务器的大多数通信都是使用http协议完成，http协议支持简单的请求和响应会话，浏览器（客户）发送一个http请求，服务器会用一个http响应做应答。 ​ 总结就是：1.html告诉浏览器如何向用户显示内容 ​ 2.http是web上客户和服务器进行通信用的协议 ​ 3.服务器使用http向客户（浏览器）发送html 1.3 HTTP协议​ http协议是TCP/IP的上层协议（TCP用于保证从一个网络节点向另一个网络节点发送的文件能完整到达，IP是一个底层协议，负责把数据块沿路移动/路由到目的地），需要依赖TCP/IP从一处向另一处完整地传送请求和响应 ​ http会话的结构是一个简单的请求/响应序列：浏览器发出请求，服务器做出响应 1.4 请求流/响应流要素1.4.1请求流关键要素：​ 1.http方法 ​ 2.要访问的页面(URL) ​ 3.表单参数（如方法参） 1.4.2响应流关键要素：​ 1.状态码（表明请求是否成功） ​ 2.内容类型（包括文本、图片、html等） ​ 3.内容（具体的html、图片等） 1.5 http请求​ http协议有很多请求方法，常用的有get方法和post方法 1.5.1 get请求​ get是最简单的http方法，用于要求服务器获取一个资源并把资源发过来 特点： ​ 1.get发送数据是有限的（取决于服务器） ​ 2.get发送的数据会追加到url后，所以发送的数据完全暴露（通过?符隔开，两部分加在一起，整个串组成完整的请求url） 1.5.1.1get请求解析//GET代表http方法， /books/test.jsp 为web服务器上资源的路径 //sex=man&amp;name=Professional为参数//HTTP/1.1 为协议的版本GET /books/test.jsp?sex=man&amp;name=Professional HTTP/1.1 //请求行//以下是请求首部Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-AliveAccept: text/xml,application/xml,text/html;q=0.9,text/plain 1.5.2 post请求​ post方法可以请求某个东西，与此同时可以向服务器发送一些表单数据 1.5.2.1post请求解析//POST代表http方法， /advisor/test.do 为web服务器上资源的路径 //HTTP/1.1 为协议的版本POST /advisor/test.do HTTP/1.1 //请求行//以下到空行为请求首部Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-AliveAccept: text/xml,application/xml,text/html;q=0.9,text/plain（----此处空一行----）//以下为消息体color=dark&amp;taste=malty 1.5.3其他方法​ 比如head、trace、put、delete、options、connect等方法 1.6 http响应​ http响应可以包含html，http还会在响应内容前增加首部信息，而浏览器使用首部信息来帮助处理html页面 1.6.1响应解析//以下为http响应首部//HTTP/1.1为http协议版本 200为http状态码 OK为状态码的相应文本HTTP/1.1 200 OKCache-Control: no-store, no-cache, must-revalidateDate: Tue, 26 Jul 2016 09:32:11 GMTExpires: Tue, 26 Jul 2016 09:32:12 GMTVary: Accept-EncodingContent-Encoding: gzipContent-Length: 3892//Content-Type响应首部的值称为MIME类型，用于告诉浏览器要接收的数据是什么类型,它的值域请求首部的Accept值相关Content-Type: text/html; charset=utf-8Last-Modified: Tue, 26 Jul 2016 09:32:12 GMT 1.7 端口​ 端口是一个16位的数(范围0～2^16 - 1)，用于标识服务器硬件上一个特定的软件程序 。它并不是一个可以插入物理设备的位置，只表示服务器应用的“逻辑“数。从0～1023的端口号已经保留，由一些众所周知的服务使用 1.7.1 常用端口​ 21：FTP ​ 23：Telnet ​ 25：SMTP ​ 37：Time ​ 80：HTTP ​ 443：HTTPS ​ 110：POP3 1.8 Web服务器​ 两个常用的Web服务器，一个是Apache，另一个是Tomcat 1.9 静态/动态Web页面​ 静态页面只是原封不动的在目录中，服务器找到静态页面，并把它原样传给客户 ​ 对于动态页面而言，Web服务器上有一个辅助应用可以生成非静态的即时页面且能与web服务器通信。每当请求到来时，辅助应用具体写出html，web服务器再把这个html响应到浏览器。辅助应用是一个CGI程序（CGI代表公共网关接口） 1.9.1 动态页面生成流程​ 举个动态页面显示当前日期的例子： 1.10 Servlet​ Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用于交互式地浏览和修改数据，生成动态Web内容 1.10.1 Servlet编写、部署、运行​ 1.项目目录树和tomcat目录树如下： ​ 2.在src目录下编写testServlet.java //以下是一个标准的Servlet声明import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class testservlet extends HttpServlet &#123; public void doGet(HttpServletRequest reque, HttpServletResponse response) throws IOException &#123; PrintWriter out = response.getWriter(); java.util.Date today = new java.util.Date(); out.println("&lt;html&gt; &lt;body&gt; &lt;h1&gt; time is &lt;/h1&gt; &lt;br&gt; today &lt;/body&gt; &lt;/html&gt;" ); //Java嵌套html &#125;&#125; ​ 3.在etc创建一个部署描述文件web.xml（每个web应用都有一个部署描述文件） &lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.4"&gt; &lt;!--一个部署描述文件可以声明多个servlet--&gt; &lt;!--servlet-name把servlet和servlet-mapping元素绑定在一起--&gt; &lt;servlet&gt; &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt; &lt;!--servlet-class是java类--&gt; &lt;servlet-class&gt;testServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt; &lt;!--url-pattern是客户所用的请求名--&gt; &lt;url-pattern&gt;/Serv1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ​ 4.在project目录下编译servlet，生成的testServelet.class文件将会在classes目录下 java -classpath /yourpath/tomcat/common/lib/Servlet-api.jar -d classes src/testServlet.java ​ 5.将testServelet.class复制到WEB-INF/classes目录下，再把web.xml复制到WEB-INF目录下 ​ 6.从tomcat目录下启动tomcat bin/startup.sh ​ 7.打开浏览器，输入 http://localhost:8080/test/Serv1 //test为项目名，Servl为servlet名 1.11 JSP​ 在html中引入Java，就是jsp。 1.11.1 示例举个当前日期的例子： &lt;html&gt; &lt;body&gt; The time is &lt;%= new java.util.Date() %&gt; &lt;/body&gt;&lt;/html&gt; 1.11.2 好处​ 1.使得Java开发人员处理Java，html开发人员开一专心处理Web（仅仅需要学如何调用具体Java方法） ​ 2.避免html以某种格式放入一个String中导致错误]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim复制代码到终端外]]></title>
    <url>%2F2018%2F12%2F22%2Fvim%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BB%88%E7%AB%AF%E5%A4%96%2F</url>
    <content type="text"><![CDATA[​ ​ 1) 打开 iTerm2 的偏好设置，找到General -&gt; Selection，取消 Copy to pasteboard on selection。 ​ 2)在 ~/.vimrc 里添加 set clipboard=unnamed 上面的步骤完成了以后，如果要复制整段代码，就按下面的步骤做： ​ 1.vim打开某一文件，按 ESC 进入 normal 模式​ 2.v 进入 visual 模式。 ​ 3.shift+g 选中光标后的所有内容 ​ 4. y复制选中内容 ​ 5. cmd+v 粘贴代码]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下mysql无法启动的解决办法]]></title>
    <url>%2F2018%2F12%2F19%2FMac%E4%B8%8Bmysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 又到了做课设的日子～然后发现电脑里的mysql服务怎么都打不开，上网百度了一下，原因是某种情况下导致”/usr/local/MySQL/data”的拥有者发生了改变，所以只需要将其拥有者修改为“mysql“就可以了。（个人觉得是更改了管理员导致的吧） ​ 这时候，我们只需要在终端中运行，mysql服务就能运行了 sudo chown -R mysql /usr/local/mysql/data1 ​ Over～]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据找前1000大]]></title>
    <url>%2F2018%2F12%2F18%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%89%BE%E5%89%8D1000%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[​ 打个比方，在100亿个亿中，找前1000大的数，我们应该怎么办？ ​ 一般人上来可能会想，可以先排序（比如快排，分治等等），然后取前1000个，这样时间复杂度是O(nlogn)（n为100亿），这样肯定是不可以的​ ​ 我们会发现，我们只需要对前1000个进行处理，而不是每个数都排序确定位置，因此我们可以对排序进行优化。打个比方对快排进行优化：取第一个数做基准，然后利用快排原理把比这个数小的移到左边，比这个数大的移到右边。若左边的数大于1000，直接把右边舍弃，对左边继续进行快排。若左边的数小于1000，记录左边数的个数m，然后对右边继续继续进行快排。此时找的是n - m - 1个数。循环执行直到找到1000，这种时间复杂度是O(n)，大概是2n左右吧。。 ​ 利用上边这种方法确实可以解决时间复杂度问题，可是要一次性读取全部的数据，100亿的int型大概需要占用40G内存，普通个人电脑是无法做到的。有的人会想，我可以把数据存在文件中，每次左边的数存1.txt里，右边的数存2.txt，根据上面的判断条件选择读取哪个文件即可。这样的想法不错，可是多次的读写操作，效率会变得很低很低。。。 ​ 这时候，我们可以考虑一下分布式，每个计算机负责一部分数据，并行计算前1000大并把数据传送到一个计算机汇总求总的前1000大 ​ 上述方法非常好，可是却需要受到硬件条件的限制。我们可以利用最小堆来实现求前1000大，首先取前1000个数构建最小堆，然后每读取一个数，若小于堆顶直接舍弃，若大于则扔掉堆顶，把该数加入到堆中。这样暂用内存不大，不受制于硬件条件，且时间复杂度为O(n) ​ 以上墨迹这么多，就是给大家提供一种思考问题的思路，要考虑到方方面面，而不是单纯的时间复杂度那么简单。 ​]]></content>
      <tags>
        <tag>探究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux一切皆文件]]></title>
    <url>%2F2018%2F12%2F18%2F%E4%BA%86%E8%A7%A3Linux%2F</url>
    <content type="text"><![CDATA[1.一切皆文件​ Linux 一切皆文件，不仅是狭义上的文件，像键盘、打印机、虚拟终端，进程间通信和网络通信等输入/输出资源都是定义在文件系统空间下的字节流 ​ 好处：对于输入/输出资源，可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源 （注：api是应用程序编程接口） ​ 操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用 ​ 在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式 ​ 注意点：Linux 文件是没有所谓的扩展名的，一个 Linux文件能否被执行与它是否可执行的属性有关，只要权限中有x就可以执行（不一定执行成功）虽然如此，但期望通过扩展名来了解该文件是什么东西，所以一般还会以适当的扩展名来表示该文件是什么 2.物理存储机制：​ 磁性存储介质磁化后会保留被磁化状态，且状态能被读取和修改，磁化有两个方向可表示0和1，所以用磁性存储介质来存储信息​ 而硬盘就是把磁性存储介质做成多个盘片（包含数以亿计的磁性存储单位），并使用磁性读写头对盘片进行读写 ​ 由于硬盘中磁性存储单元众多，所以需要一套规则来规划信息如何存取，于是就有了物理、逻辑概念： 一个硬盘有多张盘片叠成 每张盘片上的存储颗粒（一存储颗粒为1bit）成环形一圈圈地排布，每一圈称为磁道 每条磁道上都有一圈存储颗粒，每512*8（512byte，0.5KB）个存储颗粒作为一个扇区 扇区是硬盘最小的物理存储单位 N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置 簇是文件系统的最小存储单位 所有盘面上的同一磁道构成一个圆柱，称为柱面 柱面是系统分区的最小单位 ​ 磁头读写文件时先分区读写，由inode编号（区内唯一的编号）找到对应磁道和扇区，然后一个柱面一个柱面地进行读写 3.Linux文件体系：​ Linux以文件的形式对计算机中的数据和硬件资源进行管理，反映在Linux的文件类型上就是：普通文件、目录文件（也就是文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信的接口）等等。而这些种类繁多的文件被Linux使用目录树进行管理（就是以根目录（/）为根，向下呈现分支状的一种树形结构） 3.1. 普通文件​ 类似mp4、pdf这样应用层面上的文件类型都属于普通文件，Linux用户可以根据访问权限对普通文件进行查看、更改和删除 3.2. 目录文件​ 目录文件包含了目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件 3.3. 链接文件​ 类似快捷方式，是指向另一个文件的间接指针 3.4. 块设备文件和字符设备文件​ 这些文件一般隐藏在/dev目录下，在进行设备读取和外设交互时会被使用到。比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件 3.5. 管道文件​ 主要用于进程间通讯 .6. 套接字文件​ 用于进程间的网络通信，也可以用于本机之间的非网络通信，这些文件一般隐藏在/var/run目录下，证明着相关进程的存在]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2018%2F12%2F18%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 1.标题# h1## h2### h3#### h4##### h5###### h6 2.目录[TOC] //一般放在文章开头 3.引用&gt; 引用内容 4.行内标记前面内容`行内标记内容`后面内容 5.代码块 6.链接[个人博客](wwww.ivan-zcy.top) 7.插入图片![图片上传失败的备注](图片地址) 8.序表//有序1. 内容2. 内容.....//无序* 内容* 内容....//嵌套1. 内容 1. 内容 2. 内容2. 内容 9.选项- [] 选项名 10.分隔线//方法一***//方法二--- 11.跳转邮箱&lt;296763002@qq.com&gt; 12.字体倾斜//方法一：*内容*//方法二：_内容_ 13.字体加粗//方法一：**内容**//方法二：__内容__ 14.删除线~~内容~~]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github使用]]></title>
    <url>%2F2018%2F12%2F18%2FGithub%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.Github是什么？ ​ gitHub是一个面向开源及私有软件项目的托管平台，上面托管了众多优秀的项目 2.Github常用术语： ——Repository​ 仓库，用于存储你的开源项目 ——Issue​ 问题，用于对项目提出意见或建议，以及发现的Bug，修复了就可以Close掉 ——Star​ 点赞，想拥有程序员这种完美主义者的赞很难。。。拥有几千赞感觉就逆天了，上万赞的或许只有那些顶级开源项目了。。 ——Watch​ 观察，如果对某个项目设置了 Watch，那么该项目有任何更新都可以在第一时间收到通知 ——Fork​ 分叉，如果你看到别人一个好的开源项目，你想要做些改进，就可以Fork对方的项目（本质上相当于新建了一个分支） ——clone ​ 克隆，用于将代码克隆到本地 ——Pull Request​ 发起请求，如果你Fork了别人的项目并做了改进，想要把自己的改进合并到对方的项目中，就可以发起合并请求。原作者如果同意，你的改进就加到了原项目中 ——Gist​ 用于分享代码片段 ——Organizations ​ 组织，用于组织和团队 3创建自己的项目： ​ 1) 点击右上角下三角号-&gt;New repository ​ 2) 会出现如下界面： ​ 这样一个项目就创建成功啦～ 4.如何对其他开源项目进行贡献？ ​ 1)fork ​ 在想要修改的他人项目页面，点击右上角【fork】 ​ 这时候就会将该项目克隆到你的github仓库中 2)clone ​ 在本地利用git clone命令，将项目克隆到自己电脑上 3)update ​ 接下来就可以在本地对项目进行修改（建议在master上切出一个新分支进行修改，修改完后再将分支merge到master） 4)push ​ 使用git push命令将改动同步到自己的gitHub项目仓库里 5)pull request ​ 向原作者提交代码,点击文件列表上的【New pull request】 ​ 系统检查无误显示Able to merge后，就可以点击【Create pull request】进行提交 ​ 之后系统会让写一段注释，用于向原作者阐述你做了哪些修改和优化。若原作者同意将你的代码合并到原项目中，就可以点击【merge pull request】 5.修改其他开源项目时原项目发生改变时 如何保持同步？ 1)fetch ​ 先把原项目fetch到自己电脑本地 git fetch git@github.com:原作者/原作者项目 master:latest ​ master是原项目分支，latest是自己项目分支。若latest分支不存在的话，将自动创建。其实也可以将代码fetch到自己的master分支，但不建议这么做 2)merge ​ 代码fetch到latest分支之后，再切到master分支使用git merge命令将最新代码合并到master分支 3)push ​ 再使用git push命令，就可以将最新代码推到自己的github项目中 参考： ​ 如何在GitHub上大显身手？]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛I乘胜追击]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BI%E4%B9%98%E8%83%9C%E8%BF%BD%E5%87%BB%2F</url>
    <content type="text"><![CDATA[Description 三国时期，群雄割据，战乱频繁。公元228年，孙权派番阳太守周鲂诱骗曹休派兵前来，曹休果然中计。待孙权任陆逊为大都督，朱桓、全琮为左、右督，各领兵三万人迎击曹休时，曹方知被欺。但其仗恃兵力占优，仍决定与吴国交战。彼时陆逊所率大军与与曹休所率大军于石亭展开激战。陆逊探得曹休于长江边共驻扎n座军营，相互以粮道连接，其中第1座军营为大本营。当第i(i&gt;=2)座军营被攻陷时，营中残兵败将将沿粮道向第f[i]座军营逃窜。陆逊极善用兵，常人用a[i]的兵力方能攻下第i座军营，而陆逊仅需a[i]-d[i]的兵力即可攻下。倘给陆以a[i]的兵力，则陆不仅能攻下第i座军营，还可乘胜追击，沿着军士逃跑方向攻下第f[i]座军营。陆逊善用兵如此，故而仅用了最少的兵力便大破曹休，攻下所有军营，生擒一万余人，缴获牛马驴骡车辆上万。试问陆逊于石亭之战中共用兵力几何？（以上史料来自百度百科且有删改，不保证真实准确性） Input 第一行一个整数T(T&lt;=50)，代表数据组数在每组数据中：第一行一个整数n(2&lt;=n&lt;=50000)表示军营数目第二行有n-1个整数f【2】~f【n】(f【i】&lt;i)第三行有n个整数a【1】~a【n】(2&lt;=a【i】&lt;=1e9)第四行有n个整数d【1】~d【n】(1&lt;=d【i】&lt;a【i】) Output 对于每组数据，输出一行一个整数，表示陆逊攻下所有军营所需使用的最少兵力 Sample Input 1 4 1 1 3 100 50 2 5 2 49 1 1 Sample Output 7 Hint 输入数据量较大，请合理控制输入效率。 样例解释： 首先使用2兵力攻击军营3，并追击至大本营1。然后使用5-1=4兵力攻击军营4。最后使用50-49=1兵力攻击军营2。共使用兵力2+4+1=7。 思路： ​ 一道树形dp的题，比较难。二维数组dp【50005】【3】，其中dp【i】【0】代表以i本营为根节点的子树(攻打i本营无花费)的最小花费，dp【i】【1】代表以i本营为根节点的子树(攻打i本营花费a【i】- d【i】)的最小花费，dp【i】【2】代表以i本营为根节点的子树(攻打i本营花费a【i】)的最小花费。然后找到dp的递推式即可求出 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;int n;vector &lt;int&gt; zcy[50005];int two[50005], one[50005];ll dp[50005][3]; //dp[i][0]代表无花费，dp[i][1]代表仅攻克自己，dp[i][2]代表连带攻克父节点ll minn[50005];void dfs(int inx, int father) &#123; dp[inx][2] = two[inx]; dp[inx][1] = one[inx]; dp[inx][0] = 0; for (int i = 0; i &lt; zcy[inx].size(); i++) &#123; int ii = zcy[inx][i]; if (ii == father) continue; dfs(ii, inx); if (dp[ii][0]) &#123; minn[i] = min(dp[ii][0], dp[ii][1]); dp[inx][1] += minn[i]; dp[inx][2] += minn[i]; dp[inx][0] += minn[i]; &#125; else &#123; minn[i] = dp[ii][1]; dp[inx][1] += minn[i]; dp[inx][2] += minn[i]; dp[inx][0] += minn[i]; &#125; &#125; ll k = dp[inx][0]; if (k == 0) return; int suu = 0; for (int i = 0; i &lt; zcy[inx].size(); i++) &#123; int ii = zcy[inx][i]; if (ii == father) continue; if (!suu) &#123; dp[inx][0] = k - minn[i] + dp[ii][2]; &#125; else &#123; dp[inx][0] = min(dp[inx][0], k - minn[i] + dp[ii][2]); &#125; suu++; &#125;&#125;int main() &#123; int T, a; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d&quot;, &amp;n); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; zcy[i].clear(); &#125; for (int i = 2; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); zcy[i].push_back(a); zcy[a].push_back(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;two[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;one[i]); one[i] = two[i] - one[i]; &#125; dfs(1, 0); ll ans; if(dp[1][0]) &#123; ans = min(dp[1][0], dp[1][1]); &#125; else &#123; ans = dp[1][1]; &#125; printf(&quot;%lld\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018哈理工院个人赛、校团队赛总结]]></title>
    <url>%2F2018%2F12%2F10%2F2018%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E4%B8%AA%E4%BA%BA%E8%B5%9B%E3%80%81%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 院个人赛拿了亚军，校团队赛185支队伍拿了第五名。还算满意，今天打算总结总结～ ​ 哈理工院个人赛12月2号举行，10道题4个小时。题目比较简单～ ​ 两道水题 跳转到小乐乐玩木桶 和 跳转到小乐乐玩木桶+ 刚上来没理解题意，之后就过了～ ​ 一道最长公共子序列裸题 跳转到小乐乐匹配字符串 随后就A了 ​ 一道简单的思维题没过多久也A了，有一个小小的坑点 跳转到小乐乐的组合数 ​ 一道博弈题 跳转到小乐乐学博弈 写了很多样例，抱着试试看的态度交了一发过了，没在深思原因 ​ 一道模拟题 跳转到小乐乐和25 我是用模拟写的，考验的是细心吧 ​ 一道状压dp题 跳转到小乐乐搭积木 正好主攻dp和数论，这道题就笑纳啦 ​ 一道bfs题变形，调bug调到哭 跳转到小乐乐打游戏 现场赛没做出来，可恨的是我之前做过也做出来了。。快哭了 ​ 一道dp题 跳转到小乐乐下象棋 哎当时脑子笨了没想到，赛后重做发现还是蛮简单的 ​ 还有一道防Ak题好像是一道主席树变形，自己不主攻线段树也做不出来了 ​ 最后拿了院赛的亚军还行吧，冠军被增林老哥拿去了。膜拜膜拜！Orz～ ​ ​ 哈理工校团队赛12月9号举行，哈工大出题，题目中等偏难～ ​ 刚上来热身赛三道题：第一道大模拟被队友A了，自己懒得再补～ 第二道是一个01背包的变形题，秒A 跳转到信小呆 第三道是一个线性筛的变形题，也A了 跳转到孪生素数猜想 第一次AK，虽然是热身赛，也值得纪念一下，苦笑～ ​ 之后正式赛12道题5小时，最终做出来7个～ ​ 上来快速A掉一个暴力的水题 跳转到咕咕咕 ​ 然后过了一道抽屉原理的题 跳转到所以我也想玩这个序列游戏 ​ 队友过掉了一道二分题 跳转到汪汪汪 赛后自己补了一下 ​ 随后过了一道01分数规划 跳转到刘禅的课程 ​ 一道树形dp的题 跳转到树上路径计数 ​ 随后队友过了一道几何题，队友用算式推出了12维空间求解点关于直线的对称点的公式，膜拜Orz～自己不会就不补了 ​ 然后过了一道篇难的数论题 跳转到格子染色计数 ​ 赛后听题解I题也是一道树形dp，一直没往上靠，脑子好笨呀～赛后补了 跳转到乘胜追击 ​ 校赛第一不愧是亚洲区预赛金牌爷，10题膜拜膜拜Orz～ ​ 现在西区计院和东区软件学院差距越来越大了，前四名全是西区，前十名8个西区。。。无力。。。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛E格子染色计数]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BE%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意： Description 有排成一行的n个格子，你需要在 m 种颜色中选取 k 种颜色对这 n 个格子染色，要求k 种颜色都要使用，且相邻格子的颜色不同，求方案数（答案对 10^9 + 7取模）。 Input 第一行为测试数据组数T( 1 &lt;= T &lt;= 10).每组测试数据：第一行有两个个整数n, m, k. (1 &lt;= n, m &lt;= 1e9, k &lt;= 1e6)。 Output 一个整数, 为染色方案数, 输出答案对 1e9 + 7 取模. Sample Input 3 3 4 2 3 4 3 3 4 4 Sample Output 12 24 0 思路： ​ 这道题难度不小，需要利用卢卡斯定理+容斥定理+线性求阶乘逆元来求解～，答案为C(m,k)✖️(k✖️(k-1)^(n-1) - C(k,k-1)✖️(k-1)✖️(k-2)^(n-1) + C(k,k-2)✖️(k-2)✖️(k-3)^(n-1)…C(k,1)✖️1✖️0^(n-1)) 代码： #include &lt;stdio.h&gt;#define ll long long#define N 1000000#define mod 1000000007ll n, m, k;ll fact[N + 5], inv[N + 5];ll extend(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if(a == 0 &amp;&amp; b == 0) return -1; if (b == 0) &#123; x = 1; y = 0; return a; &#125; ll d = extend(b, a % b, y, x); y -= a / b * x; return d;&#125;ll reverse(ll a, ll n) &#123; ll x, y; ll d = extend(a, n, x, y); if (d == 1) return (x % n + n) % n; return -1;&#125;void init() &#123; fact[0] = fact[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; fact[i] = fact[i - 1] * i % mod; &#125; inv[N] = reverse(fact[N], mod); for (int i = N - 1; i &gt;= 0; i--) &#123; inv[i] = inv[i + 1] * (i + 1) % mod; &#125;&#125;ll C(ll n, ll m) &#123; if (n &lt; m || m &lt; 0) return 0; if (n &lt; mod) return fact[n] * inv[m] % mod * inv[n - m] % mod; return C(n / mod, m / mod) * C(n % mod, m % mod) % mod;&#125;ll ls(ll n, ll m) &#123; if (n &lt; m || m &lt; 0) return 0; ll mm = n - m; ll ans = 1; for (int i = mm + 1; i &lt;= n; i++) &#123; ans = i * ans % mod; &#125; return ans * inv[m];&#125;ll quick(ll a, ll b) &#123; ll ans = 1; while(b) &#123; if (b &amp; 1) &#123; ans = ans * a % mod; &#125; b /= 2; a = a * a % mod; &#125; return ans;&#125;int main() &#123; init(); int T; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k); ll ans = ls(m, k); ll t = k * quick(k - 1, n - 1) % mod; int tot = -1; for (int i = k - 1; i &gt;= 1; i --) &#123; t = (t + tot * (C(k, i) * i % mod * quick(i - 1, n - 1) % mod) + mod) % mod; tot = -tot; &#125; ans = ans * t % mod; printf(&quot;%lld\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛C树上路径计数]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BC%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意： Description 给定一棵有n个顶点的树，你需要统计出树上所有长度为奇数的路径数量。路径长度为经过边的条数。s 到 t 和 t 到 s视作相同。 Input 第一行为测试数据组数T( 1 &lt;= T &lt;= 5).每组测试数据：第一行有一个整数n（1 &lt;= n &lt;= 1e5），表示顶点数。接下来n - 1 行 每行两个整数u, v，表示u, v之间存在一条边。 Output 一个整数, 路径长度为奇数的数量。 Sample Input 2 2 1 2 4 1 2 2 3 1 4 Sample Output 1 4 思路： ​ 这道题典型的树形dp题，规定1节点为root，dp【i】【0】代表以i为根节点的子树的奇数子节点个数，dp【i】【1】代表以i为根节点的子树的偶数子节点个数，dp【1】【0】+dp【1】【0】✖️dp【1】【1】即为答案 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#define ll long longusing namespace std;int n;vector &lt;int&gt;zcy[100005];int dp[100005][2];void dfs(int inx, int father) &#123; for (int i = 0; i &lt; zcy[inx].size(); i++) &#123; int ii = zcy[inx][i]; if(ii ==father) continue; dfs(ii, inx); dp[inx][0] += dp[ii][1] + 1; dp[inx][1] += dp[ii][0]; &#125;&#125;int main() &#123; int T, a, b; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; memset(dp, 0, sizeof(dp)); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; zcy[i].clear(); &#125; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); zcy[a].push_back(b); zcy[b].push_back(a); &#125; dfs(1, 0); ll ans = (ll)dp[1][0] * (dp[1][1] + 1); printf(&quot;%lld\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛H刘禅的课程]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BH%E5%88%98%E7%A6%85%E7%9A%84%E8%AF%BE%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[题意： Description 刘禅对学习的态度让太傅操碎了心。刘禅有n种课程要学习（礼、乐、射、御、书、数等等），每个课程有对应的重要程度s[i]，刘禅估计了一下，机智的他算出了每个课程他最后能得到的分数c[i]， 太傅给出了他最终成绩的计算公式: 现在他可以推迟k门课程，使得他剩下的n-k门课程的最终成绩尽量高，因为这样父皇才会让他出宫玩耍。机智的刘禅已经算出了答案，不过他想考考你。输出最高的不少于n-k门课程的最终成绩。 Input 多组数据，请读入到文件末尾（数据组数不超过10）第一行两个非负整数n, k(1≤ n≤ 1e5 , 0≤ k &lt; n) 第二行n个正整数s[i] 第三行n个正整数c[i]1&lt;=s[i],c[i]&lt;=1000 Output 一个实数，四舍五入保留6位小数 Sample Input 3 1 1 2 3 3 2 1 Sample Output 2.333333 Hint 去掉最后一门课程即可。 (22+31)/(2+1)=7/3 思路： ​ 01分数规划的裸题，利用二分找结果ans，会得到si✖️ci/ si = ans ,只要贪心求的前n - k大的si✖️ci - ans✖️si的和，大于等于0返回1，否则返回0 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int a[100005], b[100005];int n, k;double t[100005];bool whd(double A, double B) &#123; return A &gt; B;&#125;bool zcy(double val) &#123; double sum = 0; for (int i = 0; i &lt; n; i++) &#123; t[i] = a[i] - val * b[i]; &#125; sort(t, t + n, whd); for (int i = 0; i &lt; n - k; i++) &#123; sum += t[i]; &#125; if (sum &gt;= 0) return 1; return 0;&#125;int main() &#123; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) &#123; double minn = 0, maxx= 0; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;b[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); a[i] = a[i] * b[i]; if (maxx &lt; a[i]) &#123; maxx = a[i]; &#125; &#125; double mid; for (int i = 0; i &lt; 80; i++) &#123; mid = (minn + maxx) / 2; if (zcy(mid)) minn = mid; else maxx = mid; &#125; printf(&quot;%.6f\n&quot;, mid); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>二分</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛K汪汪汪]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BK%E6%B1%AA%E6%B1%AA%E6%B1%AA%2F</url>
    <content type="text"><![CDATA[题意： Description 给n个区间[l, r]，判断是否存在区间交叉。即是否存在1 &lt;= i &lt; j &lt;= n，使得li &lt; lj &lt; ri &lt; rj。 Input 多组数据每组数据第一行一个整数n，第二行到第n + 1行每行两个数分别代表该区间的左右端点。 Output 如果存在交叉，输出“YES”；否则输出“NO” Sample Input 2 1 3 2 4 3 1 7 2 4 5 6 Sample Output YES NO Hint 1 &lt;= n &lt;= 1e5, 1 &lt;= li &lt; ri &lt;= 2e5, 每组数据中所有的l，r互不相同。所有组数据n的和不超过1e6.读入数据较大，请使用高效的读入方式。 思路： ​ 利用sort按照l从小到大排序，若l相同则按照r从小到大排序，然后遍历，二分查找即可。 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;namespace IO &#123; const int MX = 4e7; char buf[MX]; int c, sz; void begin() &#123; c = 0; sz = fread(buf, 1, MX, stdin); &#125; inline bool read(int &amp;t) &#123; while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++; if (c &gt;= sz) return false; bool flag = 0; if(buf[c] == &apos;-&apos;) &#123; flag = 1; c++; &#125; for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) t = t * 10 + buf[c] - &apos;0&apos;; if(flag) t = -t; return true; &#125;&#125;struct node &#123; int l, r;&#125;stu[100005];int n;bool zcy(node A, node B) &#123; if (A.l == B.l) &#123; return A.r &lt; B.r; &#125; return A.l &lt; B.l;&#125;;int erfen(int val) &#123; int star = 0, endd = n - 1; int ans = -1; while(star &lt;= endd) &#123; int mid = (star + endd) / 2; if (stu[mid].l &lt;= val) &#123; star = mid + 1; &#125; else &#123; ans = mid; endd = mid - 1; &#125; &#125; return ans;&#125;int main () &#123; IO::begin(); while (IO::read(n)) &#123; for (int i = 0; i &lt; n; i++) &#123; IO::read(stu[i].l); IO::read(stu[i].r); &#125; sort(stu, stu + n, zcy); int flag = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int inx = erfen(stu[i].l); if (inx == -1) &#123; break; &#125; for (int j = inx; j &lt; n &amp;&amp; stu[j].l &lt; stu[i].r; j++) &#123; if(stu[j].r &gt; stu[i].r) &#123; flag = 1; break; &#125; &#125; if (flag) &#123; break; &#125; &#125; if (flag) &#123; printf(&quot;YES\n&quot;); &#125; else &#123; printf(&quot;NO\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛D所以我也想玩这个序列游戏]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BD%E6%89%80%E4%BB%A5%E6%88%91%E4%B9%9F%E6%83%B3%E7%8E%A9%E8%BF%99%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题意： Description 今天dxy休息，他想出了一个序列游戏，具体描述如下：你有一个长度为n的正整数序列和一个正整数m，问其中是否存在一个非空子区间使得这个子区间的区间和是m的倍数。 Input 多组数据，读入到文件结尾对于每一组数据第一行：两个数n,m第二行：n个正整数，表示题目中的序列n&lt;=10^6，m&lt;=2000，0&lt;a[i]&lt;=10^9 Output 对于每组数据输出一行：若存在所描述的区间，则输出YES，否则输出NO Sample Input 5 3 1 2 3 4 5 5 100 1 2 3 4 5 Sample Output YES NO 思路： ​ 这道题主要利用了抽屉原理，长度为n的一个数组，若n大于等于m，则一定存在一个子区间的和是m的倍数。当n &lt; m时，由于m小于2000，直接暴力求解即可 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ll long longint a[1000005];ll sum[1000005];int main () &#123; int n, m; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123; memset(sum, 0, sizeof(sum)); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum[i] = sum[i - 1] + a[i]; &#125; if (n &gt;= m) &#123; printf(&quot;YES\n&quot;); continue; &#125; int flag = 0; for (int len = 1; len &lt;= n; len++) &#123; for (int i = 1; i + len - 1 &lt;= n; i++) &#123; if ((sum[i + len - 1] - sum[i - 1]) % m == 0) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; break; &#125; &#125; if(flag) &#123; printf(&quot;YES\n&quot;); &#125; else &#123; printf(&quot;NO\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
        <tag>抽屉原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛B咕咕咕]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BB%E5%92%95%E5%92%95%E5%92%95%2F</url>
    <content type="text"><![CDATA[题意： Description 给你一个字符串，请数出有多少个连续字符串”CCPC”，不区分大小写。 Input 输入第一行是数据组数T（T&lt;=10）接下来T行每行有一个字符串。（字符串仅由大小写英文字母构成，长度&lt;=100000） Output 输出T行，每行输出对应字符串中”CCPC”的个数 Sample Input 2 CCpc aCCpcCpcecpC Sample Output 1 2 思路： ​ 大水题，暴力就完了～ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;char s[100005];int main () &#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int sum = 0; scanf(&quot;%s&quot;, s); int n = strlen(s); for (int i = 0; i &lt; n - 3;i++) &#123; if ((s[i] == &apos;C&apos; || s[i] == &apos;c&apos;) &amp;&amp; (s[i + 1] == &apos;C&apos; || s[i + 1] == &apos;c&apos; ) &amp;&amp; (s[i + 2] == &apos;P&apos; || s[i + 2] == &apos;p&apos;) &amp;&amp; (s[i + 3] == &apos;C&apos; || s[i + 3] == &apos;c&apos;)) &#123; sum ++; &#125; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛热身B信小呆]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABB%E4%BF%A1%E5%B0%8F%E5%91%86%2F</url>
    <content type="text"><![CDATA[题意： Description ​ 小g得到一张满x减x的购物劵，他想在自己购物车中选择一部分物品来买，购物车里没种物品只能买一件，并且他想尽量少花钱。由于小g很穷很笨，如果它购物车里所有物品价值总和比x小，那么他只能选择放弃这张优惠劵 ​ 也就是说他会在n个物品中选若干，使得花费总和大于等于x且最小 ​ 问花费最少的钱能拿到货物的最大价值是多少？ Input ​ 输入第一行是t(t &lt;= 100)，表示t组样例。接下来输入n和x (0 &lt; n &lt; 100, 0 &lt; x &lt; 10000)，代表小g购物车有n件物品，优惠劵满x减x，接下来一行有n个数(0 &lt; ai &lt; 100)代表n个物品的价格 Output ​ 对于每组样例，请输出“Case x: y”, x是输入样例组数，y是小g在花最少的钱能拿到货物的最大价值 Sample Input 2 3 10 1 2 3 3 10 5 6 3 Sample Output Case 1: 0 Case 2: 11 思路： ​ 01背包的变形题,dp【i】代表总价值为i的货物搭配是否存在(1存在，0不存在)，然后从x开始遍历，若存在dp【i】则直接输出并跳出，不存在输出0 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;bool dp[10005];int main() &#123; int T, tot = 0, a, n, x; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; memset(dp, 0, sizeof(dp)); scanf(&quot;%d%d&quot;, &amp;n, &amp;x); dp[0] = 1; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); for (int j = i * 100; j &gt;= 0; j--) &#123; if (dp[j]) &#123; dp[j + a] = 1; &#125; &#125; &#125; int flag = 0; for (int i = x; i &lt;= n * 100; i++) &#123; if(dp[i]) &#123; flag = i; break; &#125; &#125; printf(&quot;Case %d: %d\n&quot;, ++tot, flag); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工第八届校团队赛热身C孪生素数猜想]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABC%E5%AD%AA%E7%94%9F%E7%B4%A0%E6%95%B0%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[题意： Description ​ 素数只能被1和自身整除，孪生素数猜想为：存在无穷多个素数对形如（p, p + 2），如3和5， 11和13等 ​ 先给定一个数k，判断k是否为孪生素数 Input ​ 输入第一行是t(t &lt;= 100)，代表数据组数，接下来每组数据输入一个k(2 &lt; k &lt; 100000) Output ​ 对于每组样例，请输出“Case x: y”, x是输入样例组数，如果是孪生数输出Yes，否则输出No Sample Input 3 5 23 30 Sample Output Case 1: Yes Case 2: No Case 3: No 思路： ​ 直接线性筛出1e5 + 2以内的全部素数，然后从素数中再筛选出全部的孪生素数并标记为1.直接判断book[k]是否为1，1Yes，0No 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100002bool book[N + 5];int prime[N + 5];void init() &#123; memset(book, 0, sizeof(book)); prime[0] = 0; for (int i = 2; i &lt;= N; i++) &#123; if (!book[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt;= N; j++) &#123; book[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125; memset(book, 0, sizeof(book)); for (int i = 2; i &lt; prime[0]; i++) &#123; if ((prime[i] - 2 == prime[i - 1]) || (prime[i] + 2 == prime[i + 1])) &#123; book[prime[i]] = 1; &#125; &#125; if(prime[prime[0]] - 2 == prime[prime[0] - 1]) &#123; book[prime[0]] = 1; &#125; return;&#125;int main () &#123; init(); int T, k, tot = 0; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; scanf(&quot;%d&quot;, &amp;k); if(book[k]) &#123; printf(&quot;Case %d: Yes\n&quot;, ++tot); &#125; else &#123; printf(&quot;Case %d: No\n&quot;, ++tot); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言核心技术-第三章]]></title>
    <url>%2F2018%2F12%2F08%2FC%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第三章 字面量 3.1 整数常量 ​ 十进制常量起始数字不可为0 ​ 以0开始的数字会被解释成八进制 ​ 十六进制以0x或0X作前缀 ​ 解析下面两行代码： 3.2浮点常量 ​ 默认类型为double，也可用后缀f或F来说明该常量是float型 3.3字符串常量 ​ 字符串常量可以初始一个char数组，也可以初始化一个指向char的指针，例： char *p = &quot;hello, zcy!&quot;; //p指向字符&apos;h&apos; ​ 虽然C语言没有严格禁止修改指针指向的字符串字面量，但也不能试图这么做，以下做法是不好的： char *p = &quot;hello, zcy!&quot;;*p = &quot;hi, acm!&quot;; //这样做很不好 ​ 这样做导致语句不具备可移植性，在某些系统下会产生运行错误。原因有两个： ​ （1）一些编译器将字符串字面量视为常量，可能将其存在只读存储器中，对其进行写操作将会产生错误 ​ （2）程序中有两个或更多完全相同的字符串字面量，编译器可能会将它们存储在相同的位置，因此修改一个字符串会对其他字符串造成影响。 ​ 而使用字符串字面量初始的数组变量不会产生这种影响]]></content>
      <tags>
        <tag>C核心技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言核心技术-第二章下]]></title>
    <url>%2F2018%2F12%2F08%2FC%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[第二章 数据类型 2.3 对象在内存中的对齐方式 ​ 类型都对其对象限定了对应的对齐方式，也就是说类型指定了该类型对象的内存地址形式。形式诸如所有地址都可存储，偶数地址开始存储，被4整除地址开始存储等等。一个类型的对齐用该类型两个连续对象在内存中相距的字节数表示 2.3.1 _Alignof操作符 ​ _Alignof用于判断一个类型的对齐，使用格式为： _Alignof(int) //此时返回4 2.3.2 _Alignas修饰符 ​ _Alignas用于规定对齐值，例如： _Alignof(4) short a; //定义一个拥有4字节对齐值的short类型变量a]]></content>
      <tags>
        <tag>C核心技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言核心技术-第二章上]]></title>
    <url>%2F2018%2F12%2F08%2FC%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[第二章 数据类型 ​ C语言中，对象引用到内存中的一个位置，该位置内容可表示为该对象的值。一个对象的数据类型决定了这个对象在内存中所占用的空间大小，以及所采用的编码方式 2.1 整数类型 ​ char类型也是一个标准的整数类型 ​ C语言只定义了标准类型最小的存储空间，char类型只占用一个字节，short类型至少占用2字节，long类型至少占用4字节，long long类型至少占用8字节(1字节 == 8位) 2.1.1stdint.h头文件 ​ stdint.h头文件定义了整数类型以满足对于已知位长的定义： ​ intN_t / uintN_t 位长为N的整数/无符号整数 ​ int_leastN_t / uint_leastN_t 位长至少为N的整数/无符号整数 ​ int_fastN_t / uint_fastN_t 位长至少为N的最快速的整数/无符号整数 ​ intmax_t / uintmax_t 位长最大的整数/无符号整数 ​ intptr_t / uintptr_t 位长足以存储指针值的整数/无符号整数 ​ 关于intptr_t的足以存储指针值的整数如何理解，我百度了一下它的宏定义： /* Types for `void *&apos; pointers. */#if __WORDSIZE == 64 # ifndef __intptr_t_defined typedef long int intptr_t; # define __intptr_t_defined # endif typedef unsigned long int uintptr_t;#else # ifndef __intptr_t_defined typedef int intptr_t; # define __intptr_t_defined # endif typedef unsigned int uintptr_t; #endif ​ 显然，intptr_t不是指针类型，而是long int型。至于为什么解释成void *指针，尽管概念上地址是指针, 但内存管理常常使用一个无符号整型更好地完成。因为内核对待物理内存如同一个大数组，并且内存地址只是一个数组索引。而一个指针容易解引用，当直接处理内存存取时, 使用一个整数类型能避免这种解引用，因此避免了 bug。所以内核中内存地址常常是unsigned long型。（关于解引用，可以解释为返回内存地址中保存的值，关于它的解释找到一篇特别好的博文 跳转 ） 2.1.2limits.h头文件 ​ 该头文件有很多宏定义，用于获得整数类型的范围，例如：INT_MIN,UINT_MAX,INT_LEAST64_MIN 等等 2.2浮点类型 ​ 关于浮点类型精度丢失的原因： ​ 是因为我们在程序里写的是十进制小数，而计算机内部只能用二进制的小数表示, 所以导致无法精确的表达 ​ 对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n），所以十进制小数都是由这些小数一点点拼凑出来的一个近似值, 所以才会不准确 ​ 例如用二进制来表示十进制的1.2:​ 1.01 = 1 + 1/4 = 1.25 , 偏大​ 1.001 = 1 + 1/8 = 1.125 , 偏小​ 1.0011 = 1 + 1/8 + 1/16 = 1.1875，偏小​ 1.001101 = 1 + 1/8+ 1/16 + 1/64 = 1.203125 , 偏大​ 1.0011001 = 1 + 1/8 + 1/16 + 1/128 = 1.1953125 ,偏小​ 1.00110011 = 1 + 1/8+1/16+1/128+1/256 = 0.19921875 , 偏小​ 直到越来越接近…这就是精度缺失的根本原因]]></content>
      <tags>
        <tag>C核心技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言核心技术—第一章下]]></title>
    <url>%2F2018%2F12%2F07%2FC%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[第一章：C语言基础 1.6编译器运行原理 ​ 用文本编辑器写完源码，编译器对翻译单元进行处理，若没有发现错误，则会生成包含对应机器码的目标文件（扩展名为.o或.obj） ​ 目标文件也成为模块，一个链接库包含多个编译好可以快速获取的模块 ​ 然后编译器调用链接器将所有目标文件和所用到的链接库函数结合起来，成为一个可执行文件 1.6.1编译的8个逻辑步骤 ​ (1)从源码读取并转换字符，如有必要将字符转换成源代码字符集的字符 ​ (2)无论何时，只要反斜线后紧跟换行符，预处理器都会将两者删除，因为行尾字符视为预处理器命令的终止，反斜线可让预处理命令（如宏定义）可以在下一行继续 ​ (3)将源码文件分解为若干预处理器标记和空格符序列，每个注释被看作一个空格 ​ (4)执行预处理命令，展开宏调用 ​ //1～4不仅作用于源码文件，也作用于#include命令插入的文件。 ​ (5)字符常量和字符串字面量中的字符和转义序列被转换成运行字符集中对应的字符 ​ (6)相邻字符串字面量被连接为一个字符串 ​ (7)编译器分析标记序列，生成对应机器码 ​ (8)链接器解析对外部函数和对象的引用，并生成可执行文件 1.6.2标记 ​ 标记可以是关键字、标识符、常量、字符串字面量、符号 ​ 将源码解析成标记过程中，采用原则如下： ​ 为避免歧义，每个连续的非空格符必须附加到正在读取的标记后面，直到出现附加后使得有效标记变为无效为止 ​ 例如：a+++b。第一个+无法当作标识符的一部分，也不能当作以a开头的关键字的一部分，所以+是一个新标记的开始。第二个+附加到第一个+后面形成一个有效标记++，第三个+附加上来+++不是有效标记，因此表达式被分解成a++ + b]]></content>
      <tags>
        <tag>C核心技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言核心技术—第一章上]]></title>
    <url>%2F2018%2F12%2F07%2FC%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[第一章：C语言基础 1.1C语言程序结构 ​ 函数定义，全局声明和预处理命令组成了C语言程序 1.1.1 关于链接库： ​ C语言链接库除标准库外，还有许多特殊链接库可以使用，例如图形函数链接库。 ​ 如果使用非标准库，会限制所开发程序的可移植性。这些程序只能移植到已经加载了这些非标准库的系统上 1.1.2关于预处理命令 ​ 函数中调用的每个函数需要在该函数前声明，预处理命令#include&lt;.h&gt;指示编译器的预处理器将该头文件内容插入到源代码中，以达到声明头文件中函数的目的。 ​ 预处理命令每条需独占一行，且#前只能有空格符或制表符，不可有其它字符（若想换行可在前一行最后加反斜线） 1.1.3关于函数 ​ C语言由函数组成，一个函数可以调用其他函数。函数的定义不能嵌套在另一个函数内（也就是说函数内可以定义局部变量，但是不能定义局部函数） 1.2源代码文件 1.2.1模块化 ​ C语言支持模块化，也就是将一个程序组织成多个源代码文件和头文件，然后分别编译他们 ​ 对于一个包含多个源文件的程序，可利用头文件来存储函数的声明、全局变量、宏与常量。并通过引用头文件来间接声明它们。 1.2.2编译单元与标记 ​ 每个C源代码文件连同被包含在其中的头文件，构成一个翻译单元。 ​ 编译器按次序处理编译单元的内容，把源代码转换成标记。标记是最小的语义单元，如变量名称与运算符 1.3注释 ​ 预处理器仅通过检查注释的结束符来判定注释结束，因此不能嵌套块注释。若想注释包含块注释的代码，可使用条件预处理命令，例： #if 0 /*如果true则执行之间的代码，false直接跳过 0代表false) int a = 5; /*定义a*/ printf(&quot;%d\n&quot;, a); /*输出a*/#endif ​ 预处理会把每个注释都替换成一个空格 1.4环境 ​ 编译器转换程序源代码时，所处环境称为编译环境 ​ 编译后程序执行，所处环境称为运行环境 1.5字符集 ​ C语言定义了两个字符集：源代码字符集和运行字符集。源代码字符集用于组成源码，运行字符集是可以被执行程序解释的字符集 ​ 在许多C语言实现版本中，两个字符集相同。若不同，则编译器会把源代码中的字符常量和字符串字面量转换成运行字符集中对应的元素 1.5.1宽字符和多字节字符 ​ 为兼容全球的所有语言，有些字符需要超过一个字节来编码。因此出现了两种表示大型字符集的标准化方法： ​ 宽字符：该字符集内，每个字符使用相同的位长 ​ 多字节字符：每个字符可以采用一个或多个字节表示，通过它所在字符串或流的上下文，来确定字符值 1.5.2双字符组和三字符组 ​ 有些符号在键盘无法输入，可采用一些等效方法实现。例如双字符组和三字符组。 ​ 例如：&lt;: 等价为 [ ​ %&gt; 等价为 } ​ ??&lt; 等价为{ 等等 1.5.3通用符和标识符 ​ 通用符即Unicode值，格式为\uXXXX或\UXXXXXXXX （X为16进制数），可用于标识符、字符常量、字符串字面量。 ​ 标识符用于引用变量、函数、宏、结构以及其他定义的对象]]></content>
      <tags>
        <tag>C核心技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-12-04博客搭建进度]]></title>
    <url>%2F2018%2F12%2F04%2F18-12-04%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间（11.13更新） ​ ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新） ​ ——新增动态背景(11.28更新) ​ ——修改网站图片外链至本地（11.28更新） ​ ——博文尾部自动添加声明（11.29更新） ​ ——实现博文字数统计（11.29更新） ​ ——添加顶部加载条（11.29更新） ​ ——添加简历页 (11.30更新) ​ ——调整底部布局 (12.02更新) ​ ——新增小游戏——见缝插针 (12.02更新) ​ ——修复音乐弹出、小火箭移动端错误问题 ​ ——更新“关于我”页面特效]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-12-02博客搭建进度]]></title>
    <url>%2F2018%2F12%2F02%2F18-12-02%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间（11.13更新） ​ ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新） ​ ——新增动态背景(11.28更新) ​ ——修改网站图片外链至本地（11.28更新） ​ ——博文尾部自动添加声明（11.29更新） ​ ——实现博文字数统计（11.29更新） ​ ——添加顶部加载条（11.29更新） ​ ——添加简历页 (11.30更新) ​ ——调整底部布局 ​ ——新增小游戏——见缝插针]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐搭积木]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%90%AD%E7%A7%AF%E6%9C%A8%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐想要给自己搭建一个积木城堡。 积木城堡我们假设为n*m的平面矩形。 小乐乐现在手里有12，21两种地砖。 小乐乐想知道自己有多少种组合方案。 输入描述: 第一行输入整数n,m。(1&lt;=n,m&lt;=10) 输出描述: 输出组合方案数。 示例1 输入 2 3 输出 3 示例2 输入 1 3 输出 0 示例3 输入 2 5 输出 8 思路： ​ 状压dp的入门题，把每一行的状态压缩成一个二进制数（竖为1横为0），然后转化为十进制。依次遍历第一行的所有状态方案数都初始化为1，然后依据dp递推式推出其余行。最后累加最后一行的所有可行性方案的和即可。 代码： #include&lt;cstdio&gt;#include&lt;cstring&gt;#define ll long long#define Maxn 2048using namespace std;int chg[Maxn*Maxn][2];ll dp[1&lt;&lt;13][13];int n,m,tot; void dfs(int c,int s,int scur)&#123; if(c&gt;m) return; if(c==m)&#123; chg[tot][0]=s; chg[tot++][1]=scur; return; &#125; dfs(c+1,s&lt;&lt;1,scur&lt;&lt;1|1); dfs(c+1,s&lt;&lt;1|1,scur&lt;&lt;1); dfs(c+2,s&lt;&lt;2|3,scur&lt;&lt;2|3);&#125; int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(m&gt;n) &#123; int kk = m; m = n; n = kk; &#125; tot=0; dfs(0,0,0); memset(dp,0,sizeof dp); dp[(1&lt;&lt;m)-1][0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;tot;j++) dp[chg[j][1]][i]+=dp[chg[j][0]][i-1]; &#125; printf(&quot;%lld\n&quot;,dp[(1&lt;&lt;m)-1][n]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐打游戏]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%89%93%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目描述 ​ 小乐乐觉得学习太简单了，剩下那么多的时间好无聊，于是便想打游戏。​ 最近新出了一个特别火的游戏，叫吃猪，小乐乐准备玩一玩。​ 吃猪游戏很简单，给定一个地图，大小为n*m，在地图中会随机出现一个火山口，只要小乐乐能逃离这个地图，他便能吃猪！​ 但吃鸡远没有那么简单：​ 1.小乐乐每走一次只能上下左右四个方向中走一步。​ 2.小乐乐每走一步，火山喷发的岩浆就会向四周蔓延一个格子，所有岩浆走过的地方都视为被岩浆覆盖。​ 3.小乐乐碰到岩浆就会死。​ 4.地图中还有很多障碍，使得小乐乐不能到达，但是岩浆却可以把障碍融化。​ 5.小乐乐只有走到题目给定的终点才算游戏胜利，才能吃猪。​ 小乐乐哪见过这场面，当场就蒙了，就想请帮帮他，告诉他是否能吃猪。 输入描述: 多组样例输入第一行给定n,m,(1 &lt;= n, m &lt;= 1000)代表地图的大小。接下来n行，每一行m个字符，代表地图，对于每一个字符，如果是&apos;.&apos;，代表是平地，&apos;S&apos;代表小乐乐起始的位置，&apos;E&apos;代表终点，&apos;#&apos;代表障碍物，&apos;F&apos;代表火山口。 输出描述: 输出只有一行。如果小乐乐能吃猪，输出&quot;PIG PIG PIG!&quot;。否则输出&quot;A! WO SI LA!&quot;。 示例1 输入 3 3F..#S##.E 输出 PIG PIG PIG! 思路： ​ 两个BFS，注意下细节即可。。。 代码： #include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int x,y,foot;&#125;;int dx[5]=&#123;0,1,-1,0&#125;,n,m;int dy[5]=&#123;1,0,0,-1&#125;;char a[1001][1001];int vis[1001][1001];int footstep[1001][1001];int bfs(int startx,int starty)&#123; deque&lt;node&gt;Q; node start; start.x = startx; start.y = starty; start.foot = 0; vis[startx][starty] = 1; Q.push_back(start); while(!Q.empty())&#123; node now = Q.front(); Q.pop_front(); // printf(&quot;x=%d y=%d foot = %d\n&quot;,now.x,now.y,now.foot); for(int i = 0; i &lt; 4; i++)&#123; int x = now.x+dx[i]; int y = now.y+dy[i]; if(x&gt;=0&amp;&amp;x&lt;n &amp;&amp;y&gt;=0&amp;&amp;y&lt;m &amp;&amp; a[x][y] != &apos;#&apos; &amp;&amp; a[x][y] != &apos;F&apos;&amp;&amp; !vis[x][y] &amp;&amp; now.foot+1&lt;=footstep[x][y])&#123; if(a[x][y] == &apos;E&apos;)&#123; return now.foot+1; &#125; vis[x][y] = 1; node then; then.x = x; then.y = y; then.foot = now.foot+1; Q.push_back(then); &#125; &#125; &#125; Q.clear(); return 0;&#125;void bfs1(int startx,int starty)&#123; deque&lt;node&gt;Q; node start; start.x = startx; start.y = starty; start.foot = 0; footstep[startx][starty] = 0; vis[startx][starty] = 1; Q.push_back(start); while(!Q.empty())&#123; node now = Q.front(); Q.pop_front(); for(int i = 0; i &lt; 4; i++)&#123; int x = now.x+dx[i]; int y = now.y+dy[i]; if(x&gt;=0&amp;&amp;x&lt;n &amp;&amp;y&gt;=0&amp;&amp;y&lt;m &amp;&amp;!vis[x][y])&#123; footstep[x][y] = now.foot+1; vis[x][y] = 1; node then; then.x = x; then.y = y; then.foot = now.foot+1; Q.push_back(then); &#125; &#125; &#125; Q.clear();&#125; int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; int Sx,Sy,Ex,Ey; for(int i = 0; i &lt; n; i++)&#123; scanf(&quot;%s&quot;,a[i]); for(int j = 0; j &lt; m; j++)&#123; if(a[i][j] == &apos;S&apos;)&#123; Sx = i,Sy = j; &#125;else if(a[i][j] == &apos;F&apos;)&#123; Ex = i,Ey = j; &#125; &#125; &#125; memset(footstep,0,sizeof(footstep)); memset(vis,0,sizeof(vis)); bfs1(Ex,Ey); memset(vis,0,sizeof(vis)); int ans1 = bfs(Sx,Sy); if(ans1)&#123; printf(&quot;PIG PIG PIG!\n&quot;); &#125;else&#123; printf(&quot;A! WO SI LA!\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐下象棋]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E4%B8%8B%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐一天天就知道玩，这一天又想玩象棋。我们都知道马走日。现在给定一个棋盘，大小是n*m,把棋盘放在第一象限，棋盘的左下角是(0,0),右上角是(n - 1, m - 1);小乐乐想知道，一个马从左下角(0, 0)开始，走了k步之后，刚好走到右上角(n - 1, m - 1)的方案数。 输入描述: 输入：多组样例输入，每组一行，三个整数n, m, k(1 &lt;= n, m, k &lt;= 200),如题目所示。 输出描述: 输出：输出答案 mod 1000000007 示例1 输入 4 4 2 输出 2 思路： ​ 设置dp【i】【j】【k】代表第k步到达坐标为(i,j)的方案数，然后三层for循环找8个方向即可 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define mod 1000000007long long dp[205][205][205];int fx[8][2] = &#123;1, 2, 2, 1, -1, 2, -2, 1, -1, -2, -2, -1, 1, -2, 2, -1&#125;;int main () &#123; int n, m, k; while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) &#123; memset(dp, 0, sizeof(dp)); dp[0][0][0] = 1; for (int p = 1; p &lt;= k; p++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int q = 0; q &lt; 8; q++) &#123; int ii = i + fx[q][0]; int jj = j + fx[q][1]; if (ii &gt;= 0 &amp;&amp; ii &lt; n &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; m) &#123; dp[i][j][p] = (dp[i][j][p] + dp[ii][jj][p - 1]) % mod; &#125; &#125; &#125; &#125; &#125; printf(&quot;%lld\n&quot;, dp[n - 1][m - 1][k]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐和25]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%92%8C25%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐特别喜欢25这个数字，他想把所有的数字都变成25的倍数。现在小乐乐得到一个数字，想问问你最少用几次操作才可以把这个数字改造成25的倍数。对于一次操作我们可以把相邻的两位做交换，比如123经过一次操作之后就可以变成213或者132。 输入描述: 多组数据输入对于每组数据，只有一行输入一个整数n(1 &lt;= n &lt;= 1000000000)。 输出描述: 如果经过最少x次操作后，这个数就变成了25的倍数，那么输出x；如果这个数无论怎么变化都变不成25的倍数，输出-1. 示例1 输入 2018 输出 -1 示例2 输入 2020 输出 1 说明 经过一次之后变成2200 思路： ​ 要想是25的倍数，只要保证最后最后两位是00或者25或者50或者75即可。然后对这四种情况进行模拟即可 代码： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;using namespace std;int a[15];int main() &#123; int n; while(scanf(&quot;%d&quot;, &amp;n) == 1) &#123; int num0 = 0, num2 = 0, num5 = 0, num7 = 0; int tot = 0, flag = 0; int minn = 0x3f3f3f3f; while(n) &#123; a[++tot] = n % 10; n /= 10; if (a[tot] == 0) &#123; num0++; &#125; else if(a[tot] == 2) &#123; num2++; &#125; else if(a[tot] == 5) &#123; num5++; &#125; else if(a[tot] == 7) &#123; num7++; &#125; &#125; if (num0 &gt;= 2) &#123; flag = 1; int aa[15]; int ls = 0; for (int i = 1; i&lt;= tot; i++) &#123; aa[i] = a[i]; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if(aa[i] == 0) &#123; ls += abs(i - 1); for (int j = i; j &gt; 1; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; for (int i = 2; i &lt;= tot; i++) &#123; if(aa[i] == 0) &#123; ls += abs(i - 2); for (int j = i; j &gt; 2; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; minn = min(minn, ls); &#125; if (num2 &gt;= 1 &amp;&amp; num5 &gt;= 1) &#123; flag = 1; int aa[15]; int ls = 0; for (int i = 1; i&lt;= tot; i++) &#123; aa[i] = a[i]; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if(aa[i] == 5) &#123; ls += abs(i - 1); for (int j = i; j &gt; 1; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; for (int i = 2; i &lt;= tot; i++) &#123; if(aa[i] == 2) &#123; ls += abs(i - 2); for (int j = i; j &gt; 2; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; minn = min(minn, ls); &#125; if(num5 &gt;= 1 &amp;&amp; num0 &gt;= 1) &#123; flag = 1; int aa[15]; int ls = 0; for (int i = 1; i&lt;= tot; i++) &#123; aa[i] = a[i]; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if(aa[i] == 0) &#123; ls += abs(i - 1); for (int j = i; j &gt; 1; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; for (int i = 2; i &lt;= tot; i++) &#123; if(aa[i] == 5) &#123; ls += abs(i - 2); for (int j = i; j &gt; 2; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; minn = min(minn, ls); &#125; if(num7 &gt;= 1 &amp;&amp; num5 &gt;= 1) &#123; flag = 1; int aa[15]; int ls = 0; for (int i = 1; i&lt;= tot; i++) &#123; aa[i] = a[i]; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if(aa[i] == 5) &#123; ls += abs(i - 1); for (int j = i; j &gt; 1; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; for (int i = 2; i &lt;= tot; i++) &#123; if(aa[i] == 7) &#123; ls += abs(i - 2); for (int j = i; j &gt; 2; j--) &#123; aa[j] = aa[j - 1]; &#125; break; &#125; &#125; minn = min(minn, ls); &#125; if (!flag) &#123; printf(&quot;-1\n&quot;); &#125; else &#123; printf(&quot;%d\n&quot;, minn); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐学博弈]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%AD%A6%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐和小皮蛋开始学习关于博弈的知识。给定两堆石子，第一堆有n个石子，第二堆有m个石子。每次操作可以从一堆石子中拿走一些石子，拿走石子的数量可以是1 - k个，小乐乐先手拿石子，然后依次轮流。假如到小乐乐的轮次，小乐乐拿不了了(也就是所有的石子都被拿光了)，那么小皮蛋就获胜，反之亦然。假设小乐乐和小皮蛋都绝顶聪明，都会采用最佳的策略，请问最后谁会赢。 输入描述: 多组数据输入，对于每一组数据，只有一行由空格分开的三个整数n, m, k(0 &lt;= n, m &lt;= 1000000000, k &gt;= |n - m|). 输出描述: 如果小乐乐会赢，输出&quot;HAI YOU SEI!&quot;,否则输出&quot;LAOZI CHUI SI NI!&quot;。 示例1 输入 130 135 5 输出 HAI YOU SEI! 说明 小乐乐会赢 思路： ​ 这道题有个输入限制k &gt;= |n - m|，自己看着n,m,k的数很大都是1e9，觉得应该是很简单的一个题，规律不可能太复杂。然后自己写了n多的样例，发现只有在n == m的时候小乐乐才会输。莽了一发过了 代码： #include &lt;stdio.h&gt;int main () &#123; int n, m, k; while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) &#123; if (n == m) &#123; printf(&quot;LAOZI CHUI SI NI!\n&quot;); &#125; else&#123; printf(&quot;HAI YOU SEI!\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐匹配字符串]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐有字符串str1,str2。 小乐乐想要给他们找朋友。 小乐乐想知道在这两个字符串中最多能匹配出多长的相同子串（可非连续）。 输入描述: 第一行输入字符串str1;第二行输入字符串str2;数据保证字符串长度小于1000，且非空，字符串仅由小写字母组成。 输出描述: 输出最长相同子串的长度。 示例1 输入 asdad 输出 2 思路： ​ 动态规划入门题，两层 for循环分别遍历两个字符串的字符，若s1【i】 == s2【j】，则dp【i】【j】= dp【i - 1】【j - 1】+ 1，否则dp【i】【j】= max(dp【i - 1】【j】,dp【i】【j - 1】)即可 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;char s1[1005], s2[1005];int dp[1005][1005];int main () &#123; memset(dp, 0, sizeof(dp)); scanf(&quot;%s&quot;, s1 + 1); scanf(&quot;%s&quot;, s2 + 1); int n1 = strlen(s1 + 1); int n2 = strlen(s2 + 1); for (int i = 1; i &lt;= n1; i++) &#123; for (int j = 1; j&lt;= n2; j++) &#123; if(s1[i] != s2[j]) &#123; dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; &#125; &#125; printf(&quot;%d\n&quot;, dp[n1][n2]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐玩木桶+]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6-1%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐用散落在森林里的木板做了一个木桶。 已知底面积为S(㎡)。 小乐乐经过各种仪器的精密测量知道了，所有木板的近似长度h[i]。 小乐乐只能选用三块木板去拼木桶，小乐乐拼凑成的木桶的最大装水体积是(㎡)？ （容量测量，底面积乘高，木桶不倾斜） 输入描述: 第一行输入整数n，S。(3&lt;=n&lt;=1000，1&lt;=s&lt;=1000，n表示拼凑木桶所需木板)第二行输入n个整数h[i](1&lt;=h[i]&lt;=1000,h[i]表示i号木板的长度) 输出描述: 输出木桶最大装水体积。 示例1 输入 3 32 3 4 输出 6 思路： ​ 这道题是上一道题的变形 上题链接 只要sort一下，用s✖️第三大的数即可 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int a[1005];int main () &#123; int n, m; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a + n); printf(&quot;%d\n&quot;, a[n - 3] * m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐玩木桶]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐用散落在森林里的木板做了一个木桶。 已知底面积为S(㎡)。 小乐乐经过各种仪器的精密测量知道了，所有木板的近似长度h[i]。 小乐乐想知道自己拼凑出的木桶的最大装水体积为？ （容量测量，底面积乘高，木桶不倾斜） 输入描述: 第一行输入整数n，S。(1&lt;=n,s&lt;=1000，n表示拼凑木桶所需木板)第二行输入n个整数h[i](1&lt;=h[i]&lt;=1000,h[i]表示i号木板的长度) 输出描述: 输出木桶最大装水体积。 示例1 输入 3 21 2 3 输出 2 思路： ​ 就是找出最小值，然后用s ✖️最小值即可。。。大水题 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int main () &#123; int n, m; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123; int minn = 0x3f3f3f3f; int a; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); if (minn &gt; a) &#123; minn = a; &#125; &#125; printf(&quot;%d\n&quot;, minn * m); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工院赛-小乐乐的组合数+]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述 小乐乐得知一周有7天之后就对7产生了兴趣。 小乐乐得到了两堆数字数字时连续的。 第一堆包含[1,n]n个数字，第二堆包含[1,m]m个数字。 小乐乐想要从两堆中各挑选出一个整数x,y，使得x,y的和为7的倍数。 请问小乐乐有多少种组合的方式。 输入描述: 输入整数n,m。(1&lt;=n,m&lt;=1e6) 输出描述: 输出满足的对数。 示例1 输入 6 7 输出 6 说明 (1,6),(2,5),(3,4),(4,3),(5,2),(6,1) 思路： ​ 从n,m中找一个较小值，用i遍历这个较小值，然后累加（(i + 较大值) / 7）- (i / 7)即为答案 代码： #include &lt;stdio.h&gt;int main () &#123; long long n, m; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); long long ans = 0; if (n &gt; m) &#123; long long flag = n; n = m; m = flag; &#125; for (int i = 1; i &lt;= n; i++) &#123; long long k = i + m; ans += k / 7 - i / 7; &#125; printf(&quot;%lld\n&quot;, ans); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-11-30博客搭建进度]]></title>
    <url>%2F2018%2F11%2F30%2F18-11-30%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间（11.13更新） ​ ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新） ​ ——新增动态背景(11.28更新) ​ ——修改网站图片外链至本地（11.28更新） ​ ——博文尾部自动添加声明（11.29更新） ​ ——实现博文字数统计（11.29更新） ​ ——添加顶部加载条（11.29更新） ​ ——添加简历页]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-11-29博客搭建进度]]></title>
    <url>%2F2018%2F11%2F29%2F18-11-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间（11.13更新） ​ ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新） ​ ——新增动态背景(11.28更新) ​ ——修改网站图片外链至本地（11.28更新） ​ ——博文尾部自动添加声明 ​ ——实现博文字数统计 ​ ——添加顶部加载条]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近几天]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%9C%80%E8%BF%91%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[​ 比完赛歇了两天后发现，三个星期外出打比赛落下的作业，课程设计，过程性考核扒拉扒拉之类的东西像冰冷的雨点在我脸上胡乱的拍，简直要哭了，直到今天所有的作业算是告一段落 ​ 补习班11月17号也开课了，前期课还挺简单（呸呸呸！不奶了不奶了），每次要坐40多分钟公交去补课的地方。哎～睡懒觉的机会没了 ​ 12月份院赛，校赛也要开始了。打打就好，过了那个兴奋的年纪 ​ 也该准备找工作滚粗了，简历几乎要完稿了，还差最最最重要的照骗，预约了明天的海马体，但愿能拍成照骗而不是照片吧哈哈哈哈 ​ 寒假是继续留在哈尔滨补课还是能pass过简历去公司实习，纠结～ 每一步都不想走错，自己继续纠结吧 ​ 哈尔滨的冬天 屋里暖气烘烘的 一天到晚好疲乏呀总是睡觉 想出去踢球 想着外边哈哈气都起雾 算了吧 哎 苦涩～ ​ ——2018.11.28夜]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-11-28博客搭建进度]]></title>
    <url>%2F2018%2F11%2F28%2F18-11-28%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间（11.13更新） ​ ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新） ​ ——新增动态背景 ​ ——修改网站图片外链至本地]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十八)getcwd(),getline(),chdir()函数]]></title>
    <url>%2F2018%2F11%2F16%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-18%2F</url>
    <content type="text"><![CDATA[关于getcwd()与getline()与chdir()函数使用： 一.getcwd()函数定义： #include&lt;unistd.h&gt;char *getcwd(char *buf,size_t size);//getcwd()会将当前工作目录的绝对路径并复制到参数buf所指的内存空间,参数size为buf的空间大小。 二.getcwd()函数用法: char path[105];getcwd(path,sizeof(path));puts(path); 三.getline()函数定义： istream&amp; getline(istream &amp;is, string &amp;str, char delim);istream&amp; getline(istream &amp;is, string &amp;str);is是进行读入操作的输入流，str是用来存储读入的内容，delim是终结符，遇到该字符停止读取操作，不写默认为回车 四.getline()函数用法： 单行输入回车结束时：string str;getline(cin, str);循环输入到ctrl + z结束时：while (getline(cin, str)) &#123; ...&#125; 五.chdir函数定义： ​ chdir 是C语言中的一个系统调用函数（同cd），用于改变当前工作目录。其参数为Path 目标目录，可以是绝对目录或相对目录。 #include &lt;unistd.h&gt; int chdir（const char * path）; chdir（）用户将当前的工作目录改变成以参数路径所指的目录。返回值执行成功则返回0，失败返回-1 六.chdir函数用法： chdir(&quot;/tmp&quot;);//当前目录更改为/tmp 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc北京站总结]]></title>
    <url>%2F2018%2F11%2F15%2F2018icpc%E5%8C%97%E4%BA%AC%E7%AB%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 亚洲区预赛北京站应该是国内最难打的一站吧。。刚开始就没抱什么期待。比赛前一星期做了青岛的重现赛，5题银牌水平，突然就对北京有了一丝期待，但愿能获个奖，希望今年不白玩。 ​ 现场赛开始后刚开始，队友告诉我I题可以用数位dp做，连忙看起了i，另两个队友看起了A题。没过10分钟清华大学A题一血。增林老哥紧随其后没多久A题Accept。赛后问队友A题好像是传递闭包，然后自己今天补了一下这道题：链接 ​ I题修修改改，找其中关系解决了n取1e5范围的所有可能。结果WA了，再读题才发现，它喵的这道题n的长度是1e5，而不是数字。。。那肯定规律题没跑了，让志愿者打印了之前处理前9位数的表。找到了规律。在第2个小时Accpet掉：链接 ​ D题现场赛被我刨除相邻建传送门的可能。。从那之后思路再也没往那上面靠过。很遗憾没出，今天补了补20多分钟就出了，满心悔恨～还是自己脑子太笨了。。 链接 ​ B题至今很迷，不知道问题出到哪儿了。我把WA的代码贴出来，希望大佬们能出一组样例Hack一下我的代码。。 #include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;string str;int num[205];int ans[205];int add[205];char c;int main () &#123; str.clear(); memset(ans, 0, sizeof(ans)); memset(add, 0, sizeof(add)); int tot = 0; int flggg = 0; int numm = 0; while((c = getchar()) != EOF) &#123; if (c == &apos;#&apos;) break; if (c == &apos;\n&apos;) &#123; tot++; num[tot] = numm; numm = 0; if (str[str.length() - 1] &gt;= &apos;0&apos; &amp;&amp; str[str.length() - 1] &lt;= &apos;9&apos;) &#123; flggg = 1; &#125; else &#123; flggg = 2; &#125; &#125; else &#123; numm++; if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; &amp;&amp; flggg == 1) &#123; str += c; flggg = 0; &#125; else if (flggg) &#123; numm++; str += &quot; &quot;; str += c; flggg = 0; &#125; else &#123; str += c; &#125; &#125; &#125; str += &quot; &quot;; num[tot]++; for (int i = 1; i &lt;= tot; i ++) &#123; add[i] = add[i - 1] + num[i]; &#125; int flag = 0, start = -1, flaa = 0, num = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (flag == 1) &#123; if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) &#123; flag = 2; &#125; else if (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos; &amp;&amp; flaa == 1)&#123; flag = 2; &#125; else if (str[i] == &apos; &apos;)&#123; if (start != -1) &#123; if (num != 0) printf(&quot; &quot;); for (int j = start; j &lt; i; j++) &#123; printf(&quot;%c&quot;, str[j]); &#125; num++; for (int j = 1; j &lt;= tot; j++) &#123; if (add[j] &gt; start) &#123; ans[j] ++; break; &#125; &#125; &#125; start = -1; flag = 0; flaa = 0; &#125; &#125; else if (flag == 2)&#123; if (str[i] == &apos; &apos;) &#123; start = -1; flag = 0; flaa = 0; &#125; &#125; else &#123; if (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; flag = 1; start = i; if (str[i] == &apos;0&apos;) flaa = 1; &#125; else if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) &#123; flag = 2; &#125; &#125; &#125; if (num != 0) &#123; printf(&quot;\n&quot;); &#125; for (int i = 1; i &lt;= tot; i ++) &#123; printf(&quot;%d\n&quot;, ans[i]); &#125; return 0;&#125; ​ 最后很惊险的拿了亚洲区预赛北京站的铜牌。。虽然今年很遗憾，但也算满足了。哪里跌倒哪里爬起，以后的日子继续加油吧～]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc北京Frog and Portal转换二进制]]></title>
    <url>%2F2018%2F11%2F15%2F2018icpc%E5%8C%97%E4%BA%ACFrog-and-Portal%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题意： 时间限制:1000ms 单点时限:1000ms 内存限制:512MB 描述 A small frog wants to get to the other side of a river. The frog is initially located at one bank of the river (position 0) and wants to get to the other bank (position 200). Luckily, there are 199 leaves (from position 1 to position 199) on the river, and the frog can jump between the leaves. When at position p, the frog can jump to position p+1 or position p+2.How many different ways can the small frog get to the bank at position 200? This is a classical problem. The solution is the 201st number of Fibonacci sequence. The Fibonacci sequence is constructed as follows: F1=F2=1;Fn=Fn-1+Fn-2.Now you can build some portals on the leaves. For each leaf, you can choose whether to build a portal on it. And you should set a destination for each portal. When the frog gets to a leaf with a portal, it will be teleported to the corresponding destination immediately. If there is a portal at the destination, the frog will be teleported again immediately. If some portal destinations form a cycle, the frog will be permanently trapped inside. Note that You cannot build two portals on the same leaf.Can you build the portals such that the number of different ways that the small frog gets to position 200 from position 0 is M? 输入 There are no more than 100 test cases.Each test case consists of an integer M, indicating the number of ways that the small frog gets to position 200 from position 0. (0 ≤ M &lt; 232) 输出 For each test case:The first line contains a number K, indicating the number of portals.Then K lines follow. Each line has two numbers ai and bi, indicating that you place a portal at position ai and it teleports the frog to position bi.You should guarantee that 1 ≤ K, ai, bi ≤ 199, and ai ≠ aj if i ≠ j. If there are multiple solutions, any one of them is acceptable. 样例输入 015 样例输出 21 12 121 1992 224 1995 5 ​ 这道题意思就是一共有200层楼梯，可以一次上一层，也可以一次上两层。我们可以建造若干个传送门，可以直接从a传送到b（强制传送）。给你一个n，问到第200层有n种方案数，需要建多少个传送门，如何建？（多种建造方案任选一种即可） 思路： ​ 这道题应该深思如何建造传送门。有3种合理的建造： 由k层传送到199层，这样总方案数会加上第k层的方案数 由k层传送到k层。死循环，总方案数不会记入该层方案数 由k层传送到k+1层。会使k层的方案数累计到k+1层中。 由这三种构造，我们可以转化为二进制来求解。 比如当n为7时，它的二进制为111，也就是1 + 2 + 4 那么传送门就应该建6个。 分别是1传送到199（总方案数+1） （这样2，3分别有1，1种方案数） 3传送到4 （这样4，5分别有2，2种方案数） 5传送到199 （总方案数+2） （这样6，7分别有2，2种方案数） 7传送到8 （这样8，9分别有4，4种方案数） 9传送到199 （总方案数+4） 10传送到10 （封死） （10以后无法到达200，方案数为0） 这样总方案数为7，符合条件 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;int flag[205];long long dp[205];int main () &#123; long long n; while(scanf(&quot;%lld&quot;, &amp;n) == 1) &#123; int ans = 0; memset(flag, 0, sizeof(flag)); if (n == 0) &#123; printf(&quot;2\n1 1\n2 1\n&quot;); continue; &#125; if (n % 2) &#123; flag[1] = 1; ans ++; n /= 2; int inx = 3; while(n) &#123; flag[inx] = 2; ans++; inx += 2; if (n % 2) &#123; flag[inx] = 1; ans++; inx += 2; &#125; n /= 2; &#125; ans++; flag[inx - 1] = 3; &#125; else &#123; n /= 2; int inx = 1; while(n) &#123; flag[inx] = 2; ans++; inx += 2; if (n % 2) &#123; flag[inx] = 1; ans++; inx += 2; &#125; n /= 2; &#125; ans++; flag[inx - 1] = 3; &#125; printf(&quot;%d\n&quot;, ans); for (int i = 1; i &lt;= 198; i++) &#123; if (flag[i] == 1) &#123; printf(&quot;%d 199\n&quot;, i); &#125; else if (flag[i] == 2) &#123; printf(&quot;%d %d\n&quot;, i, i + 1); &#125; else if (flag[i] == 3)&#123; printf(&quot;%d %d\n&quot;, i, i); &#125; &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc北京Palindromes推规律]]></title>
    <url>%2F2018%2F11%2F15%2F2018icpc-Palindromes%E6%8E%A8%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[题意： 时间限制:1000ms 单点时限:1000ms 内存限制:512MB 描述 Recently, Nvoenewr learnt palindromes in his class.A palindrome is a nonnegative integer that is the same when read from left to right and when read from right to left. For example, 0, 1, 2, 11, 99, 232, 666, 998244353353442899 are palindromes, while 10, 23, 233, 1314 are not palindromes.Now, given a number, Nvoenewr can determine whether it’s a palindrome or not by using loops which his teacher has told him on the class. But he is now interested in another question: What’s the K-th palindrome? It seems that this question is too difficult for him, so now he asks you for help.Nvoenewr counts the number from small to big, like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101 and so on. So the first palindrome is 0 and the eleventh palindrome is 11 itself.Nvoenewr may ask you several questions, and the K may be very big. 输入 The first line contains one integer T(T &lt;= 20) —— the number of questions that Nvoenewr will ask you.Each of the next T lines contains one integer K. You should find the K-th palindrome for Nvoenewr.Let’s say K is a n-digit number. It’s guaranteed that K &gt;= 1, 1 &lt;= n &lt;= 100000 and the sum of n in all T questions is not greater than 1000000. 输出 Print T lines. The i-th line contains your answer of Nvoenewr’s i-th question. 样例输入 41101120 样例输出 0911101 ​ 翻译成汉语就是问第n个回文数是多少？n的长度范围是1e5 思路： ​ 队友当时告诉我用数位dp做，然后我想了一手觉得还是找联系吧。然后发现只要处理前九位就能填满1e5的数据范围。。直到错了两发才发现，他喵的n的数据范围不是1e5，而是n的数字长度为1e5。好吧，即然这样肯定是有规律了，然后就利用之前处理的前1e9个打表找到其中的规律然后Accept（规律见代码） 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100000char s[N + 5];int main () &#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T --) &#123; scanf(&quot;%s&quot;, s); int len = strlen(s); if (len == 1) &#123; printf(&quot;%d\n&quot;, s[0] - &apos;0&apos; - 1); continue; &#125; if(len == 2 &amp;&amp; s[0] == &apos;1&apos; &amp;&amp; s[1] == &apos;0&apos;) &#123; printf(&quot;9\n&quot;); continue; &#125; if (s[0] == &apos;1&apos;) &#123; if (s[1] == &apos;0&apos;) &#123; printf(&quot;9&quot;); for (int i = 2; i &lt; len; i++) &#123; printf(&quot;%c&quot;, s[i]); &#125; for (int i = len - 2; i &gt; 1; i--) &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;9\n&quot;); &#125; else &#123; for (int i = 1; i &lt; len; i++) &#123; printf(&quot;%c&quot;, s[i]); &#125; for (int i = len - 1; i &gt; 0; i--) &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;\n&quot;); &#125; &#125; else &#123; printf(&quot;%d&quot;, s[0] - &apos;0&apos; - 1); for (int i = 1; i &lt; len; i++) &#123; printf(&quot;%c&quot;, s[i]); &#125; for (int i = len - 2; i &gt; 0; i--) &#123; printf(&quot;%c&quot;, s[i]); &#125; printf(&quot;%d\n&quot;, s[0] - &apos;0&apos; - 1); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc北京Jin Yong’s Wukong Ranking List传递闭包]]></title>
    <url>%2F2018%2F11%2F15%2F2018icpc%E5%8C%97%E4%BA%ACJin-Yong-Wukong-Ranking-List%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[时间限制:1000ms 单点时限:1000ms 内存限制:512MB 描述 Jin Yong was the most famous and popular Chinese wuxia (The one who fight bad people by his Wukong i.e. Wushu and Kongfu) novelist who lived in Hong Kong. Between 1955 and 1972, he wrote 14 novels which earned him a reputation as one of the greatest and most popular Chinese writers. Over 100 million copies of his works have been sold worldwide，not including a countless number of pirated copies. Jin Yong’s works seem to have magic. Once you begin to read a novel of his, you just can’t stop until you finish it.Last month, Jin Yong passed away at the age of 94. Many Jin Yong’s fans in PKU held a meeting to memorize him. Jin Yong’s fans always like to discuss or argue or even quarrel about whose Wukong are better among the wuxia characters of his novel. During the meeting, this happened again:Every fans said some words like “Qiao Feng’s Wukong is better than Guo Jing’s”. Obviously, those words may contradict each other and then cause quarrels. As a boring and girlfriendless male programmer of EECS school, you always want to make some things. So you are eager to point out the contradictions as soon as possible. That means, you want to find out the first one whose words contradict the words said by others before him.Please note that if A is better than B, and B is better than C, then of course A must be better than C. 输入 There are no more than 15 test cases.For each test case:The first line is an integer n( 1 &lt;= n &lt;=20), meaning that there are n sentences.The following n lines are those n sentences which is in the format below:s1 s2This means someone said that s1’s Wukong was better than s2’s. Both s1 and s2 are names of Jin Yong’s characters which consists of only English letters. It’s guaranteed that s1 and s2 are different, and their length is no more than 30. Names are case sensitive. 输出 For each test case, print the first sentence which cause a contradiction. If there are no contradiction, print 0 instead. 提示 DON’T try to figure out who are those names in the sample and waste your time. 样例输入 2 BrokenReputation ExtinctNun HelloLaught EnvelopeNotFlat 6 LandOverWind LonelyLight FireMonk CutTheForest CutTheForest LookCrazy MakeFoxRush LetMeGo HeroAunt UniqueLand LookCrazy FireMonk 样例输出 0 LookCrazy FireMonk ​ 题意就是给出一个n代表有n行，每行两个a，b，代表a的武功高于b，问最早从第几行开始导致前后矛盾，若不矛盾输出0 思路： ​ 比赛时队友用传递闭包做的，今天自己做了一下。这个题可以转化为有向图判定是否成环（利用map&lt;string, int&gt;映射一下名字），可以用bool型的book{i}{j}来代表从i到j是否连通。每一行都更新一下，若book{i}{j}和book{j}{i}都为1就代表前后矛盾 代码： #include &lt;stdio.h&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string.h&gt;using namespace std;string s1[25], s2[25];map&lt;string, int&gt;zcy;bool book[50][50];int res1[50], res2[50];int main () &#123; int n; while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123; zcy.clear(); memset(book, 0, sizeof(book)); int tot = 0; int flag = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s1[i]; cin &gt;&gt; s2[i]; if (!zcy[s1[i]]) &#123; zcy[s1[i]] = ++tot; &#125; if (!zcy[s2[i]]) &#123; zcy[s2[i]] = ++tot; &#125; if (book[zcy[s2[i]]][zcy[s1[i]]] || flag) &#123; continue; &#125; res1[0] = zcy[s2[i]]; res2[0] = zcy[s1[i]]; int tot1 = 0, tot2 = 0; for (int j = 1; j &lt;= tot; j++) &#123; if(book[j][zcy[s2[i]]] == 1) &#123; res1[++tot1] = j; &#125; &#125; for (int j = 1; j &lt;= tot; j++) &#123; if(book[zcy[s1[i]]][j] == 1) &#123; res2[++tot2] = j; &#125; &#125; for (int p = 0; p &lt;= tot1; p++) &#123; for (int q = 0; q &lt;= tot2; q++) &#123; if(book[res2[q]][res1[p]] == 0) &#123; book[res1[p]][res2[q]] = 1; &#125; else &#123; flag = 1; cout &lt;&lt; s1[i] &lt;&lt; &quot; &quot; &lt;&lt; s2[i] &lt;&lt; endl; break; &#125; &#125; if(flag) break; &#125; &#125; if (!flag) &#123; printf(&quot;0\n&quot;); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>传递闭包</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc徐州站总结]]></title>
    <url>%2F2018%2F11%2F14%2F2018icpc%E5%BE%90%E5%B7%9E%E7%AB%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ ​ 这场比赛有很多没想到吧，努力了那么久，没想到以打铁草草收场。赛后听题解说c题和i题是水题，直到最后一个小时才有人开始做这两个题。我们队也根本没有想过这两个题会是水题。直到比赛半个多小时过去，清华大学才Accept掉第一个A题。所有队伍都开始尝试做这道，我们队也不例外。 ​ 关于A题，题意跳转连接：跳转 这道题题干特别特别长，大概就是给出一个随机函数自动生成n个点m条边的无向图，让你求它的最小生成树个数✖️最小生成树权值的值。关于求最小生成树权值很简单，直接可以用Kruskal求解，而最小生成树个数我们队想了好久，刚开始试图Matrix_Tree算法来求，结果发现由于N为1e5，二维数组根本没有办法放开。后来改用dfs，修修改改直到4小时40分钟才Accept掉。 ​ 毫无疑问，打铁了。。。距离铜牌只差了12分钟罚时。。。而且给出的正解，竟然说随机函数不可能生成两个及以上的最小生成树。。。。自己辛辛苦苦用最小生成树个数✖️最小生成树权值求出来的，一些队只用简单的最小生成树权值就求出来。。。欲哭无泪，只能说自己还是太菜。。。 ​ 来时抱着争银保铜的信心，结果遗憾草草收场… ​ 抛去比赛，中国矿业大学的校园很大很美，校园里大到可以举办半程马拉松，Orz，又是别人家的大学系列。除此之外徐州的地锅鸡也非常非常好吃。一切都过去了，就这样吧～]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc徐州Rikka with Minimum Spanning]]></title>
    <url>%2F2018%2F11%2F14%2Ficpc2018%E5%BE%90%E5%B7%9ERikka-with-Minimum-Spanning%2F</url>
    <content type="text"><![CDATA[给你一个随机函数，其中n为点的数量，m为边的数量，该函数会自动初始化出一张无向无环图，函数如下所示： typedef unsigned long long ll;ll k1,k2;ll xorShift128Plus()&#123; ll k3=k1,k4=k2; k1=k4; k3^=k3&lt;&lt;23; k2=k3^k4^(k3&gt;&gt;17)^(k4&gt;&gt;26); return k2+k4;&#125;void gen()&#123; scanf(&quot;%d%d%llu%llu&quot;,&amp;n,&amp;m,&amp;k1,&amp;k2);for(int i=1;i&lt;=m;i++) &#123; e[i].u=xorShift128Plus()%n+1; e[i].v=xorShift128Plus()%n+1; e[i].w=xorShift128Plus(); &#125;&#125; 利用如上所示随机函数求出该图所形成的最小生成树个数与该最小生成树总权值的乘积 题解： ​ 这道题题意其实非常非常长，有很多很多干扰项（比如介绍了一种计算最小生成树数目的算法），翻译成汉语简化一下就是上面那个意思。 ​ 嗯嗯，我们队就是被这道题给KO了，辛辛苦苦写了4个多小时的最小生成树计数✖️最小生成树权值才过的题，最后给出的正解居然是直接构造最小生成树就行了。。。。由于随机数生成器过于给力，根本就不会出来两种以上的最小生成树，只需要特判0就行了。 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;#define MAX 100000#define mod 1000000007#define ll unsigned long longusing namespace std;int n, m, p[MAX+5];struct node &#123; int u, v; ll w;&#125;e[MAX + 5];int find(int r) &#123; if(p[r] != r) p[r] = find(p[r]); return p[r];&#125;bool cmp (node a, node b) &#123; return a.w &lt; b.w;&#125;ll k1,k2;ll xorShift128Plus() &#123; ll k3 = k1,k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4;&#125;void gen() &#123; scanf(&quot;%d%d%llu%llu&quot;,&amp;n, &amp;m, &amp;k1, &amp;k2); for(int i = 1; i &lt;= n; i++) p[i] = i; for(int i = 1; i &lt;= m; i++) &#123; e[i].u = xorShift128Plus() % n + 1; e[i].v = xorShift128Plus() % n + 1; e[i].w = xorShift128Plus(); &#125;&#125;void kurskal() &#123; gen(); sort(e + 1, e + m + 1, cmp); int cnt = 0; ll sum = 0; for(int i = 1;i &lt;= m;i++) &#123; int fu = find(e[i].u); int fv = find(e[i].v); if(fu != fv) &#123; p[fu] = fv; sum += e[i].w; cnt++; sum = sum % mod; &#125; if(cnt == n-1) break; &#125; if(cnt == n-1) printf(&quot;%llu\n&quot;, sum%mod); else printf(&quot;0\n&quot;);&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) kurskal(); return 0;&#125; ​ 没错，就是这么简单～估计这是这一生最令我伤心的一题了吧。。。 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-11-13博客搭建进度]]></title>
    <url>%2F2018%2F11%2F13%2F18-11-13%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计(10.23更新) ​ ——新增博文数量统计(10.23更新) ​ ——新增网站运行时间 ​ ——新增pdf在线浏览（仅支持电脑浏览）]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM常用数学公式]]></title>
    <url>%2F2018%2F11%2F13%2FACM%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[注意：仅支持电脑查看]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc青岛Tournament 规律+思维]]></title>
    <url>%2F2018%2F11%2F09%2F2018icpc%E9%9D%92%E5%B2%9BTournament-%E8%A7%84%E5%BE%8B-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题意： Sample Input 23 14 3 Sample Output Impossible2 1 4 33 4 1 24 3 2 1 ​ 这道题大概就是给T组样例，每组样例n个骑士，m轮比赛。每个骑士每轮比赛都得参加，且每轮比赛对手都不能相同，输出一个矩阵a【i】【j】代表第i轮和j骑士进行对决的是a【i】【j】骑士。若有多种情况，答案输出字典序最小的那个。 思路： ​ 通过打暴力码得到当n为2的次幂时，最多可以有n - 1次对决。否则当n为256的倍数时（由于n的范围只有1000且n不为2的次幂，所以从256算就可以了），最多可以有(1 + 2 + 4 + 8 + … + 128)轮比赛, 当n为128的倍数时，最多可以有(1 + 2 + 4 + … +64 )轮比赛 ……当n为2的倍数时，最多有1轮比赛。 ​ 因此只要超过这些轮比赛，直接Impossible即可。 ​ 对于满足条件的，我们找出矩阵的规律即可（对于&lt;=2的，与第i - 1轮对每2个一组的数平分两半相互交换，对于&lt;=4的，与第i - 2轮对每4个一组的数平分两半相互交换，对于&lt;= 8的，与第i - 4轮对每8个一组的数平分两半相互交换…依此递推） 代码： #include &lt;stdio.h&gt;int a[1005][1005];int ttt[15] = &#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;;int quick(int a, int b) &#123; int ans = 1; while (b) &#123; if(b &amp; 1) ans *= a; b &gt;&gt;= 1; a *= a; &#125; return ans;&#125;int main () &#123; int T, n, m; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int sum = 0, tot = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int nn = n; while(nn % 2 == 0) &#123; nn /= 2; sum += quick(2, tot); tot++; &#125; if(sum &lt; m) &#123; printf(&quot;Impossible\n&quot;); &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; a[1][i] = i + 1; &#125; for (int i = 2; i &lt;= m + 1; i++) &#123; int flaa; for (int j = 0; j &lt; 15; j++) &#123; if (ttt[j] &lt; i) &#123; flaa = ttt[j + 1]; &#125; else &#123; break; &#125; &#125; flaa /= 2; //printf(&quot;%d\n&quot;, flaa); for (int j = 0; j &lt; n; j ++) &#123; if (j % (flaa * 2) &lt; flaa) &#123; a[i][j] = a[i - flaa][j + flaa]; &#125; else &#123; a[i][j] = a[i - flaa][j - flaa]; &#125; if (j == n - 1) &#123; printf(&quot;%d\n&quot;, a[i][j]); &#125; else&#123; printf(&quot;%d &quot;, a[i][j]); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3162Walking Race 树形dp+单调队列+模拟vector]]></title>
    <url>%2F2018%2F11%2F09%2FPOJ3162Walking-Race-%E6%A0%91%E5%BD%A2dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%A8%A1%E6%8B%9Fvector%2F</url>
    <content type="text"><![CDATA[题意： Description flymouse’s sister wc is very capable at sports and her favorite event is walking race. Chasing after the championship in an important competition, she comes to a training center to attend a training course. The center has N check-points numbered 1 through N. Some pairs of check-points are directly connected by two-way paths. The check-points and the paths form exactly a tree-like structure. The course lasts N days. On the i-th day, wc picks check-point i as the starting point and chooses another check-point as the finishing point and walks along the only simple path between the two points for the day’s training. Her choice of finishing point will make it that the resulting path will be the longest among those of all possible choices. After every day’s training, flymouse will do a physical examination from which data will obtained and analyzed to help wc’s future training be better instructed. In order to make the results reliable, flymouse is not using data all from N days for analysis. flymouse’s model for analysis requires data from a series of consecutive days during which the difference between the longest and the shortest distances wc walks cannot exceed a bound M. The longer the series is, the more accurate the results are. flymouse wants to know the number of days in such a longest series. Can you do the job for him? Input The input contains a single test case. The test case starts with a line containing the integers N (N ≤ 106) and M (M &lt; 109). Then follow N − 1 lines, each containing two integers fi and di (i = 1, 2, …, N − 1), meaning the check-points i + 1 and fi are connected by a path of length di. Output Output one line with only the desired number of days in the longest series. Sample Input 3 21 11 3 Sample Output 3 Hint Explanation for the sample: There are three check-points. Two paths of lengths 1 and 3 connect check-points 2 and 3 to check-point 1. The three paths along with wc walks are 1-3, 2-1-3 and 3-1-2. And their lengths are 3, 4 and 4. Therefore data from all three days can be used for analysis. ​ 翻译成汉语，每个样例输入一个n,m,然后再给出n - 1个边的点权。n个点组成一颗树，求出每个点的离它最远的距离记为a【i】,问连续的区间中差值全部小于等于m的最长区间的长度。 思路： ​ 对于求出每个点离它最远的距离a【i】，我们可以通过树形dp来求解（注意需要用链式前向星或者模拟vector来求解，否则TLE），然后再通过尺取+单调队列来求最长长度（当然用线段树也可以求解）。单调队列需要开两个，一个存最大值队列，一个存最小值队列。 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;deque&gt;#define N 1000005#define ll long longusing namespace std;struct node &#123; int inx; ll val;&#125;;int n, m;node point[N * 2];node dp[N][3];int last[N * 2], fin[N];deque&lt;int&gt;maxn, minn;inline int read() &#123; char ch = getchar(); int x = 0; while(ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; ch = getchar(); &#125; while(&apos;0&apos; &lt;= ch &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; return x;&#125;void init() &#123; int a, b; int tot = 0; node c; n = read(); m = read(); for (int i = 2; i &lt;= n; i++) &#123; a = read(); b = read(); c.inx = a; c.val = b; point[++tot] = c; last[tot] = fin[i]; fin[i] = tot; c.inx = i; point[++tot] = c; last[tot] = fin[a]; fin[a] = tot; &#125;&#125;void dfs (int inx, int father) &#123; for (int i = fin[inx]; i != 0; i = last[i]) &#123; node son = point[i]; if (son.inx == father) continue; dfs(son.inx, inx); if (dp[inx][0].inx == 0) &#123; dp[inx][0].val = dp[son.inx][0].val + son.val; dp[inx][0].inx = son.inx; &#125; else &#123; if (dp[inx][0].val &lt; dp[son.inx][0].val + son.val) &#123; dp[inx][1].val = dp[inx][0].val; dp[inx][1].inx = dp[inx][0].inx; dp[inx][0].val = dp[son.inx][0].val + son.val; dp[inx][0].inx = son.inx; &#125; else if (dp[inx][1].val &lt; dp[son.inx][0].val + son.val) &#123; dp[inx][1].val = dp[son.inx][0].val + son.val; dp[inx][1].inx = son.inx; &#125; &#125; &#125; return;&#125;void dfs1 (int inx, int father) &#123; for (int i = fin[inx]; i != 0; i = last[i]) &#123; node son = point[i]; if (son.inx == father) continue; if (dp[inx][0].inx == son.inx) &#123; dp[son.inx][2].val = son.val + max(dp[inx][1].val, dp[inx][2].val); &#125; else &#123; dp[son.inx][2].val = son.val + max(dp[inx][0].val, dp[inx][2].val); &#125; dfs1(son.inx, inx); &#125; return;&#125;int main () &#123; int res = 0; init(); dfs(1, -1); dp[1][2].val = 0; dfs1(1, -1); int start = 1; for (int i = 1; i &lt;= n; i++) &#123; dp[i][0].val = max(dp[i][0].val, dp[i][2].val); while(!maxn.empty() &amp;&amp; dp[maxn.back()][0].val &lt; dp[i][0].val) &#123; maxn.pop_back(); &#125; maxn.push_back(i); while(!minn.empty() &amp;&amp; dp[minn.back()][0].val &gt; dp[i][0].val) &#123; minn.pop_back(); &#125; minn.push_back(i); while(dp[maxn.front()][0].val - dp[minn.front()][0].val &gt; m) &#123; if (maxn.front() &lt; minn.front()) &#123; start = maxn.front() + 1; maxn.pop_front(); &#125; else &#123; start = minn.front() + 1; minn.pop_front(); &#125; &#125; res = max(i - start + 1, res); &#125; printf(&quot;%d\n&quot;, res); return 0;&#125; ​ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc青岛Flippy Sequence 思维]]></title>
    <url>%2F2018%2F11%2F09%2F2018icpc%E9%9D%92%E5%B2%9BFlippy-Sequence-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题意： Sample Input 31102001150101000111 #### Sample Output 026 #### Hint For the second sample test case, there are two valid operation pairs: (1, 1, 2, 2) and (2, 2, 1, 1). For the third sample test case, there are six valid operation pairs: (2, 3, 5, 5), (5, 5, 2, 3), (2, 5, 4, 4), (4, 4, 2, 5), (2, 4, 4, 5) and (4, 5, 2, 4). ​ 题意就是给你T组样例，每组样例给你两个长度为n的字符串s1,s2，每个字符串必须且只能反转一个连续的区间（0变1，1变0），问两个字符串反转完毕变成相同字符串的方案数？ 思路： ​ 我们把两个字符串每一位相同的设为0，不同的设为1.若出现了3个及3个以上连续的1，那么永远无法通过反转一次得到相同字符串，此时输出0；若出现了2个连续的1，那么一定是6种方案；若出现了1个连续的1，方案数= (连续1的个数 - 1) ✖️ 2 + （n - 连续1的个数) ✖️2；若没有出现连续的1，方案数=（1 + n）✖️ n / 2。 ​ 一定要细心细心再细心！！因为细节没处理好WA了4发当时心态都崩了。 代码： #include &lt;stdio.h&gt;#define N 1000005char s1[N], s2[N];int main () &#123; int T, n, c; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s%s&quot;, s1, s2); int num = 0; int flag = 0, flaa = 0; int start, endd; int num1 = 0, num2 = 0, num3 = 0; for (int i = 0; i &lt; n; i++) &#123; if (s1[i] == s2[i]) c = 0; else c = 1; if (c == 0) &#123; if (flag) &#123; num++; if (num == 1) &#123; endd = i - 1; &#125; flag = 0; &#125; if (num == 1) &#123; num2++; &#125; &#125; else &#123; if (num == 0) &#123; if (flag == 0) &#123; start = i; &#125; num1++; &#125; else if(num == 1) &#123; num3++; &#125; else &#123; flaa = 1; break; &#125; if(i == n - 1) &#123; num++; if (num == 1) &#123; endd = i; &#125; &#125; flag = 1; &#125; &#125; if (flaa) &#123; printf(&quot;0\n&quot;); &#125; else if (num == 0) &#123; long long sum = (long long)(1 + n) * n / 2; printf(&quot;%lld\n&quot;, sum); &#125; else if (num == 1) &#123; long long sum = (long long)(num1 - 1) * 2; sum += (n - (endd - start + 1)) * 2; printf(&quot;%lld\n&quot;, sum); &#125; else if (num == 2) &#123; printf(&quot;6\n&quot;); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc青岛Books 思维]]></title>
    <url>%2F2018%2F11%2F09%2F2018icpc%E9%9D%92%E5%B2%9BBooks-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题意： DreamGrid went to the bookshop yesterday. There are books in the bookshop in total. Because DreamGrid is very rich, he bought the books according to the strategy below: Check the books from the 1st one to the -th one in order. For each book being checked now, if DreamGrid has enough money (not less than the book price), he’ll buy the book and his money will be reduced by the price of the book. In case that his money is less than the price of the book being checked now, he will skip that book. BaoBao is curious about how rich DreamGrid is. You are asked to tell him the maximum possible amount of money DreamGrid took before buying the books, which is a non-negative integer. All he knows are the prices of the books and the number of books DreamGrid bought in total, indicated by . Input There are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains two integers and (, ), indicating the number of books in the bookshop and the number of books DreamGrid bought in total. The second line contains non-negative integers (), where indicates the price of the -th book checked by DreamGrid. It’s guaranteed that the sum of in all test cases will not exceed . #### Output For each test case output one line. If it’s impossible to buy books for any initial number of money, output “Impossible” (without quotes). If DreamGrid may take an infinite amount of money, output “Richman” (without quotes). In other cases, output a non-negative integer, indicating the maximum number of money he may take. #### Sample Input 44 21 2 4 84 0100 99 98 972 210000 100005 30 0 0 0 1 #### Sample Output 696RichmanImpossible ​ 大概意思就是给T组样例，每组一个n，m代表n本书，买了其中m本。然后再给出n本书的价格。购买规则是从前往后遍历书，只要书的价格小于自己剩余的钱数，就购买，否则就跳过。问恰好能买m本拥有的钱最多是多少？若过能全买输出Richman，如果不能恰好买m本输出Impossible； 思路： ​ 若n == m就Richman，否则第一遍遍历价格为0的书的数量。如果大于m就Impossible。否则就遍历剩下的不为0的图书，小于&lt;= m - 价格为0的数量时，累加钱数，当&gt; m - 价格为0的数量时，比较出其中的最小值。最后答案为累加的钱数+ 最小值 -1 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int a[100005];int main () &#123; int T, n, m; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; long long sum = 0; int num = 0; int minn = 0x3f3f3f3f; int flag = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if (n == m) flag = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); if (a[i] == 0) num ++; &#125; if (num &gt; m) flag = 2; else m -= num; if (!flag) &#123; int tot = 0; for (int i = 1; i &lt;= n; i++) &#123; if (flag) break; if (a[i] == 0) continue; tot++; if (tot &lt;= m) &#123; sum += a[i]; &#125; else &#123; minn = min(minn, a[i]); &#125; &#125; &#125; if (minn == 0) &#123; flag = 2; &#125; else &#123; sum += minn - 1; &#125; if (flag == 1) printf(&quot;Richman\n&quot;); else if(flag == 2) printf(&quot;Impossible\n&quot;); else printf(&quot;%lld\n&quot;, sum); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018icpc青岛Function and Function 规律]]></title>
    <url>%2F2018%2F11%2F09%2F2018icpc%E9%9D%92%E5%B2%9BFunction-and-Function-%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[题意： Sample Input 6123456789 1888888888 1888888888 2888888888 99999999998640 123451000000000 0 Sample Output 5182001000000000 ​ 大概意思就是给出f(n)和g^k(n)的通项公式，让你求g^k(n)。 思路： ​ 由于n的范围是1e9，每一位累加和肯定不会超过100，只需要几次递归就可以得到10以内的f(n)，至于10以内的递归，我们可以一眼看出它们的循环结和规律 代码： #include &lt;stdio.h&gt;int a[10] = &#123;1, 0, 0, 0, 1, 0, 1, 0, 2, 1&#125;;int dfs (int x, int k) &#123; if (k == 0) return x; if (x &lt; 10) &#123; if (x == 8) &#123; if (k == 1) return a[8]; else if(k == 2) return a[2]; if(k % 2 == 1) return a[0]; else return a[1]; &#125; else if(x == 0) &#123; if(k % 2 == 1) return a[0]; else return a[1]; &#125; else if(x == 1) &#123; if(k % 2 == 1) return a[1]; else return a[0]; &#125; else if(x == 2 || x == 3 || x== 5 || x == 7) &#123; if (k == 1) return a[x]; else if (k % 2 == 0) &#123; return a[0]; &#125; else &#123; return a[1]; &#125; &#125; else if (x == 4 || x == 6 || x == 9) &#123; if (k == 1) return a[x]; else if (k % 2 == 0) &#123; return a[1]; &#125; else &#123; return a[0]; &#125; &#125; &#125; int sum = 0; while (x) &#123; sum += a[x % 10]; x /= 10; &#125; return dfs(sum, k - 1);&#125;int main () &#123; int T, x, k; scanf(&quot;%d&quot;, &amp;T); while(T --) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;k); int ans =dfs (x, k); printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3586Information Disturbing 二分+树形dp]]></title>
    <url>%2F2018%2F11%2F08%2FHDU3586Information-Disturbing-%E4%BA%8C%E5%88%86-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题意： Problem Description In the battlefield , an effective way to defeat enemies is to break their communication system.The information department told you that there are n enemy soldiers and their network which have n-1 communication routes can cover all of their soldiers. Information can exchange between any two soldiers by the communication routes. The number 1 soldier is the total commander and other soldiers who have only one neighbour is the frontline soldier.Your boss zzn ordered you to cut off some routes to make any frontline soldiers in the network cannot reflect the information they collect from the battlefield to the total commander( number 1 soldier).There is a kind of device who can choose some routes to cut off . But the cost (w) of any route you choose to cut off can’t be more than the device’s upper limit power. And the sum of the cost can’t be more than the device’s life m.Now please minimize the upper limit power of your device to finish your task. Input The input consists of several test cases.The first line of each test case contains 2 integers: n(n&lt;=1000）m(m&lt;=1000000).Each of the following N-1 lines is of the form:ai bi wiIt means there’s one route from ai to bi(undirected) and it takes wi cost to cut off the route with the device.(1&lt;=ai,bi&lt;=n,1&lt;=wi&lt;=1000)The input ends with n=m=0. Output Each case should output one integer, the minimal possible upper limit power of your device to finish your task.If there is no way to finish the task, output -1. Sample Input 5 51 3 21 4 33 5 54 2 60 0 Sample Output 3 ​ 这道题就是说给出n，m分别代表节点数和权值，再给出n-1条边ai,bi,wi，代表ai与bi之间有一条无向路，道路权值为wi。问在截断的道路总权值不超过m的前提下使得所有的叶节点都不能与跟节点相连，截断的道路中最大的权值尽可能的小，问最小值是多少？ 思路： ​ 一道较难的树形dp题，我们一般看到在什么什么的前提下，使得某个值最小或者最大。就应该想到用二分来求解。我们通过二分最小值，然后满足所截道路的权值都小于等于二分值进行dfs。最后找到最小满足条件的即是答案。 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#define N 1005using namespace std;struct node &#123; int inx, val;&#125;;vector&lt;node&gt;point[N];int n, m;int dp [N];void init() &#123; int a, b, c; node t; for (int i = 1; i &lt;= n; i++) &#123; point[i].clear(); &#125; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); t.val = c; t.inx = b; point[a].push_back(t); t.inx = a; point[b].push_back(t); &#125;&#125;bool dfs(int inx, int father, int w) &#123; int sum = 0; for (int i = 0; i &lt; point[inx].size(); i++) &#123; node son = point[inx][i]; if (son.inx == father) continue; dfs(son.inx, inx, w); if (dp[son.inx] == 0) &#123; //当儿子节点没有成立的截断 if (son.val &lt;= w) &#123; sum += son.val; &#125; else &#123; return false; &#125; &#125; else &#123; //当儿子节点有成立的截断 if (son.val &lt;= w) &#123; sum += min(dp[son.inx], son.val); &#125; else &#123; sum += dp[son.inx]; &#125; &#125; &#125; dp[inx] = sum; return true;&#125;int erfen() &#123; int star = 1, endd = m; int ans = -1; while (star &lt;= endd) &#123; int mid = (star + endd) &gt;&gt; 1; memset(dp, 0, sizeof(dp)); bool flag = dfs(1, -1, mid); if (flag == true &amp;&amp; dp[1] &lt;= m) &#123; ans = mid; endd = mid - 1; &#125; else &#123; star = mid + 1; &#125; &#125; return ans;&#125;int main () &#123; while ((scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &amp;&amp; (n || m)) &#123; init(); int ans = erfen(); printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3140Contestants Division 树形dp]]></title>
    <url>%2F2018%2F11%2F08%2FPOJ3140Contestants-Division-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题意： Description In the new ACM-ICPC Regional Contest, a special monitoring and submitting system will be set up, and students will be able to compete at their own universities. However there’s one problem. Due to the high cost of the new judging system, the organizing committee can only afford to set the system up such that there will be only one way to transfer information from one university to another without passing the same university twice. The contestants will be divided into two connected regions, and the difference between the total numbers of students from two regions should be minimized. Can you help the juries to find the minimum difference? Input There are multiple test cases in the input file. Each test case starts with two integers N and M, (1 ≤ N ≤ 100000, 1 ≤ M ≤ 1000000), the number of universities and the number of direct communication line set up by the committee, respectively. Universities are numbered from 1 to N. The next line has N integers, the Kth integer is equal to the number of students in university numbered K. The number of students in any university does not exceed 100000000. Each of the following M lines has two integers s, t, and describes a communication line connecting university s and university t. All communication lines of this new system are bidirectional. N = 0, M = 0 indicates the end of input and should not be processed by your program. Output For every test case, output one integer, the minimum absolute difference of students between two regions in the format as indicated in the sample output. Sample Input 7 61 1 1 1 1 1 11 22 73 74 66 25 70 0 Sample Output Case 1: 1 ​ 这道题翻译成汉语就是给出n个点，m条边，每个点都有一个权值，问去掉哪条边剩余两部分的权值差最小并输出最小值 思路： ​ 这道题有一个巨大的坑点，就是点的数据范围是1e5，边的数据范围是1e6，虽然如此，但是题里说了这么一句：“以便只有一种方式将信息从一所大学转移到另一所大学，而不会两次通过同一所大学”，因此这一定是无向无环图，边一定是点的数量-1，也就说一定是一颗树。因此这道题就可以通过树形dp来求解了 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N 100005#define ll long longusing namespace std;int n, m;ll val[N];ll dp[N];ll sum;vector&lt;int&gt;point[N];void init() &#123; int a, b; memset(dp, 0, sizeof(dp)); sum = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;, &amp;val[i]); sum += val[i]; point[i].clear(); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); point[a].push_back(b); point[b].push_back(a); &#125;&#125;void dfs(int inx, int father) &#123; dp[inx] = val[inx]; for (int i = 0; i &lt; point[inx].size(); i++) &#123; int son = point[inx][i]; if(son == father) continue; dfs(son, inx); dp[inx] += dp[son]; &#125; return;&#125;int main() &#123; int tot = 0; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123; if (n == m &amp;&amp; n == 0) break; init(); dfs(1, -1); ll minn = sum; ll t; for (int i = 2; i &lt;= n; i++) &#123; if (sum - dp[i] &gt; dp[i]) &#123; t = sum - dp[i] - dp[i]; &#125; else &#123; t = dp[i] - sum + dp[i]; &#125; minn = min(minn, t); &#125; printf(&quot;Case %d: %lld\n&quot;, ++tot, minn); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3107 Godfather 树形dp+模拟vector]]></title>
    <url>%2F2018%2F11%2F07%2FPOJ3107-Godfather-%E6%A0%91%E5%BD%A2dp-%E6%A8%A1%E6%8B%9Fvector%2F</url>
    <content type="text"><![CDATA[题意： Description Last years Chicago was full of gangster fights and strange murders. The chief of the police got really tired of all these crimes, and decided to arrest the mafia leaders. Unfortunately, the structure of Chicago mafia is rather complicated. There are n persons known to be related to mafia. The police have traced their activity for some time, and know that some of them are communicating with each other. Based on the data collected, the chief of the police suggests that the mafia hierarchy can be represented as a tree. The head of the mafia, Godfather, is the root of the tree, and if some person is represented by a node in the tree, its direct subordinates are represented by the children of that node. For the purpose of conspiracy the gangsters only communicate with their direct subordinates and their direct master. Unfortunately, though the police know gangsters’ communications, they do not know who is a master in any pair of communicating persons. Thus they only have an undirected tree of communications, and do not know who Godfather is. Based on the idea that Godfather wants to have the most possible control over mafia, the chief of the police has made a suggestion that Godfather is such a person that after deleting it from the communications tree the size of the largest remaining connected component is as small as possible. Help the police to find all potential Godfathers and they will arrest them. Input The first line of the input file contains n — the number of persons suspected to belong to mafia (2 ≤ n ≤ 50 000). Let them be numbered from 1 to n. The following n − 1 lines contain two integer numbers each. The pair ai, bi means that the gangster ai has communicated with the gangster bi. It is guaranteed that the gangsters’ communications form a tree. Output Print the numbers of all persons that are suspected to be Godfather. The numbers must be printed in the increasing order, separated by spaces. Sample Input 61 22 32 53 43 6 Sample Output 2 3 ​ 题目大体意思就是给出一个无向无环图，从中去掉一个结点使其分为一个或多个无向无环图，问去掉哪个结点分成的最大树的结点数最小，把所有符合条件的结点按从小到大的顺序输出出来 思路： ​ 我们可以把无向无环图看作是一棵树，网上说就是求树的所有重心（也就是结点到其它结点的距离和最小）。我的思路也和网上查不多。我们可以强制以1作为根节点，然后由叶到根求每个节点作为根节点的子树的结点和。利用dp【i】存储去掉i结点分成的k颗树的最大结点数，那么dp【i】为i的全部儿子结点为根的子树的最大值与n - (i为根节点的子树结点数)，取两者的较大值即为dp【i】 ​ 因为是一遍遍历嘛～复杂度大概为O(n)，用vector存储邻接表2s竟然TLE我的天！！！换成数组模拟vector只有400多ms，再加上快速读模版只耗费了110ms，就酱紫～ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N 50005using namespace std;namespace IO &#123; const int MX = 8e5; char buf[MX]; int c, sz; void begin() &#123; c = 0; sz = fread(buf, 1, MX, stdin); &#125; inline bool read(int &amp;t) &#123; while (c &lt; sz &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) &#123; c++; &#125; if (c &gt;= sz) return false; for (t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) &#123; t = t * 10 + buf[c] - &apos;0&apos;; &#125; return true; &#125;&#125;int n;int point[2 * N];int last[2 * N];int flag[N];int num[N];int dp[N];int ans[N];int read() &#123; char c = getchar(); int x = 0; while (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) &#123; c = getchar(); &#125; while (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; x = x * 10 + c - &apos;0&apos;; c = getchar(); &#125; return x;&#125;void init() &#123; int a, b, tot = 0;; for (int i = 0; i &lt; n - 1; i++) &#123; IO::read(a); IO::read(b); point[++tot] = b; last[tot] = flag[a]; flag[a] = tot; point[++tot] = a; last[tot] = flag[b]; flag[b] = tot; &#125;&#125;void dfs(int inx, int father) &#123; num[inx] = 1; for (int i = flag[inx]; i != 0; i = last[i]) &#123; int son = point[i]; if(son == father) continue; dfs(son, inx); num[inx] += num[son]; dp[inx] = max(dp[inx], num[son]); &#125; dp[inx] = max(dp[inx], n - num[inx]); return;&#125;int main() &#123; IO::begin(); IO::read(n); init(); dfs(1, -1); int minn = 0x3f3f3f3f; int tot = 0; for (int i = 1; i &lt;= n; i++) &#123; if(minn &gt; dp[i]) &#123; tot = 0; ans[tot++] = i; minn = dp[i]; &#125; else if(minn == dp[i]) &#123; ans[tot++] = i; &#125; &#125; for (int i = 0; i &lt; tot; i++) &#123; if (i == tot - 1) printf(&quot;%d\n&quot;, ans[i]); else printf(&quot;%d &quot;, ans[i]); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces219D 树形dp]]></title>
    <url>%2F2018%2F11%2F07%2FCodeForces219D-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[The country Treeland consists of n cities, some pairs of them are connected with unidirectional roads. Overall there are n - 1 roads in the country. We know that if we don’t take the direction of the roads into consideration, we can get from any city to any other one. The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city a is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city a to any other city. For that some roads may have to be inversed. Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country. Input The first input line contains integer n (2 ≤ n ≤ 2·105) — the number of cities in Treeland. Next n - 1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si, ti (1 ≤ si, ti ≤ n; si ≠ ti) — the numbers of cities, connected by that road. The i-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to n. Output In the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order. Examples： input 32 12 3 output 02 input 41 42 43 4 output 21 2 3 ​ 这道题翻译成汉语，大概意思就是给出一个有向无环图，问选择哪个节点道路方向反转次数最少且可以到达任意节点。输出最小反转次数和满足条件的全部节点 思路： ​ 由于是有向无环图，我们可以将其转化为树（强制节点1为根节点），我们设正常方向权值为1，反方向权值为0.然后我们第一遍dfs从叶到根遍历每个每个节点作为根节点的子树从根节点到每个节点权值和dp【i】。然后根节点1到所有节点的反转次数为num【1】= n - 1 - dp【i】,第二遍dfs从根到叶求每个节点到全部节点的反转次数即可,利用： //当从父到子为正向时num[son.inx] = num[father] + 1;//当从父到子为反向时num[son.inx] = num[father] - 1; 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define N 200005using namespace std;struct node &#123; int inx, val;&#125;;vector&lt;node&gt;point[N];vector&lt;int&gt;ans;int dp[N]; //int num[N];void dfs (int inx, int father) &#123; for (int i = 0; i &lt; point[inx].size(); i++) &#123; node son = point[inx][i]; if(son.inx == father) continue; dfs(son.inx, inx); dp[inx] += son.val + dp[son.inx]; &#125; return;&#125;void dfs1 (int inx, int father) &#123; for (int i = 0; i &lt; point[inx].size(); i++) &#123; node son = point[inx][i]; if(son.inx == father) continue; if(son.val == 1) &#123; num[son.inx] = num[inx] + 1; &#125; else &#123; num[son.inx] = num[inx] - 1; &#125; dfs1(son.inx, inx); &#125; return;&#125;int main () &#123; int n, a, b; node c; while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123; memset(dp, 0, sizeof(dp)); memset(num, 0, sizeof(num)); ans.clear(); int minn = 0x3f3f3f3f; for (int i = 1; i &lt;= n; i++) &#123; point[i].clear(); &#125; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); c.inx = b; c.val = 1; point[a].push_back(c); c.inx = a; c.val = 0; point[b].push_back(c); &#125; dfs(1, -1); num[1] = n - 1 - dp[1]; dfs1(1, -1); for (int i = 1; i &lt;= n; i++) &#123; if(minn &gt; num[i]) &#123; ans.clear(); ans.push_back(i); minn = num[i]; &#125; else if(minn == num[i]) &#123; ans.push_back(i); &#125; &#125; printf(&quot;%d\n&quot;, minn); for (int i = 0; i &lt; ans.size(); i++) &#123; printf(&quot;%d%c&quot;, ans[i], i == ans.size() - 1? &apos;\n&apos;: &apos; &apos;); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2196 Computer树形dp]]></title>
    <url>%2F2018%2F11%2F07%2FHDU2196-Computer%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[Problem Description A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. Input Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. Output For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). Sample Input 51 12 13 11 1 Sample Output 32344 ​ 翻译成汉语，就是给你n个点，再给n - 1行每行两个整数a, b，代表第i个电脑和a相连距离为b。最后输出每台电脑距离最远电脑的距离 思路： ​ 这题我们可以把图转化为树，可以说是树形dp吧。我们通过第一遍dfs由叶到根递归计算每个节点作为根节点的子树中，与该节点距离最远和次远的距离与儿子节点。再通过第二遍dfs由根到叶递归计算每个节点往上走（非该子树）节点的最长距离。最后我们遍历每个节点，只需要比较该节点作为根节点的子树中的最长距离与往上走的最大值，取较大值即为答案。 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define N 10005#define mem(a) memset(a, 0, sizeof(a));using namespace std;struct node &#123; int son, val;&#125;;struct gold &#123; int maxx, son;&#125;;int n;vector&lt;node&gt;point[N];gold maxn[N][3]; //0最大值 1次大值 2父最大值int pre[N];void init() &#123; int a, b; node c; mem(maxn); for (int i = 1; i &lt;= n; i++) &#123; pre[i] = i; point[i].clear(); &#125; for (int i = 2; i &lt;= n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); pre[i] = a; c.son = i; c.val = b; point[a].push_back(c); &#125;&#125;void dfs(int inx) &#123; for (int i = 0; i &lt; point[inx].size(); i ++) &#123; node son = point[inx][i]; dfs(son.son); if(maxn[inx][0].maxx &lt; son.val + maxn[son.son][0].maxx) &#123; maxn[inx][1].maxx = maxn[inx][0].maxx; maxn[inx][1].son = maxn[inx][0].son; maxn[inx][0].maxx = son.val + maxn[son.son][0].maxx; maxn[inx][0].son = son.son; &#125; else if(maxn[inx][1].maxx &lt; son.val + maxn[son.son][0].maxx) &#123; maxn[inx][1].maxx = son.val + maxn[son.son][0].maxx; maxn[inx][1].son = son.son; &#125; &#125;&#125;void dfs1(int inx) &#123; int father = pre[inx]; if(inx != 1) &#123; int t; for(int i = 0; i &lt; point[father].size(); i++) &#123; if(point[father][i].son == inx) &#123; t = point[father][i].val; break; &#125; &#125; if(maxn[father][0].son == inx) &#123; maxn[inx][2].son = father; maxn[inx][2].maxx = t + max(maxn[father][1].maxx, maxn[father][2].maxx); &#125; else &#123; maxn[inx][2].son = father; maxn[inx][2].maxx = t + max(maxn[father][0].maxx, maxn[father][2].maxx); &#125; &#125; for (int i = 0; i &lt; point[inx].size(); i++) &#123; dfs1(point[inx][i].son); &#125;&#125;int main () &#123; while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123; int ans; init(); dfs(1); dfs1(1); for (int i = 1; i &lt;= n; i++) &#123; ans = max(maxn[i][0].maxx, maxn[i][2].maxx); printf(&quot;%d\n&quot;, ans); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1520Anniversary party树形dp]]></title>
    <url>%2F2018%2F11%2F06%2FHDU1520Anniversary-party-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题意： Problem Description There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings. Input Employees are numbered from 1 to N. A first line of input contains a number N. 1 &lt;= N &lt;= 6 000. Each of the subsequent N lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from -128 to 127. After that go T lines that describe a supervisor relation tree. Each line of the tree specification has the form:L KIt means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line0 0 Output Output should contain the maximal sum of guests’ ratings. Sample Input 711111111 32 36 47 44 53 50 0 Sample Output 5 ​ 翻译成汉语再翻译成直男的视野，大概意思就是给出一个树，树上n个点，每个点都有一个权值，不能同时选取相邻的两个节点，问满足上述条件选取节点的最大权值和 思路： ​ 这道题是一道典型的树形dp，我们利用邻接表记录节点之间的关系，由根到叶进行dp。 ​ 对于dp【i】【0】代表以该节点为根节点的子树且根节点不被选取的最大权值和 ​ dp【i】【1】代表以该节点为根节点的子树且根节点被选取的最大权值和 ​ 我们可以得到父子之间的递推关系式子： //当父节点不被选取时，它的dp[inx][0]等于每个儿子节点被选取和不被选取的最大值的和dp[inx][0] += max(dp[son][1], dp[son][0]);//当父节点被选取时，它的dp[inx][1]等于每个儿子节不被选取的和 + 父亲节点的权值dp[inx][1] = val[inx];dp[inx][1] += dp[son][0]; 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define N 6005#define ll long longusing namespace std;int n;int val[N];int pre[N];vector&lt;int&gt;point[N];ll dp[N][2]; //1参加 0不参加void init() &#123; int a, b; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) &#123; pre[i] = i; point[i].clear(); &#125; for (int i = 1; i &lt;= n; i ++) &#123; scanf(&quot;%d&quot;, &amp;val[i]); &#125; while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) == 2) &#123; if (a == 0 &amp;&amp; b == 0) break; point[b].push_back(a); pre[a] = b; &#125; return;&#125;void dfs(int inx) &#123; dp[inx][1] = val[inx]; for (int i = 0; i &lt; point[inx].size(); i++) &#123; int son = point[inx][i]; dfs(son); dp[inx][0] += max(dp[son][1], dp[son][0]); dp[inx][1] += dp[son][0]; &#125;&#125;int main () &#123; while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123; init(); int root; for (int i = 1; i &lt;= n; i++) &#123; if(pre[i] == i) &#123; root = i; break; &#125; &#125; dfs(root); printf(&quot;%d\n&quot;, max(dp[root][1], dp[root][0])); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSOI307加分二叉树 区间dp]]></title>
    <url>%2F2018%2F11%2F06%2FSSOI307%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[【问题描述】 设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree最高得分的前序遍历【输入格式】 第1行：一个整数n（n＜30），为节点个数。第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。【输出格式】 第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。第2行：n个用空格隔开的整数，为该树的前序遍历。【输入样例1】 55 7 1 2 10【输出样例1】 1453 1 2 4 5 思路: ​ 虽然这是一个在树上的动态规划题，但实际还是一道区间DP，dp【i】【j】代表区间[i, j]的最高得分，dp【1】【n】即为答案，利用数组query【i】【j】记录该区间的根节点，通过dfs就可以得到最高得分的前序遍历。 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define ll long long#define mem(a) memset(a, 0, sizeof(a))using namespace std;ll dp[35][35];int query[35][35];int tot, n;void dfs(int left, int right) &#123; if (left &gt; right) return; int k = query[left][right]; if (tot != n - 1) &#123; printf(&quot;%d &quot;, k); &#125; else &#123; printf(&quot;%d\n&quot;, k); &#125; tot++; dfs(left, k - 1); dfs(k + 1, right);&#125;int main () &#123; while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123; tot = 0; memset(dp, 0, sizeof(dp)); memset(query, 0, sizeof(query)); for (int i = 1; i &lt;= n; i ++) &#123; scanf(&quot;%lld&quot;, &amp;dp[i][i]); query[i][i] = i; &#125; for (int len = 1; len &lt;= n - 1; len++) &#123; for (int i = 1; i + len &lt;= n; i++) &#123; for (int k = i; k &lt;= i + len; k++) &#123; ll left, right; if(k == i) &#123; right = dp[i + 1][i + len]; left = 1; &#125; else if (k == i + len) &#123; right = 1; left = dp[i][i + len - 1]; &#125; else &#123; right = dp[k + 1][i + len]; left = dp[i][k - 1]; &#125; if (dp[k][k] + right * left &gt; dp[i][i + len]) &#123; dp[i][i + len] = dp[k][k] + right * left; query[i][i + len] = k; &#125; &#125; &#125; &#125; printf(&quot;%lld\n&quot;, dp[1][n]); dfs(1, n); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客Not a subsequence动态规划]]></title>
    <url>%2F2018%2F11%2F06%2F%E8%AE%A1%E8%92%9C%E5%AE%A2Not-a-subsequence%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[题意： In this problem we consider strings over a fixed finite alphabet of size k. The alphabet contains the first k characters from the list a,b,c,…,z,A,B,C,…,Z,0,1,…,9. For every test case, we are given the value of k(notice that it cannot exceed 62), and consider only strings consisting of the first k characters from the list. Given a string s[1..n], we are interested in strings which are not its subsequences. Formally, a string t[1..m] is a subsequence of a string s[1..n] when one can choose not necessarily contiguous‾not necessarily contiguous indices 1≤i1&lt;i2&lt;…im≤n such that t[1]=s[i1],t[2]=s[i2],…,t[m]=t[im] For example, acb is a subsequence of babcaabbabcaab. Now, given a string s[1..n], we would like to compute the smallest mm such that there is a string t[1..m], which is not a subsequence of s[1..n]. Additionally, we would like to count the number of such shortest strings t[1..m]. As the latter number can be quite large, output it modulo 10^9+7. InputThe input starts with the number of test cases T≤100. Then the descriptions of TT test cases follow. A single test case consists of a single line containing the size of the alphabet k(k∈[1,62]) and the string s【1..n】(n∈[1,10^6])]. The string consists of the first k characters from a−zA−Z0−9. OutputFor every test case output one line containing two numbers. The first number is the smallest mm such that there is a string t[1..m] consisting of the first kkcharacters from a−zA−Z0−9, which is not a subsequence of s[1..n]. The second number is the total count of such shortest strings t[1..m] modulo 10^9+7. 样例输入32 abba62 01234567893 aabbcbbcbabcbab 样例输出3 51 524 7 ​ 翻译成汉语大概意思就是给你T组样例，每组样例有一个n，代表有n种字符，然后再给出一个字符串。问字符串中不存在的子串的最小长度是多少？有多少种（答案取余1e9+7）？例如 abba，对于字符a,b来说，它不存在的最小子串长度为3，分别为aaa,bbb,aab,baa,bbb 思路： ​ 一道特别难的dp题，关键是思路吧~ ​ 我们首先考虑字符串中不存在的子串的最小长度，我们从前往后遍历，每当出现一个没有标记过的字符就标记一次，当n个字符都标记过时，此时子串长度为1的都有了，因此最小长度只能是2，此时我们需要清空标记，继续往后遍历，每当出现一个没有标记过的字符就标记一次，当n个字符都标记过时，此时子串长度为2的都有了（因为每种字符前面一定每种字符至少存在一次），因此最小长度只能是3 ​ 我们再来考虑不存在的最小长度子串有多少种，若最小长度子串为1，那么种类为n-字符串中字符的种类数。若最小长度子串大于1时呢？这时候就需要DP推导式了.. ​ 给大家举个例子吧：对于3 abbcbabc来说： ​ 从前往后遍历，第一个字符为a，没有标记过，然后标记该字符，此时字符计数num = 1。那么长度为2的以a结尾的子串没有出现的种类数为3（分别是aa,ba,ca），总计数sum[2] = 3。并设置字符a上一次出现的位置为1 ​ 第二个字符b，没有标记过，然后标记该字符，此时字符计数num = 2。那么长度为2的以b结尾没有出现的子串种类数为2（分别是bb,cb），总计数sum[2] = 3 + 2 = 5。并设置字符b上一次出现的位置为2 ​ 第三个字符b，标记过，此时字符计数num = 2。长度为2的以b结尾没有出现的子串种类数为1（cb），总计数sum[2] = 3 + 2 + 1 - 2 = 4(也就是sum[2] + 1 - 上次b出现加的2)。并设置字符b上一次出现的位置为3 ​ 第四个字符c，没有标记过，然后标记该字符，此时字符计数num = 3。那么长度为2的以c结尾没有出现的子串种类数为1（分别是cc），总计数sum[2] = 3 + 2 + 1 - 2 + 1 = 5。并设置字符c上一次出现的位置为4,此时num==字符种类数，因此没出现的最小子串长度至少为2，清空标记与字符计数num ​ 第五个字符b，没有标记过，然后标记该字符，此时字符计数num = 1。那么长度为3的以b结尾没有出现的子串种类数为5（分别是aab,bab,cab,cbb,ccb），总计数sum[3] = sum[2] = 5,由于上一次出现过b且上次出现b是求长度为2的，因此sum[2] = sum[2] - 1 = 4(也就是sum[2]- 上一次b出现增加的1)，并设置字符b上一次出现的位置为5 ​ 第六个字符a，没有标记过，然后标记该字符，此时字符计数num = 2。那么长度为3的以a结尾没有出现的子串种类数为4（分别是aaa,baa,caa,cca），总计数sum[3] = 5 + 4 = 9,由于上一次出现过a且上次出现a是求长度为2的，因此sum[2] = sum[2] - 3 = 1(也就是sum[2]- 上一次a出现增加的3)，并设置字符a上一次出现的位置为6 ​ 第七个字符b，标记过，此时字符计数num = 2。那么长度为3的以b结尾没有出现的子串种类数为1（ccb），总计数sum[3] = 5 + 4 + 1 = 10,由于上一次出现过b且上次出现b是求长度为3的，因此sum[3] = sum[3] - 5 = 5(也就是sum[3]- 上一次b出现增加的5)，并设置字符b上一次出现的位置为7 ​ 第八个字符c，没有标记过，然后标记该字符，此时字符计数num = 3。那么长度为3的以c结尾没有出现的子串种类数为1（ccc），总计数sum[3] = 5 + 1 = 6,由于上一次出现过c且上次出现c是求长度为2的，因此sum[2] = sum[2] - 1 = 0(也就是sum[2]- 上一次c出现增加的1)，并设置字符c上一次出现的位置为8,由于num == 字符种类数，因此没出现的最小子串长度至少为3 ​ 因此最小子串长度为3，没出现的种类数为sum[3] = 6 ​ 原理就是这个原理～只需要线性就能求解 ​ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 1000000#define mod 1000000007#define ll long long#define mem(a) memset(a, 0, sizeof(a))char s[N + 5]; //存储字符串int map[300]; //存储字符映射bool book[70]; //标记数组ll add[70]; //存储该字符上一次增加的值int flag[70]; //记录该字符上一次是为了长度为几的子串贡献的addll dp[N + 5]; //dp[i]存储长度为i的子串没有出现的种类数void init() &#123; int tot = 0; for (int i = &apos;a&apos;; i &lt;= &apos;z&apos;; i++) &#123; map[i] = tot++; &#125; for (int i = &apos;A&apos;; i &lt;= &apos;Z&apos;; i++) &#123; map[i] = tot++; &#125; for (int i = &apos;0&apos;; i &lt;= &apos;9&apos;; i++) &#123; map[i] = tot++; &#125; return;&#125;int main() &#123; init(); int T, n; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d%s&quot;, &amp;n, s); int len = strlen(s); mem(book); mem(dp); mem(flag); mem(add); dp[1] = n; int chang = 1, num = 0; for (int i = 0; i &lt; len; i++) &#123; int t = map[s[i]]; if(chang == 1) &#123; dp[2] = (dp[2] + n - num + mod) % mod; if (book[t]) &#123; dp[2] = (dp[2] - add[t] + mod) % mod; &#125; else &#123; dp[1]--; &#125; add[t] = n - num; &#125; else &#123; dp[chang + 1] = (dp[chang + 1] + dp[chang]) % mod; ll zj = dp[chang]; if(book[t]) &#123; dp[chang + 1] = (dp[chang + 1] - add[t] + mod) % mod; &#125; else &#123; if (flag[t] == chang - 1) &#123; dp[chang] = (dp[chang] - add[t] + mod) % mod; &#125; &#125; add[t] = zj; &#125; flag[t] = chang; if(!book[t]) &#123; num++; book[t] = 1; &#125; if (num == n) &#123; chang++; mem(book); num = 0; &#125; &#125; printf(&quot;%d %lld\n&quot;, chang, dp[chang]); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客Gold Rush水题]]></title>
    <url>%2F2018%2F11%2F05%2F%E8%AE%A1%E8%92%9C%E5%AE%A2Gold-Rush%E6%B0%B4%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意： Alice and Bob are on an adventure trip. Deep in the woods they discover a mysterious deep cave which they enter flutteringly. They find an old console with a giant bar of gold in it. On the bar, there is a number n. Both tried to carry the gold out the cave, but it was still to heavy for one of them. Suddenly a little fairy appears in the corner of the cave and approaches Alice and Bob: “This gold is heavy. It weights 2^n femto-grams (10^−15) and nncan reach 62.” Bob answered: “What luck! Alice’s knapsack can carry up to aa femto-grams and mine bb femto-grams with a+b=2^n.” Alice interjected: “But how can we divide the gold?” Fairy: “I can help you with a spell that can burst one piece of gold into two equally weighted ones. But for each single spell, the cave will be locked one additional day.” Alice consults with Bob to use the help of the fairy and take all of the gold. How long will they be trapped if they are clever? InputThe input starts with the number t≤1000 of test cases. Then tt lines follow, each describing a single test case consisting of three numbers n,an,a and bb with a,b≥1,a+b=2^n, and 1≤n≤62. OutputOutput one line for every test case with the minimal number of days that Alice and Bob are locked in the cave. 样例输入32 2 22 1 310 1000 24 样例输出127 ​ 翻译成汉语大概意思就是有T组样例，每组样例有一个数是2^n，把它分成a，b，每次只能把一个数分成两个该数的一半，问最少分多少次能够分成a，b巴拉巴拉～ ​ 思路： ​ 我们只需要得到a，b的最小值t，然后循环把2^n累除2，若比t小就用t-该数，直到t为0为止 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;long long n;long long quick(long long a, long long b) &#123; long long ans = 1; while(b) &#123; if(b&amp;1) ans *= a; a *= a; b &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; int T; long long n, a, b; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;a, &amp;b); long long res = quick(2, n); long long minn = min(a, b); int num = 0; while(minn) &#123; res /= 2; num++; if(res &lt;= minn) &#123; minn -= res; &#125; &#125; printf(&quot;%d\n&quot;, num); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客Algebraic Teamwork思维]]></title>
    <url>%2F2018%2F11%2F05%2F%E8%AE%A1%E8%92%9C%E5%AE%A2Algebraic-Teamwork%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[题意： The great pioneers of group theory and linear algebra want to cooperate and join their theories. In group theory, permutations – also known as bijective functions – play an important role. For a finite set A, a function σσ: A → A is called a permutation of A if and only if there is some function ρ : A → A with σ(ρ(a))=a and ρ(σ(a))=afor all a∈A. The other half of the new team – the experts on linear algebra – deal a lot with idempotent functions. They appear as projections when computing shadows in 3D games or as closure operators like the transitive closure, just to name a few examples. A function pp : A → A is called idempotent if and only if p(p(a))=p(a)for all a∈A. To continue with their joined research, they need your help. The team is interested in non-idempotent permutations of a given finite set AA. As a first step, they discovered that the result only depends on the set’s size. For a concrete size 1≤n≤10^5, they want you to compute the number of permutations on a set of cardinality nnthat are not idempotent. InputThe input starts with the number t≤100 of test cases. Then tt lines follow, each containing the set’s size 1≤n≤10^5. OutputOutput one line for every test case containing the number modulo 1000000007=(109+7) of non-idempotent permutations on a set of cardinality nn. 样例输入3122171 样例输出016425 ​ 翻译成汉语，就是给出T组数据，每组数据给出一个集合A的范围n，问有多少对映射σ和ρ，使得σ(ρ(a))=a and ρ(σ(a))=afor all a∈A.但不满足p(p(a))=p(a)for all a∈A. 思路： ​ 对于第一个条件，我们只要满足a经过ρ，σ映射后还为a且映射关系都为一一映射，这道题刚开始以为是错排的种类数，结果不对后仔细一想，不满足p(p(a))=p(a)for all a∈A.，只要有一个a不满足即可，所以只要不是完全不变的映射即可（种类数为1），答案也就是全排列-1 代码： #include &lt;stdio.h&gt;const long long mod = 1e9+7;long long jc[100005];void init() &#123; jc[1] = 1; for (int i = 2; i &lt;= 100000; i++) &#123; jc[i] = i * jc[i - 1] % mod; &#125;&#125;int main() &#123; int T, n; init(); scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%lld\n&quot;, jc[n] - 1); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客Bounty Hunter多路dp]]></title>
    <url>%2F2018%2F11%2F05%2F%E8%AE%A1%E8%92%9C%E5%AE%A2Bounty-Hunter%2F</url>
    <content type="text"><![CDATA[题意： Spike is a bounty hunter and he is currently tracking a criminal! To investigate he uses his spaceship, the Swordfish II, and travels to Ndifferent places on 2D Euclidean space before returning to his crew at the starting location with all the information he has gathered. The starting location is the leftmost place (with the lowest x-coordinate) and Spike wants to travel to everyeveryother place before returning. However space fuel costs a lot of Woolongs and Spike would rather spend his money on special beef with bell peppers. Therefore he wants to travel the minimum possible distance. On top of that he is being chased by the Red Dragon crime syndicate. To make sure they don’t catch him he can only visit places in increasing order of their xx-coordinate until he reaches the rightmost place (with the largest x-coordinate), then he can turn around and visit places in decreasing order of their x-coordinate until he reaches his starting location again. InputThe input starts with an integer T(1≤T≤100) specifying the number of test cases that follow. Each test case consists of an integer N(2≤N≤512) specifying the number of places in the tour. The coordinates of these places are given as integers in the next NN lines, xx-coordinate first, yy-coordinate second (0≤x,y≤5000). The places are given in ascending order of the x-coordinate. Every place has a unique x-coordinate. OutputFor each test case, output on a single line the minimum travel distance needed to complete the tour. Your output should have an absolute or relative error of at most 10^-2 样例输入250 11 22 03 24 13100 1200 1300 1 样例输出9.300563079746400 大概意思就是给T组样例，每组样例有n个地方，从最左边开始，从左往右走到最右边，再从最右边返回到最左边，每个点有且经过一次，求最短路径 思路： ​ 我们找一个人从起点开始绕一圈的最短路，其实就是找两个人从起点到达终点（两个人除了终点和起点，不能经过相同的点）路径和的最小值。这是一个旅行商问题。由于505数值太大，因此可以用多路dp来求解 ​ 我们设dp【i】【j】保证第一个人到达i点，第二个人到达j点，i &lt; j且j之前的所有点都经过的最小花费，有关递推式在代码中有标注 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#define inf 0x3f3f3f3fusing namespace std;struct node &#123; double x, y;&#125;point[550];bool zfq (node A, node B) &#123; return A.x &lt; B.x;&#125;double sq(node A, node B) &#123; return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));&#125;double dp[550][550]; //dp[i][j]保证第一个到达i点，第二个人到达j点，i &lt; j且j之前的所有点都经过的最小花费double d[550][550];int main() &#123; int T, n; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; double ans = inf; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y); &#125; sort(point, point + n, zfq); for (int i = 0; i &lt; n; i ++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; dp[i][j] = inf; d[i][j] = sq(point[i], point[j]); &#125; &#125; dp[0][1] = d[0][1]; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; dp[j][j + 1] = min (dp[j][j + 1], dp[i][j] + d[i][j + 1]);//可能是i走到j+1 dp[i][j + 1] = min (dp[i][j + 1], dp[i][j] + d[j][j + 1]);//也可能是j走到j+1 &#125; &#125; for (int i = 0; i &lt; n - 1; i ++) &#123; ans = min(ans, dp[i][n - 1] + d[i][n - 1]); //由于i&lt;j，所以需额外加一个for循环求dp[n-1][n-1]的最小值 &#125; printf(&quot;%f\n&quot;, ans); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>多路dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客Equator尺取法]]></title>
    <url>%2F2018%2F11%2F04%2F%E8%AE%A1%E8%92%9C%E5%AE%A2Equator%2F</url>
    <content type="text"><![CDATA[题意： In a galaxy far away, the planet Equator is under attack! The evil gang Galatic Criminal People Cooperation is planning robberies in Equator’s cities. Your help is needed! In order to complete your training for becoming a lord of the dark side you should help them deciding which cities to rob. As the name says, the desert planet Equator only can be inhabited on its equator. So the gang lands there at some point and travels into some direction robbing all cities on their way until leaving the planet again. But what is still open for them is to decide where to land, which direction to take, and when toleave. Maybe they shouldn’t even enter the planet at all? They do not consider costs for travelingor for running their ship, those are peanuts compared to the money made by robbery! The cities diﬀer in value: some are richer, some are poorer, some have better safety functions. So the gang assigned expected proﬁts or losses to the cities. Help them deciding where to begin and where to end their robbery to maximize the money in total when robbing every city in between.输入 The input starts with the number of test cases T ≤ 30. Each test case starts a new line containingthe number of cities 1 ≤ n ≤ 1 000 000. In the same line n integers c i follow. Each c i (0 ≤ i &lt; n,−1000 ≤ c i ≤ +1000) describes the money obtained when robbing city i, a negative c i describes the amount of money they would lose.输出 For each test case print one integer describing the maximum money they can make in total.样例输入 33 1 2 38 4 5 -1 -1 1 -1 -1 52 -1 -1样例输出 614 0 ​ 这道题翻译成中文的意思大概就是给出一个n个数围成一圈，问最大连续子序列的和是多少？ 思路： 这道题解法有很多，自己习惯用尺取来求解。对于一个循环的序列，它的最大连续自序列要么是在这个数组中连续，要么是在这个数组中首尾相连。对于在这个数组中连续，我们可以通过尺取法求出来。对于收尾相连，我们可以换位思考，求出数组中连续的最小连续子序列，那么用数组的权值和减去最小连续子序列，剩下的两段连接起来就是收尾相连的最大连续子序列，我们只需要比较数组中连续的和数组首尾相连，取最大值即是正确答案 代码： #include &lt;stdio.h&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;ll a[1000005];int main () &#123; int T, n; scanf(&quot;%d&quot;, &amp;T); while(T --) &#123; ll sum = 0; ll maxx = 0; ll minn = 0x3f3f3f3f; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); sum += a[i]; &#125; int endd = 0; ll num = 0; while(endd &lt; n) &#123; if (num + a[endd] &lt; 0) &#123; num = 0; &#125; else &#123; num += a[endd]; maxx = max(num, maxx); &#125; endd ++; &#125; num = 0; endd = 0; while(endd &lt; n) &#123; if (num + a[endd] &gt; 0) &#123; num = 0; &#125; else &#123; num += a[endd]; minn = min(num, minn); &#125; endd ++; &#125; ll ans = max(maxx, sum - minn); printf(&quot;%lld\n&quot;, ans); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元]]></title>
    <url>%2F2018%2F10%2F26%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[待补～]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论十四)莫比乌斯反演]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[​ 上一篇将了二项式反演，这一篇讲一下莫比乌斯反演 学习莫比乌斯反演前，我们先要学习一下莫比乌斯函数 一.莫比乌斯函数定义： ​ 定义如下： ​ μ(1) = 1 当x = 1时 ​ μ(x) = (-1)^k 当x由k个不同的质数相乘得到时（保证每个质数都不同且只有质数） ​ μ(x) = 0 其余情况 ​ 二.莫比乌斯函数性质： ​ 性质1:当n = 1时，∑ μ(d) = 1 （其中d为n的全部因子） ​ 当n&gt;1时，∑ μ(d) = 0 （其中d为n的全部因子） ​ 性质2：∑ μ(d) / d = φ(n) / n φ(n)为欧拉函数 三.线性处理莫比乌斯函数： int mu[N + 5], vis[N + 5], prime[N + 5]; //mu数组用来存储莫比乌斯函数值，vis数组用于标记，prime用于存素数void init()&#123; mu[1] = 1; for(int i = 2; i &lt;= N; i ++)&#123; if(!vis[i])&#123; //如果是素数 prime[++prime[0]] = i; mu[i] = -1; //莫比乌斯函数为1 &#125; for(int j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt;= N; j ++)&#123; vis[i * prime[j]] = 1; if(i % prime[j]) mu[i * prime[j]] = -mu[i]; else&#123; mu[i * prime[j]] = 0; break; &#125; &#125; &#125;&#125; 四.莫比乌斯反演公式： 或者： 其中d|n表示能被n整除的所有因子d 五.例题 ​ 给出x, y的范围(x &lt;= a, y &lt;= b),问满足gcd(x, y) == k的对数？ ​ 当然啦，有其它巧妙的思路，比如利用欧拉函数+容斥原理，下面来说一下莫比乌斯反演的做法： ​ 设g(d)为满足gcd(x, y) == d的x,y对数，f(d)为满足gcd(x, y) == d的倍数 的x，y的对数 ​ 则：f(1) = g(1) + g(2) + g(3) + … ​ f(2) = g(2) + g(4) + g(6) + … ​ 我们由题意可得f(n) = (a / n)✖️(b / n) ​ 再根据莫比乌斯反演求解g(1) = μ(1)✖️f(1) + μ(2)✖️f(2) + μ(3)✖️f(3) +… + μ(a)✖️f(a) (当a &lt; b时)即可 ​ 若是对数(1, 2)和(2, 1)算作一个则需要去重！！ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论十三)二项式反演]]></title>
    <url>%2F2018%2F10%2F24%2F%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[一.引出反演 ​ 对于公式f(n) = g(1) + g(2) + … + g(n)，我们只要已知g(x)的函数方程，就可以得到任意的f(n)。但是已知f(x)的函数方程，我们能得到任意的g(n)吗？ ​ 这时候，我们就需要用到反演定理了。利用反演定理，我们就可以通过f(x)求任意的g(n)了 二.反演定理: ​ 对于不同的的用法，c，d是不同的，至于推导。。。我是不会，Orz～ 关于常用的反演，数学家们已经推倒出来c函数和d函数，我们直接记住用就可以了。 ​ 我们常见的反演有二项式反演，斯特林反演，莫比乌斯反演和最值反演，接下来说一下二项式反演。 三.二项式反演： ​ ​ 其中（上:n 下:i）代表C(n, i) ​ 四.例题： ​ 比如，n封信全部装错的方案数？ ​ 当然啦，有个错排公式能O(n)的的推出来，我们还是先看一下二项式反演的做法： ​ 我们设g(i)代表i封信全部装错的方案数 ​ 那么∑ C(n, i)✖️g(i)正好是全部的装信情况，也就是n! ​ 因此,f(n) = n! = ∑ C(n, i)✖️g(i) ​ 我们根据二项式反演公式得g(n) = ∑ (-1)^(n - i)✖️C(n, i)✖️f(i) ​ 因此我们只需要累加i从0～n的 (-1)^(n - i)✖️C(n, i)✖️(i)!的和，即为正确答案～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论十二)母函数]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%AF%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一.引出母函数 ​ 母函数，也就是生成函数，在ACM中常常用于求解组合数学的计数问题。 ​ 一般的，能用母函数做的题，也能用其它方法（诸如推规律啦，DP啦）等等来做，母函数的复杂度为O(n^3),可以说是非常高了，所以只有在数据特别小且实在想不到其他方法求解的时候才可以尝试一下用母函数来做 ​ 那么，什么是母函数呢？ 二.母函数的内容与例子 ​ 把一个已知的序列和x的多项式{x^0, x^1, x^2, … , x^n}合并起来，产生的新的多项式就叫做原来序列的母函数。 ​ 例如：序列{1, 0, 2, 4, 3, 1, 2}的母函数为f(x) = 1✖️x^0 + 0✖️x^1+ 2✖️x^2 + 4✖️x^3 + 3✖️x^4 + 1✖️x^5 + 2✖️x^6; ​ 下面就讲解两道例题，来说明母函数的用法： ​ 1.例如有1g, 2g, 3g, 4g砝码各一枚，问能称几种重量，每种重量的方案数？ ​ 1g砝码就是x^0 + x^1，2g砝码就是 x^0 + x^2，3g砝码就是x^0 + x^3，4g砝码就是x^0 + x^4 ​ 把他们累乘并化简，得到：1 + x + x^2 + 2✖️x^3 + 2✖️x^4 + 2✖️x^5 + 2✖️x^6 + 2✖️x^7 + x^8 + x^9 + x^10 ​ 我们从方程式可知，可以称0～10种重量，其中3～7有两种称法，其余一种 ​ ​ 2.有1分，2分，3分邮票无限，问贴出不同数值的方案数 （数值小于等于100）？ ​ 一分邮票可表示为(x^0 + x^1 + x^2 + x^3 + ….+ x^100) ​ 二分邮票可表示为(x^0 + x^2 + x^4 + x^6 + ….+ x^100) ​ 三分邮票可表示为(x^0 + x^3 + x^6 + x^9 + ….+ x^99) ​ 将三者累乘即可得到如例1中的方程式，即可一眼得到答案（可利用剪枝省略数值&gt;100的部分） 三.母函数的代码实现 ​ 我们拿第2个例子来说： ll N = 100; //设置上界ll c1[N + 5]; //c1[i]为最终多项式幂为i的系数ll c2[N + 5]; //c2为临时合并的多项式void init() &#123; c1[0] = 1; //初始化0的情况算1种 for (int i = 1; i &lt;= 3; i++) &#123; //遍历每种邮票 for (int j = 0; j &lt;= N; j += i) &#123; //该种邮票存在的次幂j for (int k = 0; j + k &lt;= N; k++) &#123; c2[j + k] += c1[k] * 1; //因为每种邮票的不同次幂系数都为1 &#125; &#125; for (int j = 0; j &lt;= N; j++) &#123; //将中间状态c2转移到c1并清空c2 c1[j] = c2[j]; c2[j] = 0; &#125; &#125;&#125;//c1[i]即为组成i分钱的方案数 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1430 康托展开]]></title>
    <url>%2F2018%2F10%2F24%2FHDU1430-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[这道题需要用到上一篇讲的康托展开与逆展开原理 跳转 题意： Problem Description 在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为： 1 2 3 48 7 6 5 对于魔板，可施加三种不同的操作，具体操作方法如下： A: 上下两行互换,如上图可变换为状态87654321B: 每行同时循环右移一格,如上图可变换为41236785C: 中间4个方块顺时针旋转一格,如上图可变换为17245368 给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。 Input 每组测试数据包括两行，分别代表魔板的初态与目态。 Output 对每组测试数据输出满足题意的变换步骤。 Sample Input 12345678172453681234567882754631 Sample Output CAC 思路： 上一篇举的例子就是这道题。在上一篇中我们说过，这道题无论把序列作为10进制或利用状压转成二进制都无法进行存储。因此需要利用康托展开的方式进行存储。 ​ 因此，我们只需要利用BFS预处理出初状态为1,2,3,4,5,6,7,8到每种状态的最小步骤即可，然后利用map将1,2,3,4,5,6,7,8映射到真正的初始状态，然后利用该映射关系得到目标状态相对于1,2,3,4,5,6,7,8的状态目标状态值t，ans[t]即为结果，因此只需要预处理，其它查询都是O(1)操作 ​ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define N 100000#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)using namespace std;char s1[10], s2[10];ll fact[10];queue&lt;ll&gt; q;bool book[N + 5];bool flag[10];string ans[N + 5];map&lt;d, d&gt; zcy;//逆康托展开string inv_cantor (ll num) &#123; string s = &quot;&quot;; mem(flag); For(i, 0, 7) &#123; ll t = num / fact[7 - i]; num %= fact[7 - i]; ll tot = -1; For(j, 1, 8) &#123; if (!flag[j]) tot++; if (tot == t) &#123; flag[j] = 1; s += (&apos;0&apos; + j); break; &#125; &#125; &#125; return s;&#125;//康托展开ll cantor (string s) &#123; ll res = 0; For(i, 0, 7) &#123; d tot = 0; For (j, i + 1, 7) &#123; if (s[i] &gt; s[j]) tot++; &#125; res += tot * fact[7 - i]; &#125; return res;&#125;//三种操作string chooes (string s, d inv) &#123; if (inv == 0) &#123; For(i, 0, 3) &#123; swap(s[i], s[7 - i]); &#125; &#125; else if (inv == 1)&#123; Forr(i, 3, 1) &#123; swap(s[i], s[i - 1]); &#125; For(i, 4, 6) &#123; swap(s[i], s[i + 1]); &#125; &#125; else &#123; swap(s[1], s[2]); swap(s[1], s[5]); swap(s[1], s[6]); &#125; return s;&#125;//预处理开始为1,2,3,4,5,6,7,8到各个状态的最小步数void init () &#123; mem(fact); mem(book); while (!q.empty()) &#123; q.pop(); &#125; fact[0] = fact [1] = 1; For(i, 2, 7) &#123; //预处理阶乘 fact[i] = fact[i - 1] * i; &#125; book[0] = 1; q.push(0); while (!q.empty()) &#123; ll num = q.front(); q.pop(); string s = inv_cantor (num); For(i, 0, 3) &#123; //保证字典序最小 string ss = chooes (s, i); ll num1 = cantor(ss); if (!book[num1]) &#123; q.push(num1); book[num1] = 1; ans[num1] = ans[num] + (char)(&apos;A&apos; + i); &#125; &#125; &#125; return;&#125;d main () &#123; init (); while (scanf(&quot;%s&quot;, s1 + 1) == 1) &#123; scanf(&quot;%s&quot;, s2 + 1); zcy.clear(); string s = &quot;&quot;; For(i, 1, 8) &#123; //利用映射关系把初始转化为12345678的序列,目标序列随之改变 zcy[s1[i] - &apos;0&apos;] = i; &#125; For(i, 1, 8) &#123; s += (&apos;0&apos; + zcy[s2[i] - &apos;0&apos;]); &#125; ll num = cantor(s); printf(&quot;%s\n&quot;, ans[num].data()); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论十一)康托展开与逆康托展开]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[一.引出康托展开 ​ 动态规划题有一类分支叫状压DP，意思就是把状态压缩为一个二进制数组，然后转为十进制数存储。一般n的大小不会超过20，因为20个状态的组合就有2^20,也就是1e6种可能。 ​ 对于一些题目，紧紧利用状态压缩，会发现状态的组合数远远超过1e6的范围，那时候我们没有办法在1s内遍历出来，或者大到根本连数组都开不出来的时候，一般情况下就需要用到康托展开 ​ 例如：对于一个组合 1 2 3 4 5 6 7 8，A操作可以让其转变为8 7 6 5 4 3 2 1，B操作可以让其转变为4 1 2 3 6 7 8 5，C操作可以让其转变为1 7 2 4 5 3 6 8 ​ 给出一个初始组合和目标组合，问由初始到目标最少的变换步骤，若多种则选字典树最小的那种？ ​ 对于这种题，如果我们把1～8看作0～7，拿这8个数的当作一个状态来存储，需76543210种状态（且里边有些状态根本就不可能出现，如11111111），这样肯定是不可行的。 ​ 如果我们利用状态压缩把它转为2进制，0为000，1为001，2为010….7为111,那么8个数连在一起共有24位，也就是需要2^24 = 16777216个状态进行存储，然后缩小了7倍，但是数组依旧太大了 ​ 这时候，我们需要考虑康托展开对状态进行定义 二.关于康托展开 ​ 和状压数组不同，康托展开数组a[i]代表的是该序列从第i位开始到最后一位，第i位的数排第几(排名和i都是从0开始) ​ 举个例子：3，5，4，1，2中：a[0] = 2,a[1] = 3, a[2] = 2,a[3] = 0, a[4] = 0 ​ 那么3 5 4 1 2的状态值 = a[0]✖️4! + a[1]✖️3! + a[2]✖️2! + a[3]✖️1! + a[4]✖️0! = 70 ​ 也就是说，康托展开能够把状态压缩到极致（即像上边那种没有用过的诸如11111111等都被抛弃掉，只剩有用的状态存在），即节省了空间也节省了时间。 三.关于康托逆展开 ​ 我们在二中得到的70可以通过康托逆展开重新得到3，5，4，1，2，方法如下： ​ 70 / 4! = 2余22，因此a[0] = 2; ​ 22 / 3! = 3余4，因此a[1] = 3; ​ 4 / 2! = 2余0，因此a[2] = 2; ​ 0 / 1! = 0余0，因此a[3] = 0; ​ 0 / 0! = 0余0，因此a[4] = 0; ​ 在1, 2 , 3, 4, 5中，第2大（从0开始算）的数是3 ​ 在1, 2 , 4, 5中，第3大（从0开始算）的数是5 ​ 在1, 2 , 4中，第2大（从0开始算）的数是4 ​ 在1, 2中，第0大（从0开始算）的数是1，最后一个数就是2 ​ 因此就能得到序列3，5，4，1，2 ​ 以上就是康托逆展开 四.代码实现： ​ (1)康托展开实现代码： fact[10]; //fact[i]存储i的阶乘的值//把数组s合并为一个状态num, k代表数组长度void cantor (int s[], ll &amp;num, int k) &#123; num = 0; for (int i = 0; i &lt; k; i ++) &#123; int cnt = 0; for (int j = i + 1; j &lt; k; j++) &#123; if (s[i] &gt; s[j]) cnt++; &#125; num += fact[k - i - 1] * cnt; &#125;&#125; （2）康托逆展开代码： fact[10]; //fact[i]存储i的阶乘的值//把状态值num转回数组sbool book[10]; //判断序列中下角标为i的数是否已经标记void inv_cantor (int s[], ll num, int k) &#123; memset (book, 0, sizeof(book)); for (int i = 0; i &lt; k; i++) &#123; int p = num / fact[k - i - 1]; num %= fact[k - i - 1]; int tot = 0; for (int j = 0; j &lt; k; j++) &#123; if (!book[j]) tot ++; if (tot == p) &#123; book[j] = 1; s[i] = j + 1; break; &#125; &#125; &#125;&#125; ​ 理论就是这些～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论十)卢卡斯定理与扩展卢卡斯]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%85%B3%E4%BA%8E%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[​ 在数论中我们经常遇到求组合数的问题，比如有n个球放入m个箱子里(m &gt; n)，每个箱子只能放一个球，问有多少种方案？类似这种题目就需要用到组合数来求解 ​ 学习该内容需学会之前讲的逆元和中国剩余定理。跳转链接：逆元 中国剩余定理 ​ 那么求组合数都有什么方法呢？ 一.其实早在古代，伟大的先人就解决了求解组合数的问题，那就是伟大的杨辉三角 ​ 我们发现 ​ 1 ​ 1，1 ​ 1，2，1 ​ 1，3，3，1 ​ 1，4，6，4，1 ​ 1，5，10，10，5，1 ​ 有没有发现，C（n,m）的值就是第n行m列的值（下标从0开始） ​ 虽然这样可以求组合数，但是它的复杂度是O(n^2)太大了，只能求解1e3以内的组合数 二.我们可以进一步优化 ​ 由于已知C（n,m）= n！/ (n - m)! ✖️m！ ​ 我们只需要预处理出前n的阶乘与前n阶乘的逆元，每次就可以O（1）的时间求出组合数的值 ​ 因此，我们只需要耗费O(n)的复杂度预处理就可以了 ​ 因此它可以求1e6以内的组合数 三.卢卡斯定理 ​ 卢卡斯定理：C（n,m）% p = C（n / p ,m / p)✖️C（n % p ,m % p) % p ​ 当n和m特别大时题目中必须有取余操作，要不会爆longlong，若p小于1e7时卢卡斯定理就派上了用场。 ​ 附上代码： ll fact[N + 5];ll inv[N + 5];//省略中间的扩展欧几里得求逆元void init () &#123; fact[0] = fact[1] = 1; for (int i = 2; i &lt;= N; i ++) &#123; fact[i] = fact[i - 1] * i % mod; &#125; inv[N] = mod_reverse(fact[N], mod); //调用扩展欧几里得求逆元 for (int i = N -1; i &gt;= 0; i--) &#123; inv[i] = inv[i + 1] * (i + 1) % mod; &#125; return;&#125;ll C (ll n, ll m) &#123; if (n &lt; m || m &lt; 0) return 0; if (n &lt; mod) return fact[n] * inv[m] % mod * inv[n - m] % mod; return C (n / mod, m / mod) * C (n % mod, m % mod) % mod;&#125; ​ 以上代码只适用于p&lt;1e7且p为素数的情况，若p为合数呢？ ​ 此时就需要用到扩展卢卡斯定理了（此前需学会中国剩余定理） 四.扩展卢卡斯定理： ​ 由于p为合数，因此我们可以将p分解为p1^a1✖️p2^a2✖️…pk^ak的形式 ​ 因此我们可以利用卢卡斯定理求得： ​ ans ≡ x1 (mod p1^a1) ​ ans ≡ x2 (mod p2^a2) ​ …… ​ ans ≡ xk (mod pk^ak) ​ 不同质数的幂次方之间肯定两两互质，通过求得每组的解xi，再利用中国剩余定理就可以合并得到最终答案 ​ 每组解xi的求法：C（n，m）% (pi^ai) ​ 因此我们需要获得剔除pi因子后的乘积n！,m！的逆元,（n - m）！的逆元的乘积去取模（pi^ai）并加入被剔除的pi的贡献即可 ​ 那么我们如何求n！剔除pi因子的乘积呢？ ​ 例如19! % (3^2) = （1✖️2✖️4✖️5✖️7✖️8）✖️(10✖️11✖️13✖️14✖️16✖️17)✖️(19)✖️(1✖️2✖️3✖️4✖️5✖️6) ​ （）内的代表一个分组，每个分组在取余pi^ai后结果相同，因此只需暴力一个分组，利用快速幂求解即可，对于(19)这种不足一个分组的，可以暴力单度计算。对于(1✖️2✖️3✖️4✖️5✖️6)，可提前预处理出来 ​ 最后xi = (n)! % (pi^ai)✖️inv((m)! % (pi^ai), pi^ai)✖️inv((m)! % (pi^ai), pi^ai)✖️pi^k即可（其中k为pi在C(n, m )中出现的次数） ​ 最后利用中国剩余定理将xi合并即可 ​ 附上代码： ll ksm(ll a, ll b, ll mod) &#123;&#125; //省略快速幂ll extend_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123;&#125; //省略扩展欧几里得ll mod_reverse (ll a, ll n) &#123;&#125; //省略逆元//用于求n!%(pi^ai) 其中pk =（pi^ai）ll mul(ll n,ll pi,ll pk) &#123; if(!n) return 1; ll ans=1; if(n / pk) &#123; for(ll i = 2;i &lt; pk; i++) if(i % pi) ans = ans * i % pk; ans = ksm(ans, n / pk, pk); &#125; for(ll i = 2;i &lt;= n % pk; i++) if(i % pi) ans = ans * i % pk; return ans * mul(n / pi, pi, pk) % pk;&#125;//求xill C(ll n, ll m, ll mod, ll pi, ll pk) &#123; if(m &gt; n) return 0; ll a = mul(n, pi, pk),b = mul(m, pi, pk),c = mul(n-m, pi, pk); ll k=0, ans; for(ll i = n; i; i /= pi) k += i / pi; for(ll i = m; i; i /= pi) k -= i / pi; for(ll i = n - m; i; i /= pi) k -= i / pi; ans = a * mod_reverse(b, pk) % pk * mod_reverse(c, pk) % pk * ksm(pi, k, pk) % pk; return ans * (mod / pk) % mod * mod_reverse(mod / pk, pk) % mod;&#125;//扩展卢卡斯ll exLucas(ll n, ll m, ll mod) &#123; ll ans = 0; for(ll x = mod, i = 2; i &lt;= mod; i++) if(x % i == 0) &#123; ll pk = 1; while(x % i == 0) &#123; pk *= i; x /= i; &#125; ans = (ans + C(n, m, mod, i, pk)) % mod; &#125; return ans;&#125; ​ 完工～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论九)中国剩余定理与扩展]]></title>
    <url>%2F2018%2F10%2F23%2F%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[​ 学习中国剩余定理之前必须学会求解逆元： 跳转 一.中国剩余定理： ​ 记得小时候听过一个故事，就是韩信想知道自己有多少士兵，然后就先让士兵排成x列，余出来a个人，后来又让士兵排成y列，余出来b个人，后来又让士兵排成z列，余出来c个人，最后韩信直接算出了自己的士兵数。。Orz～ ​ 呃呃呃，感觉有点像小学的时候做过的奥数题。。。 ​ 假使x，y，z分别为3，5，7，a，b，c分别为2，3，2，那么我们问最小士兵数是多少？ ​ 注意一点！！！x,y,z必须满足两两互质！！！ ​ 根据逆元的性质，我们可以知道： ​ 3✖️5✖️mod_reverse(15, 7) ≡ 1 （mod 7） （1） ​ 3✖️7✖️mod_reverse(21, 5) ≡ 1 （mod 5) (2) ​ 5✖️7✖️mod_reverse(35, 3) ≡ 1 （mod 3） (3) ​ 把(1)乘2，(2)乘3，(3)乘2，得： ​ 2✖️3✖️5✖️mod_reverse(15, 7) ≡ 2 （mod 7） （4） ​ 3✖️3✖️7✖️mod_reverse(21, 5) ≡ 3 （mod 5) (5) ​ 2✖️5✖️7✖️mod_reverse(35, 3) ≡ 2 （mod 3） (6) ​ 我们设： ​ a = 2✖️3✖️5✖️mod_reverse(15, 7) ​ b = 3✖️3✖️7✖️mod_reverse(21, 5) ​ c = 2✖️5✖️7✖️mod_reverse(35, 3) ​ 因此我们可以得到： ​ (a + b + c) % 3 = a % 3 + b % 3 + c % 3 = 0 + 0 + 2 = 2; ​ (a + b + c) % 5 = a % 5 + b % 5 + c % 5 = 0 + 3 + 0 = 3; ​ (a + b + c) % 7 = a % 7 + b % 7 + c % 7 = 2 + 0 + 0 = 2; ​ 所以说，士兵数为a + b + c就满足该条件 ​ 代码实现如下： //省略扩展欧几里得求逆元的函数ll china (ll n, ll *a, ll *m) &#123; //m[i]代表3，5，7等除数，a[i]代表2，3，2等余数 ll M = 1; //M代表所有除数的乘积 ll res = 0; for (int i = 0; i &lt; n; i++) &#123; M *= m[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; ll w = M / m[i]; ret = (ret + a[i] * w * mod_reverse(w, m[i])) % M; //若上面的式子爆longlong，可利用快速乘来求解 &#125; return (ret + M) % M;&#125; ​ 二.中国剩余定理扩展： ​ 前边注意中已经标注了，中国剩余定理的前提是x，y，z（也就是说除数）必须两两互质。如果不互质我们又该怎么办呢？ ​ 我们假设x ≡ a1 (mod n1) ​ x ≡ a2 (mod n2) ​ 合并两式，得：n1k1 = n2k2 + a2 - a1 ​ 两边同除gcd(n1, n2)，得： ​ n1k1 / gcd(n1, n2) = n2k2 / gcd(n1, n2) + (a2 - a1) / gcd(n1, n2) ​ 由于n1 / gcd(n1, n2) 与n2 / gcd(n1, n2)互质，因此： ​ n1k1 / gcd(n1, n2) ≡ (a2 - a1) / gcd(n1, n2) （mod n2 / gcd(n1, n2)） ​ 同除n1 / gcd (n1, n2)，得：k1 ≡ mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2) （mod n2 / gcd(n1, n2)） ​ k1 = mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2) + n2 / gcd(n1, n2)✖️y ​ 把k1代入x = n1k1 + a1，得： ​ x = mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2)✖️n1 + n1n2 / gcd(n1, n2)✖️y ​ 呃呃呃，解x就求出来了… ​ 这是两个式子的联立，那么多个呢？ ​ 对于多个，我们先求出两个数的解x，把x带入到a2中，并把n2替换为lcm(n1, n2)，然后继续求2，3的解，直到递推到n结束。最后n - 1和 n的解x即为答案。 ​ 代码如下： const int maxn=1e5+5;int n;ll m[maxn],a[maxn]; //m[i]为除数，a[i]为余数//求gcdll gcd (ll a, ll b) &#123; return a % b == 0? b: gcd(b, a % b);&#125;//扩展欧几里得算法ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (a == 0 &amp;&amp; b == 0) return -1; if (b == 0) &#123; x = 1; y = 0; return a; &#125; ll d = extend_gcd(b, a % b, y, x); y -= a / b * x; return d;&#125;//求a关于n的逆元ll mod_reverse (ll a, ll n) &#123; ll x, y; ll d = extend_gcd(a, n, x, y); if (d == 1) return (x % n + n) % n; return -1;&#125;//中国剩余定理扩展ll work()&#123; int flag = 0; for (int i = 2; i &lt;= n; i++) &#123; ll n1 = m[i - 1], n2 = m[i]; ll a1 = a[i - 1], a2 = a[i]; ll d = gcd(n1, n2); if ((a2 - a1) % d != 0) &#123; flag = 1; break; &#125; m[i] = m[i - 1] / d * m[i]; ll x = (mod_reverse(n1 / d, n2 / d) * (a2 - a1) / d) % (n2 / d) * n1 + a1; x = (x % m[i] + m[i]) % m[i]; a[i] = x; &#125; if (flag) return -1; return a[n];&#125; ​ 大概就是这样～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论八)容斥原理与抽屉原理]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一.先讲一下抽屉原理，其实高中的时候我们都学过，它可扩展为3个： ​ 1.把n + 1个物体放到n个抽屉，至少有一个抽屉里物件不少于2 ​ 2.把mn + 1个物体放到n个抽屉，至少有一个抽屉里物件不少于m+1 ​ 3.把无穷多个物体放到n个抽屉，至少有一个抽屉里有无穷多 它又衍生出来第二抽屉原理，即： ​ 把nm - 1个物体放到n个抽屉，必有一个抽屉中至多有m - 1个物体 定理就这么简单，但是想用好属实挺难～ ​ 例如给你一个数组a和一个数m，问数组中能否选出几个数相加的和能被m整除？ ​ 这个题咋一看和抽屉原理也没啥必然联系啊，那就再仔细瞅瞅。。 ​ 联系抽屉原理，我们可以知道，当n &gt; m时，必然能选出几个数的和被m整除。 ​ 为什么？因为n个数求余m会产生n个余数，至少有两个相同的余数。 ​ n个m以内的余数一定能组成m的倍数 ​ 这样，我们只需要判断 n &lt;= m时的情况即可 二. 容斥原理 ​ 容斥原理原理是为避免重复计算的一种想法，很简单，同抽屉原理一样，难在活学活用～ ​ 简单说一下容斥原理，例如下图，我们知道三个圆各自的面积，问三个圆一共占有的面积是多少？这时候为了避免重复运算，就需要用到容斥原理了： ​ 在此感谢百度百科提供的图片资源～～～ 也就是说，3个圆占有的面积是三个圆的面积和 - 红色部分 + G部分 嗯嗯，原理就是这些，还是实战一下吧： ​ 1.例如从m种颜色挑选k种给n盆花染色，要求相邻花颜色不同，问方案数？ ​ 从m种颜色挑选k种共有C(m, k)种方案数，而k种颜色给n盆花染色且相邻花颜色不同，这时候我们就可以利用容斥原理了。 ​ 种类数应该是：可用k种颜色保证相邻花色不同的方案数 - 可用k - 1种颜色种颜色保证相邻花色不同的方案数+ 可用k - 1种颜色种颜色保证相邻花色不同的方案数…(-1)^(k - 1)✖️可用1种颜色种颜色保证相邻花色不同的方案数 ​ 只需要把种类数✖️C(m, k)即为答案 ​ 这样就可以简化思考的复杂度了～ ​ 2.求区间(a, b)中与n互质的数的个数，例如求区间(a, b)中与12互质的个数 ​ 我们可以先筛选出12的全部素因子2, 3，我们只需要求(a, b)的个数 - 素因子2对(a, b)的贡献 - 素因子3对(a, b)的贡献 + 因子(2✖️3)对(a, b)的贡献，即是最终答案。​ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杜教BM模版(推规律)]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%9D%9C%E6%95%99BM%E6%A8%A1%E7%89%88-%E6%8E%A8%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[​ 无论是矩阵快速幂求第n项，还是给出输出前几项求规律的第n项。。。几乎就没有它做不到的～至于原理。。。呃呃呃，会用就完了！！！ ​ 下面是找到的能用的BM模版： #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+... // printf(&quot;%d\n&quot;,SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main() &#123; while (~scanf(&quot;%d&quot;,&amp;n)) &#123; vector&lt;int&gt;v; v.push_back(1); //这儿就可以输入前几项的数，用来推规律 v.push_back(2); v.push_back(4); v.push_back(7); v.push_back(13); v.push_back(24); //VI&#123;1,2,4,7,13,24&#125; printf(&quot;%d\n&quot;,linear_seq::gao(v,n-1)); &#125;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-10-23博客搭建进度]]></title>
    <url>%2F2018%2F10%2F23%2F18-10-23%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果(10.20更新) ​ ——新增页面卡通人物效果(10.20更新) ​ ——微调音乐布局(10.20更新) ​ ——微调小火箭布局(10.20更新) ​ ——新增标签数量统计 ​ ——新增博文数量统计]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论七)关于sqrt、pow与log的巧用]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%85%B3%E4%BA%8Esqrt%E4%B8%8Elog%E7%9A%84%E5%B7%A7%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一. sqrt ​ 大家都知道sqrt(x)是求x的平方根，c中自带的math.h库有关于该函数的使用。这里就不多叙述~ ​ 关于求sqrt，这里有一个神人约翰-卡马克，大家可以百度搜索一下这个神人的辉煌事迹（求sqrt的神秘数字），附上它的代码%一下： float Q_rsqrt( float number )&#123;long i;float x2, y;const float threehalfs = 1.5F;x2 = number * 0.5F;y = number;i = * ( long * ) &amp;y; // evil floating point bit level hackingi = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck?y = * ( float * ) &amp;i;y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration// y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed#ifndef Q3_VM#ifdef __linux__assert( !isnan(y) ); // bk010122 - FPE?#endif#endifreturn y;&#125; ​ 它的这段代码求sqrt(number)的倒数，速度比math.h库中的(float)(1.0/sqrt(x))快4倍！！！ ​ 注释中的what the fuck? 也表明了我们普通人的心情。。。。 ​ 话不多说，%%%%%%%%%%%%%%%%%%%%%%%%%%就完了 ​ 二.pow ​ 关于pow函数也存在与math.h库中，具体使用也不详细介绍，我们来说一下它的巧用 ​ 假如a^b = c，我们已知b和c，如何求a？（其中b &lt;= 200, a &lt;= 1e9, c &lt;=1e100 ） ​ 注意！！c的取值范围是1e100！！！ ​ 这时候就有一个巧办法了，虽然double精度不足1e100，但我们只需要知道它的前16位即可，因为当b错一位，c的前16位变化很大。所以虽然double只保留了16位，但计算出的c是唯一的。因此： ​ pow (c, 1 / n)保留0位小数，即为a 三.log ​ 关于log的巧妙用法 ​ 第一个：例如给出a, b, c, d,如何比较a^b与c^d的大小？ ​ 我们只需要求p = b✖️log(a); q = d✖️log(c) ​ 如果p - q的绝对值 &lt;= 1e-6，则两者相等， ​ 如果 p &lt; q ，则a^b &lt; c^d， ​ 否则a^b &gt; c^d ​ ​ 第二个：求一个数x有多少位数： ​ 利用(int)log10(x) + 1可以求得x一共多少位 ​ 第三个：求一个数x在二进制下有多少位： ​ 利用(int)log2(x) + 1可以求得x在二进制下一共多少位 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论六)关于欧拉(定理、公式、函数、降幂)]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%85%B3%E4%BA%8E%E6%AC%A7%E6%8B%89-%E5%AE%9A%E7%90%86-%E5%85%AC%E5%BC%8F-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[​ 最最开始的时候，我以为欧拉函数，欧拉定理，欧拉公式是一个东西，傻傻分不清。傻笑～ ​ 后来知道，这完完全全是三种东西！！要说有啥必然的联系，它们可能都叫欧拉吧～ ​ 首先，我们来讲一下三者的定义： ​ 欧拉定理：若n,a为正整数且互质，则a^(Φ(n)) = 1 (mod n) ​ 欧拉公式：e^(i✖️x) = cos(x) + i✖️sin(x) （例如把x = π带进去，得e^(i✖️π) = -1） ​ 欧拉函数：Φ(n)，用于求1～n中与n互质的个数，若n为质数，那么Φ(n) = n - 1​ 欧拉降幂：我们知道当幂特别大的时候可以用快速幂来求，而当幂大到10^1000时快速幂也求不了了。。这时候就需要用到欧拉降幂，它的定理如下（前提是a，p互质）： ​ a^b ≡ a^(b % Φ(p) + Φ(p)) (mod p)，当x &gt;= p时 ​ a^b ≡ a^(b % Φ(p)) (mod p)，当x &lt; p时 关于欧拉公式在ACM中我还没有做过相关的题，因此先只讲欧拉函数和欧拉降幂，欧拉定理 一.关于欧拉定理没什么好说的～ ​ 之前我们说过一嘴费马小定理：a ^ (p - 1 ) ≡ 1 (mod p) ​ 又说过当p为素数时Φ(p) = p - 1，因此欧拉定理实际上是费马小定理的推广 二.关于欧拉函数的求解，我们知道n为质数的情况了，若n为合数呢？ ​ 学到了以下四种求法n的欧拉函数： ​ 1.利用容斥原理： ​ 我们先找到n的全部质因子，然后利用容斥原理删掉全部的因子，剩下的就是与n互质的个数 ​ 例如30 = 2✖️3✖️5 ​ Φ(30) = 30 - 30 / 2 - 30 / 3 - 30 / 5 + 30 / (2✖️3) + 30 / (2✖️5) + 30 / (3✖️5) - 30 / (2✖️3✖️5) ​ = 8 ​ 2.上面的写法很麻烦，下面有种简便的写法： ​ 30 = 30✖️1 / 2 ✖️2 / 3✖️4 / 5 = 8，这样就能自动容斥啦，时间复杂度是O(sqrt(n)) ​ 3.埃筛法： ​ 是不是很耳熟！！！对，求素数有埃筛和线筛，求欧拉函数也有埃筛和线筛～，埃筛的原理就是利用方法2～，时间复杂度是O(n✖️sqrt(n)) ​ ​ 代码如下： void getEuler() &#123; memset(euler, 0, sizeof(euler)); euler[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!euler[i]) &#123; for (int j = i; j &lt;= N; j += i) &#123; if (!euler[j]) &#123; euler[j] = j; //若不存在先初始化 &#125; euler[j] = euler[j] / i * (i - 1); //实质就是方法2 &#125; &#125; &#125;&#125; ​ ​ 4.线性筛 ​ 线性筛，顾名思义就是线性求解1～n的欧拉函数，需用到一下几个性质： ​ 1.当p为素数时，Φ(p) = p - 1; ​ 2.当p为素数且i % p ==0时，Φ(i✖️p) = Φ(i)✖️p ​ 3.当p为素数且i % p != 0时，Φ(i✖️p) = Φ(i)✖️(p - 1) ​ 代码如下： ll phi[N + 5]; //存储欧拉函数ll prime[N + 5]; //存素数void Euler() &#123; phi[1] = 1; memset(phi, 0, sizeof(phi)); prime[0] = 0; for (int i = 2; i &lt;= N; i++) &#123; if(!phi[i]) &#123; //若i为素数 phi[i] = i - 1; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; (ll)i * prime[j] &lt;= N; j++) &#123; if (i % prime[j]) &#123; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; else &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; &#125; &#125; return;&#125; 三.欧拉降幂： ​ 根据 a^b ≡ a^(b % Φ(p) + Φ(p)) (mod p)，当x &gt;= p时 ​ a^b ≡ a^(b % Φ(p)) (mod p)，当x &lt; p时 ​ 我们可以得到以下代码： #define Mod(a, b) a &lt; b? a: a % b + b //重定义取模，按照欧拉定理的条件map&lt;ll,ll&gt; mp; //记忆化存储欧拉函数//按照欧拉定理的条件进行快速幂ll qpow(ll x, ll n, ll mod) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = Mod(res * x, mod); n--; &#125; x = Mod(x * x, mod); n &gt;&gt;= 1; &#125; return res;&#125;//求k的欧拉函数值ll phi(ll k) &#123; ll i; ll s = k; ll x = k; if (mp.count(k)) return mp[x]; //记忆化存储 for(i = 2; i * i &lt;= k; i++) &#123; if (k % i == 0) s = s / i * (i - 1); //利用方法2 while(k % i == 0) k /= i; &#125; if(k &gt; 1) s = s / k * (k - 1); mp[x]=s; return s;&#125; 注意！！当快速幂需要用到之前的递归时，也需要迭代模!!! ​ 例如 a[1]^(a[2]^(a[3]^(a[4]…))) LL solve(LL l,LL r,LL mod) &#123; if (l==r||mod==1) return Mod(a[l], mod); //如果到右端点或者φ值等于1，那么直接返回当前数字 return qpow(a[l], solve(l+1, r, phi(mod)), mod); //否则指数为[l+1,r]区间的结果&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论五)关于自己理解的逆元]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%85%B3%E4%BA%8E%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[学这个之前建议看看之前发的那篇关于快速幂和扩展gcd的博文：跳转 一.引出逆元的用途 在讲逆元是什么之前，先说一下我们遇到的错误。。 ​ 对于特别大的数的连乘，让我们对最终结果取模1e9 + 7，可能在连乘的时候就已经爆longlong了，我们应该怎么做呢？ ​ 根据同余定理可知，(a✖️b) % mod = ( (a % mod) ✖️ (b % mod)) % mod，因此，我们可以设longlong型数ans = 1，每次乘以一个较大数的时候，都取模一下1e9+7，避免爆longlong。代码如下： const ll mod = 1e9 + 7;ll ans = 1;for (int i = 0; i &lt; n; i++) &#123; ans = ans * a[i] % mod;&#125;最终ans即为n个数连乘取模1e9 + 7的结果 ​ ​ 若是不只是乘法，中间再夹杂着除法，我们再按照上面的方式ans = ans / a[i] % mod，当我们兴冲冲的上交后，一个冷冰冰的WA在我们脸上胡乱的拍～ ​ 这是为啥呢？ ​ 因为同余定理中不包含(a / b) % mod = ((a % mod) / (b % mod)) % mod，记住不包含！！！ ​ 那么我们该怎么办呢？好办，我们将除法改成乘不就完了嘛～ ​ 除以一个数不就是乘一个数的倒数嘛，一个倒数在取模mod时为多少呢？ ​ 这时候逆元就出现了！！ ​ 也就是说，a / b % mod相当于a ✖️ b关于mod的逆元 % mod ​ 我们只需要求b关于mod的逆元就可以了～ 二.逆元的求法 ​ 至于求逆元的方式有很多，比如利用费马小定理，扩展欧几里得，欧拉定理等等…我比较常用方法是费马小定理和扩展欧几里得 ​ (1)利用费马小定理求逆元： ​ 我们由于费马小定理可知：当p为素数时，有a ^ (p - 1) ≡ 1 (mod p) ​ 两边同时除a，得a^(p - 2) ≡ inv(a) (mod p) 其中inv(a)是a关于p的逆元 ​ 因此: inv(a) = a ^ (p - 2) (mod p) ​ 我们就可以通过使用快速幂求得a ^ (p - 2)取模p得到 a 关于p的逆元 ​ 代码如下： //利用快速幂求a^(p - 2) mod pll pow_mod (ll a, ll b, ll p) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;//费马小定理求a关于p的逆元ll permat (ll a, ll p) &#123; return pow_mod (a, p - 2, p);&#125; (2)利用扩展欧几里得求逆元 ​ 上一篇我们学了gcd的求法，它是根据欧几里得算法的核心 gcd (a, b) = gcd (b, a % b)递归得到的 ​ 那么，扩展欧几里得是什么呢？ ​ 我们可以利用已知的a，b，一定存在至少一组解x，y，使它们满足贝祖等式：a✖️x + b✖️y = gcd(a, b) ​ 至于这个定理为什么成立，我也没学。。。Orz，我觉得会用就可以了，冷汗😓 ​ 根据a✖️x + b✖️y = gcd(a, b)，若a，b互质，那么此时a✖️x + b✖️y = gcd(a, b) = 1 ​ 我们对a✖️x + b✖️y = 1同时取余b，会得到a✖️x % b + b✖️y % b = 1 % b ​ =&gt; a✖️x % b = 1 % b ​ =&gt; a✖️x = 1(mod b) ​ 大家看着是不是似成相识呢？，对！x就是a关于b的逆元 ​ 因此，我们就可以通过扩展欧几里得算法求解x即可。 关于扩展欧几里得算法： ​ 我们设x✖️a + y✖️b = d （d为gcd(a, b)); (1) ​ 那么x1✖️b + y1✖️(a % b) = d; (2) ​ 也就是说x✖️a + y✖️b = x1✖️b + y1✖️(a % b); （3） ​ 因为a % b = a - (a / b)✖️b; (4) ​ 我们把(4)带入(3)，得： ​ x✖️a + y✖️b = x1✖️b + y1✖️(a - (a / b)✖️b) (5) ​ 化简得：x✖️a + y✖️b = y1✖️a + (x1 - (a / b)✖️y1)✖️b （6） ​ 因此，我们可得x = y1， y = x1 - (a / b)✖️y1 代码实现如下： //扩展欧几里得ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp; y) &#123; if (a == 0 &amp;&amp; b== 0) return -1; //此时由于a,b无最大公约数，所以出错 if (b == 0) &#123; //递归终止条件，若b == 0，那么gcd(a,b) == a，a * x + b * y = gcd (a, b) = 1，因此x = 1 x = 1; y = 0; return a; //返回a用于判断a是否为1，用以确定原a,b是否互质 &#125; ll d = extend_gcd (b, a % b, y, x); //由扩展欧几里得可得 y -= a / b * x; return d;&#125;//求逆元 ax = 1 (mod p)ll mod_reverse (ll a, ll p) &#123; ll x, y; ll d = extend_gcd(a, p, x, y); //把a带入a，p带入b，通过扩展欧几里得求x if (d == 1) return (x % p + p) % p; //如果a == 1表明gcd(a,p)为1，也就是a,p互质，因此输出x else return -1; //否则a,p不互质，返回-1&#125; 三.线性求逆元 ​ 求素数有线性筛，那么逆元呢？逆元当然不能落后啦，于是线性求逆元出现了Orz～ ​ 线性求逆元的公式是：inv(a) = (p - p / a)✖️inv(p % a) % p ​ 证明过程：设x = p % a, y = p / a; ​ 则有x + y✖️a = p ​ 因此(x + y✖️a) % p = 0 ​ x % p = (- y)✖️a % p ​ x✖️inv(a) % p = (-y) % p ​ inv(a) = (p - y)✖️inv(x) % p ​ inv(a) = (p - p / a)✖️inv(p % a) % p 这样，我们就可以利用之前的逆元求解后面的逆元了，代码如下： void init() &#123; inv[0] = 1; inv[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; inv[i] = ((p - p / i) * inv[p % i]) % p; &#125;&#125; ​ 四.线性求阶乘逆元 ​ 如果我们需要求0!到n!的逆元，对每个元素都求一遍会特别慢​ 前面说了，逆元就可一看做是求倒数 ​ 那么就有1 / (n+1)! × (n+1)=1/ n! ​ 因此inv[n + 1]✖️(n + 1) = inv[n] (mod p) 代码如下： ll fact[N + 5]; //存储阶乘ll inv[N + 5]; //存储阶乘的逆元fact[0] = 1;for (int i = 1; i &lt;= N; i++) &#123; fact[i] = fact[i - 1] * i % p; //线性求阶乘&#125;inv[N] = mod_reverse(fact[N], p); //利用前面学的扩展欧几里得求fact[N]关于p的逆元for (int i = N - 1; i &gt;= 0; i--) &#123; inv[i] = inv[i + 1] * (i + 1) % mod; //求线性阶乘逆元&#125; ​ ​ 以上就是我对逆元的全部理解了，就酱紫～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论四)快速幂与gcd扩展]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E5%BF%AB%E9%80%9F%E4%B9%98%E4%B8%8Egcd%E6%89%A9%E5%B1%95-%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[一.关于快速幂: ​ 我们要想求a^b，也就是b个a相乘，我们可以设置ans = 1，然后for循环b次，用ans累成a得到最终答案ans，这样时间复杂度是O(b) ​ 当b大于1e9，我们用上面的办法就不能在1s内求出结果了。 ​ 举个栗子2^11,我们仔细观察一下： ​ ans = 2 ^ 11 ​ = 2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2 ​ = 4✖️4✖️4✖️4✖️4✖️2 ​ = 16✖️16✖️4✖️2 ​ = 256✖️4✖️2 ​ 因此我们可以只求2，4，16，256中2,4,256组合得到2^11，而2,4,16,256可以根据平方递推得到，这样要想求得a ^ b的值时间复杂度只有O(log(b))，可以说是非常快了 ​ 代码如下： ll quick(ll a, ll b) &#123; //求a^b ll ans = 1; while (b) &#123; if (b &amp; 1) ans *= a; //只有b为奇数时乘a，例如2^11时ans只累乘2，4，256 b &gt;&gt;= 1; //相当于b /= 2 a *= a; //就是上面所说的通过平方和递推，优化运算时间 &#125; return ans;&#125; 二. gcd扩展： ​ gcd几乎是我们刚入学接触的第一个递归了，大家想必已经熟记于心。 ​ 根据gcd(a, b) = gcd (b, a % b) （a &gt; b且 b != 0) 公式，我们只需要知道递归的终止条件，就可以写出这个递归代码。 ​ 由于b != 0，所以当a % b == 0时不能继续递归。那么，当a % b == 0时，我们应该返回什么呢？谁才是a,b的最小公约数？ ​ 由于a % b == 0，因此a一定是b的倍数，也就说b一定是a的因子，又因为b的最大因子是b，因此a,b的最大公约数一定是b，根据gcd(a, b) = gcd(b, a % b)，我们知道b也是最初始的a,b的最大公约数。 ​ 实现代码如下： ll gcd (ll a, ll b) &#123; //前提条件：a,b中不存在0 return a % b == 0? b: gcd(b, a % b);&#125; ​ 题外话，以前以为该函数的前提条件是a必须大于b。。。其实a&lt;b也可以，因为经过一次递归，就变成了 a = b, b = a，亏我之前还判断a，b的大小。。 ​ 好啦，我们说几个gcd的扩展定理： ​ (1).gcd (ka, kb) = k✖️gcd(a, b) ​ (2).lcm(ka, kb) = k ✖️lcm(a, b) ​ (3).lcm(s / a, s / b) = s / gcd(a, b) ​ ​ 有一些题目可通过这些扩展定理来少走很多弯路～ ​ Over～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论三)素数原理]]></title>
    <url>%2F2018%2F10%2F21%2F%E7%B4%A0%E6%95%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[​ 打算写一下自己对ACM中常用到的数论知识，加深巩固和查缺补漏。 ​ 在数学中，对于n&gt;1,若n的因子只有1和它本身，那么n就是质数，也称作素数。而在ACM中素数类型的题目是经常会碰到的。 ​ 那么我们可以怎么判断素数呢？ 一.对于判断单个n是否为素数，我们可以通过三种情况来判断： ​ （1）用i遍历2~ n -1，若n % i == 0就代表存在除1和它本身以外的因子，就直接跳出，若执行完就代表没有其它因子，n为素数。时间复杂度为O(n) ​ (2) 我们可以优化(1)，因为若存在大于sqrt(n)的因子k，那么n / k 的值一定在 2 ~ sqrt(n)中。因此我们只需要用i遍历2 ~ sqrt(n)即可，若n%i == 0就代表存在除1和它本身以外的因子，就直接跳出，若执行完就代表没有其它因子，n为素数，时间复杂度为O(sqrt(n)) 。 ​ (3) 我们继续优化(2)，若 n % 2 != 0，那么从i从3~sqrt(n)，只需要考虑奇数即可。因此时间复杂度为O(sqrt(n) / 2) 我给出(3)的代码： bool chooes(ll n) &#123; //判断n是否为素数 if (n % 2 == 0) return false; //若n%2==0，则说明n不是素数 for (int i = 3; i * i &lt;= n; i += 2) &#123; //从3～sqrt(n)，每次+=2，若存在n % i == 0，则说明n不是素数 if (n % i == 0) return false; &#125; return true; //否则n为素数&#125; 二.对于判断2～n每个数是否为素数，我们应该怎么办呢？ ​ 我们利用一中最快的(3)方法，时间复杂度为O(n✖️sqrt(n) / 2)，若n为1e5以上，1s之内是筛选不出来的。因此我们只能想别的办法，先来介绍第一种： （1）由于是求2～n的每个数，因此我们可以尝试利用之前已经判断过的数来求后面的数是否为素数。我们知道，素数的因子只有1和它本身，那么一个2以上的数的倍数一定不是素数！！又因为合数一定可以由素数累乘得到，所以我们只需要把所有素数的倍数标记为合数，剩余的数一定是质数。 ​ 也就是说，对于n = 10，素数2的倍数4，6，8，10一定是合数； ​ 素数3的倍数6，9一定是合数 ​ 4是合数跳过，素数5的倍数10一定是合数； ​ 6是合数跳过，得到素数7 ​ 由于8，9，10是合数，因此全部跳过 ​ 我们就得到10以内的素数2，3，5，7 ​ 通过这样的办法，我们可以在趋近于线性（实际是nlog(log(n))) 的时间内求出2～n中的每个数是否是素数。 ​ 以上的第一种方法，是被埃拉托斯特尼发明的，因此也叫做埃筛法 ​ 如果大家觉得还不够快，趋近于线性也不是线性啊！！有没有线性时间就能求出来2～n所有素数的方法呢？ ​ 答案是有的，该方法称为线筛。 （2）我们知道上面的数，对于素数2的倍数4，6，8，10一定是合数； ​ 对于素数3的倍数6，9一定是合数； ​ 大家有没有发现6此时两次被判定为合数，埃筛之所以不是线性的原因就在于这里。。它可能会造成合数的重复判定。我们怎么样才能每个数只判定一次呢？就是在这个合数的最小素因子时判定该数为合数，其它素因子时不判定，这样就可以保证每个合数只判定一次了。这也就是线性筛的精髓了： ​ 对于2，我们判定为素数，我们检索已经存在的素数2，把2✖️2，也就是4标记为合数； ​ 对于3，我们判定为素数，我们检索已经存在的素数2, 3，把2✖️3，3✖️3，也就是6， 9标记为合数 ​ 对于4已标记为合数，我们检索已经存在的素数2，3，把2✖️4，也就是8标记为合数，由于4 % 2 == 0，因此我们直接跳出，不再执行3✖️4也就是12的判定（因为它可以由2✖️6判定，2是12的最小素因子） ​ 对于5，我们判定为素数，我们检索已经存在的素数2，3，5，把2✖️5，3✖️5，5✖️5，也就是10，15，25标记为合数 ​ 对于6已标记为合数， 我们检索已经存在的素数2，3，5，把2✖️6，也就是12标记为合数，由于6 % 2 == 0，因此我们直接跳出，不再执行3✖️6也就是18的判定（因为它可以由2✖️9判定，2是18的最小素因子） ​ ……… ​ 就不往下继续写了，通过以上的流程，我们就可以判定2～n中的每个数是否为素数并保证每个数只判定一次（还可以加如果两数相乘大于n直接跳出等限制条件），这样时间复杂度就是O(n) 我给出(2)方法的实现代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ll long long#define N 100005bool book[N + 5]; //book[i]判断i是否为素数int prime[N + 5]; //prime数组存储2～N全部素数，若MLE可改小该数组长度void init() &#123; memset(book, 0, sizeof(book)); prime[0] = 0; //代表2～N当前有多少个素数 for (int i = 2; i &lt;= N; i++) &#123; if (!book[i]) &#123; //如果是素数 prime[++prime[0]] = i; //存入该素数 &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; (ll)prime[j] * i &lt;= N; j++) &#123; //遍历之前存储的素数 book[prime[j] * i] = 1; //素数的i倍一定不是素数 if (i % prime[j] == 0) break; //保证每个合数只判断一次的精髓 &#125; &#125; return;&#125;int main () &#123; init(); return 0;&#125; ​ 以上就是素数判定和素数筛的一些理论与模版。在ACM中关于素数的题目很活，变形也很多，大家有兴趣可以看一下我博客中的数论标签的题目，里面有很多基于素数筛框架的变形题目～ ​ 附上博客地址：跳转 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA8512线段树维护线性基]]></title>
    <url>%2F2018%2F10%2F21%2FUVA8512%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[​ 题目需要用到线性基，之前写过线性基的原理和模版，想看的同学点右边 -&gt; 走你 题意： Consider an array A with n elements . Each of its element is A[i] (1≤i≤n) . Then gives two integers Q, K, and Q queries follow . Each query , give you L, R, you can get Z by the following rules. To get Z , at first you need to choose some elements from A[L] to A[R] ,we call them A[i1],A[i2]…A[it] , Then you can get number Z=K or (A[i1] xor A[i2] … xor A[it]) . Please calculate the maximum Z for each query . InputSeveral test cases . First line an integer T (1≤T≤10). Indicates the number of test cases.Then TT test cases follows . Each test case begins with three integer N, Q, K (1≤N≤10000, 1≤Q≤100000, 0≤K≤100000). The next line has N integers indicate A[1] to A[N] (0≤A[i]≤108). Then Q lines , each line two integer L, R (1≤L≤R≤N) . OutputFor each query , print the answer in a single line. 样例输入15 3 01 2 3 4 51 32 43 5 样例输出377 ​ 翻译成汉语就是，给你一个T代表T组样例，每组样例有n, q, k，表示一个数组有n个数，有q次询问。下一行给出n个数分别是数组中每个数的值。接下来q行每行两个数l,r，问数组a[l] ～a[r]中选几个数的异或和|k的值最大 问最大值是多少？ 思路： ​ 由于异或和|k值最大，这里有个小技巧。就是对数组中的每个数进行a[i] = a[i] &amp; (~k)，这样新的数组中最大的异或和|k就是最大值，因此我们只需要求新数组l～r的最大异或和 ​ 由于n的数据范围是1e4，q的数据范围是1e5，如果每查询一次重新求一次线性基数组，肯定会超时。因此我们可以利用线段树来维护l～r之间的线性基数组。 ​ 再加上各种剪枝，快速读写。用了不到600msA掉 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define d int32_t#define N 10005#define lson rt&lt;&lt;1#define rson rt&lt;&lt;1|1#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)using namespace std;//快速读namespace IO &#123; const d MX = 1e7; //1e7 占用内存 11000kb char buf[MX]; d c, sz; void begin() &#123; //该方法用于main方法开头位置，可一次性读完全部输入 c = 0; sz = fread(buf, 1, MX, stdin); //一次性全部读入 &#125; inline bool read(int &amp;t) &#123; //用于从buf中读入每个数 while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++; if (c &gt;= sz) return false; //若读完整个缓冲块则退出 bool flag = 0; if(buf[c] == &apos;-&apos;) &#123; flag = 1; c++; &#125; for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) t = t * 10 + buf[c] - &apos;0&apos;; if(flag) t = -t; return true; &#125; inline void write(int t) &#123; if (t &gt; 9) write(t / 10); putchar(t % 10 + &apos;0&apos;); &#125;&#125;//全局变量d k;//树节点（可存储范围内值的最高位maxn和线性基数组c）struct node &#123; d maxn; d c[35]; void init() &#123; mem(c); &#125; void addx(d x) &#123; Forr(i, 30, 0) &#123; if(x &gt;&gt; i &amp; 1) &#123; maxn = i; c[i] = x; break; &#125; &#125; &#125; d ansmax() &#123; d t = 0; Forr(i, maxn, 0) &#123; if ((t ^ c[i]) &gt; t) &#123; t ^= c[i]; &#125; &#125; return t; &#125; node merge(node A) &#123; node t; t.init(); Forr(i, maxn, 0) &#123; t.c[i] = c[i]; &#125; Forr(i, A.maxn, 0) &#123; if (A.c[i]) &#123; d x = A.c[i]; Forr(j, i, 0) &#123; if (x &gt;&gt; j &amp; 1) &#123; if (!t.c[j]) &#123; t.c[j] = x; break; &#125; x ^= t.c[j]; &#125; if (x == 0) break; &#125; &#125; &#125; t.maxn = max(maxn, A.maxn); return t; &#125;&#125;shu[N &lt;&lt; 2];//建树void Build (d rt, d l, d r) &#123; if (l == r) &#123; d t; IO::read(t); t = t &amp; (~k); shu[rt].init(); shu[rt].addx(t); return; &#125; d mid = (l + r) &gt;&gt; 1; if (l &lt;= mid) Build(lson, l, mid); if (mid &lt; r) Build(rson, mid + 1, r); shu[rt] = shu[lson].merge(shu[rson]);&#125;//查询node request (d rt, d l, d r, d L, d R) &#123; node t; t.init(); if (l &lt;= L &amp;&amp; r &gt;= R) &#123; return shu[rt]; &#125; d mid = (L + R) &gt;&gt; 1; if (l &lt;= mid &amp;&amp; r &gt; mid) return request(lson, l, r, L, mid).merge(request(rson, l, r, mid + 1, R)); else if(l &lt;= mid) return request(lson, l, r, L, mid); else if(r &gt;= mid) return request(rson, l, r, mid + 1, R); else return t;&#125;d main() &#123; IO::begin(); d T, n, q, l, r; IO::read(T); while (T--) &#123; IO::read(n); IO::read(q); IO::read(k); Build(1, 1, n); For(i, 1, q) &#123; IO::read(l); IO::read(r); node t = request(1, l, r, 1, n); d ans = (t.ansmax() | k); IO::write(ans); putchar(&apos;\n&apos;); &#125; &#125;&#125; ​ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢!]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快到难以想象的快速读模版]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%BF%AB%E5%88%B0%E9%9A%BE%E4%BB%A5%E6%83%B3%E8%B1%A1%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AF%BB%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[​ 没错，比上一个快速读写模版 跳转 还要快，这个模版是利用fread方法实现一次性读完（速度快，缺点也明显，特别耗费内存！！） ​ 具体模版如下： namespace IO &#123; const int MX = 4e7; //1e7 占用内存 11000kb char buf[MX]; int c, sz; void begin() &#123; //该方法用于main方法开头位置，可一次性读完全部输入 c = 0; sz = fread(buf, 1, MX, stdin); //一次性全部读入 &#125; inline bool read(int &amp;t) &#123; //用于从buf中读入每个数 while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++; if (c &gt;= sz) return false; //若读完整个缓冲块则退出 bool flag = 0; if(buf[c] == &apos;-&apos;) &#123; flag = 1; c++; &#125; for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) t = t * 10 + buf[c] - &apos;0&apos;; if(flag) t = -t; return true; &#125;&#125; ​ 具体用法如下： int a[105];int main() &#123; IO::begin(); //一次性读完全部输入 int T, n; IO::read(T); //从buf中读入到T while (T--) &#123; IO::read(n); //从buf中读入到n for (int i = 0; i &lt; n; i++) &#123; IO::read(a[i]); //从buf中读入到a[i] &#125; &#125;&#125; ​ 注意！！！只有当运行ctrl + z时才代表IO::begin()结束（在windows下，Linux下为ctrl + d），程序正式执行～ ​ 就酱紫～]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-10-20博客搭建进度]]></title>
    <url>%2F2018%2F10%2F20%2F18-10-20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器(10.05更新) ​ ——新增主页博文出场特效(10.05更新) ​ ——新增鼠标点击爱心效果 ​ ——新增页面卡通人物效果 ​ ——微调音乐布局 ​ ——微调小火箭布局]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5971二分图染色]]></title>
    <url>%2F2018%2F10%2F20%2FHDU5971%2F</url>
    <content type="text"><![CDATA[题意： Nowadays, at least one wrestling match is held every year in our country. There are a lot of people in the game is “good player”, the rest is “bad player”. Now, Xiao Ming is referee of the wrestling match and he has a list of the matches in his hand. At the same time, he knows some people are good players,some are bad players. He believes that every game is a battle between the good and the bad player. Now he wants to know whether all the people can be divided into “good player” and “bad player”. Input Input contains multiple sets of data.For each set of data,there are four numbers in the first line:N (1 ≤ N≤ 1000)、M(1 ≤M ≤ 10000)、X,Y(X+Y≤N ),in order to show the number of players(numbered 1toN ),the number of matches,the number of known “good players” and the number of known “bad players”.In the next M lines,Each line has two numbersa, b(a≠b) ,said there is a game between a and b .The next line has X different numbers.Each number is known as a “good player” number.The last line contains Y different numbers.Each number represents a known “bad player” number.Data guarantees there will not be a player number is a good player and also a bad player. Output If all the people can be divided into “good players” and “bad players”, output “YES”, otherwise output “NO”. Sample Input 5 4 0 01 31 43 54 55 4 1 01 31 43 54 52 Sample Output NOYES ​ 翻译成汉语，就是给出n个人，m场比赛，已知x个人为好的运动员，y个人为差的运动员，每场比赛两个人必有一个好一个差，问好的和差的是否会前后冲突？如果不冲突是否每个运动员都可以归类？ 思路： ​ 听队友说正解是二分图染色，自己不会图论，就用BFS做了一手，只用62ms成功A掉 ​ 初始化book数组为0，把x个好运动员的book[i]初始化为1，y个差运动员的book[i]初始化为-1，并把这x+y个运动员加入到队列中。对队列中的每个运动员进行检查，和该运动员有关的（也就是与他有比赛的）运动员book[i]为0，那么就设置成和他之相反并把有关的运动员加入到队列中。如果和他book[i]相同，那么代表前后矛盾，直接标记为失败并跳出循环。 ​ 这是对与X+Y以及与之有关的运动员进行判定，如果没有失败的话，则对所有参与比赛的人进行检索，若存在参加比赛的人book[i]为0，这时候要注意，这个运动员和之前的运动员不存在任何关联！！！所以可以把他设置为book[i]为1并加入到优先队列，再次进行BFS进行检索查看是否有矛盾 ​ 若上面两个步骤都没有矛盾，则从头遍历所有运动员，是否有未归类的运动员，若没有则输出YES，否则都是NO。 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define d int32_t#define ll int64_t#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;d book[1005];vector&lt;d&gt;zcy[1005];queue&lt;d&gt;line;d n, m, x, y;d a[10005], b[10005];//初始化void init() &#123; mem(book); d p; For(i, 1, n) &#123; zcy[i].clear(); &#125; while (!line.empty()) &#123; line.pop(); &#125; For(i, 1, m) &#123; scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]); zcy[a[i]].push_back(b[i]); zcy[b[i]].push_back(a[i]); &#125; For(i, 1, x) &#123; scanf(&quot;%d&quot;, &amp;p); book[p] = 1; line.push(p); &#125; For(i, 1, y) &#123; scanf(&quot;%d&quot;, &amp;p); book[p] = -1; line.push(p); &#125;&#125;//BFS检索与已经入队的运动员有关的运动员是否前后冲突d work() &#123; d flag = 0; while (!line.empty()) &#123; d t = line.front(); line.pop(); d pan = book[t]; for (d i = 0; i &lt; zcy[t].size(); i++)&#123; if(book[zcy[t][i]] == 0) &#123; book[zcy[t][i]] = -pan; line.push(zcy[t][i]); &#125; else if(book[zcy[t][i]] == pan)&#123; flag = 1; break; &#125; &#125; if(flag) break; &#125; return flag;&#125;d main () &#123; while (scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;x, &amp;y) == 4) &#123; init(); d flag = work(); if(flag) &#123; printf(&quot;NO\n&quot;); continue; &#125; For(i, 1, m) &#123; if(!book[a[i]]) &#123; book[a[i]] = 1; line.push(a[i]); flag = work(); if(flag) break; &#125; &#125; if(flag) &#123; printf(&quot;NO\n&quot;); continue; &#125; //最后检索是否存在没有归类的运动员 For(i, 1, n) &#123; if(!book[i]) &#123; flag = 1; break; &#125; &#125; if(flag) &#123; printf(&quot;NO\n&quot;); continue; &#125; printf(&quot;YES\n&quot;); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5976思维]]></title>
    <url>%2F2018%2F10%2F20%2FHDU-5976%2F</url>
    <content type="text"><![CDATA[题意： ​ In a highly developed alien society, the habitats are almost infinite dimensional space.In the history of this planet,there is an old puzzle.​ You have a line segment with x units’ length representing one dimension.The line segment can be split into a number of small line segments: a1,a2, … (x= a1+a2+…) assigned to different dimensions. And then, the multidimensional space has been established. Now there are two requirements for this space:​ 1．Two different small line segments cannot be equal ( ai≠aj when i≠j).​ 2．Make this multidimensional space size s as large as possible (s= a1∗a2*…).Note that it allows to keep one dimension.That’s to say, the number of ai can be only one.​ Now can you solve this question and find the maximum size of the space?(For the final number is too large,your answer will be modulo 10^9+7) Input ​ The first line is an integer T,meaning the number of test cases.​ Then T lines follow. Each line contains one integer x.​ 1≤T≤10^6, 1≤x≤10^9 Output ​ Maximum s you can get modulo 10^9+7. Note that we wants to be greatest product before modulo 10^9+7. Sample Input 245 Sample Output 46 翻译成汉语就是给出一个数T代表T组样例，然后每组样例给出一个x，然后将x拆分成任意多个各不相同的数a1,a2a1,a2, … 满足(x= a1+a2a1+a2+…) ，怎样拆分才能使得这些数的乘积最大，输出最大值并取模1e9+7 思路： ​ 我们先特判a为1的情况，输出1 ​ 对于a&gt;1的情况： ​ 由于拆分出的数各不相同，因此我们可以求sum[i]数组代表2 + 3 + .. + i（i &gt;= 2），ans[i]代表2✖️3✖️…✖️i (i &gt;= 2，注意累成需取模1e9+7否则爆longlong)。至于为什么不含1，因此任何数满足n &gt; (n - 1)✖️1，所以拆成1不划算。 ​ 我们利用二分找到第一个大于等于a的sum[i]，此时需要分类讨论： ​ 若sum[i] == a，则直接输出ans[i]即为答案 ​ 若sum[i] - a == 1，则去掉2和i（也就是用ans[i]分别乘2和i关于1e9+7的逆元），再乘（i + 1）并取模1e9+7即为答案 ​ 若sum[i] - a &gt; 1，我们设sum[i] - a为k，k一定小于等于i，我们直接去掉k即可（也就是ans[i]乘k关于1e9+7的逆元）并取模1e9+7即为答案 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define N 45000#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;d sum[N + 5];ll ans[N + 5];const ll mod = 1e9 + 7;//预处理sum与ans数组void init() &#123; mem(sum); ans[1] = 1; For(i, 2, N) &#123; sum[i] += sum[i - 1] + i; ans[i] = ans[i - 1] * i % mod; &#125;&#125;//扩展欧几里得ll exten(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if(a == 0 &amp;&amp; b == 0) return -1; if (b == 0) &#123; x = 1; y = 0; return a; &#125; ll t = exten(b, a % b, y, x); y -= a / b * x; return t;&#125;//求逆元ll mod_reverse(ll a, ll n) &#123; ll x, y; ll t = exten(a, n, x, y); if (t == 1) return (x % n + n) % n; return -1;&#125;//二分查找第一个大于等于val的sum[i]下角标d erfen(d val) &#123; d l = 2, r = N, mid; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if(sum[mid] &gt;= val) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;d main () &#123; init(); d T, a; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d&quot;, &amp;a); if (a == 1) &#123; //特判当a为1时 printf(&quot;1\n&quot;); continue; &#125; d inx = erfen(a); d t = sum[inx] - a; if (t == 0) &#123; //分三种情况讨论 printf(&quot;%lld\n&quot;, ans[inx]); &#125; else if (t == 1) &#123; d k = inx + 1; ll res = ans[inx] * mod_reverse(2, mod) % mod * mod_reverse(inx, mod) % mod * k % mod; printf(&quot;%lld\n&quot;, res); &#125; else &#123; ll res = ans[inx] * mod_reverse(t, mod) % mod; printf(&quot;%lld\n&quot;, res); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5974方程化简]]></title>
    <url>%2F2018%2F10%2F20%2FHDU5974%2F</url>
    <content type="text"><![CDATA[题意： Given two positive integers a and b,find suitable X and Y to meet the conditions:​ X+Y=a​ Least Common Multiple (X, Y) =b Input Input includes multiple sets of test data.Each test data occupies one line,including two positive integers a(1≤a≤2*10^4),b(1≤b≤10^9),and their meanings are shown in the description.Contains most of the 12W test cases. Output For each set of input data,output a line of two integers,representing X, Y.If you cannot find such X and Y,output one line of “No Solution”(without quotation). Sample Input 6 8798 10780 Sample Output No Solution308 490 ​ 翻译成汉语，就是给出两个数a，b (a &lt;= 2e4, b &lt;= 1e9)，问是否存在x,y，使得x + y = a, x和y的最小公倍数为b？一共有12万组样例！！ 思路： ​ 由于有12W组样例，只要每组样例超过1e3几乎就凉了,因此这个题肯定不能暴力。于是我想到了第一种方法： ​ 方法一：先利用素数筛把sqrt(1e9)以内的所有素数筛出来，然后求出b的所有种素因子和每种素因子的个数。 然后dfs每种素因子（每种素因子可以取0～a[i]个），再加上各种剪枝。。。982ms飘过～～ ​ ​ 方法一代码耗时982ms实在是太吓人了，万一现场赛评测机一个不高兴给你慢个20ms你就嗝屁了，然后看到网上正解，一拍脑瓜子。哎，智商压制啊～ ​ 方法二：我们设x和y的最大公约数为c，那么x = i ✖️ c，y = j ✖️ c。 ​ 由于c是x，y的最大公约数，所以i，j一定互质（要是两者不互质存在公约数的话，x，y的最大公约就为c✖️i和j的公约数，而不是c了，因此i，j一定互质） ​ 那么： ​ a = x + y = (i ✖️ c) + （j✖️c）= （i + j) ✖️ c ​ b = lcm(x, y) = x ✖️ y / gcd(x, y) = x ✖️ y / c = （i ✖️ c ✖️ j ✖️ c) / c = i ✖️j✖️c ​ 由于i,j互质，那么（i + j）和 （i * j）也一定互质。我们可以用反证法证明： ​ 若（i + j）,（i✖️j)不互质存在一个素因子t：那么在i✖️j中，t只能是 i的素因子 或 j的素因子(因为i,j互质，不存在公共素因子)；又因为i和j必须都存在素因子t才能使得(i + j)存在素因子t(相当于同余定理，若a % t == 0， 则b % t == 0才能使得（a + b）% t == 0)，因此和i 存在素因子t 或 j存在素因子t相矛盾，所以(i + j)和(i * j)互质 ​ 因此gcd(a, b) = c = gcd (x, y) ​ 因此化简得： ​ x + y = a (一) ​ x✖️y = b ✖️ gcd(x, y) = b ✖️gcd(a, b) （二） ​ a，b已知，因此就相当于解二元一次方程，把方程（一）带入（二）得： ​ x✖️(a - x) = b ✖️gcd(a, b) =&gt; x^2 - a✖️x + b✖️gcd(a,b) = 0 =&gt; x = (a + sqrt(a^2 - 4✖️b✖️gcd(a,b))) / 2 ​ 就可以求出x，y了。这样代码简短，而且耗时只有124ms： ​ Orz～ 代码： ​ 方法一： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;ctype.h&gt;#define d int32_t#define ll int64_t#define N 32000#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)bool book[N + 5];int prime[N + 5];ll ans[105];ll ansnum[105];ll a, b;bool flag;//预处理素数void init() &#123; mem(book); mem(prime); For(i, 2, N) &#123; if (!book[i]) &#123; prime[++prime[0]] = i; &#125; For(j, 1, prime[0]) &#123; ll t = prime[j] * i; if (t &gt; N) break; book[t] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;//求最大公约数ll gcd (ll y, ll x) &#123; ll c = y % x; return c == 0? x: gcd(x, c);&#125;//枚举不同素数组成的因子可能void dfs(ll now, ll n, ll val) &#123; if (flag) return; if (val &gt; a / 2) return; if(now == n + 1) &#123; if(val * (a - val) / gcd((a - val), val) == b) &#123; printf(&quot;%lld %lld\n&quot;, val, a - val); flag = 1; &#125; return; &#125; ll res = 1; dfs(now + 1, n, val); For(i, 1, ansnum[now]) &#123; res *= ans[now]; dfs(now + 1, n, val * res); &#125;&#125;d main () &#123; init(); while (scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) == 2) &#123; mem(ansnum); ll tot = 0, bb = b; flag = 0; For(i, 1, prime[0]) &#123; if(bb % prime[i] == 0) &#123; ans[++tot] = prime[i]; while(bb % prime[i] == 0) &#123; ansnum[tot]++; bb /= prime[i]; &#125; &#125; if (bb == 1) break; &#125; if(bb != 1) &#123; ans[++tot] = bb; ansnum[tot] = 1; &#125; dfs(1, tot, 1); if(!flag) &#123; printf(&quot;No Solution\n&quot;); &#125; &#125; return 0;&#125; ​ 方法二： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;ll gcd (ll y, ll x) &#123; ll c = y % x; return c == 0? x: gcd(x, c);&#125;d main () &#123; ll a, b; while (scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) == 2) &#123; ll c = gcd(max(a, b), min(a, b)); double x = (sqrt(a * a - 4 * b * c) + a) / 2; if (x == (ll)x) &#123; ll t = (ll)x; printf(&quot;%lld %lld\n&quot;, min(t, a - t), max(t, a - t)); &#125; else &#123; printf(&quot;No Solution\n&quot;); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5978水题]]></title>
    <url>%2F2018%2F10%2F20%2FHDU5978%2F</url>
    <content type="text"><![CDATA[题意： A box contains black balls and a single red ball. Alice and Bob draw balls from this box without replacement, alternating after each draws until the red ball is drawn. The game is won by the player who happens to draw the single red ball. Bob is a gentleman and offers Alice the choice of whether she wants to start or not. Alice has a hunch that she might be better off if she starts; after all, she might succeed in the first draw. On the other hand, if her first draw yields a black ball, then Bob’s chances to draw the red ball in his first draw are increased, because then one black ball is already removed from the box. How should Alice decide in order to maximize her probability of winning? Help Alice with decision. Input Multiple test cases (number of test cases≤50), process till end of input.For each case, a positive integer k (1≤k≤10^5) is given on a single line. Output For each case, output:1, if the player who starts drawing has an advantage2, if the player who starts drawing has a disadvantage0, if Alice’s and Bob’s chances are equal, no matter who starts drawingon a single line. Sample Input 12 Sample Output 01 ​ 翻译成汉语，大概意思是一个箱子中有n个蓝球，1个红球。爱丽丝先抓，鲍勃后抓，直到抓到红球的人获胜为止。问谁赢的概率大。0代表概率一样，1代表爱丽丝赢的概率大，2代表鲍勃赢的概率大 思路： ​ 当n为1的时候，爱丽丝赢的概率是1 / 2；当n为2的时候，爱丽丝赢的概率是1 / 3 + 2 / 3 ✖️ 1 / 2 = 2 / 3；当n为3的时候，爱丽丝赢的概率是1 / 4 + 3 / 4 ✖️ 2 / 3 ✖️1 / 2 = 1 / 2；当n为4的时候，爱丽丝赢的概率是1 / 5 + 4 / 5 ✖️ 3 / 4 ✖️1 / 3 + 4 / 5 ✖️ 3 / 4 ✖️ 2 / 3 ✖️ 1 / 2 = 3 / 5； ​ 因此我们发现，当n为偶数的时候，爱丽丝赢的概率大，输出1。当n为奇数时，两者赢的概率相同，输出0。 代码： #include &lt;stdio.h&gt;int main () &#123; int a; while (scanf(&quot;%d&quot;, &amp;a) == 1) &#123; if(a &amp; 1) &#123; printf(&quot;0\n&quot;); &#125; else &#123; printf(&quot;1\n&quot;); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5980水题]]></title>
    <url>%2F2018%2F10%2F20%2FHDU5980%2F</url>
    <content type="text"><![CDATA[题意： As is known to all,the ASCII of character ‘a’ is 97. Now,find out how many character ‘a’ in a group of given numbers. Please note that the numbers here are given by 32 bits’ integers in the computer.That means,1digit represents 4 characters(one character is represented by 8 bits’ binary digits). Input The input contains a set of test data.The first number is one positive integer N (1≤N≤100),and then N positive integersai (1≤ aiai≤2^32 - 1) follow Output Output one line,including an integer representing the number of ‘a’ in the group of given numbers. Sample Input 397 24929 100 Sample Output 3 ​ 翻译成汉语，意思是int类型的数在二进制下有32位，问你一个数组中的数，8位8位的看，问存在多少个97 思路： ​ 我们把数组中的每个数累除256直到0，每次累除都取余256看是否存在97，存在就++即可 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main () &#123; int n; while(scanf(&quot;%d&quot;, &amp;n) == 1) &#123; unsigned int a; int sum =0; for (int i = 1; i &lt;= n; i++)&#123; scanf(&quot;%u&quot;, &amp;a); while(a) &#123; if (a % 256 == 97) sum ++; a /= 256; &#125; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5979水题]]></title>
    <url>%2F2018%2F10%2F20%2FHDU5979%2F</url>
    <content type="text"><![CDATA[题意： We have a special convex that all points have the same distance to origin point.As you know we can get N segments after linking the origin point and the points on the convex. We can also get N angles between each pair of the neighbor segments.Now give you the data about the angle, please calculate the area of the convex Input There are multiple test cases.The first line contains two integer N and D indicating the number of the points and their distance to origin. (3 &lt;= N &lt;= 10, 1 &lt;= D &lt;= 10)The next lines contain N integers indicating the angles. The sum of the N numbers is always 360. Output For each test case output one float numbers indicating the area of the convex. The printed values should have 3 digits after the decimal point. Sample Input 4 190 90 90 906 160 60 60 60 60 60 Sample Output 2.0002.598 ​ 2016ICPC大连站的签到题，翻译成汉语，意思是给出n，k，代表凸n边形，每个顶点距离原点的距离为k。然后下一行给出n个角度a[i]，角度之和等于360度。代表从上一个顶点与下一个顶点之间的夹角是a[i]度。问这个凸n边形的面积是多少？ 思路： ​ 由于已知角度和两个顶点距离原点的距离，所以我们可以根据三角形面积公式s = 1 / 2 * sin(夹角度数)分别求出每个三角形的面积。n个三角形的面积求和就是凸n变形的面积。 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#define pi acos(-1.0)#define d int32_t#define ll int64_t#define INF 0x3f3f3f3f#define N 100#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;d main() &#123; d n; double t, a; while (scanf(&quot;%d%lf&quot;, &amp;n, &amp;t) == 2) &#123; double s = 0; For(i, 0, n - 1) &#123; scanf(&quot;%lf&quot;, &amp;a); s += sin(pi * a / 180) * t * t / 2; &#125; printf(&quot;%.3f\n&quot;, s); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论二)浅谈线性基]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[​ 前两天作了一套题，有一道线性基的模版题没出，觉得有必要学一手线性基了.. 一.线性基是什么？ ​ 线性基其实就是一个集合。假设一个普通的集合为A，它的线性基集合B是A的一个子集。B中所有子集的异或和组成的集合等价于A中所有子集的亦或和组成的集合（除0外）。 二.线性基有什么性质： ​ 1.若一个数x能被线性基集合中某个子集的异或和得到，该子集唯一 ​ 2.线性基集合中任意一个子集的异或和不为0 ​ 3.线性基集合中每个元素的最高位互不相同 ​ 4.若线性基集合是满的（也就是说最高位是1～n位的数都存在），那么它的异或集合是【1, 2^n - 1】 三.关于线性基的代码实现： ​ 我们用p数组存储线性基的元素 ​ （1）关于线性基中元素的插入 ​ 我们要插入一个数x，需要从高到低枚举所有位，若x&amp;当前位 != 0，若当前位不存在线性基元素，则将x当作线性基的当前位元素，否则x异或当前位元素，直到x为0或将x添加到线性基中 ​ 代码如下 ： void addx (ll x) &#123; for (ll i = 62; i &gt;= 0; i--) &#123; //long long型的最大值为2^63 - 1，因此是0～62 if (x &gt;&gt; i &amp; 1) &#123; if (!p[i]) &#123; p[i] = x; break; &#125; x ^= p[i]; &#125; &#125; return;&#125; ​ (2)关于求最大异或和： ​ 初始化res = 0，从高到低遍历位数，若res ^ p[i]大于res就更新res，最后res即为线性基所能得到的最大异或和 ​ 代码如下： ll getmax() &#123; ll res = 0; for (ll i = 62; i &gt;= 0; i--) &#123; if (res &lt; (res ^ p[i])) res ^= p[i]; &#125; return res;&#125; ​ (3)关于求异或t后的最大异或和： ​ 同上一样，只需要初始化res = t即可。 ​ 代码如下： ll getmaxt() &#123; ll res = t; for (ll i = 62; i &gt;= 0; i--) &#123; if (res &lt; (res ^ p[i])) res ^= p[i]; &#125; return res;&#125; ​ (4)关于求最小异或和： ​ 最小值就是线性基中位数由低到高第一个存在的p[i] ​ 代码如下： ll getmin () &#123; for (ll i = 0; i &lt;= 62; i++) &#123; if (p[i]) return p[i]; &#125; return 0;&#125; ​ (5)关于求异或集合中的第k小值 ​ 需要把线性基集合中的元素改为除了最高位为1，其余位为0的形式。也就是说，若j&lt;i且p[i]中第j位是1，就p[i] ^ p[j] ​ 我们对k进行二进制拆分，若第i位为1，就异或p[i]，最终得到的答案就是第k小的异或值 ​ 代码如下： int tot = -1;void build () &#123; for (ll i = 62; i &gt;= 0; i--) &#123; for (ll j = i - 1; j &gt;= 0; j--) &#123; if (p[i] &gt;&gt; j &amp; 1) p[i] ^= p[j]; &#125; &#125; for (ll i = 0; i &lt;= 62; i++) &#123; if (p[i]) g[++tot] = p[i]; &#125;&#125;ll query (ll k) &#123; //若原数组中存在元素0，则此时需要k-- if (k &gt;= (1LL * tot)) return -1; ll res = 0; for (ll i = tot; i &gt;= 0; i--) &#123; if (k &gt;&gt; i &amp; 1) res ^= g[i]; &#125; return res;&#125; 四. 线性基能求解什么问题？ ​ (1). 给出一个数组，问一个数能否由数组中的元素异或得到 ​ (2).给出一个数组，问数组中全部子集异或和组成的集合中，第k小的数是多少 ​ (3).给出一个数组和一个数t，问数组全部子集的异或和（可重复）按从小到大排序，第一个等于t的下角标是多少？ ​ (4).给出一个可重集合和k，等概率选一个子集A，得到A的异或和x，问x^k的数学期望值是多少？ ​ (5).给出一个连通无向图（n个点m条边，每个边有一个权值）,问从起点走到终点异或和最小的值是多少？ ​ 以上就是总结的线性基的基础，遇到异或问题，可以首先考虑能否使用线性基，就酱～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1636区间dp]]></title>
    <url>%2F2018%2F10%2F19%2FhihoCoder-1636%2F</url>
    <content type="text"><![CDATA[题意： 描述In Chinese mythology, Pangu is the first living being and the creator of the sky and the earth. He woke up from an egg and split the egg into two parts: the sky and the earth. At the beginning, there was no mountain on the earth, only stones all over the land. There were N piles of stones, numbered from 1 to N. Pangu wanted to merge all of them into one pile to build a great mountain. If the sum of stones of some piles was S, Pangu would need S seconds to pile them into one pile, and there would be S stones in the new pile. Unfortunately, every time Pangu could only merge successive piles into one pile. And the number of piles he merged shouldn’t be less than L or greater than R. Pangu wanted to finish this as soon as possible. Can you help him? If there was no solution, you should answer ‘0’. 输入There are multiple test cases. The first line of each case contains three integers N,L,R as above mentioned (2&lt;=N&lt;=100,2&lt;=L&lt;=R&lt;=N). The second line of each case contains N integers a1,a2 …aN (1&lt;= ai &lt;=1000,i= 1…N ), indicating the number of stones of pile 1, pile 2 …pile N. The number of test cases is less than 110 and there are at most 5 test cases in which N &gt;= 50. 输出For each test case, you should output the minimum time(in seconds) Pangu had to take . If it was impossible for Pangu to do his job, you should output 0. 样例输入 3 2 21 2 33 2 31 2 34 3 31 2 3 4 样例输出 960 ​ 翻译成汉语，大概意思就是给你三个数n，l，r，代表有n堆石子，之后一行有n个数，代表每堆石子的个数。每次只能把连续的l～r堆石子合并为1堆，若能最终把n堆石子合并为1堆，问最小花费是多少？不能合并为1堆则输出0。（l～r堆石子合并为1堆的花费是这些堆的石子数总和） 思路： ​ 这是一道区间dp题，做的时候一直在研究如何限制合并的堆数为l～r，想破头皮想出来区间DP嵌套dfs的做法，结果超时了。。。最后从网上看了题解，发现自己想问题想复杂了。我们设sum【i】为前i堆石子的石子数和，dp【i】【j】【k】代表区间i～j的石子堆合并成k堆所需要的最小花费，初始化为INF，然后对于dp【i】【j】【i - j + 1】初始化为0，对于dp【i】【i + len - 1】【1】初始化为sum【i + len - 1】 - sum【i - 1】。 ​ 对于推导式，当k！=1时： dp[i][j][k] = min(dp[i][j][k],dp[i][p][k - 1] + dp[p + 1][j][1]); //其中p属于【i，j) ​ 我们在k！=1时其实不需要限制l～r的合并，因为此时没有合并操作，只是i～p有k - 1堆石子，（p + 1） ～ r有1堆石子，那么i～j有k堆石子，取最小的即可。至于为什么是k - 1 和 1项加，因为遍历全部的p，就包含i～j的所有合并可能且不重复了。因此我们只需要考虑当k == 1时的合并问题 ​ ​ 对于推导式，当k == 1时： dp[i][j][1] = min(dp[i][j][1], dp[i][p][len - 1] + dp[p + 1][j][1] + sum[j] - sum[i - 1]); //其中p属于【i，j), len属于【l，r】 ​ ​ 因此，就可以用区间dp来求解，将酱～ 代码； #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define INF 0x3f3f3f3f#define N 100#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;d a[N + 5]; //每堆石子数ll sum[N + 5]; //前缀和ll dp[N + 5][N + 5][N + 5]; //dp[i][j][k]代表区间i～j能合并成k堆的最小花费d n, l, r;//初始化void init () &#123; mem(sum); memset(dp, INF, sizeof(dp)); For(i, 1, n) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum[i] = a[i] + sum[i - 1]; &#125; For(i, 1, n) &#123; For(j, i, n) &#123; dp[i][j][j - i + 1] = 0; &#125; &#125; For(i, l, r) &#123; For(p, 1, n + 1 - i) &#123; dp[p][p + i - 1][1] = sum[p + i - 1] - sum[p - 1]; &#125; &#125;&#125;void work () &#123; For(len, 2, n) &#123; For(i, 1, n - len + 1) &#123; For(q, l, r) &#123; For(p, i, i + len - 2) &#123; dp[i][i + len - 1][1] = min(dp[i][i + len - 1][1], dp[i][p][q - 1] + dp[p + 1][i + len - 1][1] + sum[i + len - 1] - sum[i - 1]); &#125; &#125; For(k, 2, len - 1) &#123; For(p, i, i + len - 2) &#123; dp[i][i + len - 1][k] = min(dp[i][i + len - 1][k], dp[i][p][k - 1] + dp[p + 1][i + len - 1][1]); &#125; &#125; &#125; &#125;&#125;d main() &#123; while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;r) == 3) &#123; init(); work(); if ((d)dp[1][n][1] == INF) &#123; printf(&quot;0\n&quot;); &#125; else &#123; printf(&quot;%lld\n&quot;, dp[1][n][1]); &#125; &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM快速读写模版]]></title>
    <url>%2F2018%2F10%2F18%2FACM%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%A8%A1%E7%89%88%2F</url>
    <content type="text"><![CDATA[​ 有必要整一个快速读写的模版了，万一就差几十ms给TLE了就嗝屁了～ #include &lt;stdio.h&gt;#include &lt;ctype.h&gt;//快速读inline int read() &#123; int num=0, w=0; char ch=0; while (!isdigit(ch)) &#123; w|=ch==&apos;-&apos;; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48); ch = getchar(); &#125; return w? -num: num;&#125;//快速写inline void write(int x)&#123; if(x&lt;0) &#123; putchar(&apos;-&apos;); x = -x; &#125; if(x&gt;9) write(x / 10); putchar(x % 10 + &apos;0&apos;);&#125;int main()&#123; int t; t = read(); //读入到t中 write(t); //输出t putchar(&apos;\n&apos;);&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 8521组合数+dp]]></title>
    <url>%2F2018%2F10%2F18%2FUVALive-8521%2F</url>
    <content type="text"><![CDATA[题意： problem description 5 friends play LOL together . Every one should BAN one character and PICK one character . The enemy should BAN 5 characters and PICK 5 characters . All these 20 heroes must be different . Every one can BAN any heroes by his personal washes . But he can only PICK heroes which he has bought . Suppose the enemy can PICK or BAN any heroes. How many different ways are there satisfying the conditions? For example , a valid way is : Player 1 : picks hero 1, bans hero 2 Player 2 : picks hero 3, bans hero 4 Player 3 : picks hero 5, bans hero 6 Player 4 : picks hero 7, bans hero 8 Player 5 : picks hero 9, bans hero 10 Enemies pick heroes 11,12,13,14,15 , ban heroes 16,17,18,19,20 . InputThe input contains multiple test cases.(No more than 20) In each test case . there’s 5 strings S[1]∼S[5] ,respectively whose lengths are 100 , For the i-th person if he has bought the j-th hero, the j-th character of S[i] is ‘1’, or ‘0’ if not. The total number of heroes is exactly 100 . OutputFor each test case , print the answer mod 1000000007 in a single line . 样例输入01100111000110010011000111100011100011100010100101111111101010100100110100001101000110010011111010111000111101111110110100001101001101010001111001001011110001111110101000011101000001011100001001011010010010110001111001110011011001110011110001001001100111111010111111100000011000111000011000110000111011100101010100010001101000111010100010100001100011111111101010100000000011110011101101011100000100111000010011111110001101100000101001110100011000111010011111110110111010011111010110101111011111011011 样例输出515649254 ​ 翻译成汉语，大概意思是LOL一共有100个英雄，十个人（每队5人）选英雄，每人可以选一个扳一个，问十个人有多少种不同的选扳方案（对答案取余1e9+7）。对面英雄全有，输入5个01串表示我方五个人分别拥有的英雄（1有0无） 注意点：1.每个人只能选自己拥有的英雄，任意两个人不能选或者扳同一个英雄。同一队伍的1，2，3，4，5召唤师选英雄1，2，3，4，5和选英雄5，4，3，2，1是不同的方案，而1，2，3，4，5召唤师扳英雄1，2，3，4，5和5，4，3，2，1是相同的方案 思路： ​ 因为我们要求的是全部的方案数，所以我们不用管中间的过程（过程太复杂没法模拟），整体地看待总方案数为：我方选择的英雄方案数✖️敌人选择的英雄方案数✖️我方扳的英雄方案数✖️敌人扳的英雄方案数。 ​ 我们无论怎么选取5个英雄，那么敌人只能从剩下的95个中选5个，所以方案数是A（95，5），而我方扳的英雄方案数是C（90， 5），敌人扳的英雄方案数是C（85，5）。至于谁先谁后无所谓，因为： A(95,5) * C(90,5) * C(85,5) = C(95,5) * C(90,5) * A(85,5) = C(95,5) * A(85,5) * C(90,5) ​ 由于敌人选择的英雄方案数✖️我方扳的英雄方案数✖️敌人扳的英雄方案数的值是固定的，我们可以预处理出来，得到g， ​ 因此我们只需要每次利用dp求解我方选择的英雄方案数，再乘g就能得到答案 ​ 关于dp求解我方选择的英雄方案数，我们可以设dp【i】【j】代表前j个英雄已经选了i个英雄的方案数，然后遍历每个成员，里层遍历每个英雄。为了避免重复，我们保证每个成员选的英雄都比上一个成员选的英雄下角标大（这样会导致方案数不全，因此我们需在最外层对成员下标进行全排列） 代码： #include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define d int32_t#define ll int64_t#define mod 1000000007#define r return#define mem(a) memset(a, 0, sizeof(a));#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;char s[8][150];d t[8][150];ll dp[8][150];//扩展欧几里得ll extend(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (a == 0 &amp;&amp; b==0) r -1; if (b == 0) &#123; x = 1; y = 0; r a; &#125; ll g = extend(b, a % b, y, x); y -= a / b * x; r g;&#125;//求逆元ll mod_re(ll a, ll n) &#123; ll x, y; ll g = extend(a, n, x, y); if(g == 1) r (x % n + n) % n; r -1;&#125;//求A(95，5) * C(90, 5) * C(85, 5)的值ll init() &#123; ll res = 1; For(i, 81, 95) &#123; res = res * i % mod; &#125; For(i, 2, 5) &#123; ll g = mod_re(i, mod); res = res * g % mod * g % mod; &#125; r res;&#125;//求我方选择英雄的总类数ll work() &#123; ll ans =0; d inx[5] = &#123;0, 1, 2, 3, 4&#125;; do &#123; mem(dp); For(j, 0, 99) &#123; dp[0][j] = dp[0][j - 1]; if(s[inx[0]][j] == &apos;1&apos;) &#123; dp[0][j]++; &#125; &#125; For(i, 1, 4) &#123; For(j, 0, 99) &#123; dp[i][j] = dp[i][j - 1]; if(s[inx[i]][j] == &apos;1&apos;) &#123; dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod; &#125; &#125; &#125; ans = (ans + dp[4][99]) % mod; &#125;while (next_permutation(inx, inx + 5)); r ans;&#125;int main() &#123; ll g = init(); while (scanf(&quot;%s&quot;, s[0]) == 1) &#123; For(i, 1, 4) &#123; scanf(&quot;%s&quot;, s[i]); &#125; ll ans = work(); printf(&quot;%lld\n&quot;, g * ans % mod); &#125; r 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用命令（转）]]></title>
    <url>%2F2018%2F10%2F18%2FVim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[作者：Bonnie-帮你来源：CSDN原文：https://blog.csdn.net/daocaoren1543169565/article/details/53114347 感觉总结的特别好，万分感谢！！转了～ （一）初级个性化配置你的vim 1、vim是什么？ vim是Vi IMproved，是编辑器Vi的一个加强版，一个极其强大并符合IT工程师（程序员、运维）习惯的编辑器。如果你是一名职业的SE，那么一定在寻找一款出色的能够自由定制、满足灵活编辑功能的编辑器。那么答案，就是vim或者Emacs。而这一套连续的博文，就为您介绍vim编辑器。至于另一款强大的编辑器Emacs，我们会在今后的一个系列博文中看到。 2、配置文件在哪？ Windows系统的配置文件是vim安装目录下的vimrc文件。 Linux系统，RHEL和CentOS的配置文件是/etc/vimrc，Debian和Ubuntu的配置文件是/usr/share/vim/vimrc。 Mac OS X的配置文件是/usr/share/vim/vimrc。 3、vimRC中的RC是什么意思？ 为什么把这么个没有意义的问题也列出来？原因很简单，就是我在接触vim之初第二个想问的问题就是这个（第一个就是上面的“1”）。一般在运行某个软件、环境或工具之初，要初始执行的一些命令，称为Run Commands，即RC。根据Wikipedia.org的记载，RC缩写的用法源自MIT的相容分时操作系统（Compatible Time-Sharing System，CTSS）[参考1]。所以以后如果你看到了SystemRC或者ScreenRC，也就知其缘由了。 4、三种基本模式 在《大家来学vim》中提到vim有6+5种模式，但除了细分程度不同外，实际上常用的只有3种模式：Normal Mode、Insert Mode和Command-line Mode。 从Normal Mode进入Insert Mode，可以按i、I、a、A、o、O、r、R即可。其中i和I表示插入（Insert），r和R表示替换（replace）。 从Insert Mode进入Normal Mode，只需要按ESC键即可。 从Normal Mode进入Command-line Mode，可以按“:”、“/”、“?”。其中“:”表示输入vim命令，“/”表示后面输入要向下搜索的字符串，“?”表示后面输入要向上搜索字符串。 从Command-line Mode进入Normal Mode，只需要按ESC键即可了。 你可以把Normal Mode理解为常态，进入其他任何一种模式，需要某种特殊方式，而从其他特殊模式回到Normal Mode，就按ESC键即可。 5、vim中那些最最常用的配置 当你尝试去Google一些其他人的vimrc配置时，你一定会找到一篇叫做《The ultimate vim configuration》的文章，不过它的作者，Amix后来在他的博客上提到[参考2]，这份在google搜索vimrc会排在前十的vim配置文件，如今已经过时了，所以他提供了一些更新信息。 （1）颜色设置 syntax on &quot;开启代码高亮 syntax off &quot;关闭代码高亮 syntax enable &quot;开启代码高亮 （2）搜索设置 set hlsearch &quot;开启搜索高亮 set nohlsearch &quot;关闭搜索高亮 set incsearch &quot;输入搜索字符串的同时进行搜索 set ignorecase &quot;搜索时忽略大小写 （3）用户界面 set showmode &quot;开启模式显示 set ruler &quot;开启光标位置提示 set number &quot;显示行号 set nonu &quot;不显示行号 set cursorline &quot;强调光标所在行 set cmdheight=1 &quot;命令部分高度为1 （4）编辑辅助配置 set autoindent &quot;自动缩进 set noautoindent &quot;不自动缩进 set smartindent &quot;智能缩进 set autoread &quot;当文件在外部被改变时，vim自动更新载入 set showmatch &quot;显示匹配的括号 参考： Run Commands，http://en.wikipedia.org/wiki/Run_commands The Ultimate vim Configuration(vimRC)，http://amix.dk/blog/post/19486 （二）常用的状态切换按键 1、Normal Mode -&gt; Insert Mode i 小写字母i，在光标位置插入a 小写字母a，在光标的下一个位置插入I 大写字母I，在光标所在行的第一个非空格处插入A 大写字母A，在光标所在行的最后一个字符处插入o 小写字母o，在光标所在行的下一行处插入新行O 大写字母O，在光标所在行的上一行处插入新航r 小写字母r，替换光标所在处的字符一次R 大写字母R，持续替换光标所在处的字符，直到按下ESC 2、Normal Mode -&gt; Command-line Mode :w 保存文件:w! 强制保存文件（前提是用户有修改文件访问权限的权限）:q 退出缓冲区:q! 强制退出缓冲区而不保存:wq 保存文件并退出缓冲区:wq! 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限） :w 另存为名为filename文件:n1,n2 w 将n1行到n2行的数据另存为名为filename文件:x 如果文件有更改，则保存后退出。否则直接退出。 3、Insert Mode -&gt; Normal Mode 按下ESC键 4、Command-line -&gt; Normal Mode 按下ESC键 （三）常用光标移动按键 1、光标字符操作 j 向下 k 向上 h 向左 l 向右 $ 光标移动到行尾（End），注意要按Shift键 0 光标移动到行首（Home） ^ 光标移动到行首第一个非空白字符（Home），注意要按Shift键 2、光标词操作 w 光标移动到后一词的词首 W 光标移动到后一词的词首且忽略标点符号 e 光标移动到后一词的词尾 E 光标移动到后一词的词尾且忽略标点符号 b 光标移动到前一词的词首 B 光标移动到前一词的词首且忽略标点符号 3、光标句操作 ) 光标移动到后一句的句首 ( 光标移动到前一句的句首 % 配合“(”和“)”使用，寻找相匹配的另一半 4、光标行操作 G 光标移动到文档的最后一行的第一个非空白字符 nG 光标移动到文档的第n行，相当于”:n” gg 光标移动到文档的第1行的第一个非空白字符，相当于”1G”，也相当于”:1″ 光标向下移动N行 5、光标段操作 } 光标移动到下一段的段首 { 光标移动到上一段的段首 % 配合“(”和“)”使用，寻找相匹配的另一半 6、光标页操作 Ctrl+f 向下翻页（Pagedown） Ctrl+b 向上翻页（Pageup） Ctrl+d 向下翻半页 Ctrl+u 向上翻半页 H 光标移动到目前显示页的第一行 M 光标移动到目前显示页的中间行 L 光标移动到目前显示页的最后一行 7、光标自由操作 Ctrl+o 回到光标的上一位置 （四）常用编辑操作按键 1、删除操作（delete） dd 删除光标所在行 ndd 删除从光标所在行开始，向下的n行 d1G 删除从光标所在行开始，到第一行的所有行 dG 删除从光标所在行开始，到最后一行的所有行 d$ 删除从光标所在位置，到行尾的所有字符 d0 删除从光标所在位置，到行首的所有字符 2、复制操作（yank） yy 复制光标所在行 nyy 复制从光标所在行开始，向下的n行 y1G 复制从光标所在行开始，到第一行的所有行 yG 复制从光标所在行开始，到最后一行的所有行 y$ 复制从光标所在位置，到行尾的所有字符 y0 复制从光标所在位置，到行首的所有字符 3、粘贴操作（paste） p 小写字母p，粘贴剪贴板中的数据，从光标所在行的下一行开始 P 大写字母P，粘贴剪贴板中的数据，从光标所在行的上一行开始 4、撤销与重做操作（undo，redo） u （Undo）撤销上一个操作 Ctrl+r （Redo）重做上一个操作 5、重复操作 . 重复上一操作 6、替换操作（replace） r 替换光标所在处字符 R 进入替换模式，直至按ESC退出 cc 替换光标所在行 cw 替换光标所在的英文单词 ~ 转换大小写 7、排版操作 :le 光标所在行左对齐 :ri 光标所在行右对齐 :ce 光标所在行居中 （五）常用多缓冲区操作按键 1、多文件编辑模式 argument list模式，就是在打开vim编辑器时，携带多个文件路径参数。 buffer list模式，就是在进入vim编辑器后，打开多个缓冲区进行编辑。 2、单一缓冲区打开多个文件 :files 显示目前打开了哪些文件 :n 切换到下一个缓冲区内容 :N 切换到上一个缓冲区内容 :2n 切换到下下个缓冲区内容 :bn 下一个缓冲区内容（buffer next） :bp 上一个缓冲区内容（buffer previous） 3、多个缓冲区打开多个文件 :sp [filename] 打开一个新的缓冲区，如果有filename则内容为该文件，否则为当前文件 Ctrl+w n 新建一个缓冲区 Ctrl+w q 退出光标所在的缓冲区 Ctrl+w j 光标移动到下一缓冲区 Ctrl+w k 光标移动到上一缓冲区 Ctrl+w l 光标移动到右一缓冲区 Ctrl+w h 光标移动到左一缓冲区 Ctrl+w v 左右切割窗口新建缓冲区 Ctrl+w s 上下切割窗口新建缓冲区 Ctrl+w o 使光标所在缓冲区最大化，其他缓冲区隐藏 （六）常用搜索与书签操作快捷键 搜索字符串 /string 向下搜索字符串“string”?string 向上搜索字符串“string” 重复上次搜索 n 根据上次搜索条件找到下一个匹配的字符串N 根据上次搜索条件找到上一个匹配的字符串 搜索单词 向下搜索光标所在处的单词（完全匹配）# 向上搜索光标所在处的单词（完全匹配）g* 向下搜索光标所在处的单词（部分匹配）g# 向上搜索光标所在处的单词（部分匹配） 标记书签（mark） ma a为小写字母，为光标所在处设定文档书签amA A为大写字母，为光标所在处设定全局书签A 使用书签（mark） a 到文档书签a处，Tab键上方&#39;a 到文档书签a所在行行首处，Enter键左边A 到全局书签A处，Tab键上方’A 到全局书签A所在行行首处，Enter键左边`n 如果n=0，缓冲区将打开上一次的文档，且光标在上次编辑最后的位置，1-9以此类推’n 如果n=0，缓冲区将打开上一次的文档，且光标在上次编辑最后的位置所在行的行首，1-9以此类推 查看书签列表 :marks 查看当前所有书签 （7）关于加密 1、加密你的文本文件 当你用vim打开或新建一个文件时，如果加上-x参数，即： vim -x filename 那么vim会提示你： Enter entryption key: 当你输入了密码后，vim会提示你重复输入以确认： Enter same key again: 你在设置密码的时候，是以*来显示的，非明文。当下次有人（包括你自己）打开该文件的时候，vim就会提示： Need encryption key for “main.cpp”Enter encryption key: 这时你只要输入你之前所设置的密码就可以了。如果你输入的密码是错误的，vim并不会提示你密码错误，而是显示一堆无意义的垃圾代码。 2、解除加密与重设密码 打开你已经加密的文件，然后输入： :set key= 这样，你的密码就被设置为空了，今后进入就不再需要输入密码了。而如果你向重设密码的话，你可以输入： :X 注意是个大写字母X。这时vim会提示你，只要反复输入两次新的密码就可以了： Enter entryption key: *Enter sanme key again: * 3、加密引起的问题 vim的加密功能，可以说是问题一大堆。比如： （1）如果密码输入错误，vim不会拒绝访问者编辑文件。在这种显示乱码的情况下编辑文件并保存，整个文件就会变得混乱不堪，无法辨识。今后即使使用正确的密码打开文件，也看不到正确的文档了。 （2）如果对一个需要编译的源代码文件进行了加密，则无法通过编译器的语法检查。 （3）交换文件是无法加密的。这样引起什么问题？问题就是如果其他用户想办法读取到了你的交换文件，就可以绕过解密环节，你的加密也就无意义了。解决的办法就是，不使用交换文件。方法有三个，一是修改你的vimrc文件（vim配置文件）： set noswapfile 二是在用vim打开文件之初就输入命令： vim -x -n filename （注意-x是加密参数，与我们所说的swap没有关系，不要搞混） 三是在进入vim编辑该文件后，输入： :setlocal noswapfile 不过不使用交换文件的坏处就是，你可能会面临数据丢失而无法找回的悲剧。所以又想用加密，又想不丢失文件的朋友们，就勤按“:w”吧。]]></content>
      <tags>
        <tag>收藏</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1632模拟]]></title>
    <url>%2F2018%2F10%2F17%2FhihoCoder-1632%2F</url>
    <content type="text"><![CDATA[题意： 描述The Yongzheng Emperor (13 December 1678 – 8 October 1735), was the fifth emperor of the Qing dynasty of China. He was a very hard-working ruler. He cracked down on corruption and his reign was known for being despotic, efficient, and vigorous. Yongzheng couldn’t tolerate people saying bad words about Qing or him. So he started a movement called “words prison”. “Words prison” means literary inquisition. In the famous Zhuang Tinglong Case, more than 70 people were executed in three years because of the publication of an unauthorized history of the Ming dynasty. In short, people under Yongzheng’s reign should be very careful if they wanted to write something. So some poets wrote poems in a very odd way that only people in their friends circle could read. This kind of poems were called secret poems. A secret poem is a N×N matrix of characters which looks like random and meaning nothing. But if you read the characters in a certain order, you will understand it. The order is shown in figure 1 below: ​ figure 1 figure 2 Following the order indicated by arrows, you can get “THISISAVERYGOODPOEMITHINK”, and that can mean something. But after some time, poets found out that some Yongzheng’s secret agent called “Mr. blood dripping” could read this kind of poems too. That was dangerous. So they introduced a new order of writing poems as shown in figure 2. And they wanted to convert the old poems written in old order as figure1 into the ones in new order. Please help them. 输入There are no more than 10 test cases. For each test case: The first line is an integer N( 1 &lt;= N &lt;= 100), indicating that a poem is a N×N matrix which consist of capital letters. Then N lines follow, each line is an N letters string. These N lines represent a poem in old order. 输出For each test case, convert the poem in old order into a poem in new order. 样例输入 5THSAD IIVOP SEOOH RGETI YMINK2ABCD4ABCDEFGHIJKLMNOP 样例输出 THISIPOEMSDNKIAOIHTVOGYREABDCABEIKHLFNPOCMJGD ​ 翻译成汉语大概是将一串字符按图一的规律排列，让你输出将这串字符按图二的规律排列并输出。 思路： ​ 没啥别的，暴力大模拟就完了。。。不过暴力一定要优雅和简练！！比如我哈哈哈～ 代码： #include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define r return#define N 100000#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)#define Forr(i, star, endd) for(d i = star; i &gt;= endd; i--)#define mem(a) memset(a, 0, sizeof(a))using namespace std;char s1[105][105], s2[105][105], s3[105][105];d main() &#123; d n; while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123; mem(s2); mem(s3); For(i, 0, n - 1) &#123; scanf(&quot;%s&quot;, s1[i]); &#125; int tot = 0; For(i, 0, 2 * n - 2) &#123; if (i &amp; 1) &#123; For(j, 0, i) &#123; if (i - j &gt; n - 1 || j &gt; n - 1) continue; s2[tot / n][tot % n] = s1[j][i - j]; tot++; &#125; &#125; else &#123; Forr(j, i, 0) &#123; if (i - j &gt; n - 1 || j &gt; n - 1) continue; s2[tot / n][tot % n] = s1[j][i - j]; tot++; &#125; &#125; &#125; tot = 0; for (int i = n; i &gt;= 1; i -= 2) &#123; for (int j = (n - i) / 2; j &lt;= n - 2 - (n - i) / 2; j++) &#123; s3[(n - i) / 2][j] = s2[tot / n][tot % n]; tot++; &#125; for (int j = (n - i) / 2; j &lt;= n - 2 - (n - i) / 2; j++) &#123; s3[j][n - 1 - (n - i) / 2] = s2[tot / n][tot % n]; tot++; &#125; for (int j = n - 1 - (n - i) / 2; j &gt;= (n - i) / 2 + 1; j--) &#123; s3[n - 1 - (n - i) / 2][j] = s2[tot / n][tot % n]; tot++; &#125; for (int j = n - 1 - (n - i) / 2; j &gt;= (n - i) / 2 + 1; j--) &#123; s3[j][(n - i) / 2] = s2[tot / n][tot % n]; tot++; &#125; &#125; if (n &amp; 1) &#123; s3[n / 2][n / 2] = s2[n - 1][n - 1]; &#125; For(i, 0, n - 1) &#123; printf(&quot;%s\n&quot;, s3[i]); &#125; &#125; r 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>大模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1631模拟]]></title>
    <url>%2F2018%2F10%2F17%2FhihoCoder-1631%2F</url>
    <content type="text"><![CDATA[题意： 描述There are many homeless cats in PKU campus. They are all happy because the students in the cat club of PKU take good care of them. Li lei is one of the members of the cat club. He loves those cats very much. Last week, he won a scholarship and he wanted to share his pleasure with cats. So he bought some really tasty fish to feed them, and watched them eating with great pleasure. At the same time, he found an interesting question: There are m fish and n cats, and it takes ci minutes for the ith cat to eat out one fish. A cat starts to eat another fish (if it can get one) immediately after it has finished one fish. A cat never shares its fish with other cats. When there are not enough fish left, the cat which eats quicker has higher priority to get a fish than the cat which eats slower. All cats start eating at the same time. Li Lei wanted to know, after x minutes, how many fish would be left. 输入There are no more than 20 test cases. For each test case: The first line contains 3 integers: above mentioned m, n and x (0 &lt; m &lt;= 5000, 1 &lt;= n &lt;= 100, 0 &lt;= x &lt;= 1000). The second line contains n integers c1,c2 … cn, ci means that it takes the ith cat ci minutes to eat out a fish ( 1&lt;= ci &lt;= 2000). 输出For each test case, print 2 integers p and q, meaning that there are p complete fish(whole fish) and q incomplete fish left after x minutes. 样例输入 2 1 1 1 8 3 5 1 3 4 4 5 1 5 4 3 2 1 样例输出 1 0 0 1 0 3 ​ 翻译成汉语就是给m条鱼，n只猫，每只猫吃鱼的速度为c[i]。问x秒后有多少条鱼没被吃，多少条鱼没吃完？（同一秒吃的快的猫先拿鱼吃） 思路： ​ 用两个数m代表剩余鱼数，mm代表n-完全吃光的鱼数，两数都初始化为n。先把猫吃鱼的速度排个序，开一个book数组记录一下每个猫的状态（0时代表需要拿一个鱼，1时代表正在吃鱼），我们初始化为0。然后遍历x秒，每秒从快-&gt;慢的猫进行遍历。若状态为0则m–，并把状态更改为1。若时间正好时该鱼速度的倍数，那么mm–，然后把状态更新为0。最后注意当m为0的时候跳出，再注意一下特判就可以啦。 代码： #include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define r return#define N 100000#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)#define mem(a) memset(a, 0, sizeof(a))using namespace std;d a[105];d book[105];d main() &#123; d m, n, x; while(scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;x) == 3) &#123; d mm = m; mem(book); For(i, 1, n) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a + 1, a + n + 1); For(i, 1, x) &#123; d flag = 0; For(j, 1, n) &#123; if (!book[j]) &#123; book[j] = 1; m--; if(m == 0) &#123; if(i % a[j] == 0) &#123; //需要特判m为0的时候是否i%a[j] == 0 mm --; book[j] = 0; &#125; flag = 1; break; &#125; &#125; if(i % a[j] == 0) &#123; mm --; book[j] = 0; &#125; &#125; if(flag) &#123; break; &#125; &#125; printf(&quot;%d %d\n&quot;, m, mm - m); &#125; r 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6237思维]]></title>
    <url>%2F2018%2F10%2F17%2FHDU6237%2F</url>
    <content type="text"><![CDATA[​ 这是2017年ccpc哈尔滨站的一道数论题，很荣幸在我们学校举办，题目另辟蹊径，很好的一道素数题。 题意： Problem Description After he has learned how to play Nim game, Bob begins to try another stone game which seems much easier. The game goes like this: one player starts the game with N piles of stones. There is ai stones on the ith pile. On one turn, the player can move exactly one stone from one pile to another pile. After one turn, if there exits a number x(x&gt;1) such that for each pile bi is the multiple of x where bi is the number of stone of the this pile now), the game will stop. Now you need to help Bob to calculate the minimum turns he need to stop this boring game. You can regard that 0 is the multiple of any positive number. Input The first line is the number of test cases. For each test case, the first line contains one positive number N(1≤N≤100000), indicating the number of piles of stones. The second line contains N positive number, the ith number ai(1≤ai≤100000) indicating the number of stones of the ith pile. The sum of N of all test cases is not exceed 5∗105. Output For each test case, output a integer donating the answer as described above. If there exist a satisfied number x initially, you just need to output 0. It’s guaranteed that there exists at least one solution. Sample Input 251 2 3 4 525 7 Sample Output 21 ​ 翻译成汉语，大概意思就是给你一个T代表有T组样例，然后每组样例第一行给出一个n代表有n堆石子，然后分别输入每堆石子的石子数。只能从一堆石子中取一个石子移动到另一堆，问至少移动几次能使得每一堆的石子数的公共gcd &gt; 1（若此时已经gcd&gt;1了就输出0，一堆石子允许全部移光） ​ 思路： ​ 我们求出所有堆石子的总和sum，然后筛选出它的全部素因子。也就是说，要想让每堆石子的公共gcd大于1，至少其中一个素因子是全部石子堆的因子。因此我们需要遍历每个素因子，分别求出每堆石子数变成该素因子的倍数所需的最小步数，取个最小值就是答案 代码： #include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define d int32_t#define ll int64_t#define r return#define N 100000#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)#define mem(a) memset(a, 0, sizeof(a))using namespace std;d T, n;d a[N + 5];d b[N + 5];ll prime[105];bool book[N + 5];ll prime1[N + 5];//筛1e5以内素数void init() &#123; mem(book); prime1[0] = 0; For(i, 2, N) &#123; if (!book[i]) &#123; prime1[++prime1[0]] = i; &#125; For(j, 1, prime1[0]) &#123; ll t = prime1[j] * i; if (t &gt; N) break; book[t] = 1; if (i % prime1[j] == 0) break; &#125; &#125; r;&#125;//筛选出t的全部素因子void su(ll t) &#123; prime[0] = 0; for (d i = 1; i &lt;= prime1[0]; i ++) &#123; if (t % prime1[i] == 0) &#123; prime[++prime[0]] = prime1[i]; while (t % prime1[i] == 0) &#123; t /= prime1[i]; &#125; if (t == 1) break; &#125; &#125; if (t != 1) &#123; prime[++prime[0]] = t; &#125; r;&#125;//从大到小排列bool cmp (d A, d B) &#123; r A &gt; B;&#125;//求每堆素因子为t的倍数时的最小移动次数ll Num(ll t) &#123; ll sum = 0, ans = 0; For(i, 1, n) &#123; b[i] = a[i] % t; sum += b[i]; &#125; sort(b + 1, b + n + 1, cmp); For(i, 1, n) &#123; if (b[i] == 0) break; ans += t - b[i]; sum -= t; if (sum == 0) &#123; break; &#125; &#125; r ans;&#125;//遍历全部素因子，取最小次数ll work() &#123; ll minn = 99999999999; For(i, 1, prime[0]) &#123; minn = min(minn, Num(prime[i])); &#125; r minn;&#125;d main() &#123; init(); scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; ll sum = 0; scanf(&quot;%d&quot;, &amp;n); For(i, 1, n) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum += a[i]; &#125; su(sum); ll ans = work(); printf(&quot;%lld\n&quot;, ans); &#125; r 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces-1047C思维]]></title>
    <url>%2F2018%2F10%2F16%2FCodeForces-1047C%2F</url>
    <content type="text"><![CDATA[题意： ​ Mr. F has nn positive integers, a1,a2,…,an. ​ He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers. ​ But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward. ​ Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers. Input: ​ The first line contains an integer nn (2≤n≤3⋅10^5) — the number of integers Mr. F has. ​ The second line contains nn integers, a1,a2,…,an (1≤ai≤1.5⋅10^7). Output: ​ Print an integer — the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers. ​ You should not remove all of the integers. ​ If there is no solution, print «-1» (without quotes). Examples Input 31 2 4 Output 1 Input 46 9 15 30 Output 2 Input 31 1 1 Output -1 Note In the first example, the greatest common divisor is 1 in the beginning. You can remove 1 so that the greatest common divisor is enlarged to 2. The answer is 1. In the second example, the greatest common divisor is 3 in the beginning. You can remove 6 and 9 so that the greatest common divisor is enlarged to 15. There is no solution which removes only one integer. So the answer is 2. In the third example, there is no solution to enlarge the greatest common divisor. So the answer is −1. ​ 翻译成汉语就是给你n个数，你会得到这n个数的公共gcd，问最少删除几个数，使得删除后的公共gcd比原来的大，如果有输出最少删除数，没有输出-1 思路： ​ 我们知道，一个数val可以写成p1^a1 ✖️p2^a2✖️ …✖️pn^an的形式，若每个数中都存在pk1，pk2，且pk1在每个数中最少存在t1次，pk2在每个数中最少存在t2次，那么这n个数的公共gcd为pk1^t1✖️pk2^t2 ​ 因此，我们想要提高公共gcd的大小，有以下两种办法： ​ 1.对于每个数都存在的素因子，我们去除它最小的幂次方数，如2, 4, 12，它们中都存在素因子2，2中存在1个素因子2，4中存在2个素因子2，12中存在2个素因子2，因此我们只要去掉最小的幂次方的次数，也就是1个素因子2的2，就可以使得gcd变大 ​ 2.对于不是每个数都存在的素因子，我们只要去掉存在改素因子的数，就可以使得gcd变大 ​ 对于以上两种情况，我们记录一个最小值即可，若最后需要去除n个或者没办法去除，那么就输出-1 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define d int32_t#define r return#define ll int64_t#define N 15000000#define NN 1000000#define mem(a) memset(a, 0, sizeof(a))#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)using namespace std;d book[N + 5]; //book[i]存i的最小素因子在prime中的下角标d prime[NN + 5]; //存全部素数d num[NN + 5]; //存该素数在几个数中出现(若个数等于n取答案与numminx[i]的最小值 小于n取答案与n-num[i]的最小值）d minx[NN + 5]; //该素数在n个数中若出现，存在其中一个数中出现的次数的最小值d numminx[NN + 5]; //该素数在n个数中若出现且是最小值的个数void init() &#123; mem(book); mem(prime); mem(num); memset(minx, 0x3f3f3f3f, sizeof(minx)); mem(numminx); For(i, 2, N) &#123; if (!book[i]) &#123; prime[++prime[0]] = i; book[i] = prime[0]; &#125; For(j, 1, prime[0]) &#123; if (prime[j] * i &gt; N) &#123; break; &#125; book[i * prime[j]] = j; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125; r;&#125;void work(d a) &#123; while(a != 1) &#123; d aa = a; d t = prime[book[a]], inx = 0; num[book[a]]++; while (a % t == 0) &#123; inx ++; a /= t; &#125; if (inx &lt; minx[book[aa]]) &#123; minx[book[aa]] = inx; numminx[book[aa]] = 1; &#125; else if (inx == minx[book[aa]]) &#123; numminx[book[aa]] ++; &#125; &#125;&#125;d main()&#123; init(); d n, a; d minn = 0x3f3f3f3f; scanf(&quot;%d&quot;, &amp;n); For(i, 1, n) &#123; scanf(&quot;%d&quot;, &amp;a); work(a); &#125; For(i, 1, prime[0]) &#123; if(!num[i]) continue; if (num[i] == n) &#123; minn = min(numminx[i], minn); &#125; else &#123; minn = min(n - num[i], minn); &#125; &#125; if (minn == 0x3f3f3f3f || minn == 0 || minn == n) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, minn); r 0;&#125; ​ 就酱紫～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-048快速乘]]></title>
    <url>%2F2018%2F10%2F16%2FProject-Euler-048%2F</url>
    <content type="text"><![CDATA[048题：题意： ​ 十项的自幂级数求和为 1^1 + 2^2 + 3^3 + … + 10^10 = 10405071317。 ​ 求如下一千项的自幂级数求和的最后10位数字：1^1 + 2^2 + 3^3 + … + 1000^1000 思路： ​ 设mod为1e10，根据同余定理，我们可以利用快速幂求i^i关于mod的模。但是有一个问题，就是快速幂中存在两数先相乘再取余mod的过程，可能两数在相乘时就爆long long了。因此，我们可以通过一个小技巧来防治爆long long。 ​ 对于a * b % mod，我们设k为1e5，那么一定存在a = ik + j，b = pk + q （其中i = a / k，j = a % k，p = b / k，q = b % k） ​ 把a和b带入原式，得到： a * b % mod = (ik + j) * (pk + q) % mod = (ipk^2 + iqk + jpk + jq) % mod ​ 由于ipk^2,iqk,jpk,jq都在longlong范围内，因此解决了爆longlong问题 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define d int32_t#define r return#define ll int64_t#define t (ll)1e5#define mod (ll)1e10#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)//乘法防爆longlongll mul (ll a, ll b) &#123; ll ans = 0; ll i = a / t; ll j = a % t; ll p = b / t; ll q = b % t; ans = (i * p % mod * t % mod *t % mod + i * q % mod * t % mod + j * p % mod * t % mod + j * q % mod) % mod; r ans;&#125;//快速幂ll quick(ll a, ll b) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mul(ans, a); b &gt;&gt;= 1; a = mul(a, a); &#125; r ans;&#125;//循环球i^ill work() &#123; ll ans = 0; For(i, 1, 1000) &#123; ans = (ans + quick(i, i)) % mod; &#125; r ans;&#125;d main()&#123; ll ans = work(); printf(&quot;%&quot; PRId64 &quot;\n&quot;, ans); r 0;&#125; 最后结果为：9110846700 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6228求边的左右节点数]]></title>
    <url>%2F2018%2F10%2F15%2FHDU6228%2F</url>
    <content type="text"><![CDATA[题意： Problem Description Consider a un-rooted tree T which is not the biological significance of tree or plant, but a tree as an undirected graph in graph theory with n nodes, labelled from 1 to n. If you cannot understand the concept of a tree here, please omit this problem.Now we decide to colour its nodes with k distinct colours, labelled from 1 to k. Then for each colour i = 1, 2, · · · , k, define Ei as the minimum subset of edges connecting all nodes coloured by i. If there is no node of the tree coloured by a specified colour i, Ei will be empty.Try to decide a colour scheme to maximize the size of E1 ∩ E2 · · · ∩ Ek, and output its size. Input The first line of input contains an integer T (1 ≤ T ≤ 1000), indicating the total number of test cases.For each case, the first line contains two positive integers n which is the size of the tree and k (k ≤ 500) which is the number of colours. Each of the following n - 1 lines contains two integers x and y describing an edge between them. We are sure that the given graph is a tree.The summation of n in input is smaller than or equal to 200000. Output For each test case, output the maximum size of E1 ∩ E1 … ∩ Ek. Sample Input 34 21 22 33 44 21 21 31 46 31 22 33 43 56 2 Sample Output 101 ​ 翻译成汉语大概意思就是有一颗树，在树上的点涂色，每个点涂一种颜色，一共可以涂k种颜色，然后你需要把每种颜色的点按最短路径用该种颜色连起来，问涂k次的边最多有几条？ ​ 第一行输入的是T代表有T组样例，每组样例第一行为n，k，分别代表树上有n个节点，可用k种颜色给节点涂色。之后n-1行a,b代表节点a到节点b之间有一条边 思路： ​ 我们可以把树转化为图，对于每个边进行dfs（利用记忆化搜索），分别求出该边左边和右边的节点数，只要都大于等于k就可以累加，累加和就是答案。时间复杂度，大概也就O(n)吧，因为记忆化搜索dfs多也多不多少。。 代码： #include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define d int32_tusing namespace std;struct node &#123; d left, right;&#125;bian[200005];d num[200005][2]; //num[i][0]存储第i个边左边的节点数，num[i][1]存储第i个边右边的节点数vector&lt;int&gt;zcy[200005]; //zcy[i]存储以i点为端点的边的编号,zcy[i].size()即为边的个数//利用dfs+记忆化搜索求编号为now的边的chooes（0为左，1为右）的节点数int dfs(int now, int chooes) &#123; if(num[now][chooes]) return num[now][chooes]; //记忆化搜索 int ans = 1, t; if (chooes == 0) &#123; t = bian[now].left; &#125; else &#123; t = bian[now].right; &#125; for (int i = 0; i &lt; zcy[t].size(); i++) &#123; int next = zcy[t][i]; if (bian[next].left == bian[now].left &amp;&amp; bian[next].right == bian[now].right) &#123; continue; &#125; if (bian[next].left == t) &#123; if (num[next][1]) &#123; //记忆化搜索 ans += num[next][1]; &#125; else &#123; ans += dfs(next, 1); &#125; &#125; else &#123; if (num[next][0]) &#123; //记忆化搜索 ans += num[next][0]; &#125; else &#123; ans += dfs(next, 0); &#125; &#125; &#125; num[now][chooes] = ans; //记录中间状态 return ans;&#125;int main()&#123; int T, n, k; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int ans = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); memset(num, 0, sizeof(num)); for (int i = 1; i &lt;= n; i++) &#123; zcy[i].clear(); &#125; for (int i = 1; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;bian[i].left, &amp;bian[i].right); zcy[bian[i].left].push_back(i); zcy[bian[i].right].push_back(i); &#125; for (int i = 1; i &lt; n; i++) &#123; dfs(i, 0); //每个边两个dfs，分别求左边和右边（由于有记忆化搜索，所以可以不用右边=节点数-左边） dfs(i, 1); &#125; for (int i = 1; i &lt; n; i++) &#123; if (num[i][0] &gt;= k &amp;&amp; num[i][1] &gt;= k) ans++; //此时满足条件 &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-021线性求约数和]]></title>
    <url>%2F2018%2F10%2F15%2FProject-Euler-021%2F</url>
    <content type="text"><![CDATA[021题：题意： ​ 记d(n)为n的所有真因数（小于n且整除n的正整数）之和​ 如果d(a) = b且d(b) = a，且a ≠ b，那么a和b构成一个亲和数对，a和b被称为亲和数 ​ 例如，220的真因数包括1、2、4、5、10、11、20、22、44、55和100，因此d(220) = 284；而284的真因数包括1、2、4、71和142，因此d(284) = 220 ​ 求所有小于10000的亲和数的和 思路： ​ 在数论中我们称d(n)这样的函数为约数和函数。具体有以下几个性质： ​ 1.约数和函数为积性函数，因此满足任意两个互质的数a，b，都有d(a✖️b) = d(a) ✖️d(b) ​ 2.若b = a ✖️ a中的最小素因子p1 ，也就是 a = p1^a1 * p2^a2 * ... * pn^anb = p1 * p1^a1 * p2^a2 * ... * pn^an 则： d(b) = d(a) * (1 - p1^(a1 + 2)) / (1 - p1^(a1 + 1)) ​ ​ 3.对于素数来说，它的约数只有1和它本身，所以： d(n) = n + 1; //当n为素数 ​ ​ 4.对于求解一般的约数和函数，我们有一个约数和定理： d(n)=(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak)//n = p1^a1 * p2^a2 *...* pk^ak且p都为素数 ​ 通过等比数列求和公式化简一下，为： d(n)=Π (1 - pi^(ai + 1)) / (1 - pi) //pi为它的素因子，ai为该种素因子的个数 ​ 我们就可以根据n的素因子种类pi和每种的个数ai来求约数和了。关于pi和ai我们可以利用之前的线性筛求因子个数框架来求取 抛个链接：走你 ​ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_t#define f double#define r return#define N (d)1e4#define mem(a) memset(a, 0, sizeof(a))#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)#define printfl(a) printf(&quot;%lld\n&quot;, a)#define printfd(a) printf(&quot;%d\n&quot;, a)#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)ll prime[N + 5]; //存全部的素数ll dd[N + 5]; //用来存约数和ll book[N + 5]; //book[i]用来存储i的最小素因子幂次方值，如book[24] = 8void init() &#123; mem(prime); mem(dd); mem(book); For(i, 2, N) &#123; if(!book[i]) &#123; prime[++prime[0]] = i; dd[i] = i + 1; //素数的约数只有1和它本身 book[i] = i; //素数的最小素因子幂次方值等于它本身 &#125; For(j, 1, prime[0]) &#123; ll t = prime[j] * i; if (t &gt; N) break; if (i % prime[j] == 0) &#123; //当为性质2的时候 book[t] = book[i] * prime[j]; dd[t] = dd[i] * (book[i] * prime[j] * prime[j] - 1) / (book[i] * prime[j] - 1); break; &#125; else &#123; //当为性质1的时候 dd[t] = dd[prime[j]] * dd[i]; book[t] = prime[j]; &#125; &#125; &#125; r;&#125;d main () &#123; init(); ll ans = 0; For(i, 2, N) &#123; dd[i] -= i; &#125; For(i, 0, N) &#123; if (dd[i] != i &amp;&amp; dd[i] &lt;= N &amp;&amp; i == dd[dd[i]]) &#123; ans += i; &#125; &#125; printfl(ans); r 0;&#125; 最后结果是：31626 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6265狄利克雷卷积]]></title>
    <url>%2F2018%2F10%2F14%2FHDU6265%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[下面就做一道欧拉函数|积性函数|狄利克雷卷积的题吧，相关原理在上一篇博文：点我跳转 题意： ​ 翻译成汉语，大概意思就是首先输入一个数T代表有T组样例，每组样例第一行m代表有m对&lt;p,q&gt;（其中p为素数，每对中的p各不相同），计算得到全部pi^qi的乘积n，最后求一下∑d|n φ(d) × n / d的值取模998244353 思路： ​ 由于p和q数据范围是1e8，我们没办法求出全部p^q的乘积n（爆long long），只能想办法化简公式和通过中间过程来得到答案，又因为给出的∑d|n φ(d) × n / d包含求和，我们遍历辣么大的数的求和铁定超时，所以还应该想办法把公式化简成O(1)的，也就是把求和给去掉 ​ 我们接着按照上面的需求想问题： ​ 令函数f(n) = n，令h(n) = ∑d|n φ(d) × n / d，是不是发现了点什么！！！对，h(n）是φ(n)与f(n)的狄利克雷卷积。由于φ(n)是欧拉函数，所以它是积性函数，f(n) = n是单位函数，所以它是完全积性函数，那么h(n)一定也是积性函数，它满足a,b互质，则h(a b) = h(a) h(b)的性质 ​ 又因为每对中的p都是不同的素数！！！因此每对pi^qi之间都是互质的，所以,我们就可以解决爆long long 问题： h(n) = h(p1^q1 * p2^q2 * ... * pm^qm) = ∏ h(pi ^ qi) //i为从1～m ​ 这样我们从求h(n)变成了求m个h(pi^qi)的乘积了 ​ 此时pi^qi也会爆long long，我们先别管继续往下走 ​ 这时候∑d|n φ(d) × n / d就变成了求∑d|p^q φ(d) × p^q / d .我们需要通过化简∑d|p^q φ(d) × p^q / d为O(1)来解决超时问题，怎么化简呢？手写了一份化简过程： 我们就可以把h(p^q) = ∑d|p^q φ(d) × p^q / d 化简为h(p^q) = p^q + q p^(q - 1) (p - 1) 这样我们就可以通过h(n) = ∏ h(pi ^ qi)来求h(n)了（通过不断的取余998244353来防治爆longlong） ​ Over～ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_t#define f double#define r return#define mod 998244353#define mem(a) memset(a, 0, sizeof(a))#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)#define printfl(a) printf(&quot;%lld\n&quot;, a)#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)//快速幂ll quick(ll a, ll b) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) &#123; ans = ans * a % mod; &#125; b &gt;&gt;= 1; a = a * a % mod; &#125; r ans;&#125;d main () &#123; d T, m; ll p, q; scanfd(T); while (T--) &#123; ll ans = 1; scanfd(m); For (i, 1, m) &#123; ll res = 0; scanfl(p); scanfl(q); res = quick(p, q - 1) * q % mod * (p - 1) % mod; res = (res + quick(p, q)) % mod; ans = ans * res % mod; &#125; printfl(ans); &#125; r 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(数论一)积性函数与狄利克雷卷积]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[​ 今天做的一道题就是有关积性函数与狄利克雷卷积的，很懵逼。觉得有必要学一手了 一. 积性函数是什么呢？​ 对于函数f，对于任意的a,b互质，都有: f(a * b) = f(a) * f(b) ​ 这样的函数f就称为积性函数，若a,b不互质也满足上述条件的话，那么函数f又可称为完全积性函数 ​ 它又有什么性质呢？ 1.若n = p1^q1✖️p2^q2✖️ …✖️pn^qn，那么对于积性函数f，有： f(n) = f(p1^q1) * f(p2^q2) * ... * f(pn^qn) 2.若积性函数f满足f(p^n) = f^n(p)，那么f也是完全积性函数 二. 那么，狄利克雷卷积是什么呢？​ 对于任意函数f,g，令h = f * g,都有： h(n) = ∑d|n f(d)⋅g(n / d) //d为能被n整除的数 ​ 此时这个h就可以称为f和g的狄利克雷卷积 它有什么性质呢？ ​ 1.狄利克雷卷积满足交换律，结合律，加法分配律： f * g = g * ff * g * h = f * (g * h)f * (g + h) = f * g + f *h ​ 2.积性函数卷个积性函数的狄利克雷卷积仍旧是积性函数 ​ 三. 常见的积性函数和狄利克雷卷积有哪些？我们先说一下常见的积性函数： 1.id^k(n) = n^k：幂函数，属于完全积性函数 2.I(n) = 1: 恒等函数，属于完全积性函数，相当于id^0(n) 3.id(n) = n： 单位函数，属于完全积性函数，相当于id^1(n) 4.e(n) = [n = 1]：代表单位元函数，它卷上任意的函数都得原函数，即： e * f = f 5.φ(n)：欧拉函数，表示小于等于 n 且与 n 互质的数的个数 6.μ(n)：莫比乌斯函数，在狄利克雷卷积中与恒等函数互为逆元： μ * I = e ​ 关于莫比乌斯函数公式： μ(n) = 1; //当n为1时μ(n) = (-1)^k //当n由k个不同质数相乘得到时μ(n) = 0; //其余情况 7.σ(n)：约数和函数，表示n的全部约数和 8.τ(n)：约数个数函数，表示n的全部约数个数 9.σk(n)=∑d|n d^k ：因数函数，表示n全部约数的k次方和 再来说一下常用的狄利克雷卷积： I ∗ μ = e （即莫比乌斯函数与恒等函数互为逆元） μ∗id = φ (即莫比乌斯函数卷上单位函数为欧拉函数) I ∗ id = σ（即恒等函数卷个单位函数为约数和函数） I ∗ I = τ （即恒等函数卷个恒等函数为约数个数函数） I * φ = id (即恒等函数卷个欧拉函数为单位函数) 可以由狄利克雷卷积证明很多结论，比如： 1.n = ∑d|n φ(d) ，也就是n等于全部 φ(d)的和（φ(d)为d的欧拉函数） 2.σ(n) = ∑d|n τ(d) ∗ φ(n / d)，也就是欧拉函数卷个约数个数函数为约数和函数 3.二项式反演： 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>数论原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6267推规律+线性阶乘逆元]]></title>
    <url>%2F2018%2F10%2F14%2FHDU6267%2F</url>
    <content type="text"><![CDATA[去年杭州站没做上来的一道数学题，今天补了～ 题意： ​ Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query, you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifies the nodes with labels from 0 to n − 1 and then visits them one by one. For each i (1 ≤ i ≤ n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: for i = 1 to n - 1: father[i] = random(0, i - 1); ​ where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. ​ Knowing n and the value of the i-th node ai, Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her? Input ​ The first line contains an integer T (1 ≤ T ≤ 10) representing the number of test cases. For each test case, the first line contains an integer n (1 ≤ n ≤ 100000), the number of the nodes in the rooted tree.​ The second line contains n integers a0, a1, …, an−1 (1 ≤ ai ≤ 100000) represent the values of nodes. Output ​ It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p ∗ q−1 mod 998244353 in one line. q−1 is the inverse of q under module number 998244353. Example Explanation ​ The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3 ∗ 2−1 mod 998244353 = 499122178. ​ There are two possible shapes in the second test case, node 1’s father destines to be 0, but node 2’s father might be node 0 or node 1. Both conditions are equally possible. ​ If node 2’s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. ​ If node 2’s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. ​ So the expectation is (6+2+3+6+5+3)/6 = 25/6. The output is 25∗6−1 mod 998244353 = 166374063. ​ 这么一大串英文，翻译成汉语大概也就是说让你输入一个T，代表有T组样例。每组样例第一行输入一个n，代表一个树有n个节点，然后循环输入每个节点的权值。它组成树的方式是：k号节点等概率的选择0～k-1中任意一个节点当它的父节点。然后随意选一个节点，问以它为根节点组成的子树的权值和的数学期望是多少？ 思路： ​ n个节点，每个节点等概率的选择0～k-1中任意一个节点当它的父节点。那么这n个节点组成树的可能性为（n - 1）!个。例如4个节点可能组成以下6种树： ​ 又因为任选一个节点当根节点，所以共有n * （n - 1），也就是n!种子树 ​ 因此我们可以通过求（每个节点在全部子树的贡献和）/ n！来求数学期望值。 ​ 我们可以看到，0号节点在全部子树的贡献是6次（每种树只有选取0号节点当根节点才包含0号节点），也就是3! ​ 1号节点在全部子树的贡献是12次（每种树只有选取0号节点或者1号节点才包含1号节点），也就是3! + 3! / 1 ​ 2号节点在全部子树的贡献是15次（有3种树选0，1，2号节点当根节点包含2号节点，有3种树选0，2号节点当根节点才包含2号节点）,也就是3! + 3! / 1 + 3! / 2 ​ 3号节点在全部子树的贡献是17次（有1种树选0，1，2，3号节点当根节点包含3号节点，有2种树选0，1，3号节点当根节点包含3号节点，有1种树选0，2，3号节点当根节点包含3号节点，有2种树选0，3号节点当根节点包含3号节点),也就是3! + 3! / 1 + 3! / 2 + 3! / 3 ​ 我们发现第k号节点的贡献为：(n - 1)! + (n - 1) ! / 1 + …. + (n - 1) / k ​ 所以我们设i号节点的贡献为pi，权值为qi，那么每个节点在全部子树的贡献和为∑pi*qi （i从0到n-1），再除以n！即为数学期望。因为需要取余998244353且包含除法，因此需要用到求逆元。 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_t#define f double#define r return#define N 100000#define mod 998244353#define mem(a) memset(a, 0, sizeof(a))#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)#define printfl(a) printf(&quot;%lld\n&quot;, a)#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)ll q[N + 5]; //存储每个节点的权值ll fact[N + 5]; //存储阶乘ll inv[N + 5]; //存储阶乘的逆元ll inv1[N + 5]; //存储线性逆元ll num[N + 5]; //存储节点的贡献值//扩展欧几里得算法ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (a == 0 &amp;&amp; b == 0) r -1; if (b == 0) &#123; x = 1; y = 0; r a; &#125; ll t = extend_gcd(b, a % b, y, x); y -= a / b * x; r t;&#125;//求a关于mod的逆元ll mod_reverse (ll a) &#123; ll x, y; ll t = extend_gcd(a, mod, x, y); if (t == 1) r (x % mod + mod) % mod; r -1;&#125;//预处理1～100000阶乘及逆元，处理线性逆元void init() &#123; fact[0] = fact[1] = 1; inv1[0] = inv1[1] = 1; For (i, 2, N) &#123; fact[i] = fact[i - 1] * i % mod; inv1[i] = (mod - mod / i) * inv1[mod % i] % mod; &#125; inv[N] = mod_reverse(fact[N]); Forr (i, N - 1, 0) &#123; inv[i] = inv[i + 1] * (i + 1) % mod; &#125; r;&#125;//处理权值和ll work(d n) &#123; ll ans = 0; num[0] = fact[n - 1]; ans = (ans + num[0] * q[0]) % mod; For(i, 1, n - 1) &#123; num[i] = (num[i - 1] + fact[n - 1] * inv1[i]) % mod; ans = (ans + num[i] * q[i]) % mod; &#125; r ans;&#125;d main () &#123; init(); d T, n; scanfd(T); while (T--) &#123; scanfd(n); For (i, 0, n - 1) &#123; scanfl(q[i]); q[i] %= mod; &#125; ll ans = work(n) * inv[n] % mod; printfl(ans); &#125; r 0;&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-019菜勒公式]]></title>
    <url>%2F2018%2F10%2F13%2FProject-Euler-019%2F</url>
    <content type="text"><![CDATA[019题：题意： ​ 在二十世纪（1901年1月1日到2000年12月31日）中，有多少个月的1号是星期天？ 思路： ​ 我们需要遍历从1901到2000年的每一月，判断是否1号为星期天。 ​ 一.先用日历看一下1901年一月1号是星期几，然后根据把星期一到星期天定义为0～6，预处理每个月的天数（注意平年和闰年），然后累加取余7，只要判断是否为6即可，是就累加到结果中 ​ ​ 二.利用蔡勒公式 w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;//其中w为星期（0～6分别代表星期一到星期天），y，m，d分别代表年月日 ​ 该公式有个注意点，就是当月份为1月或2月时，分别把它当作上一年的13月14月计算。 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define r return#define N 1000005#define mem(a) memset(a, 0, sizeof(a))using namespace std;bool chooes(d y, d m, d day) &#123; if(m == 1 || m == 2) &#123; y --; m += 12; &#125; d w = (day + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; if (w == 6) r 1; r 0;&#125;d main() &#123; d ans = 0; for (d i = 1901; i &lt;= 2000; i++) &#123; for (d j = 1; j &lt;= 12; j++) &#123; if(chooes(i, j, 1)) &#123; ans++; &#125; &#125; &#125; printf(&quot;%&quot; PRId32&quot;\n&quot;, ans); r 0;&#125; 最后答案是：171 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-047线性求质因子种类]]></title>
    <url>%2F2018%2F10%2F13%2FProject-Euler-047%2F</url>
    <content type="text"><![CDATA[047题：题意： 首次出现连续两个数均有两个不同的质因数是在： ​ 14 = 2 × 7​ 15 = 3 × 5 首次出现连续三个数均有三个不同的质因数是在： ​ 644 = 22 × 7 × 23​ 645 = 3 × 5 × 43​ 646 = 2 × 17 × 19 首次出现连续四个数均有四个不同的质因数时，其中的第一个数是多少？ 思路： ​ 有一下两个思路： ​ 一.先预处理前1e6个素数，然后从1开始往后遍历每个数，如果满足连续四个数的素因子种类都为4，就返回并输出，时间复杂度为O(n*m)，n为预处理的1e6，m为找到的那个数 ​ 二.利用线性筛框架，把标记数组改为记录该数有多少种不同素因子的数组。时间复杂度为O(n + m) 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define r return#define N 1000005#define mem(a) memset(a, 0, sizeof(a))using namespace std;d prime[N]; //记录1e6范围内的全部素数d book[N]; //book[i]记录数字i由多少种不同素因子相乘得到void init() &#123; mem(prime); mem(book); for (d i = 2; i &lt; N; i++) &#123; if (!book[i]) &#123; book[i] = 1; prime[++prime[0]] = i; &#125; for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt; N; j++) &#123; if (i % prime[j] == 0) &#123; book[prime[j] * i] = book[i]; break; &#125; book[prime[j] * i] = book[i] + 1; &#125; &#125; r;&#125;d main() &#123; init(); for (d i = 2; i &lt; N - 4; i++) &#123; if(book[i] == 4 &amp;&amp; book[i + 1] == 4 &amp;&amp; book[i + 2] == 4 &amp;&amp; book[i + 3] == 4) &#123; printf(&quot;%&quot; PRId32&quot;\n&quot;, i); break; &#125; &#125; r 0;&#125; 答案是：134043 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-029思维]]></title>
    <url>%2F2018%2F10%2F13%2FProject-Euler-029%2F</url>
    <content type="text"><![CDATA[029题：题意： 考虑所有满足2 ≤ a ≤ 5和2 ≤ b ≤ 5的整数组合生成的幂ab： 22=4, 23=8, 24=16, 25=3232=9, 33=27, 34=81, 35=24342=16, 43=64, 44=256, 45=102452=25, 53=125, 54=625, 55=3125 如果把这些幂按照大小排列并去重，我们得到以下由15个不同的项组成的序列： 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125 在所有满足2 ≤ a ≤ 100和2 ≤ b ≤ 100的整数组合生成的幂ab排列并去重所得到的序列中，有多少个不同的项？ 思路： ​ 我们肯定没有办法计算类似100^100的值，因此我们只能考虑什么情况下a^b的值等于p^q的值 ​ 我们可以发现: 2^6 = 4^3 = 8^2，这种情况下我们只需要计算一个即可 ​ 我们把4^3化简得到 (2^2)^3 = 2^6,8^2化简得到(2^3)^2=2^6，所以，4，8，16等数都可以看作是2的平方数的形式 ​ 因此我们可以创建一个map&lt;inde, bool&gt;zcy[105]的映射数组， 用i遍历2～100，然后若book[i]不存在（即i不是任何数的幂次方)，就对它的所有幂次方进行遍历，设它的inx次方为t，那么它t^j == (i ^ inx) ^j == (i) ^ (inx j)，利用map[i]【j inx】映射判断是否存在过该数。若不存在就累加。时间复杂度大概1e4，完美的解决了爆longlong的问题 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#define ll int64_t#define d int32_t#define r return#define mem(a) memset(a, 0, sizeof(a))using namespace std;map&lt;int, bool&gt;zcy[1005];ll ans = 0;bool book[105];void init() &#123; mem(book); for (d i = 2; i &lt;= 100; i++) &#123; //遍历a if (!book[i]) &#123; zcy[i].clear(); d t = i, inx = 1; while (t &lt;= 100) &#123; book[t] = 1; for (d j = 2; j &lt;= 100; j++) &#123; //遍历j if (!zcy[i][j * inx]) &#123; 对于t来说，它等于i^inx,因此它就相当于i^(inx * j) ans ++; zcy[i][j * inx] = 1; &#125; &#125; inx ++; t *= i; &#125; &#125; &#125;&#125;d main() &#123; init(); printf(&quot;%&quot; PRId64&quot;\n&quot;, ans); r 0;&#125; 答案是：9183 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-024思维]]></title>
    <url>%2F2018%2F10%2F13%2FProject-Euler-024%2F</url>
    <content type="text"><![CDATA[024题：题意： ​ 排列指的是将一组物体进行有顺序的放置。例如，3124是数字1、2、3、4的一个排列。如果把所有排列按照数字大小或字母先后进行排序，我们称之为字典序排列。0、1、2的字典序排列是： ​ 012 021 102 120 201 210 ​ 数字0、1、2、3、4、5、6、7、8、9的字典序排列中第一百万位的排列是什么？ 思路： ​ 设n = 1e6，这个题可以预处理出1～9位数的组合数分别是sum[1~9]； ​ 然后用i遍历从9～1 ​ 如果n % sum[i] != 0，那么最高位数字是剩余数字中第n / sum[i] 个数（从0开始）并取出 ​ 如果n % sum[i] == 0，那么最高位数字是剩余数字中第n / sum[i] - 1个数（从0开始）并取出，剩余数字由大到小排序，并跳出i循环 ​ 这样只需要一次遍历就可以求出第1000000位的排列是多少 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define r return#define mem(a) memset(a, 0, sizeof(a))using namespace std;const ll n = 1e6;ll sum[15];bool book[15];//预处理void init() &#123; mem(book); mem(sum); sum[0] = 1; for (d i = 1; i &lt;= 9; i++) &#123; sum[i] = sum[i - 1] * i; &#125;&#125;//求第m个数是多少void work (ll m) &#123; for (d i = 9; i &gt;= 1; i--) &#123; ll t = m / sum[i]; if (m % sum[i] == 0) &#123; //当m%sum[i]==0时 d num = 0; for (d j = 0; j &lt;= 9; j++) &#123; if (!book[j]) &#123; if (num == t - 1) &#123; printf(&quot;%&quot; PRId32, j); book[j] = 1; break; &#125; num ++; &#125; &#125; for (d j = 9; j &gt;= 0; j--) &#123; if(!book[j]) &#123; printf(&quot;%&quot; PRId32, j); &#125; &#125; printf(&quot;\n&quot;); r; &#125; //当m % sum[i] != 0时 d num = 0; for (d j = 0; j &lt;= 9; j++) &#123; if (!book[j]) &#123; if (num == t) &#123; printf(&quot;%&quot; PRId32, j); book[j] = 1; break; &#125; num ++; &#125; &#125; m %= sum[i]; &#125; //最后别忘已经固定的个位数 for (d i = 0; i &lt;= 9; i ++) &#123; if (!book[i]) &#123; printf(&quot;%&quot; PRId32&quot;\n&quot;, i); r; &#125; &#125; r;&#125;d main() &#123; init(); work (n); r 0;&#125; 答案是：2783915460 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-015组合数]]></title>
    <url>%2F2018%2F10%2F13%2FProject-Euler-015%2F</url>
    <content type="text"><![CDATA[015题：题意： 从一个2×2方阵的左上角出发，只允许向右或向下移动，则恰好有6条通往右下角的路径。 对于20×20方阵来说，这样的路径有多少条？ 思路： ​ 有两个解题思路： ​ 一.利用DP求解，我们可以设二维数组dp【i】【j】代表到达第i行第j列的方案数，初始化dp【0】【0】= 1利用dp推导式dp【i】【j】=dp【i-1】【j】+dp【i】【j-1】就可求出dp【20】【20】了。这样复杂度式O(n^2) ​ ​ 二.我们可以利用组合数求解，由于它只能向右或者向下，那么想要到达第i行第j列，就必须往下走i步，往右走j步，有且只能走i+j步。所以我们就可以转化为有i+j个盒子，红球有i个，蓝球有j个，问不同的颜色组成方案。也就是(i + j)! /(i! * j!)的值，时间复杂度为O(n+m) n为行，m为列.一定要注意爆longlong范围的解决方法。 代码： ​ 还是只写复杂度最低的代码： #include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define r returnusing namespace std;//用于求(n + m)! / (n)! * (m)!ll work (ll n, ll m) &#123; ll ans1 = 1, t = 20; for (ll i = n + m; i &gt; max(n, m); i--) &#123; ans1 *= i; while (ans1 % t == 0 &amp;&amp; t &gt;= 2) &#123; //解决爆longlong ans1 /= t; t--; &#125; &#125; r ans1;&#125;d main() &#123; ll ans = work (20, 20); printf(&quot;%&quot; PRId64&quot;\n&quot;, ans); r 0;&#125; 答案为：137846528820 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C与C++区别（转）]]></title>
    <url>%2F2018%2F10%2F13%2FC%E4%B8%8EC-%E5%8C%BA%E5%88%AB-%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[原文地址：点我跳转]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言指针详解（转）]]></title>
    <url>%2F2018%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E2%80%94%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[看到讲得特别好，果断转了，原文地址：点我跳转]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-012积性函数性质]]></title>
    <url>%2F2018%2F10%2F12%2FProject-Euler-012%2F</url>
    <content type="text"><![CDATA[012题：题意： ​ 三角形数数列是通过逐个加上自然数来生成的。例如，第7个三角形数是 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28。三角形数数列的前十项分别是： ​ 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, … ​ 让我们列举出前七个三角形数的所有约数： ​ 1: 1 3: 1,3​ 6: 1,2,3,6​ 10: 1,2,5,10​ 15: 1,3,5,15​ 21: 1,3,7,21​ 28: 1,2,4,7,14,28 ​ 我们可以看出，28是第一个拥有超过5个约数的三角形数。 ​ 第一个拥有超过500个约数的三角形数是多少？ 思路： ​ 任何一个数都可以写成一个或多个素数的乘积，我们设为n = p1^n1 p2 ^ n2 ….. ​ 因此，一个数的因子个数，等同于(n1 + 1) (n2 + 1) …. ​ 为什么呢？我们可以想一下，对于素因子p1，我们有n1 + 1种选择，分别是：不选，选一个，选两个…直到选n1个，同理p2有n2+1种选择，所以种类数就是(n1 + 1) (n2 + 1) …. ​ 因此，我们只需要计算一个数有多少种素因子，每种素因子的个数，就可以通过算式直接求得一个数的因子数，求法有两种： ​ ——一种是预处理全部素数，然后每次遍历整除直到该数为1，时间复杂度是O(n)，其中n为满足条件的数 ​ ——另一种方式是创建记忆化数组数组，存储每个数的最小素因子。再利用：如果a,b互质，那么num(a ✖️ b) = num (a) ✖️ num(b) ,又因为三角形数都是n / 2 ✖️ (n - 1)或n / 2 ✖️ (n + 1)（n &gt;= 2且n为偶数），所以我们只预处理sqrt（n）项即可（注：num(a)代表数字a的因子数），时间复杂度为O(sqrt(n)) 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_t#define f double#define r return#define mem(a) memset(a, 0, sizeof(a));#define N 40000d book[N + 5]; //存储每个数的最小素因子d prime[N + 5]; //存储2～40000全部素数d number[N + 5]; //存储前40000数的因子数//利用线性筛框架初始化void init() &#123; mem(book); mem(prime); for (d i = 2; i &lt;= N; i++) &#123; if (!book[i]) &#123; prime[++prime[0]] = i; book[i] = i; &#125; for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt;= N; j++) &#123; book[prime[j] * i] = prime[j]; if (i % prime[j] == 0) break; &#125; &#125; r;&#125;//用于求S(n)ll mul (ll n) &#123; r (n + 1) * n / 2;&#125;//求n的因子数d num(ll n) &#123; if (n == 1) r 1; d res = 1; d t = book[n]; while(n % t == 0) &#123; res++; n /= t; &#125; r res * num(n);&#125;//利用当a，b互质，num(a * b) = num(a) * num(b)求a*b的因子数void work () &#123; for (ll i = 1; i &lt;= N; i++) &#123; number[i] = num(i); &#125; for (ll i = 2; i &lt;= N; i += 2) &#123; d p1 = number[i / 2] * number[i - 1]; d p2 = number[i / 2] * number[i + 1]; if (p1 &gt; 500) &#123; printf(&quot;%&quot; PRId64&quot;\n&quot;, i / 2 * (i - 1)); r; &#125; else if(p2 &gt; 500) &#123; printf(&quot;%&quot; PRId64&quot;\n&quot;, i / 2 * (i + 1)); r; &#125; &#125; r;&#125;d main () &#123; init(); work(); r 0;&#125; 答案是：76576500 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-009素勾股数]]></title>
    <url>%2F2018%2F10%2F12%2FProject-Euler-009%2F</url>
    <content type="text"><![CDATA[009题：题意： ​ 毕达哥拉斯三元组是三个自然数a &lt; b &lt; c组成的集合，并满足 ​ a2 + b2 = c2 ​ 例如，32 + 42 = 9 + 16 = 25 = 52。 ​ 有且只有一个毕达哥拉斯三元组满足 a + b + c = 1000。求这个三元组的乘积abc ​ 相同类型的还有039题，有时间大家可以做一下！ 思路： ​ 暂时想到了二个： ​ 一.两层嵌套for循环分别从1～1000遍历a和b，只要满足a + b &lt; 1000 &amp;&amp; a^2 + b ^ 2 == （1000 - a - b）^2即可，时间复杂度大概1e6 ​ 二.利用素勾股数公式：满足gcd(n, m) == 1的互质数，存在a = 2 n m; b = m^2 - n^2; c = m^2 + n ^2，这是只需要遍历n和m（取值范围都是1～32），只要满足a+b+c == 1000即可，时间复杂度大概是1e3 代码： #include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define f double#define r return#define mem(a) memset(a, 0, sizeof(a));using namespace std;//求gcdd gcd(d a, d b) &#123; r b == 0?a : gcd(b, a % b);&#125;void work() &#123; for (d i = 1; i &lt;= 32; i++) &#123; for (d j = i + 1; j &lt;= 32 &amp;&amp; i * i + j * j &lt; 1000; j++) &#123; if (gcd(j, i) == 1) &#123; d a = 2 * i * j; d b = j * j - i * i; d c = j * j + i * i; d sum = a + b + c; if (1000 % sum == 0) &#123; d t = 1000 / sum; printf(&quot;%&quot; PRId64&quot;\n&quot;, (ll)t * t * t * a * b * c); r; &#125; &#125; &#125; &#125; r;&#125;d main () &#123; work(); r 0;&#125; ​ 答案是：31875000 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-045思维]]></title>
    <url>%2F2018%2F10%2F12%2FProject-Euler-045%2F</url>
    <content type="text"><![CDATA[045题：题意： ​ 三角形数、五边形数和六角形数分别由以下公式给出： 三角形数 Tn=n(n+1)/2 1, 3, 6, 10, 15, … 五边形数 Pn=n(3n−1)/2 1, 5, 12, 22, 35, … 六边形数 Hn=n(2n−1) 1, 6, 15, 28, 45, … ​ 可以验证，T285 = P165 = H143 = 40755。 ​ 找出下一个同时是三角形数、五边形数和六角形数的数 思路： ​ 由于六边形增长速度最快，所以我们优先根据公式遍历六边形数。然后我们看一下三角形数，把n = 2k - 1带入公式，得到Tk = k(2k - 1)，所以，每下角标为2n - 1的三角形数都是六边形数，也就是说是六边形数，一定也是三角形数 ​ 因此我们只需要判断六边形数是否为五边形数即可，找到第一个就返回 ​ 有以下三个想法判断是否为五边形数： ​ 1.先预处理出前10000个五边形数(应该不会超过这些)，然后利用mapzcy映射一下这些五边形数，然后从144开始遍历六边形数，只要zcy[六边形数]存在就直接输出，时间复杂度O(m + n)，其中m为预处理的五边形数的个数 ​ 2.外层for循环从144开始遍历六边形数，然后利用二分五边形数下角标查找是否存在对应的五边形数，若存在则返回并输出，时间复杂度O(n * logn) ​ 3.for循环从144开始遍历六边形数，设得到的数设为t，我们求n(3n−1)/2 = t 的正整数解，也就是n = (1 + sqrt(1 + 24t)) / 6，若n为正整数则该数也为五边形数，时间复杂度O(n) 代码： ​ 老规矩上时间复杂度最低的： #include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define f double#define r return#define mem(a) memset(a, 0, sizeof(a));using namespace std;//六边形公式ll g(ll a) &#123; r a * (2 * a - 1); &#125;//判断该六边形数g(a)是否为五边形数bool chooes(ll a) &#123; ll t = g(a); f inx = (sqrt(24 * t + 1) + 1 ) / 6; if (inx == (ll)inx) return true; r false;&#125;d main () &#123; for (ll i = 144; ; i++) &#123; if (chooes(i)) &#123; printf(&quot;%&quot; PRId64&quot;\n&quot;, g(i)); break; &#125; &#125; r 0;&#125; 最后答案为：1533776805 ​ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-044剪枝]]></title>
    <url>%2F2018%2F10%2F11%2FProject-Euler-044%2F</url>
    <content type="text"><![CDATA[044题：题意： ​ 五边形数由公式Pn=n(3n−1)/2生成。前十个五边形数是： ​ 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, … ​ 可以看出P4 + P7 = 22 + 70 = 92 = P8。然而，它们的差70 − 22 = 48并不是五边形数。 ​ 在所有和差均为五边形数的五边形数对Pj和Pk中，找出使D = |Pk − Pj|最小的一对；此时D的值是多少？ 思路： ​ 我们假设a[j] - a[i] = a[t]; a[j] + a[i] = a[k]; ​ 想了很久，只能想到极度剪枝的O(n^2)做法，大概三四秒出的答案。 ​ 我们可以先预处理出前3000个数，然后用map映射一下。然后从小到大遍历a[t]，内层嵌套遍历a[i],只要有一个满足“a[i] + a[t]存在且2 * a[i] + a[t]存在”，就直接返回a[t]。因为以后再出现的就一定大于等于当前a[t]，可以减少时间浪费。 ​ 然后我们进一步剪枝，对于内层for循环遍历a[i]，当i &gt; t时只要a[t] + a[i] &lt; a[i + 1]，那么当i大于当前i值时一定会有a[t] + a[i] &lt; a[i + 1],所以可以直接break跳出 ​ 层层剪枝 + map映射之后，速度还是很慢，有些忧伤。。 代码： #include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define mem(a) memset(a, 0, sizeof(a));#define N 3000using namespace std;map&lt;ll, bool&gt;zcy;ll a[N + 5];//预处理前3000个数，并map一下void init() &#123; zcy.clear(); for (ll i = 1; i &lt;= N; i++) &#123; a[i] = i * (3 * i - 1) / 2; zcy[a[i]] = 1; &#125;&#125;ll work() &#123; for (d i = 1; i &lt; N; i++) &#123; //外层遍历|a[k] − a[j]|，只要出现第一个，那一定就是最小，直接返回 for (d j = 1; j &lt; N; j++) &#123; if (j &gt; i &amp;&amp; a[i] + a[j] &lt; a[j + 1]) break; //当j &gt; i时只要a[i] + a[j] &lt; a[j + 1]，那么a[i]+a[j + 1]一定小于a[j + 2],所以可以直接break跳出 if (zcy[a[i] + a[j]] &amp;&amp; zcy[2 * a[j] + a[i]]) &#123; return a[i]; &#125; &#125; &#125; return 0;&#125;int main () &#123; init(); ll ans = work(); printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);&#125; 最后答案是：5482660 ​ 也就是当a[2167] - a[1020] = a[1912]; a[2167] + a[1020] = a[2395];时 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统与系统编程（四）]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4%2F</url>
    <content type="text"><![CDATA[系统调用的常用方法：一.系统调用方法用来运行不同的程序，格式为： int execve(const char* filename, char* const argv[], char* const envp[]); ​ 该方法以argv为参运行filename指向的可执行程序，并将envp存储的“变量=数值”对作为环境变量代入这个程序。argv的第一个参数必须与filename一致，真正的参数从第二个开始。 注意！！​ 该方法会让filename的程序覆盖进程中正在运行的程序，因此该方法后的代码无法被执行（除非该方法运行失败） 二.在 Linux 系统中，比起系统调用更常使用以exec开头的六个函数： int execl(const char* path, const char* arg, ...);int execlp(const char* file, const char* arg, ...);int execle(const char* path, const char* arg, ..., char* const envp[]);int execv(const char* path, char* const argv[]);int execvp(const char* file, char* const argv[]);int execvpe(const char* file, char* const argv[], char* const envp[]);例如：execl(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, (char *)NULL);execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, (char *)NULL);char* const args[] = &#123;&quot;ls&quot;, &quot;al&quot;, &quot;(char *)NULL&quot;&#125;;execv(&quot;ls&quot;, args);execvp(&quot;ls&quot;, args); ​ 它们都具有系统调用功能，可将这些函数表示为：“exec + l/v + p/e/pe”，这六个函数主要有两处不同： ​ 第一处不同（l/v）——“l”类函数将所有参数作为一整个字符串代入，而“v”类函数将参数分别放入一个字符串数组中，将数组作参代入函数运行 ​ 第二处不同（p/e/pe）——包含 p的函数可以模仿计算机中壳功能，在“file”中不含“/”时使用环境变量 PATH 中的目录来寻找可执行文件，包含 e的函数可以像execve一样将“变量=数值”对作为环境变量代入程序 三.用法 ​ 使用系统调用函数一般先调用fork()产生新进程，然后再新进程中用exec()类函数运行新程序。 ​ 可能大家有疑问，调用fork()会复制了全部父进程地址空间又弃置，会造成浪费。 ​ 其实， Linux 系统采用了 copy_on_write 技术，只有在某一数据被修改时那个数据才会被实际复制到子进程的地址空间。所以在fork()之后直接运行exec()时，父进程的地址空间不会被复制过来。 举个栗子： #include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int count = 0;int main()&#123; int pid = fork(); if (pid==0)&#123; count++; int pid2 = fork(); if (pid2 == 0)&#123; char** argv = (char**) malloc(3*sizeof(char*)); argv[0] = &quot;echo&quot;; argv[1] = &quot;Hello!&quot;; argv[2] = NULL; int pid3 = fork(); count++; if (pid3 == 0)&#123; count++; execvp(&quot;echo&quot;, argv); printf(&quot;Count %d,&quot;,count); exit(0); &#125; else &#123; free(argv); wait(NULL); printf(&quot;%d,&quot;,count); exit(0); &#125; &#125; else &#123; wait(NULL); printf(&quot;%d,&quot;,count); exit(0); &#125; &#125; else &#123; wait(NULL); printf(&quot;%d.&quot;,count); return 0; &#125; &#125; ​ 最后输出为：hello! ​ 2,1,0. 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>多进程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-038思维]]></title>
    <url>%2F2018%2F10%2F11%2FProject-Euler-038%2F</url>
    <content type="text"><![CDATA[题意： 将192分别与1、2、3相乘： 192 × 1 = 192192 × 2 = 384192 × 3 = 576 连接这些乘积，我们得到一个1至9全数字的数192384576。我们称192384576为192和(1,2,3)的连接乘积。 同样地，将9分别与1、2、3、4、5相乘，得到1至9全数字的数918273645，即是9和(1,2,3,4,5)的连接乘积。 对于n &gt; 1，所有某个整数和(1,2, … ,n)的连接乘积所构成的数中，最大的1至9全数字的数是多少？ 思路： ​ 首先，我们需要需要想到的是确定范围。所求是对于n&gt;1来说，所以乘数最大是4位数（因为5位数的话，乘数✖️1得到一个5位数，乘数✖️2 最小是5位数，5+5大于9） ​ 我们继续缩小范围： ​ 当乘数是1位数的话，被乘数最多乘到9才能满足乘积是9位数 ​ 当乘数是2位数的话，被乘数最多乘到4才能满足乘积是9位数 ​ 当乘数是3位数的话，被乘数最多乘到3才能满足乘积是9位数 ​ 当乘数是4位数的话，被乘数最多乘到2才能满足乘积是9位数 ​ 因此我们只需要判断这样的数的乘积链接是否为全数字即可。对于链接，我们可以通过以下算式进行链接乘积： res = res * (int)(pow(10, (int)log10(乘积))) + 乘积; //res即链接后的9位数 代码如下： #include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;algorithm&gt;#define ll int64_t#define d int32_t#define mem(a) memset(a, 0, sizeof(a));#define N 10000using namespace std;d book[10]; //用于标记d maxx = 0; //存储最终结果//用于判断数字t，最长乘到n的链接数是否为全数字，如果是返回该全数字，不是返回0d chooes (d t, d n) &#123; mem(book); d res = 0; d chang = 0; for (d i = 1; i &lt;= n; i++) &#123; d val = t * i; d len = (int)log10(val) + 1; d vall = val; chang += len; while (vall) &#123; if (vall % 10 == 0 || book[vall % 10]) &#123; return 0; &#125; book[vall % 10] = 1; vall /= 10; &#125; res = res * (int)(pow(10, len)) + val; if (chang == 9) return res; &#125; return res;&#125;//用于遍历1，2，3，4位数void work(d len, d n) &#123; d low = (int)pow (10, len - 1); d high = (int)pow (10, len); for (d i = low; i &lt; high; i++) &#123; d val = chooes(i, n); if (val) &#123; maxx = max(maxx, val); &#125; &#125;&#125;int main () &#123; d p[4] = &#123;1, 2, 3, 4&#125;; d q[4] = &#123;9, 4, 3, 2&#125;; for (d i = 0; i &lt; 4; i++) &#123; work(p[i], q[i]); &#125; printf(&quot;%&quot; PRId32&quot;\n&quot;, maxx);&#125; 最后结果为：932718654 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统与系统编程（三）]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[​ （三）进程常用方法：可通过fork()创建进程，fork()函数格式为： #include &lt;unistd.h&gt;pid_t fork(void); ​ fork()函数无参数，直接创建一个新进程，新进程为调用fork()的进程的子进程，返回一个进程标识ID(用于区分父进程与子进程，父进程中返回的标识ID是新创建的子进程ID，而子进程中返回的ID为0) 可通过exit()结束进程，exit()函数格式为： #include &lt;stdlib.h&gt;void exit(int status); ​ 参数status为进程结束时的状态，当调用该函数结束子进程时，status会作为父进程中wait()函数的第一个参 wait()函数格式为: #include &lt;sys/wait.h&gt;pid_t wait(int* stat_loc); ​ stat_loc为等待的子进程结束状态值的指针（由子进程exit(int status)中的参数status提供，成功为0否则对应错误数字) ，当然，我们设为NULL，函数仍可正常运行。 ​ wait()返回值是返回结束的子进程标识 ID； ​ wait()使父进程的状态变为等待态，直到父进程中任意一个子进程成功退出并返回结束状态值，父进程才可进入就绪态； ​ 如果在wait()被调用时已经有可用的结束状态值，那么wait()会立即返回 注意！！​ （1）如果在等待过程中出现错误（如已经没有可等待的子进程），wait()将返回-1 ​ （2）父进程不能直接等待子进程的子进程 wait函数作用： ​ 1使子进程某些指令在执行父进程前完成 ​ 2 使用wait()让父进程等待所有子进程结束后结束，避免僵尸进程的出现 举个栗子： #include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; int pid = fork(); if (pid != 0) &#123; int status; int result = wait (&amp;status); if (result == -1 || status != 0) &#123; printf(&quot;%s\n&quot;, &quot;额，没收到儿子的回信&quot;); return -1; &#125; else &#123; printf(&quot;%s\n&quot;, &quot;我是父亲&quot;); &#125; &#125; else &#123; int second_pid = fork(); if (second_pid != 0) &#123; int new_status; int new_result = wait (&amp;new_status); if (new_result == -1 || new_status != 0) &#123; printf(&quot;%s\n&quot;, &quot;额，没收到孙子的回信&quot;); exit (-1); &#125; else &#123; printf(&quot;%s\n&quot;, &quot;我是儿子&quot;); exit(0); &#125; &#125; else &#123; printf(&quot;%s\n&quot;, &quot;我是孙子&quot;); exit(0); &#125; &#125; return 0;&#125; ​ waitpid()函数格式： #include &lt;sys/wait.h&gt;pid_t waitpid (pid_t pid, int* stat_loc, int options); ​ waitpid()可指定一个标识ID来等待指定进程（当pid &gt; 0时等待标识ID为pid的子进程，当pid == -1时等待任意子进程，当pid == 0时等待进程组标识ID与父进程相同的子进程，当pid &lt; -1时，等待任意进程组标识ID为pid绝对值的进程） ​ options代表特殊选项（目前Linux只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可用”|”运算符连接使用，当options为0时代表没有特殊选项） ​ 关于特殊选项： ​ ——WNOHANG ：若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待，若结束，则返回该子进程的ID ​ ——WUNTRACED 若子进程进入暂停状态则马上返回，此时子进程的结束状态不予理会 ​ 所以，当pid = -1，options = 0时，waitpid()等价于wait() ​ 说了以上四个有关进程的函数，它可以用在哪呢？ ​ 多进程的应用有很多，比如在网络编程中，每当服务器接收到一个请求，主进程就会用fork()产生一个新进程去处理那个请求，而父进程继续等待其它请求。大家可以自己去探索发现～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>多进程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-035线性筛]]></title>
    <url>%2F2018%2F10%2F10%2FProject-Euler-035%2F</url>
    <content type="text"><![CDATA[035题：题意： ​ 197被称为圆周素数，因为将它逐位旋转所得到的数：197，719和971都是素数。 ​ 小于100的圆周素数有十三个：2、3、5、7、11、13、17、31、37、71、73、79和97。 ​ 小于一百万的圆周素数有多少个？ 类似的题还有037题，有空大家可以做一下～ 思路： ​ 如果1～1000000所有数都逐位旋转复杂度太高，所以应该用线性筛筛选出全部的素数。 ​ 对于怎么逐位旋转，我们可以依据以下三点： ​ 1.通过(int)log10(n) + 1来求n的位数 ​ 2.利用 n = n / 10 + (n % 10) * pow(10, (int)log10(n)) 来得到逐位旋转的值 ​ 3.利用线性筛使用的bool数组来判断逐位旋转的值是否位素数 ​ 看到这题网上有些人写了两百多行代码并且时间复杂度还高，觉得利用上述三点就可以缩短代码长度并提高运行效率～ 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;inttypes.h&gt;#define d int32_t#define ll int64_t#define mem(a) memset(a, 0, sizeof(a));#define N 1000000d ans; //存储满足条件的个数d prime[N + 5]; //筛选出100万内的全部素数，其中prime[0]为这些素数的个数bool book[N + 5]; //book[i]代表i是否为素数（0是，1不是）//初始化和预处理100万内的全部素数void init() &#123; mem(prime); mem(book); ans = 0; for (d i = 2; i &lt; N; i++) &#123; if (!book[i]) &#123; prime[++prime[0]] = i; &#125; for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt; N; j++) &#123; book[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;//判断素数t是否满足条件bool chooes (d t) &#123; d len = (int)log10(t); d maxx = (int)pow(10, len); for (d i = 0; i &lt; len; i++) &#123; if (t % 10 == 0) &#123; return 0; &#125; t = t / 10 + (t % 10) * maxx; if (book[t]) return 0; &#125; return 1;&#125;//遍历全部素数void work() &#123; for (d i = 1; i &lt;= prime[0]; i++) &#123; d t = prime[i]; if (chooes (t)) ans++; &#125;&#125;d main() &#123; init(); work(); printf(&quot;%&quot; PRId32&quot;\n&quot;, ans); return 0;&#125; 最后答案是 55 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-032思维]]></title>
    <url>%2F2018%2F10%2F10%2FProject-Euler-32%2F</url>
    <content type="text"><![CDATA[032题：题意： 全数字的乘积 ​ 如果一个n位数包含了1至n的所有数字恰好一次，我们称它为全数字的；例如，五位数15234就是1至5全数字的。 ​ 7254是一个特殊的乘积，因为在等式39 × 186 = 7254中，被乘数、乘数和乘积恰好是1至9全数字的。 ​ 找出所有被乘数、乘数和乘积恰好是1至9全数字的乘法等式，并求出这些等式中乘积的和。 ​ 注意：有些乘积可能从多个乘法等式中得到，但在求和的时候只计算一次 思路： ​ 和之前一样，不讲暴力。我们想要满足被乘数、乘数和乘积恰好是1至9全数字的，必须保证乘数位数+被乘数位数+乘积位数 = 9 ​ 我们知道，乘积位数 = 乘数位数 + 被乘数位数 - 0或1；我们可进一步去重，保证乘数位数 &lt;= 被乘数位数 ​ 因此我们发现要想存在1～9全数字乘法等式，只有两种情况： ​ 1.乘数是1位数，被乘数是4位数，乘积是4位数 ​ 2.乘数是2位数，被乘数是3位数，乘积是4位数 ​ 我们进一步优化，可用dfs+标记找出所有的位值不同的2位数，3位数,4位数,然后用筛选过的2位数乘3位数，看是否满足全数字；再用1位数乘4位数，看是否满足全数字。满足的乘积用map处理一下，第一次出现的累加到结果中 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#include &lt;map&gt;#define mem(a) memset(a, 0, sizeof(a))#define ll int64_t#define d int32_tusing namespace std;d num[5][3500]; //num[i][j]表示预处理i位数每位不相同的数，其中num[i][0]代表i位这样的数的个数d book [15]; //标记数组d ans = 0; //总结果map &lt;d, d&gt;zcy; //用于映射满足条件的乘积void dfs(d n, d inx, d val) &#123; //n代表位数，inx代表当前位, val代表数字的值 if (inx == n) &#123; num[n][++num[n][0]] = val; return; &#125; for (d i = 1; i &lt;= 9; i++) &#123; if (!book[i]) &#123; book[i] = 1; dfs(n, inx + 1, val * 10 + i); book[i] = 0; &#125; &#125; return;&#125;//预处理函数void init() &#123; mem(book); mem(num); zcy.clear(); num[1][0] = 8; //预处理1,2,3,4位数每位不相同的数 for (d i = 2; i &lt;= 9; i++) &#123; num[1][i - 1] = i; &#125; for (d i = 2; i &lt; 5; i ++) &#123; mem(book); dfs (i, 0, 0); &#125;&#125;//用于判断单个数字bool chooes1(d x, d *sum) &#123; while (x) &#123; if (book[x % 10] || (x % 10 == 0)) &#123; return 0; &#125; *sum += 1; book [x % 10] = 1; x /= 10; &#125; return 1;&#125;//用于判断乘法算式是否为全数字void chooes(d x, d y, d z) &#123; mem(book); d sum = 0; bool flag1 = chooes1(x, &amp;sum); bool flag2 = chooes1(y, &amp;sum); bool flag3 = chooes1(z, &amp;sum); if (flag1 &amp;&amp; flag2 &amp;&amp; flag3 &amp;&amp; sum == 9) &#123; if (!zcy[z]) &#123; ans += z; zcy[z] = 1; &#125; &#125; return;&#125;void work() &#123; for (d i = 1; i &lt;= num[1][0]; i++) &#123; //处理1位数*4位数 d x = num[1][i]; for (d j = 1; j &lt;= num[4][0]; j++) &#123; d y = num[4][j]; d z = x * y; chooes(x, y, z); &#125; &#125; for (d i = 1; i &lt;= num[2][0]; i++) &#123; //处理2位数*3位数 d x = num[2][i]; for (d j = 1; j &lt;= num[3][0]; j++) &#123; d y = num[3][j]; d z = x * y; chooes(x, y, z); &#125; &#125; return;&#125;d main() &#123; init(); work(); printf(&quot;%&quot; PRId32&quot;\n&quot;, ans); return 0;&#125; ​ 最后结果是45228 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统与系统编程（二）]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[（二）进程与线程1.关于进程： ​ ——进程在用户方面，包含了程序的运行状态和这个程序所用的抽象内存及存储数据。 ​ ——进程在操作系统方面：包括： ​ (1)一个进程的运行状态(通过在进程中存储”状态寄存器、指令计数器、栈指针、通用寄存器“等代表进程目前运行状态的值实现) ​ (2)从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址及其存储的数据（通过分页存储、分段存储等方法来实现映射） ​ 我们可以将进程笼统看成是一个或多个线程与一个地址空间的结合体 ​ 2.关于进程的地址空间： ​ 一个进程的全部内存地址和存储的数据，称为这个进程的地址空间 3.关于线程： ​ 由于多核计算机程序可并发，因此一个进程可能同时包含多个不同的运行状态。为更好区分进程在一个处理器上的运行状态和进程本身的运行状态，于是引入“线程”这一概念。 ​ 4.​进程控制块和线程控制块： ​ 每个线程拥有一个线程控制块，用来存储“状态寄存器、指令计数器、栈指针、通用寄存器”等数值（也就是在该线程下的进程运行状态），同一进程的所有线程都共享同一个地址空间 ​ 进程控制块中包含实现地址转换信息和进程运行状态的线程信息，以及系统在调度进程时需要的信息（比如进程号、进程所处状态、进程优先级等） ​ 注意！！​ 进程控制块只需存储从抽象内存地址获得实际物理地址的方法，而不会将整个地址空间中地址及其数据都存储 ​ 由于进程控制块中的信息是用户进程无权修改的，因此进程控制块存储在内核空间中 5.三态模型和五态模型 ​ 进程三态模型包括运行态（正在执行），就绪态（准备就绪，排入就绪队列等待执行），等待态（等待某一事件发生后才会变为就绪态） ​ 五态模型还包括新建态（被创建尚未加入就绪队列的状态。内核建一个进程需要给它分配资源等，在这个过程中进程就处于新建态）和终止态（终止态对应进程结束但尚未被系统收回的状态，此时系统仍可以获得该进程结束时的信息） ​ 新建态可避免一个新进程在未获得全部资源前就开始运行，终止态可避免一个进程运行完毕后即被系统收回而导致无法获取其信息（因为无法获取该进程信息而导致某一进程停滞不前，产生“僵尸进程”） 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统与系统编程（一）]]></title>
    <url>%2F2018%2F10%2F10%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[​ 对于操作系统和系统编程，自己学的迷迷糊糊懵懵懂懂，希望能够通过写博客梳理一下脉络，加深一下自己的理解～ （一）操作系统的一些理解与概念1.一般程序猿也不会参与系统编程，那么还有学习操作系统和系统编程的必要吗？ ​ 答案是肯定，因为理解操作系统可以更好地服务于编程，比如更深入的理解多线程等 2.操作系统的理解： ​ 操作系统是应用程序和硬件间的抽象层，方便软件利用硬件资源，也可以避免软件直接与物理资源接触（防止恶意程序） ​ 操作系统的抽象包括很多层面，包括文件和文件系统，基于进程的抽象等 3.操作系统的作用： ​ ——提供公共服务：如读写文件等（无需用户理解实现原理） ​ ——协调进程交互：操作系统负责给每个进程分配处理器时间、内存等。进程间同步和通信、进程切换过程中处理器和高速缓存器状态的变化等都属于操作系统的协调范围 ​ ——管理与控制资源：将有限物理资源合理分配给不同的进程，提高资源利用率 ​ 以上称为操作系统内核，计算机启动时第一个运行的进程就是内核，所有用户进程都基于内核运行，所有资源管控、进程交互协调都由内核完成。也就是说处理器每隔一段时间就中断正在执行的用户进程，切回内核，让它重新分配物理资源，然后决定下一个运行的用户进程。 4.关于进程的理解： ​ 我们知道，程序在处理器上运行是不连续的，因为硬件资源有限，不可能为所有程序提供全部处理器时间，同样计算机有限的内存迫使一个程序的部分内存留在磁盘上，只有部分数据存在系统内存中。所以系统处理程序的过程是非常复杂的 ​ 如果程序猿在编写程序的过程中需要考虑那么多，估计会累死吧。。所以，就有了“进程”这样一个概念。 ​ 我们把占用全部内存和处理器时间的程序（理想状态）抽象为“进程”。“进程”大大方便了多个程序同时在系统中运行（因为程序猿不需考虑在内存中所占大小和位置，也不需考虑上下文切换（从一个进程切换到另一个进程）时的复杂过程，只需考虑自己的程序在理想状态下的运行情况） ​ 而且，每个进程都在抽象的内存空间中进行读写，不直接接触其它进程的内存，从而保护进程不受到其它恶意进程的侵害 5.关于内核与用户进程的理解： ​ 内核和用户进程都是进程！内核就相当于一个指挥官，而用户进程就相当于小兵，指挥官决定小兵的资源分配以及小兵间的协调配合。 ​ 内核与用户进程使用不同的存储空间，防止用户进程获得内核信息（内核所在存储空间称为系统空间 用户进程所用空间称为用户空间） 6.用户进程到内核的方式 ​ ——系统调用 （关于系统调用，会在8中的（1）里有详细描述） ​ ——中断（又称外中断或异步中断）包括时钟中断（即一个进程执行一段时间后，时钟发出中断信号使计算机进入内核态）、设备 I/O 中断。 ​ ——异常（又称内中断或同步中断）可能源于程序的非法操作（如除数为0、超长度读取数组等）、硬件故障等，通过内核中对应的异常处理程序处理 7.关于双模式操作： ​ 我们用两种不同模式来区分用户进程与内核的不同权限，这种区分被称为双模式操作 ​ 两种模式由处理器中一个位来区分，当处理器执行只允许内核态执行的操作时，它会通过位判断是否处于内核态，如果不是，处理器就会触发异常并终止该进程 8.一些疑问和答案： （1）诸如文件读写啦，进程间通信啦，都是内核专属的权利，用户进程是没有权限的，那么平时用的软件是怎么实现该操作的呢？ ​ 操作系统提供了给用户进程的服务(即系统调用)，它可以使用户进程在固定位置进入系统空间并使用系统提供的服务，这样就可以解决文件读写之类的问题啦 ​ 所有系统调用的地址存放在系统调用表里（存储的是系统自带的系统调用的地址！！） ​注意！！！​ 编程中新建一个数组是用户进程使用自己已分配的一段内存，并不需要进入内核态！！！ ​ 而从磁盘中读取文件，写入文件，处理异常等操作都需进入内核态！！ （2）如果同时有多个中断发生时，处理器将怎么处理？ ​ 处理器会先处理优先级高的中断。如果在处理一个中断过程中出现另一个优先级更高的中断信号，那么处理器可能切换处理新的中断信号，这时会出现多重中断。 ​ 为避免中断耗费过多时间，在处理中断信号时会屏蔽某一优先等级的中断信号或某个单独的中断信号 ​ （3）怎么控制用户进程获取系统调用？ ​ 所有中断服务程序的地址按顺序存储在中断向量表中。向量表控制用户进程进入系统的地址，保护内核不被篡改。处理器可以利用中断向量表转入中断服务程序 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-031动态规划]]></title>
    <url>%2F2018%2F10%2F10%2FProject-Euler-031%2F</url>
    <content type="text"><![CDATA[031题：题意： ​ 英国的货币单位包括英镑£和便士p，在流通中的硬币一共有八种： 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), £2 (200p) ​ 以下是组成£2的其中一种可行方式： 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p 不限定使用的硬币数目，组成£2有多少种不同的方式？ 思路： ​ 题目很简单～有一个坑点。 ​ 起初的DP推导式： dp[0] = 1; //dp[i]代表当有i元时的组合方案数for (d i = 1; i &lt;= 200; i++) &#123; for (d j = 0; j &lt; 8; j++) &#123; d t = i - money[j]; if (t &gt;= 0) &#123; dp[i] += dp[t]; &#125; &#125;&#125; ​ 以上代码会造成重复，比如当i为5的时候，dp[4] = 5，它把1+1+1+1，2+1+1，1+2+1，1+1+2，2+2分别当成了一种。 ​ 我们知道，2+1+1，1+2+1，1+1+2它们三个应该算作一种，应当怎样避免这种重复呢？ ​ 我们可以通过创建二维数组dp【i】【j】（代表共有i元钱，其中最大的钱为money[j]的方案数）来解决（确定好最大的钱，以后添加的钱只能大于等于最大的钱，就可以避免重复问题，比如上面i为4时，只会出现1+1+1+1，1+1+2，2+2三种情况）。最后累加dp【200】【0】～dp【200】【7】,即是正确答案 代码： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_td dp[205][10]; //dp[i][j]代表共有i元钱，其中最大的钱为money[j]的方案数d money[8] = &#123;1, 2, 5, 10, 20, 50, 100, 200&#125;; //存储钱的种类d main() &#123; d ans = 0; //存储总方案数 memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (d i = 1; i &lt;= 200; i++) &#123; for (d j = 0; j &lt; 8; j++) &#123; d t = i - money[j]; if (t &gt;= 0) &#123; for (d p = 0; p &lt;= j; p++) &#123; //避免重复计算精髓 dp[i][j] += dp[t][p]; &#125; &#125; &#125; &#125; for (d i = 0; i &lt; 8; i ++) &#123; ans += dp[200][i]; &#125; printf(&quot;%&quot; PRId32&quot;\n&quot;, ans); return 0;&#125; 答案为：73682 Over～ —————————分割线———————— ​ 呃呃呃，上面二维DP数组可以简化为一维，就是完全背包了。。今天脑子不好使了～ ​ 推导式如下： dp[0] = 1; //dp[i]代表当有i元时的组合方案数for (d j = 0; j &lt; 8; j++) &#123; for (d i = 1; i &lt;= 200; i++) &#123; d t = i - money[j]; if (t &gt;= 0) &#123; dp[i] += dp[t]; &#125; &#125;&#125; ​ 没错。。就是将两个for循环的位置调换一下，就可解决重复问题，因为遍历钱的种类数在外层，就使得后面钱种类一定大于等于前面 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-014记忆化搜索]]></title>
    <url>%2F2018%2F10%2F09%2FProject-Euler-014%2F</url>
    <content type="text"><![CDATA[014题：​ 今天做了将近10道Project Euler上的题，要么和之前写的题型类似，要么简单，吐血～ ​ 14题虽然简单些，但是胜在之前没说过，就一并讲一下吧。。。 题意： ​ 在正整数集上定义如下的迭代序列： ​ n → n/2 （若n为偶数）​ n → 3n + 1 （若n为奇数） ​ 从13开始应用上述规则，我们可以生成如下的序列： ​ 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 ​ 可以看出这个序列（从13开始到1结束）共有10项。尽管还没有被证明，但我们普遍认为，从任何数开始最终都能迭代至1（“考拉兹猜想”）。 ​ 从小于一百万的哪个数开始，能够生成最长的序列呢？ ​ 注： 序列开始生成后允许其中的项超过一百万 思路： ​ 如果采用暴力的话，从1到1000000分别枚举，每个数再模拟一下它变成1的过程。时间复杂度估计会大到爆炸吧～ ​ 接下来我就想能不能逆推，推出最长的那个数。但是题上说允许迭代的过程中存在大于1000000的数，那么逆推暂时没有想到终止条件是什么。Orz～ ​ 好吧。。这题我只想到一种思路能在1s内算出来，就是采用记忆化搜索！由于每个数它的用dp[]数组来记录每个数的迭代步数(初始化dp[1] = 0)。 ​ 例如：3的迭代过程是：3-&gt;10-&gt;5-&gt;16-&gt;8-&gt;4-&gt;2-&gt;1 ​ 此时dp[2] = 1;dp[4] = 2; dp[8] = 3; dp[16] = 4; dp[5] = 5; dp[10] = 6;dp[3] = 7; ​ 我们再看4的迭代时，直接可由dp[4] = 2得到步数为2； ​ 以此类推，看5的迭代时，可由dp[5] = 5得到步数为5; ​ 看6的迭代时，6-&gt;3，可由dp[3] + 1得到dp[6] = 7； ​ 这样就省略了很多很多的中间过程，优化了效率，典型的用空间换取时间。 代码如下： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_t#define N 1000000d dp[N + 5]; //记忆化数组d maxx = 0; //记录最大步数d dfs (ll n) &#123; if (n == 1) &#123; return 0; &#125; if (n &lt;= N &amp;&amp; dp[n] != 0) &#123; //该步就相当于剪枝 return dp[n]; &#125; if (n &amp; 1) &#123; d t = 1 + dfs(n * 3 + 1); if (n &lt;= N) &#123; dp[n] = t; &#125; return t; &#125; else &#123; d t = 1 + dfs(n / 2); if (n &lt;= N) &#123; dp[n] = t; &#125; return t; &#125;&#125;d main() &#123; ll ans; memset(dp, 0, sizeof(dp)); for (ll i = 1; i &lt;= N; i++) &#123; d res = dfs(i); if (maxx &lt; res) &#123; maxx = res; ans = i; &#125; &#125; printf(&quot;%&quot; PRId64&quot;\n&quot;, ans); return 0;&#125; 最后答案为：837799 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-005短除法]]></title>
    <url>%2F2018%2F10%2F09%2FProject-Euler-005%2F</url>
    <content type="text"><![CDATA[005题：题意： ​ 2520是最小的能够被1到10整除的数。 ​ 最小的能够被1到20整除的正数是多少？ 思路： ​ 我们能够想到，既然是12的倍数，那么也一定会是1，2，3，4，6的倍数；既然是14的倍数，也一定会是7的倍数；既然是15的倍数，也一定是5的倍数；既然是16的倍数，也一定是8的倍数；既然是18的倍数，也一定是9的倍数；既然是20的倍数，那一定也是10的倍数 ​ 所以，我们只需要考虑11～20的最小公倍数即可 ​ 思路一：​ 利用辗转相除法求11和12的最大公因子，进而通过11*12/gcd(11,12) 来求它们的最小公倍数，然后求最小公倍数和13的最小公倍数并更新最小公倍数，循环上述过程直到20 ​ 思路二：我们知道，两个数的最小公倍数，相比它俩相乘，缩小了它俩的公共因数倍。 ​ 类比到多个数，比如： 2，3， 6， 12，16： 2 = 2； 3 = 3； 6 = 3*2； 12 = 3 * 2* 2；16 = 2 * 2 * 2 * 2； ​ 我们发现： ​ 公因子2在2中存在1次，在6中存在1次，在12中存在2次，在16中存在4次 ​ 公因子3在3中存在1次，在6中存在1次，在12中存在1次 ​ 那么它们的最小公倍数，就是pow（2，4）* pow（3，1）= 48 ​ 也就是说，每个因子找这些数中它出现的最大次数，其它数都是重复的，可以去掉，然后累乘每个因子的最大次数幂即为最小公倍数。 ​ 除了运算速度快之外，还可以避免辗转相除法取余1e9+7导致错误的尴尬（只有累乘不会出错，但是中途取余求gcd会造成错误） ​ 兴冲冲的发现了这个规律后，结果一百度发现已经存在这个定理了，叫短除法。。哎，优队算法就这样没了。。。 代码： ​ 和之前一样，暴力求法不写 #include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_tusing namespace std;d a[10];ll ans = 1; //最终结果ll prime[8] = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125;; //20以内的质数//用于存储11～20void init() &#123; for (d i = 0; i &lt; 10; i ++) &#123; a[i] = 11 + i; &#125;&#125;//快速幂函数ll quick (ll a, d b) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res *= a; b &gt;&gt;= 1; a *= a; &#125; return res;&#125;//短除法void short_division() &#123; for (d i = 0; i &lt; 8; i ++) &#123; d maxx = 0; //对于11～20，能够循环整除prime[i]的最大次数 for (d j = 0; j &lt; 10; j++) &#123; d inx = 0; //记录当前数能循环整除prime[i]的最大次数 while (a[j] % prime[i] == 0) &#123; a[j] /= prime[i]; inx ++; &#125; maxx = max(maxx, inx); &#125; ans *= quick(prime[i], maxx); //结果乘质因子的最大循环整除次数次幂 &#125; printf(&quot;%&quot; PRId64&quot;\n&quot;, ans); //最后结果为11～20，也就是1～20的最小公倍数&#125;int main()&#123; init(); short_division(); return 0;&#125; 最后结果为：232792560 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-030思维]]></title>
    <url>%2F2018%2F10%2F09%2FProject-Euler-030%2F</url>
    <content type="text"><![CDATA[跳题是因为有些题简单没有写的必要，或者难度大需要在后面写，循序渐进～ 030题：该题与Project Euler-034和Project Euler-036类似，有时间的童鞋可以看一下那两道题 题意： 有三个数可以写成它们各位数字的四次幂之和： 1634 = 1^4 + 6^4 + 3^4 + 4^48208 = 8^4 + 2^4 + 0^4 + 8^49474 = 9^4 + 4^4 + 7^4 + 4^4 由于1 = 1^4不是一个和，所以这里并没有把它包括进去。 这些数的和是1634 + 8208 + 9474 = 19316。 找出所有可以写成它们各位数字的五次幂之和的数，并求这些数的和。 思路： ​ 遇到这个题，我们首先需要确定它的上界是什么，不然暴力枚举都不知道终止条件。 ​ 对于每一位来说，9^5最大，因此我们通过每位都是9的数来确定它的上界。我们设上限为n ​ 当n为二位数时，最大累计和为六位数; 当n为三位数时，最大累计和为六位数; 当n为四位数时，最大累计和为六位数; 当n为五位数时，最大累计和为六位数; 当n为六位数时，最大累计和为六位数; 当n为七位数时，最大累计和为六位数。 ​ 从上边就可以看出，当一个数为7位数及更大，它的最大累计和都不足该数的位数，说明n的上限为6位数。 ​ 因此，我有以下两个思路： ​ 思路一：求出6个9^5的和为354294，然后遍历2～354294之间的数，只要满足条件就累加求和，时间复杂度为1e6 ​ 思路二：分别求出0～9的五次方（快速幂），然后遍历位数（从2～6），多少位就相当于取多少个数（利用dfs剪枝），只需判断这些数的五次方和是否为与位数相同且等同与这几个数，相同就累加，时间复杂度大概1e5（就相当于有10种球，每种球无限个，同时取2个，3个，4个，5个，6个的方案数，经计算只有7997种） 代码： ​ 老规矩，暴力代码不写： #include &lt;stdio.h&gt;#include &lt;string.h&gt;int num[10];int ans;int book1[10], book2[10];int sss = 0;//快速幂函数int quick (int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res *= a; a *= a; b &gt;&gt;= 1; &#125; return res;&#125;//预处理0～9的五次方void init () &#123; memset (num, 0, sizeof(num)); for (int i = 0; i &lt; 10; i++) &#123; num[i] = quick (i, 5); &#125;&#125;//dfs剪枝求当为n位数的不同数字组合void dfs(int now, int inx, int n, int val) &#123; if (inx == n) &#123; sss ++; //计算枚举的个数 memset (book2, 0, sizeof(book2)); int vall = val, flag = 0; while (vall) &#123; book2[vall % 10] ++; vall /= 10; &#125; for (int i = 0; i &lt; 10; i ++) &#123; if (book1[i] != book2[i]) &#123; flag = 1; break; &#125; &#125; if (!flag) &#123; ans +=val; &#125; return; &#125; //剪枝精髓 for (int i = now; i &lt; 10; i++) &#123; book1[i] ++; dfs (i, inx + 1, n, val + num[i]); book1[i] --; &#125; return;&#125;int main () &#123; init(); ans = 0; for (int i = 2; i &lt;= 6; i ++) &#123; memset(book1, 0, sizeof(book1)); dfs(0, 0, i, 0); &#125; printf(&quot;%d\n&quot;, ans); //printf(&quot;%d\n&quot;, sss); //真正枚举的个数，只有7997 return 0;&#125; 最后输出答案为: 443839 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-003思维+线性筛]]></title>
    <url>%2F2018%2F10%2F08%2FProject-Euler-003%2F</url>
    <content type="text"><![CDATA[003题：题意： ​ 13195的所有质因数为5、7、13和29。 ​ 600851475143最大的质因数是多少？ 思路： ​ 600851475143大概是6e11，如果纯暴力找它的每个因子，然后再判断每个因子是不是质数，时间复杂度大约是1e22，家用电脑估计一个小时也跑不完吧～ ​ 有些人继续优化，说可以用线性筛求[2,600851475143]范围内的质数，然后找最大满足是600851475143因子的质数。这样时间复杂度是1e11，家里电脑依然跑不完～而且线性筛需要开两个1e11的数组分别用来判断是否为质数和存质数，我们无法开这么大的数组。 ​ 这时候，我们就需要明白一点，600851475143的临界值是多少？嗯，这个数的临界值为（int）(sqrt(600851475143))，为什么呢？ ​ 仔细想一下，如果最大质因子小于等于(int)(sqrt(600851475143))，那么我们只需要线性筛前(int)(sqrt(600851475143))就可以找出它的最大质因子。 ​ 如果最大质因子大于(int)(sqrt(600851475143))，那么600851475143中不可能同时存在两个大于(int)(sqrt(600851475143))的质因子（如果存在，两个质因子相乘就大于600851475143啦），所以我们可以通过除以(int)(sqrt(600851475143))以内所有600851475143的质因子，最后剩下的数，就是大于(int)(sqrt(600851475143))的质因子。 ​ 而(int)(sqrt(600851475143))为775146,用线性筛求775146范围内的质数时间复杂度只有1e6左右，家用电脑一秒钟以内肯定能求出来～ 代码如下： #include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;inttypes.h&gt;#define ll int64_t#define d int32_t#define len 775150ll n = 600851475143;//prime[]用于存素数d prime[len];//choose[i]用于判断i是否为素数,0是，1不是bool choose[len];ll init() &#123; ll maxx = 0; //用来存储最大的质因子 prime[0] = 0; //用来记录质数个数 memset (choose, 0, sizeof(choose)); for (d i = 2; i &lt; len; i ++) &#123; if (!choose[i]) &#123; //如果i是素数就添加到prime中 prime [++prime[0]] = i; //如果i是不断缩小的n的因子，则n循环累除i if(n % i == 0) &#123; while (n % i == 0) &#123; n /= i; &#125; //更新质因子的最大值 maxx = i; &#125; &#125; //线性筛的性质 for (d j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt; len; j++) &#123; choose[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125; //如果此时n不为1，说明最大质因子大于(int)sqrt(600851475143) if (n != 1) &#123; maxx = n; //那么更新最大质因子 &#125; return maxx; //最后返回值即为结果&#125;int main() &#123; ll ans = init(); printf(&quot;%&quot; PRId64&quot;\n&quot;, ans); return 0;&#125; ​ 最后输出答案为6857 ，Over～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-002矩阵快速幂+二分]]></title>
    <url>%2F2018%2F10%2F08%2FProject-Euler-002%2F</url>
    <content type="text"><![CDATA[002题：题意： ​ 斐波那契数列中每一项都是前两项的和。由1和2开始生成的斐波那契数列前10项为： ​ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … ​ 考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和 思路： ​ 本题也想到了两个思路： ​ 思路一：由于斐波那契数列增长速度非常快，所以不超过四百万的斐波那契数顶多有100个，极限了。因此我们可以通过while(Fib[i] &lt;= 4e6) 循环查找出为偶数的项并累加求和 ​ 思路二（有点脱了裤子放屁的感觉～）：我们通过斐波那契数列的性质可知，对于该斐波那契数列： ​ 1 2 3 5 8 13 21 34….. ​ 有以下两个有用的性质： ​ 1. S(n) = Fib[n + 2] - 2 ​ //S(n)代表斐波那契数列前n项和 ，Fib[i]代表下标为i的斐波那契数 ​ 2. 对于前下角标为3的倍数 + 2个斐波那契数，项数为偶数的和等于项数为奇数的和 + 1 ​ ​ 因此我们可以通过二分法套矩阵快速幂来求取4e6以内的最大斐波那契数，并返回该数在斐波那契数中的下角标n，然后用矩阵快速幂求Fib[n + 2]，求的n + 2的下角标为3的倍数 + 2，所以偶数项的和为（Fib[n+2] - 1） / 2; 代码如下： #include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ll long longint N = 2;//用于矩阵相乘void multi(ll *a, ll *b) &#123; ll c[N][N]; memset(c, 0, sizeof(c)); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; for (int k = 0; k &lt; N; k++) &#123; c[i][j] += *(a + i * N + k) * *(b + k * N + j); &#125; &#125; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; *(a + i * N + j) = c[i][j]; &#125; &#125;&#125;//矩阵快速幂void quick(ll *a, ll n) &#123; ll ans[N][N]; memset(ans, 0, sizeof(ans)); for (int i = 0; i &lt; N; i++) &#123; ans[i][i] = 1; &#125; while (n) &#123; if (n &amp; 1) &#123; multi(ans[0], a); &#125; n &gt;&gt;= 1; multi(a, a); &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; *(a + i * N + j) = ans[i][j]; &#125; &#125;&#125;//二分法找4e6以内最大斐波那契数，并返回该下角标int erfen(int l, int r, ll val) &#123; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; ll root[N][N], a[N][N]; memset(root, 0, sizeof(root)); memset(a, 0, sizeof(a)); root[1][0] = 1; a[0][1] = 1; a[1][0] = 1; a[1][1] = 1; quick(a[0], mid); multi(a[0], root[0]); ll res = a[1][0]; if(res &lt;= val) &#123; l = mid + 1; &#125;else &#123; r = mid - 1; &#125; &#125; return r;&#125;int main() &#123; //感觉不会超过100个啦，就二分的下标1到100 int res = erfen(1, 100, 4000000); ll root[N][N], a[N][N], sum; memset(root, 0, sizeof(root)); memset(a, 0, sizeof(a)); root[1][0] = 1; a[0][1] = 1; a[1][0] = 1; a[1][1] = 1; if (res % 3 == 2) &#123; quick(a[0], res + 2); multi(a[0], root[0]); sum = (a[1][0] - 1 )/ 2; &#125;else if(res % 3 == 1) &#123; //由于满足res % 3 == 2 就不再考虑 &#125;else &#123; //由于满足res % 3 == 2 就不再考虑 &#125; printf(&quot;%lld\n&quot;, sum); return 0;&#125; ​ 最后求出结果为：4613732 ​ 第二个想法虽好，但由于最后发现下角标的值才40多！！可能二分+矩阵快速幂比纯暴力还慢。。。就酱紫～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler-001容斥原理]]></title>
    <url>%2F2018%2F10%2F08%2FProject-Euler-001%2F</url>
    <content type="text"><![CDATA[欧拉计划里面都是一些数学题，可以通过编程来解决它，只需要输入最后的结果即可。从简单到难，一点一点做，加油！ 001题：题意： ​ 如果我们列出10以内所有3或5的倍数，我们将得到3、5、6和9，这些数的和是23。 ​ 求1000以内（不包括1000）所有3或5的倍数的和 思路： ​ 有两个：1.用暴力的方法遍历从1～999，只要是3或5的倍数就累加 ​ 2.利用容斥原理，用3的倍数的和 + 5的倍数的和 - 15的倍数的和 代码： #include &lt;stdio.h&gt;int main () &#123; int num3 = 999 / 3; //求出1000以内3的倍数的个数 int num5 = 999 / 5; //求出1000以内5的倍数的个数 int num15 = 999 / 15; //求出1000以内15的倍数的个数 //求出1000以内3的倍数的数的累加和 int ans3 = (1 + num3) * num3 / 2 * 3; //求出1000以内5的倍数的数的累加和 int ans5 = (1 + num5) * num5 / 2 * 5; //求出1000以内15的倍数的数的累加和 int ans15 = (1 + num15) * num15 / 2 * 15; //通过容斥原理求得结果为233168 printf (&quot;%d\n&quot;, ans3 + ans5 - ans15); return 0;&#125; ​ Over～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十七)]]></title>
    <url>%2F2018%2F10%2F07%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%B8%83%2F</url>
    <content type="text"><![CDATA[忽略点十七：指针空间补充与堆内存保存函数中的值​ 关于之前讲解就不再重复，点➡️ 点我 跳转 补充1:​ 除了之前讲的malloc和calloc外，还有一个特别重要的函数——realloc()，具体格式如下： void* realloc (void* ptr, size_t size); ​ realloc可以将已分配的堆内存扩充到size的大小，并返回扩充后的内存起始地址（注意！当第一个参数所指向的内存空间不够扩大到size时，realloc将会重新分配一段足够大的内存空间，将旧内存空间中的内容拷贝到新地址并释放旧内存空间） 补充2:​ 易错点：对于下面代码，会输出什么？ char* test = &quot;test&quot;;test[0] = &apos;j&apos;;printf(&quot;%s\n&quot;, test); ​ 既不是”test”，也不是”jest”，也不是”j”， 由于”test”存在内存的常量区，因此不能修改 补充3:​ 由于函数执行完毕后会释放掉函数所占用的栈内存，所以在函数中定义的东西就会随栈内存的释放而消失。那么，我们怎么样才能保存函数中一些有用的信息呢？ ​ 我暂时就想到以下3种方法，欢迎大佬们补充： ​ ——利用返回值： ​ 我们可以利用返回值把函数中的某一个值传入到main函数中，如果有多个值，我们也可以专门定义一个结构体，把多个值放到结构体中，返回该结构体（如果你们不嫌麻烦的话）例如： struct node &#123; char name[10]; int age; char address[15];&#125;;node fun() &#123; node t; int age = 12; char name[10] = &quot;Ivan&quot;; char address[15] = &quot;Shan Dong&quot;; t.age = age; strcpy(t.name, name); strcat(t.address, address); return t;&#125;int main() &#123; node k = fun(); printf(&quot;%s\n&quot;, k.name);&#125; ​ ——利用静态变量 ​ 我们可以在函数中声明该变量为静态变量，这样变量就不会随着函数的结束而消失，而是直到整个程序结束后才会释放。但是声明静态变量有个局限性，就是该变量的作用域！！在函数内定义的静态变量，它虽然不会随着函数的消失而消失，但它只能作用于函数中！！例如： void fun() &#123; static int a = 0; a ++; printf(&quot;%d\n&quot;, a);&#125;int main() &#123; fun(); //此时a输出1 fun(); //此时a输出2 表明上次fun函数释放后a的值保存了下来&#125; ​ ——创建堆内存存储并返回指向堆内存空间的指针 ​ 感觉这是最好的解决办法了，专门声明一块堆内存空间，然后把函数中想保存的东西存到里面，然后返回指向该内存空间的指针。这样就不会随函数的消失而消失，而且无论什么情况下都可通过指针去调用。例如： int* fun() &#123; int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p = (int *)malloc(5 * sizeof(int)); for (int i = 0; i &lt; 5; i ++) &#123; p[i] = a[i]; &#125; return p;&#125;int main() &#123; int *k = fun(); for (int i = 0; i &lt; 5; i ++) &#123; printf(&quot;%d &quot;, k[i]); //输出为1 2 3 4 5 &#125;&#125; ​ ​ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十六)]]></title>
    <url>%2F2018%2F10%2F07%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E5%85%AD%2F</url>
    <content type="text"><![CDATA[忽略点十六：EOF NULL \0的区别——关于EOF：​ 在C语言中，关于EOF的宏定义： #define EOF -1 ​ 也就是说，EOF其实就是-1，由于ASCII代码值的范围是从0～255，不会存在-1的情况，因此可以用EOF作为文件(必须是文本文件)结束标志或输入结束标志！！例如： while (scanf (&quot;%d&quot;, &amp;a) != EOF) &#123;&#125; ​ EOF结束在windows对应按键是CTRL+Z，在linux对应按键是CTRL+D ——关于NULL：​ 在C语言中，关于NULL的宏定义： #undef NULL#if defined(__cplusplus) //如果存在__cplusplus这个宏定义#define NULL 0 //NULL代表0#else //否则#define NULL ((void *)0) //NULL代表((void *)0)#endif ​ 由于__cplusplus宏定义只存在于C++中，所以在C语言里，NULL代表的是值为0的void型指针，称为空地址； ​ 空地址真的是空吗？我们通过下面代码来输出一下NULL指针的地址： int *p=NULL;printf(&quot;%p\n&quot;,p); //输出结果为0x00000000 ​ 也就是说，NULL是用来代表指针为空的，但NULL也有地址，它并不是真正意义的空！！！它的作用是用来防止出现野指针的。从下面代码中就可以看出： int *p;if(p == NULL) &#123; printf(&quot;Ok\n&quot;); //不会执行，表明野指针并不为空&#125;printf(&quot;%p\n&quot;, p); //输出为一个随机地址 ​ ​ 我们可以使用NULL作为空指针常量使用，例如：int p = NULL;也可以直接使用0作为空指针常量，例如：int p = 0; ​ 所以NULL常常用于指代对象或指针为空。例如用在链表中： node* p = root;while (p -&gt; next != NULL) &#123; //前提条件是最后一个节点的next成员已经赋值为NULL，不然野指针并不为NULL p = p -&gt; next;&#125; ——关于\0:​ ‘\0’是一个ASCII控制字符(转义字符)，它代表空字符，作为字符串结尾字符～ ​ 比如用在某个字符串的遍历中： char s[15] = &quot;hello ACM&quot;;int i = 0;while (s[i] != &apos;\0&apos;) &#123; i ++;&#125; ​ 至于为什么拿出这三个来讲，是因为有时在while()里面对字符串，文本文件，指针之类的操作，!= 后加什么有时候迷糊～ ​ 就酱紫～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十五)]]></title>
    <url>%2F2018%2F10%2F07%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%BA%94%2F</url>
    <content type="text"><![CDATA[忽略点十五：strtok()的使用​ 在ACM中，常常使用字符串函数诸如：strlen求字符串长度，strcpy字符串复制，strcmp字符串比较，strcat字符串追加等等，但忽略了一个特别重要的函数——strtok() char* strtok(char* str, const char* delimiters); ​ 它用于将字符串str用分隔符delimiters分为更短的字符串。delimiters是含多个字符的字符串，其中每个字符都是一个独立的分隔符。如\n\t中\n和\t都是分隔符。 ​ 需要注意！！strtok函数会改变源字符串str，返回值指向第一个由非分隔符字符的指针的分割片段；之后每次调用，都要把NULL作为第一个参数，如果调用成功就会返回下一个分割片段，如果已经到达str的末尾则会返回NULL ​ 具体使用如下： char s[55] = &quot;hello,My name is Ivan,I&apos;m fifteen years|old&quot;;char s1[5] = &quot;, |&quot;;char *p = strtok(s, s1); //利用s1中分隔符将s分隔开printf(&quot;%s\n&quot;, s); //输出helloprintf(&quot;%ld\n&quot;, strlen(s)); //输出5，代表s只剩分隔符分隔后的第一块while (p != NULL) &#123; printf(&quot;%s\n&quot;, p); //循环输出每一块 //分别为hello,My,name,is,Ivan,I&apos;m,fifteen,years,old p = strtok(NULL, s1); //循环的使用方法&#125; 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS High问题及解决方法(转载)]]></title>
    <url>%2F2018%2F10%2F06%2FMacOS-High%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原文地址：https://blog.csdn.net/jackymvc/article/details/78256120 OSX的High Sierra正式版出来半个月有余，听着什么自媒体、科技媒体吹这系统多么牛B，手贱点了升级，好在升级过程中没有遇到各种坑还挺顺利的，但是我没有感觉多么好用的同时，却给我带来不大不小的麻烦。且听我一一道来…… 10.13版本加强了权限的限制，尤其是对/usr/local目录，默认开通 SIP （System Intergrity Protection），它禁止了软件以root身份在Mac上运行，不管你是在终端中如何运行 MyMBP:~ Jacky$ sudo chown -R $(whoami) /usr/local ，返回给你的就是 chown: Operation not permitted，哪怕你是用root的身份。 有些软件在运行过程中需要对/usr/local下的文件读写，比如你更新ruby，起因是我要通过homebrew来安装zookeeper brew install zookeeper 运行后下载了zookeeper，但是安装过程中，报了一个ruby的错误（原谅我没有截图），大意是ruby 2.3.0已经不被High Sierra支持了，看样子是要更新ruby 顺序做了一些操作，都没有起什么作用 rvm -v发现是1.19.3版本最新的已经到1.29.3了 ruby -v版本是2.3.0，最新已经到2.4.2了 rvm install 2.4.2也是由于权限问题安装不了 看来只有关掉SIP了 1.重启Mac，按住Command + R键直到Apple Logo出现，进入Recovery Mode模式（我感觉我是按了好半天） 2.点击工具里的Terminal（终端） 3.输入csrutil disable，之后回车 4.重启Mac 5.重启完成后，终端中输入sudo chflags norestricted /usr/local &amp;&amp; sudo chown -R $(whoami):admin /usr/local 成功执行，没有报操作不允许了 （如果想重新开启安全设置，则重复1、2步骤，输入csrutil enable就可以了） 更新rvm工具：curl -L get.rvm.io | bash -s stable rvm install 2.4.2（这次可以正确安装ruby了，别问我为什么是2.4.2版本） 然后就是安装zookeeper brew install zookeeper（这次也正确安装了） 后来又重启过一次，发现我的mysql不能开机启动了 在系统偏好设置最下方找到MySQL的图标，打开后发现mysql已经停止，且有一行警告：the /usr/local/mysql/data directory is not owned by the ‘mysql’ or ‘_mysql’ user 这个好办：sudo chown -R mysql /usr/local/mysql/data 然后就可以启动mysql了 自从长乔帮主走后，苹果办事越来越不上心了，哪怕是自己的OSX系统，伤心……估计还会有不少童鞋遇到我类似的情况，不妨一试]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十四)]]></title>
    <url>%2F2018%2F10%2F06%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-14%2F</url>
    <content type="text"><![CDATA[忽略点十四：gdb的使用​ 在Linux系统下如果想要调试一个项目，我们应该怎么做？ ​ 有些童鞋可能会说：IDE呀！ ​ 没毛病老哥～非常标准的答案。除此之外，我们还可以使用gdb，为什么使用gdb，它有什么优势呢？它可以在终端下使用，它短小精悍，功能强大～ ​ 嗯嗯嗯，我就是这样说服自己的～ ​ 要注意！！使用gdb前，我们在编译项目文件时需加-g作为一个编译参数(否则你将看不见函数名、变量名，而只能看到运行时的内存地址)，再通过gdb运行可执行文件，例： gcc -o program -g main.cgdb ./program ​ 执行完上述命令，会看到关于 gdb 的说明和如下所示的调试命令行： (gdb) ​ ​ 关于gdb的基本使用： ​ ——输入l（list 首字母)gdb 会列出10行代码，l后可加参数代表从第参数行开始列出（例如希望列出第 2 到11行时，我们可以写l 2） ​ ——输入b（breakpoint首字母），表示设置程序运行的断点，程序运行到断点处就会暂停运行。b后既可以加函数名作参数，使程序在调用某函数时暂停；也可以加行号作为参数，使程序在运行至某一行时暂停。 ​ ——输入d（Delete breakpoint简写），对应b命令，用于删除断点 ​ ——输入i b ：(info breakpoints简写), 用于查看断点信息 ​ ——输入r（run 首字母），程序会开始运行，并在第一个断点处暂停 ​ ——输入q (quit首字母)，退出GDB调试环境 ​ ——输入help [cmd] , 如果制定了cmd命令，则显示该命令说明 否则显示全部 ​ ——直接回车：重复上一步命令 ​ ——输入p 表达式（print 的首字母） 表示在当前断点处运行该表达式并查看它的值。例如p ++age[0]表示我们希望让age[0]自增并查看自增后的值（表达式会对之后程序运行造成影响） ​ ——输入finish ：结束函数 ——输入s (step首字母) 程序会执行下一行代码，如果此行代码中有函数调用，则进入该函数 ​ ——输入n（next 的首字母）程序会执行下一行代码，如果此行代码中有函数调用一并执行 ​ ——输入c（continue 的首字母）程序会继续执行到下一个断点处并暂停（如果没有断点就会执行直到结束） ​ 以上就是gdb的简单用法，具体用法请参考官方文档～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十三)]]></title>
    <url>%2F2018%2F10%2F06%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-13%2F</url>
    <content type="text"><![CDATA[忽略点十三：文件操作​ 我们要想对文件进行读取或写入，需要有一个能够访问到该文件的文件指针（FILE类型）,这样我们就能通过文件指针对文件进行操作啦！ FILE *fp; //声明文件指针fp = fopen(文件路径, 访问模式); //指向文件，第一个参数为字符串 ​ 关于访问模式： ——只读：“r” ​ ——只写（覆盖）： “w” ​ —— 文件末尾追加： “a” ​ ——可读可写： “r+”或“w+” ​ ——二进制文件：“b” ​ ——文本文件：“t” ​ //访问模式可以叠加，例如”rb”代表读取二进制文件 ​ 之后我们就可以对文件进行操作啦（如fgetc()函数（读取）和fputc()函数（写入）） ​ ——关于读取：文件指针指向文件后，通过fgetc(fp);获得当前指针之后位置的一个字符，每获得一个字符指针就会自动向后移动一个字符（如果到达文件尾部则会返回EOF） ​ ——关于写入：通过fputc(‘字符’, fp);方式将字符写入到与fp关联的文件中 ​ 文件指针不再使用后需断开关联，格式为： fclose(fp); //若不加此句，程序正常结束后系统会自动为打开的文件调用fclose ​ 举个栗子： //省略代码FILE *p1 = fopen(&quot;路径1&quot;, &quot;r&quot;);FILE *p2 = fopen(&quot;路径2&quot;, &quot;w&quot;);char c;while ((c = fgetc(p1)) != EOF) &#123; //把一个文件内容复制到另一个文件 fputc(c, p2);&#125;fclose(p1);fclose(p2); 注意！！！！​ 在给文件指针命名时，不能使用 stdin、stdout 和 stderr 这三个名字，因为这三个名字是系统内置用于标准输入、标准输出、标准错误的文件指针名 ​ 我们可通过 fgetc(stdin); 获得来自标准输入的字符 ​ 通过 fputc(ch, stdout); 将 ch 字符输出到标准输出 ​ 通过 fputc(ch, stderr); 将 ch 字符输出到标准错误 ​ ​ 除fgetc和fputc外，我们还可以使用fscanf和fprintf函数 ​ 我们可以使用fscanf通过文件指针读取： ​ 也可以使用fprintf通过文件指针写出 fscanf(p1, &quot;%c&quot;, &amp;a); //通过文件指针p1获取字符并存储到a中fprintf(p2, &quot;%c&quot;, a); //通过文件指针p2将字符a写入文件中 ​ 这两个函数是不是感觉有点眼熟？对！大家熟悉的scanf和printf 和它们长得很像，那它们之间有关系吗？ ​ 答案是有的。scanf可以看作是 fscanf的特例 ​ printf可以看作是fprintf 的特例 ​ 至于为什么，看下面的代码: fscanf(stdin, &quot;%c&quot;, &amp;a); //等价于下一行scanf(&quot;%c&quot;, &amp;a); fprintf(stdout, &quot;%c&quot;, a); //等价于下一行printf(&quot;%c&quot;, a); ​ 嗯嗯，上面也说啦，stdin和stdout的实质也是文件指针，分别代表从控制台获取，输出到控制台。 ​ 当然啦，stdin和stdout也可以通过fclose关掉，大家可以试一下关掉后还能进行scanf和printf嘛～ 赶紧跑路hahaha 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！ ​]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十二)]]></title>
    <url>%2F2018%2F10%2F06%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-12%2F</url>
    <content type="text"><![CDATA[忽略点十二：main函数参数​ 大家都知道，main函数的完整格式如下： int main(int argc, char *argv[]) &#123; // ... return 0;&#125; ​ 这两个参数有什么用呢？ ​ main函数第一个参数是整数型，代表命令行参数的个数（系统依据用户输入的参数个数自动生成，非手动输入），第二个参是char *argv[]，也就是char型指针数组，用于储存用户从命令行中传进来的参 ​ 例如：在命令行中输入./main hello world ​ 此时，argc为 3，argv[0]为./main，argv[1]为hello，argv[2]为world ​ 命令行参数默认是由空格分隔，但如果某个参数中含空格我们应该怎么办 这时我们在输入含空格的参数时要用引号将整个参数包裹起来，例如： ​ 执行./main “hello world” is my greet ​ 此时，argc为 5，argv[0]为./main，argv[1]为hello world，argv[2]为is，argv[3]为my，argv[4]为greet 易错点！！！！int main(int arc, char **argv)中argc取的不是main函数的参数个数！！！​ main函数个数固定是2！！argc取的是命令行中键入的参数个数！！而不是main函数的参数个数 ​ 关于参数的使用： int main(int argc, char **argv) &#123; //**argv等价于*argv[] for (int i = 0; i &lt; argc; i ++) &#123; printf(&quot;%s\n&quot;, argv[i]); &#125;&#125; ​ main函数的参数也挺有用的，比如你可以设置进入一个软件的两种模式 ​ 比如当strcmp(argv[1], “master”) == 0时，进入该软件的管理员模式，其余情况或者无参时进入用户模式等等。 ​ 除了上述，main函数参还有很多黑科技！！！等待大家去发现，哈哈哈～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十一)]]></title>
    <url>%2F2018%2F10%2F06%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-11%2F</url>
    <content type="text"><![CDATA[忽略点十一：make命令与Makefile文件​ 在讲make与Makefile之前，我们需要明白为什么它们的作用和优点是什么？ ​ 对于C/C++项目，在编译时我们需要把每个模块的代码都生成为目标文件，然后再将目标文件联编生成一个可执行文件。 ​ 编译要输入这么多命令，每次修改一点内容就要重新编译整个工程，是不是特别恶心！！！ ​ 这时候，上帝就出现了——make命令，它可以读取当前路径下的Makefile文件，并根据Makefile中的规则描述把源文件生成为可执行的程序文件 注意，Makefile文件无后缀名！！​ Makefile文件中包含了一系列形式如下的规则： 目标: 依赖1 依赖2 ... 命令 ​ 例如： a.o: a.c a.h #表示生成a.o文件需要依赖a.c与a.h gcc -c -o a.o a.c #生成a.o的命令 注意！！！每条规则的命令前，必须有一个制表符’\t‘​ 这样我们想编译生成a.o文件，只需要执行make a.o即可。（为了提高效率，该命令只有a.o不存在或者a.c与a.h中至少有一项变化时才会真正执行） ​ ​ 对于Makefile文件中存在多条规则： main: a.o m.o gcc -o main a.o m.om.o: m.c a.h gcc -c -o m.o m.ca.o: a.c a.h gcc -c -o a.o a.c ​ 我们想生成哪一个，就可以在make命令后加上需要生成的目标名称。 ​ 例如：make a.o 注意!！在我们执行make main时，make命令发现a.o和m.o不存在，就会自动生成它们（没有a.o和m.o的规则也能生成）​ 为什么没有a.o和m.o规则也能生成呢？因为makefile文件默认生成.o文件格式为：\$(CC) \$(CFLAGS) -c -o 名.o 名.c ​ 而CC默认值为cc，CFLAGS默认值为空（可通过修改CC和CFLAGS来修改对应的编译环境与参数（如-std -Wall等等）） 执行makefile文件中的第一条规则可以在命令行中简写成make！！！​ 例如上边代码中执行make相当于执行make main ​ 可以利用makefile规则添加删除功能： clean: rm -f a.o m.o main //rm命令表示删除，-f表示强制 ​ 以上规则有一个Bug——就是当已经存在clean文件，rm命令就不执行了（而且执行一次make clean 就会产生clean文件，该命令最多只能执行一次） ​ 这时我们可以通过 .PHONY 来声明clean为伪目标来解决上述问题（系统不会检查伪目标是否存在，且不会通过规则生成该目标文件）上代码： .PHONY: cleanclean: rm -f array.o main.o main 抛出一个较为完整的Makefile 栗子： # 井号开头的行是一个注释# 设置 C 语言的编译器CC = gcc# -g 增加调试信息# -Wall 打开大部分警告信息CFLAGS = -g -Wall# 整理一下 main 依赖哪些目标文件MAINOBJS = main.o array.o.PHONY: cleanmain: $(MAINOBJS) $(CC) $(CFLAGS) -o main $(MAINOBJS) #定义的变量可通过$(变量名)使用array.o: array.c array.h $(CC) $(CFLAGS) -c -o array.o array.cmain.o: main.c array.h $(CC) $(CFLAGS) -c -o main.o main.cclean: rm -f $(MAINOBJS) main 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-10-05博客搭建进度]]></title>
    <url>%2F2018%2F10%2F05%2F18-10-05%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[​ 特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接(10.03更新) ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新) ​ ——提供博文百度搜索功能(需审核 10.03更新) ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名(10.03更新) ​ ——代码托管从github转到coding，优化网速(10.03更新) ​ ——修正主页博文标签跳转错误(10.03更新) ​ ——新增弹出式音乐播放器 ​ ——新增主页博文出场特效]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让hexo博文被百度收录]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%A6%82%E4%BD%95%E8%AE%A9hexo%E5%8D%9A%E6%96%87%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[​ 建了博客，大家可能会发现，必须得进了博客主页后才能查看博文，没有办法通过百度搜索博文的方式，进入主页中对应的博文。 ​ 这样会导致很少人发现你的博文（除了真爱哈哈哈），这怎么能行呢！！！所以，我们需要让百度收录自己的博客，具体步骤如下： ——Step1:让百度收录你的域名​ 很简单，就是百度搜索自己的域名，如果搜索不到，会出现“很抱歉！没有找到xxxx相关的网页”，这时候底下会出现 “提交网址”给我们 的超链接，我们点进去 ——Step2:验证网站的所有权​ 登录百度站长平台 , 在站点管理中点击添加网站，然后输入你的域名地址（加前缀www） ​ 在选择完网站的类型后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证,html标签验证和cname解析验证，使用哪一种方式都可以。具体流程在官方会有提示，就不再重复了 ——Step3:生成网站地图​ 我们先安装sitemap插件 npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save12 ​ 再修改博客路径下的配置文件（非主题）中的url站点地址 # URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: #在这儿填写你的博客域名root: /permalink: :title.htmlpermalink_defaults: ​ 执行完之后就会在博客路径下生成sitemap.xml文件和baidusitemap.xml文件，可以通过http://此处填你的域名/baidusitemap.xml,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件 ——Step4:向百度提交链接​ 找到百度站长平台-&gt;网站支持-&gt;数据引入-&gt;链接提交，我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap ​ 大家可以任选一种方式进行提交，具体流程官方会有提示和帮助，就不一一列举了。 ​ 然后，我们的博客就被百度收录啦，可以通过文章名百度一下就能找到对应的文章。（当然啦，这个需要一定的时间收录，以百度的速度，大概需要个半月吧 Orz～） 转载请注明出处！！！ ​ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(十)]]></title>
    <url>%2F2018%2F10%2F04%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-10%2F</url>
    <content type="text"><![CDATA[忽略点十：#ifndef与#endif​ 印象中两者在C/C++项目创建头文件时自动添加，一直没有深究它的意义，决定跟大家讲一下它的用法，顺便也是对自己的查缺补漏 ​ 要将他们，首先要说一下项目，对于C语言项目来说，多文件中的每个文件的特殊全局变量，类型定义，函数可能需要在多个文件中被使用，这时可将这些全局变量，类型定义，函数声明单独写成一个头文件 ​ 这些头文件一般采用 源文件名.h 命名，在需要用到该头文件的文件中采用#include “源文件名.h” 引用（注意不是尖括号&lt;&gt;，而是””）,不仅源文件可以引用头文件，头文件也可以引用头文件。 ​ 这时候，会出现一种情况：源文件1.c中引用2.h和3.h头文件，而2.h头文件中也引用了3.h头文件。 这时3.h头文件被引用了两次，有可能会造成函数，变量的重复声明！！！ ​ 为了避免这一种情况的出现，我们可以在3.h中定义一个宏： #define 宏名 ​ 只要这个宏定义过，就跳过整个3.h的整个内容 ​ 如何实现这一点呢？ ​ 对，就是利用#ifndef 宏名和#endif，格式如下： #ifndef 宏名 //判断是否声明过该宏名，如果声明过，直接跳到#endif#define 宏名 //如果没有声明过，声明该宏名//.h文件内容#endif ​ 这样又会造成一个问题，若2.h的验证宏名为p（即#ifndef后声明的宏名），3.h的验证宏名也为p，那么先引用2.h，后引用3.h，会造成3.h引用不上。也就是说，必须得保证每个头文件的#ifndef后的宏名都不一样！！！ ​ 因此，此类宏名有一个固定格式，即：工程名 _ 路径名_ 文件名_ H_ ​ 这样就能避免重名的风险 ​ 以上就是#ifndef和#endif的全部，Over！ 转载请注明出处！！！ ​ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(九)]]></title>
    <url>%2F2018%2F10%2F04%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-9%2F</url>
    <content type="text"><![CDATA[忽略点九：共用体与枚举类型​ 共用体？What？它是什么，上了两年大学的我有点懵逼。共用体已然成了我C语言的盲区。 ​ 存在必然有它的意义，所以恶补了一下有关共用体的知识。 ​ 在我的理解里，共用体和上一篇博文所介绍的结构体，都是用来存储不同数据类型的“容器”。 ​ 那么他们两个的区别呢？从上上篇查缺补漏系列博文中 跳转至查缺补漏（七），我们知道结构体不同类型类型成员按照内存对齐规则，“排队”占用内存，而共用体，则是所有类型成员共用同一块内存（也就是说他们的起始位置都是从0开始）。 ​ 既然所占用内存都是从0开始，那么共用体有两个特征： ——成员不会同时出现使用后面出现的成员会覆盖掉之前成员的内容(也会相互影响)，因为两者的内存地址都是从0开始的，例如： union A &#123; int a; int b;&#125;;//省略代码A p1;p1.a = 1; p1.b = 2;printf(&quot;%d %d\n&quot;, p1.a, p1.b); //结果p1.a，p1.b输出都为2p1.a++;printf(&quot;%d %d\n&quot;, p1.a, p2.b); //结果p1.a, p1.b都输出为3 ——收尾： 共用体所占内存的总大小，必须是它内部最大成员所占内存大小的整数倍(像数组，结构体等成员在计算时按其成员的最大成员所占内存算)，不是要补齐 给大家上份代码理解一手： union A &#123; int a; //所占内存地址为0~3 int b; //所占内存地址为0～3 char s[10]; //所占内存为0～9&#125;; //共用体A总共所占内存地址为0～11union B &#123; double t; //所占内存地址为0～7 A a; //所占内存地址为0～11 int b[3]; //所占内存内存地址0～11&#125;; //共用体B总共所占内存地址为0～15 在共用体A中： ​ int类型a为4字节，所以占用0～3位置 ​ int类型a为4字节，所以占用0～3位置 ​ char型数组s中最大成员单个char为1字节，而数组长度为10，所以占用0～9位置 ​ 在共用体A中，最大成员为int型的4字节，所用占用内存大小为4的倍数，由于最大占用空间为10，所以共用体至少占用内存位置为0～11 在共用体B中： ​ double类型t为8字节，所以占用0～7位置 ​ A类型a中最大成员为int类型为4字节，A类型总的内存占用为12字节，所以占用0～11位置 ​ int型数组b中最大成员单个int为4字节，而数组长度为3，所以占用0～11位置 ​ 在共用体B中，最大成员为double型的8字节，所用占用内存大小为8的倍数，由于最大占用空间为12，所以共用体至少占用内存位置为0～15 ​ 由于共用体特别节省内存，所以大家不能学我，它在C语言中是不容忽略的！！！（比如用于存储IPV4，IPV6地址，可用共用体来存储） ​ 枚举类型大学期间使用次数仅仅比共用体好上那么一丢丢，举个枚举类型的栗子： enum week &#123; Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday //注意，最后没有分号！！！！！&#125;;//省略代码week now = Sunday; 关于枚举类型只要记住两点就可以： ——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）​ 例如上边代码，默认Sunday的值为0，Monday的值为1，一直到Saturday的值为6 ——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此+1​ 例如以下代码中： enum week &#123; Sunday = 1, Monday, Tuesday, Wednesday = 0, Thursday, Friday, Saturday //注意，最后没有分号！！！！！&#125;; ​ 上边代码中，Sunday为1，Monday为2，Tuesday为3，Wednesday为0，Thursday为1，Friday为2， Saturday为3 ​ 好啦，共用体和枚举类型查缺补漏完毕！ 转载请注明出处！！！ ​ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-10-03博客搭建进度]]></title>
    <url>%2F2018%2F10%2F03%2F18-10-03%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新) ​ ——新增返回顶部的小火箭 (09.29更新） ​ ——优化布局(09.29更新) ​ ——新增巨巨们的友情链接(09.29更新) ​ ——主页新增邮箱与QQ跳转链接 ​ ——引入“畅言”评论平台(位于留言界面，需等待3秒加载) ​ ——提供博文百度搜索功能（需审核） ​ ——关联www.ivan-zcy.com 与 www.ivan-zcy.top 域名 ​ ——代码托管从github转到coding，优化网速 ​ ——修正主页博文标签跳转错误]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(八)]]></title>
    <url>%2F2018%2F10%2F03%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-8%2F</url>
    <content type="text"><![CDATA[忽略点八：typedef的使用至于typedef，说起来实在是太丢人了！！这两年一直以为这个关键字是结构体的专属关键字： typedef 结构体类型 &#123; //省略代码&#125; 类型别名类型别名 变量名 //定义 ​ 最近才发现，它不仅可以给结构体起别名，还可以给各种各样的类型起各种各样的别名，用法实在是太活了！ ​ ——比如基本数据类型： typedef int size;size a; //等价于int a; ​ ——比如数组： typedef int T[105];T a; //等价于 int a[105]; ​ ​ ——比如指针： typedef char* ps;ps p1, p2; //等价于 char *p1, *p2; ​ 说到这儿，有一个代码大家需要注意： char* p1, p2; ​ 这里面的p1和p2分别是什么类型？ ​ 可能和大家想的不太一样（反正到时我是掉坑里了，尴尬），p1是char型指针，p2是char型。 ​ ——用来定义与平台无关的东西： ​ 比如定义一个叫Max_Double的浮点类型: typedef long double Max_Double; //在一般平台的定义typedef double Max_Double; //在不支持long double平台的定义typedef float Max_Double; //在不支持double平台的定义 ​ 这样在跨平台时，只需要改一下Max_Double定义即可，比如之前博文写的通用long long写法 点这儿走你 添加的&lt;inttype.h&gt;头文件就是采用了该方法。 ​ 要记住！！！typedef是定义了一种类型的新别名，不是简单的字符串替换！！比如: typedef int* T;int mystrcmp(const T); ​ const T等同于什么？我当初不假思索地以为是const int 。然后现实给了我狠狠的打嘴巴子，它实际上相当于int const。原因在于const给予了整个指针本身以常量性，也就是形成了常量指针int* const (简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。) ​ 说到const int 和 int const等几个的区别： ​ ——const int *a; 表示a是一个指针，可以任意指向int型常量或变量 ​ ——int const a： 同const int a ​ ——int * const a; 表示a是一个指针常量，初始化时必须固定指向一个int变量，之后就不能再指向别的地方了 ​ ​ 除此之外，typedef不能影响对象的存储特性！！！例如以下代码会出错： typedef static int T; //无法与之前的&apos;typedef&apos;声明说明符结合使用 ​ 最后再总结一句：typedef作用是为类型起别名，但不同于#define的简单替换！而且不同于#define替换时不作正确性检查，typedef是在编译时处理的。 转载请注明出处！！！ ​ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(七)]]></title>
    <url>%2F2018%2F10%2F03%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-7%2F</url>
    <content type="text"><![CDATA[忽略点七:结构体内存对齐原则​ 直到前几个星期做了一道选择题才知道，结构体元素的声明顺序可能影响结构体使用时所需的内存大小！！！ ​ 一查才知道，在C语言中结构体有内存对齐原则，这个原则可以总结为两点： ——数据成员对齐规则：​ 结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个成员存储的起始位置为该成员大小（当该成员为基本类型时）或者该成员的最大子成员大小(当该成员为数组，结构体等时)的整数倍位置 ——收尾：​ 结构体所占内存的总大小，必须是它内部最大成员所占内存大小的整数倍(像数组，结构体等成员在计算时按其成员的最大成员所占内存算)，不是要补齐 ​ ​ 对于以上的文字，大家可能会不理解，给大家上份代码理解一手： struct bb &#123; int id; //所占内存位置为0～3 double weight; //所占内存位置为8～15 char s[10]; //所占位置为16~25&#125;; //整个结构体bb所占内存位置为 0~31 struct aa &#123; char name[2]; //所占内存位置为0～1 bb b; //所占内存位置为8~39; int age; //所占内存位置为40~43;&#125;; //整个结构体aa所占内存位置0~47 在结构体bb中： ​ int类型id为4字节，所以占用0～3位置 ​ double类型weight为8字节，它的起始位置必须是8的整数倍，所以它的起始位置为8，占用位置为8～15 ​ char型数组s中最大成员单个char是1字节，所以char数组的起始位置必须是1的整数倍，所以它的起始位置为16，而数组长度为10，总占用字节为10，所以占用位置为16～25 ​ 在结构体bb中，最大成员为double型的weight（有同学会说char s[10]最大，为什么不是char s[10]？因为char s的最大成员所占内存为1，s按照1进行比较），所以结构体bb总占用内存必须为8的整数倍，所以结构体bb的总内存地址为0～31 在结构体aa中： ​ char型数组name数组长度为2，单个char占1字节，数组总共占两字节，所以占用位置为0～1 ​ bb型结构体b中最大成员为double型的weight，所以bb类型的起始位置必须是8的整数倍，也就是8，而结构体bb总占用内存是32，所以占用b位置为8～39 ​ int型age为4字节，所以起始位置必须是4的整数倍，也就是40,所以它占用的位置是40～43 ​ 在结构体aa中，最大成员是结构体b（它的最大成员weight占用内存为8），所以结构体aa总占用内存必须是8的整数倍，所以结构体aa的总内存地址为0～47 ​ 而这样： ​ 讲到这儿，我们会有一个疑问，C语言为什么要有对齐原则呢？多浪费空间呀！大家可能知道桶排这种算法，以空间换时间。对齐原则也不例外，以耗费空间为代价，来加快寻址速度。 ​ 至于原理：如果一个结构的最大成员字长为w，那么系统会假设在这种体系结构上字长为w的数据使用最频繁，优先提高对w位数据操作。所有的数据访问都以w位对齐，这样需要传输的地址位减少，寻址自然就可以加快。 ​ 那么我们可以自己设定对齐规则吗？在规定的范围内是可以的，例如： ​ 在文件开头加 #pragma pack(1) //不对齐 ​ #pragma pack(2) //支持1,2对齐 ​ #pragma pack(4) //支持1,2,4对齐 ​ #pragma pack(8) //支持1,2,4,8对齐（默认） ​ 也就是说pack是多少，结构体中的成员它的初始位置最多是多少的倍数 ​ ​ 嗯嗯，就酱紫~ ​ 转载请注明出处！！！ ​ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！ ​]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(六)]]></title>
    <url>%2F2018%2F10%2F02%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-6%2F</url>
    <content type="text"><![CDATA[忽略点六:内存空间，指针的指针​ 介绍内存前，我们首先要知道一个由C/C++编译的程序占用的内存分为哪几个部分： ​ ——栈内存：C语言程序在编译时会被分配到内存的一片有限的连续区域，这部分内存会用于存储局部变量（函数中声明的变量），这部分连续区域被成为栈内存，由编译器自动分配和释放 ​ ——堆内存：一般由程序员分配和释放，若程序员没有释放，则可能在程序结束时由操作系统回收（并不一定）。注意它与数据结构中的堆是两种东西！！ ​ ——全局区(静态区，static)：程序的全局变量和静态变量都存放在这里， 初始化存放在一块区域，未初始化的放在相邻的另一块区域（BSS），程序结束后由系统释放。注意！它既不是栈内存，也不是堆内存！ ​ ——文字常量区：也叫字面量池区。常量字符串就是放在这里，又系统释放。 ​ ——程序代码区：存放函数体的区域 ​ 以下代码大家理解一手： int a = 1; //全局初始化区int b; //全局未初始化区int main() &#123; char s[] = &quot;abc&quot;; //栈区 char *p = &quot;abc&quot;; //“abc”在文字常量区（“abc”不是变量，也不是指针变量），p在栈区 static c = 0; //全局初始化区 char *q = (char *) malloc (sizeof(char)); //q为栈区，申请的内容为堆区&#125; ​ 关于栈内存与堆内存： ​ ——栈内存：内存大小由系统预先设定，且是一块连续的内存空间，如果超出范围就是造成栈溢出，由于是系统分配的，所以速度较快，但程序猿无法控制。 ​ ——堆内存：内存大小由程序猿手动申请，不一定连续，无内存范围限制（当然啦，肯定不能超过系统的有效内存），由于是程序猿分配的，一般速度较慢，但是用起来方便。（当然，如果使用不当的话，会造成严重的内存泄漏！！！而栈内存由于编译器自动回收内存，所以不会出现泄漏问题） ​ 我们由上边知道了堆内存是需要程序猿申请和释放的。那么通过什么方法申请呢？用什么头文件呢？ ​ ——关于头文件，sodlib.h头文件与malloc.h都有封装的相关申请与释放堆内存的函数，所以两个选择任意一个即可 ​ ——关于方法，申请有两个函数 一个是malloc函数，它的格式为：int *p = (int *) malloc (n * sizeof (int)); ​ sizeof (int)表示n个整形变量所需内存空间大小 ​ malloc (sizeof (int))表示申请该大小的内存空间，返回值为void型的指针 ​ (int *)表示强制转换成int类型的指针 另一个是calloc函数，它个格式为：int *p = (int *) calloc (n, sizeof(int)); ​ 该代码意义同malloc一致，至于两者的区别，malloc申请后不初始化，而calloc申请后全部初始化为0 ​ ——释放有一个函数free，它的用法如下 free(p); //将p所指向的堆内存空间释放回系统p = NULL; //为避免错误使用p指针碰触已释放的内存，应设置为 p = NULL ​ 以上就是内存空间的申请和释放，可能会有童鞋说还有new,delete，这些属于C++中的内容，等到C++查缺补漏时再总结～ ​ 前一篇博文探究了指针作参的情况，这篇博文来研究一下指针的指针 ​ 废话不多说，上代码： int a = 1;int *p = &amp;a;int **q = &amp;p; ​ 在上面代码中： ​ 对于第一行来说：a是int类型变量 ​ 对于第二行来说：p为变量a的地址(&amp;a)，而*p为a的值 ​ 对于第三行来说，q为指针变量p的地址，也就是&amp;p，而*q为p的值，也就是a的地址(&amp;a) ​ 因此：*q = p = &amp;a q = &amp;p ​ 就是酱紫～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！ ​]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo加快访问速度]]></title>
    <url>%2F2018%2F10%2F02%2Fhexo%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[​ hexo+github访问速度超慢！！！这两天算是领悟到了它的龟速暴击。。。原因只有一个，托管网站的github是外网，访问外网慢是必然的。 ​ 有很多人博客采用hexo+github+coding方式，至于coding是什么？大家可以理解为中国版的github，如果把代码既托管到coding上，又托管到github上，让大陆的用户访问的是由coding托管的网站，歪果仁访问的是由github托管的网站，这样访问速度就能上去了。 ​ hexo与github的步骤不再重复，全在之前的博客里 点这里跳转 ​ 完成上面步骤，我们接着往下走： ​ Step1:此时我们需要创建一个coding账号，然后添加一个项目，项目名为你的coding账号名，例如我的账号名是ivan-zcy，所以我新建的项目为ivan-zcy，注意要在初始化项目那一项打勾 ​ ​ ​ Step2:进入项目 -&gt; 设置 -&gt; 部署公匙 -&gt;新建部署公匙，给项目添加公匙SSH，ssh公匙获取方法和github一样，在之前博客 点这里跳转 第四步有详细的介绍。公匙名称可以不填，但是授予推送权限选项必须打勾，这样你才有写权限 ​ Step3: 在你的域名管理平台中（比如阿里云，腾讯云之类的），域名 -&gt;管理-&gt; 解析域名，增加一条CNAME信息，记录值为 youruser.coding.me（youruser为你的coding用户名）例如我的： ​ Step4:等到第三步的解析生效（最长十分钟），在coding中，项目 -&gt; 代码 -&gt; Pages服务中，一键部署Pages。在Pages的设置里，自定义自己的域名并绑定（域名前加www.前缀） Step5:在本地博客路径下，修改_config.yml下的deploy，改为： deploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,master 格式一定要正确！！！不然会报错！！！ Step6: ​ 在本地博客路径下，执行命令： $ hexo clean$ hexo g$ hexo d Ok!这样本地博客就能同时同步到github和coding上了，访问你的域名会解析到coding平台上，速度比github快很多 最后！！！关于万恶的coding广告，每次跳转你的域名都会弹出coding的广告，有两个解决办法： ​ 1.充钱即王道，198元包年。。。 ​ 2.在博客首页加入它的推广链接（只需要将以下代码加入到首页html任意位置即可），然后向官方申请去除广告（建议平民采用这种方法，大概一天审批时间，审批方法：主页头像 -&gt; 切换旧版 -&gt; 项目 -&gt; 代码 -&gt; Pages中）： &lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; ​ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个特别搞笑的故事哈哈]]></title>
    <url>%2F2018%2F10%2F02%2F%E4%B8%80%E4%B8%AA%E7%89%B9%E5%88%AB%E6%90%9E%E7%AC%91%E7%9A%84%E6%95%85%E4%BA%8B%E5%93%88%E5%93%88%2F</url>
    <content type="text"><![CDATA[分享一个特别长的程序猿的故事： ​]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(五)]]></title>
    <url>%2F2018%2F10%2F01%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-5%2F</url>
    <content type="text"><![CDATA[忽略点五:指针作参​ 平时比赛很少用到指针（链表，动态数组都有对应的STL，字典树也可以用数组模拟），业精于勤荒于嬉，C语言的指针就这样被我遗忘了。。 ​ 之前博文说过，C语言的优势之一就是在于能够直接访问物理地址，C语言的一大特色就是指针！！所以，学C语言舍弃指针是非常不明智的选择，终归是要还以前忽略的债。。苦笑～ ​ 关于指针，自己忽略的部分有很多，这一篇主要讲一下关于指针作参的用法： ——对于函数来说：​ 它不像变量那样可以进行值传递，我们在将函数作参进行传递时，需要传递它的地址，格式为： int g (int (*f)(int), int a) &#123; //定义 return f(a);&#125;//省略代码g(函数名, int型变量); //调用 ——对于一维数组来说：​ 它的格式为： void f (int *p) &#123; //定义 //省略代码&#125;//省略代码int a[5];f (a); //调用 ​ 关于这个a，我对它的理解是数组的初始位置，它等价于&amp;a[0]。因为我们在声明指针指向a数组时，是通过 int *p = a来实现的。 注意点！！！！void f (int a[5]) &#123; //定义 //省略代码&#125;//省略代码int a[5];f (a); //调用 ​ 对于 void f(int a[5])，参数int a[5]就真的是数组吗？ ​ 答案是否定的，这里如果真的把数组作为函数参数的话，需要分配临时的栈区执行拷贝等操作，会特别麻烦。所以编译器对代码进行了优化，把数组退化成了指针。从调用传入的是a（指针）就可以看出。 ——对于二维数组来说：它的格式为： void f (int *p) &#123; //定义 //省略代码&#125;//省略代码int a[5][5];f (a[0]); //调用 由一维数组可知，a[0]等价于&amp;a[0][0]，也等价于*a ​ a[0]等同于二维数组的首地址，也是二维数组下标为0行的首地址，同理a[1]为下标为1行的首地址，以此类推。 ​ 下面的问题没想明白，欢迎大佬来为我解惑。 ​ 我的认识（不一定正确）：那么二维数组的a是什么呢？从上边我们可以知道，a[0], a[1]等等都是地址信息，把他们整体来看，就是一个一维的指针数组。那么a为这个一维指针数组的首地址，而*a就是a[0]的值，也就是二维数组的首地址，从下面代码中也可以证实我的观点： void f(int *p) &#123; for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%d\n&quot;, p[i]); &#125;&#125;//省略代码int a[2][2] = &#123;1, 2, 3, 4&#125;;f(*a); ​ 最后结果输出 1，2，3，4，说明了*a 等价于a[0]，也就是二维数组的首地址 ​ 按上面的逻辑，a等价于a[0]，那么a就是存储a[0]指针地址的地址，所以a的值应该与a[0]不相同，也就是与 a不相同，所以以下代码会报错： void f(int *p) &#123; for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%d\n&quot;, p[i]); &#125;&#125;//省略代码int a[2][2] = &#123;1, 2, 3, 4&#125;;f(a); 可我通过以下代码输出发现，a的值等于 a[0] int a[2][2] = &#123;1, 2, 3, 4&#125;;printf(&quot;%p\n&quot;, a);printf(&quot;%p\n&quot;, *a); 输出为： 很迷茫。。。希望有大佬能为我解惑～ ——对于结构体来说：​ 结构体指针和变量指针作参类似，但它的指针可通过 -&gt;符指向它的成员，举个栗子(截取遍历链表代码的一部分)： struct node &#123; int val; node *next;&#125;void f(node *root) &#123; while (root -&gt; next != NULL) &#123; printf(&quot;%d\n&quot;, root -&gt; val) &#125;&#125;//省略代码node root = &#123;a, NULL&#125;;f(&amp;root); ​ root -&gt; val等价于 (*root).val ​ 只要捋清楚每个变量所代表的意义，指针作参就不会那么迷糊了，就酱紫～ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(四)]]></title>
    <url>%2F2018%2F10%2F01%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-4%2F</url>
    <content type="text"><![CDATA[忽略点四:宏定义的使用与#、##用法​ 初学C语言时常常忽略宏定义的使用，因为觉得声明局部变量，全局变量，静态变量就够用了，所以忽略了宏定义的使用 ​ 上述想法完全是错误的，因为宏定义在系统编译时就将其全部替换，定义的变量不会在运行时候分配内存。所以它有无可替代的优点：效率特别高！！！不占用内存空间！！！ ​ 宏定义不仅可以定义变量，使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。 ​ 如果不使用宏定义，在发生函数调用时，需要保留调用函数的现场，以便子函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，当函数调用次数特别多的时候，这些时间的消耗是不可忽略的。 ​ 而使用宏定义就不会出现这个问题，因为它在预处理阶段即进行了宏展开，在执行时不需要转换。 宏定义有无参宏定义和带参数宏定义两种 1.无参宏定义的一般形式为:# define 宏名 字符序列 //宏名与字符序列之间用空格符分隔，用于替代后面的字符序列 ​ ​ ——每个宏定义都在源程序中单独占一行，换行符是宏定义的结束标志。如果一个宏定义一行不够时可采用续行的方法。续行是在按回车前先输入符号”/“ ​ 注意！！回车要紧接在符号”/“后，中间不能插入其它符号 ​ ——宏定义的有效范围称为辖域，辖域从定义开始到源文件末尾。可用预处理命令#undef终止宏定义名的辖域 ​ ——宏名可被重复定义，重定义后会覆盖之前的字符序列 一般无参宏定义用于定义常量，比如定义数组长度（数组长度不能由变量定义，除了宏定义外，还可以使用const 关键字定义） 2.带参宏定义的一般形式为:# define 宏名(参数表) 字符序列 //参数间用逗号分隔，字符序列中应包含参数表中的参数 ​ 注意！！宏名与左圆括号之间不允许有空白符 以下是易错点！！！！！！！！！！！！！​ 易错点一：大家要深入理解宏替换的“替换”两个字！例如： #define F(x) x * x ​ 如果a = 1, b = 2，那么F(a + b)为多少？ ​ 很多同学会认为是9，但是答案是5。 ​ 原因是替换！只是简单的替换！！！ ​ F(x) = x x = 1 + 2 1 + 2 = 5 ​ 就是酱紫。。所以代码需要改成#define F(x) (x) * (x) 才会输出9 ​ 在宏定义中，我们使用#把宏参数变为一个字符串 ​ 用##把两个宏参数连在一起（这里说的是在预处理是对源文件的操作）​ 例如： #define S(s) #s #define F(a,b) int(a##e##b) ​ ​ 易错点二： ​ 对于以下代码 #define a 1e5const int b = 1e5; ​ 输出a和b的值，分别是多少呢？ ​ a: -272632256 ​ b: 100000 ​ 所以，要想宏定义科学计数法，需： #define a int(1e5) ​ 此时a的值为100000 关于宏中#和##的用法：在字符序列中： ​ 用#可以把宏参数变为一个字符串 ​ 用##可以把两个宏参数连接在一起 例如下面代码： #define STR(s) #s #define CONS(a,b) int(a##e##b)//...省略其余代码printf(STR(hello)); // 输出字符串&quot;vck&quot; printf(&quot;%d/n&quot;, CONS(1,5)); // 输出:100000 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(三)]]></title>
    <url>%2F2018%2F09%2F30%2FC%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-3%2F</url>
    <content type="text"><![CDATA[忽略点三:空格规范以及通用long long类型的定义​ 大一大二两年时间都没有注意过空格的规范，导致自己写的代码奇丑无比，被队友同学诟病 冷汗！ ​ 直到我看到另一份比我更丑的代码后，我才意识到代码的规范有多重要！！ 尤其是空格的合理使用！！！！​ 为了避免后来难改这种陋习，建议从刚开始学C语言就贯彻空格的使用规范 ​ ——逗号，分号后加空格 ​ ——运算符前后都需要加空格 ​ ——if，switch等关键字与左括号之间加空格 ​ ——函数名与左括号之间加空格 ​ ——左花括号前，右花括号后加空格 ​ —— -&gt;或者.后不能加空格！！ ​ 为了避免同学同事幽怨的目光，请妥善使用空格哈哈哈！！！ ​ 在ACM竞赛中，官方会提前告诉我们对于long long类型，我们是用%lld输出(Linux系统)，还是用%I64d输出(Windows系统) ​ 不过，我们有一种兼容的写法（这个特别重要！因为这种写法兼容性好，真需要代码移植的时候就不需要挨个手动改了) 注意，需要加inttypes.h头文件！！！​ 通用写法: int64_t a; ​ printf (“%”PRId64”\n”, a); ​ 其中PRId64为宏替换，在Linux下为lld，在Windows下为I64d ​ 除了int64_t (long long类型)以外,还有int32_t (int类型)，int16_t (short类型), int8_t (char类型)，uint64_t (unsigned long long类型)，uint32_t (unsigned int类型)，uint16_t (unsigned short类型), uint8_t (unsigned char类型)等等，就不一一列举了，大家可以自行百度！ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(二)]]></title>
    <url>%2F2018%2F09%2F30%2Fc%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-2%2F</url>
    <content type="text"><![CDATA[忽略点二：使用IED而忽略最基础的命令大一开始使用CodeBlocks来写C语言程序，后来用VS，再后来Xcode。最近才发现一个问题，自己竟然不会使用终端编译执行.C文件。这种最基本的东西，很遗憾在这两年学习中被我无情的忽略了。 ​ 第一步： cd到.c文件所在目录 $ cd 路径地址 ​ 第二步：编译源文件并生成可执行代码文件，举个例子 $ gcc main.c //编译main.c文件，生成可执行文件(默认名a.out) $ gcc -o program main.c //main.c为源文件，program为生成的可执行文件 关于默认生成的a.out，它是临时性的可执行文件。如果同一路径下多个c语言源文件采用了默认编译，a.out中输出的内容为最后一个C语言源文件所执行的结果（也就是说之前源文件编译生成的a.out被覆盖掉了) 这时候就体现了 gcc -o 的-o的作用 它可以指定生成输出文件 以下到第三步之前是附加内容（除此之外 选项 -E 可以将test.c预处理输出（其中-E的功能是预处理test.c并输出到终端，不生成文件) $ gcc -E test.c -o test.i$ gcc -E test.c &gt; test.i //其中&gt;为重定向符 选项 -S 可以将test.c汇编成test.s文件（也就是从源文件-&gt;汇编代码) $ gcc -S -o test.s test.c $ gcc -S test.c (简写 效果一样)$ gcc -S test.c &gt; test.s 选项 -c 可将test.c编译输出到test.o文件 (编译过程中的中间文件) $ gcc -c -o test.o test.c $ gcc -c test.c (简写 效果一样) 除此之外，还有选项 -g 用于增加调试信息，选项 -Wall用于打开大部分警告信息 ，-std=版本号用于选择标准（例如：-std=c99）等等，就不一一列举了，大家可以查相关文档 其中： .i文件是进行预编译之后生成的文件，一般是引用头文件的内容和一些宏定义 ​ .s文件是汇编语言源文件,一般是 .c 文件经过汇编器处理后的输出 ​ .o文件程序编译中的目标文件（注意是编译中，不是最终！）里面包含了各个函数的入口标记与描述，程序执行还需要链接(link).链接就是把多个.o文件链成一个可执行文件。） ​ ​ 第三步：执行可执行文件 $ ./program 以上就是用命令行实现C语言的编译运行的全过程 对于项目（多文件），我们无法单个的编译运行，这时候我们应该怎么办呢？ ​ 第一步: 分别用-c命令编译每个.c文件(包括main函数文件) $ gcc -c xxx.c 我们会得到每个xxx.c文件的目标文件xxx.o ​ 第二步:将主程序的目标代码与他们链接在一起 ​ 例如下面命令是将项目的所有目标代码xxx.o与main.o链接在一起，并输出了可执行文件program $ gcc main.o xxx.o xxx.o xxx.o -o program 这样一个项目多文件代码就可以运行啦！ 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言查缺补漏(一)]]></title>
    <url>%2F2018%2F09%2F30%2Fc%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-1%2F</url>
    <content type="text"><![CDATA[忽略点一：C语言能够干什么？它的优势在哪？首先，这是我们在学C语言前就应该了解的。总觉得大学的课程缺少一个体系，学完了之后，不知道能用它来做什么，或者说不知道用它处理什么东西好。 这是我刚开始学C语言时所忽略的地方，现在回头想想这个东西其实挺重要的。 C语言的优势是什么？ ​ ——快！快！快！！！！C语言允许直接访问物理地址，可以直接对硬件进行操作。这是高级语言所无法比拟的。所以，越是经常反复使用的代码，越需要用这类语言实现。可能调用一次两次差距不明显，但调用次数多了，两者的运算差距就大了。 ​ ——生成目标代码质量高，程序执行效率高。其本质还是上边所讲的，快！C语言相比汇编语言可读性好，易于调试和移植，而效率只比汇编程序生成的目标代码低10%～20% ​ ——至于它的可移植性，虽不是最好，但也有较高的可移植性 我们就要紧紧抓住它的优势，让它的优势最大化，所以我们最好把它用在以下几个方面： ​ ——C语言可用与操作系统上的编程，比方说自己写个内存管理啦服务器之类的 ​ ——C语言用来设计操作系统，大部分的操作系统内核就是用C语言写的 ​ ——关于网络传输协议的设计与实现，离不开C语言 ​ ——嵌入式系统编程大部分也依赖于C语言 ​ ——很多编译器也是通过C语言实现的 ​ ——现如今C/C++语言也常常用于游戏开发 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用网站汇总(持续更新)]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[以下是这几年积攒的全部家底了，哈哈哈！ 在线编程平台: ​ 计蒜客 传送门 ——灰常好用 ​ hackerrank 传送门 ——国外学习各类语言的在线编译平台 除网速慢 其它特别棒 白瞎全哥给我推荐了 几乎没用过 ​ 在线编译 传送门 ——能在线编译10多种语言 网上学习平台: ​ 维基百科 传送门 —— 涵盖方方面面 ​ stackoverflow 传送门 ——与程序相关的IT技术问答网站 ​ 海贼科技 传送门 ——信海贼 得永生 ​ 哔哩哔哩 传送门 ——里面啥都有 不容反驳！！！ ​ Github 传送门 ——开源大法好 ​ coding 传送门 —— 国语版的Github？ ​ CSDN 传送门 ——个人感觉CSDN是目前为止对我帮助最大的平台了 ​ 博客园 传送门 —— 如果还有的话，那就是博客园 ​ 计蒜客 传送门 —— 伴随式学习课程 方便学习 ​ 网易云课堂 传送门 —— 感觉国内最好的视频学习平台了 ​ 慕课网 传送门 ——和计蒜客类似 ​ 菜鸟教程 传送门 ——各种语言的学习文档 ​ 易百教程 传送门 ——和菜鸟教程差不多 ​ 简书 传送门 ——里边有很多IT文章 特别赞 C语言：​ stack overflow 传送门 ——C语言界的“知乎”​ cplusplus 传送门 ——C语言文档 ACM： ​ 小白菜OJ 传送门 ——简单基础，带视频讲解 ​ 洛谷 传送门 ——灰常好玩 ​ HUD 传送门 ——个人认为国内现在最繁忙的OJ了吧 ​ POJ 传送门 ——北大OJ ​ Project Euler 传送门 ——国外一个纯数学编程题的网站 ​ 华中理工VJ 传送门 ——可以很方便的从各大OJ拉题 ​ CodeForce 传送门 ——比赛特别多 不过大多数都在半夜！ 平时不需要翻墙 注册时需要翻墙才能收到验证码 ​ 数论 传送门 ——看过最好的数论博客 ​ 大佬 传送门 ——分享一个经常看的大佬博客 机器学习类: ​ 吴恩达课程+笔记 传送门 ——黄海广博士翻译 数学类： ​ OEIS 传送门 ——国外的在线整数数列查询网站 啥也不说了 OEIS大法好 ​ WolframMathWorld 传送门 ——国外数学网站 Linux： ​ Linux命令大全 传送门 ——全中文呀 面试题： ​ 猿圈 传送门 ——有针对于面试笔试的题库 ​ 牛客网 传送门 ——同猿圈一样​ ​ 云服务平台： ​ DNSPOD 传送门 ——第三方域名解析平台 ​ 阿里云 传送门 ——云服务的集成平台 ​ 景安 传送门 ——为什么是景安？没错，是贫穷！ ​ GoDaddy 传送门 ——国外域名商 买完后悔了 现在法律规定必须备案才能使用 要备案必须得转到国内。。 工具： ​ 在线工具 传送门 ——特别全的在线工具集合 ​ ProcessOn 传送门 ——在线绘图平台 ​ 超级简历 传送门 ——在线简历制作 ​ 知页 传送门 ——同超级简历一样 ​ 印象笔记 传送门 ——记事本 可同步移动端 ​ 前端类: ​ Iconfont 传送门 ——许许多多美观的图标 ​ Font Awesome 传送门 ——简洁大方的图标字体库 ​ 设计导航 传送门 ——前端所需的汇总平台 ​ jQuery插件库 传送门 ——里面有好多很棒的特效 ​ W3school 传送门 ——前端语言学习文档 ​ 花瓣网 传送门 ——图片素材 ​ 模版王 传送门 ——有许许多多网站模版 不过坑好多 ​ Layui 传送门 ——关于前端的使用 它的颜色设计感很棒 转载请注明出处！！！ 如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blog搭建流程(Mac系统完结帖)]]></title>
    <url>%2F2018%2F09%2F30%2FBlog%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B-Mac%E7%B3%BB%E7%BB%9F%E5%AE%8C%E7%BB%93%E5%B8%96%2F</url>
    <content type="text"><![CDATA[讲完这一篇hexo就算暂时性翻过去了 以后专注于算法和C++底层 加油加油！ Step1 安装Node.js可通过以下两种方式在 Mac OS 上安装 node.js： 方式一： 在官方下载网站下载 pkg 安装包，直接点击安装即可 方式二： 使用 brew 命令来安装： brew install node Step2 安装Git首先查看电脑是否安装Git，终端输入： git 安装过则会输出下表，然后跳过该步 WMBdeMacBook-Pro:~ WENBO$ gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects&apos;git help -a&apos; and &apos;git help -g&apos; list available subcommands and someconcept guides. See &apos;git help &lt;command&gt;&apos; or &apos;git help &lt;concept&gt;&apos;to read about a specific subcommand or concept. ​ ​ 如果没有显示上面内容，我们可以通过homebrew安装GIt，若未安装homebrew 则通过终端执行： /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; ​ 随后执行一下命令进行Git的安装 brew install git Step3 注册Github账号并新建仓库​ 网站链接：Github ​ 注册完账号后需新建一个仓库。注意！！新建的仓库名字必须是username.github.io。例如我username是ivan-zcy，那么仓库名字必须是ivan-zcy.github.io Step4 配置SSH Key（可省略 建议配置）这一步能省略 但是配置后更新博客就不用每次都输入用户名密码了 步骤：​ 1 检查主机是否已存在SSH Key cd .sshls -la 若输出的文件列表中存在id_rsa.pub 或 id_dsa.pub 文件，则直接跳到第三小步 ​ ​ 2 创建SSH Key在终端输入如下命令 ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 按下回车 会让输入文件名，直接回车会创建默认文件名的文件 然后会提示输入两次密码(可为空) ​ 3 添加SSH Key到Github （如果之前在Github中添加过SSH 则跳过该步） 如果你没有指定文件名（也就是使用默认文件名），那么在.ssh文件夹下会有一个id_rsa.pub文件，打开该文件并复制里面的内容 登录Github，点击右上角头像右边的三角图标，点击Settings –&gt; SSH and GPG keys –&gt; New SSH key。Title 随便填一个，在Key栏中填入复制的内容，点击Add SSH key，就添加成功了 ​ 4 检验SSH Key是否配置成功在终端输入如下命令 ssh -T git@github.com 如果最后出现 Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 就说明SSH Key配置成功了 Step5 安装Hexo使用npm命令安装Hexo npm install -g hexo 接着在任意位置创建一个文件夹，如Blog，cd到该路径下执行 hexo init 该命令会在目标文件夹内建立网站所需的基础文件 接着安装安装依赖包 npm install 此时本地博客就搭建好了 执行 hexo generatehexo server 此时可在浏览器中输入http://localhost:4000/进行本地查看（其他人无法访问） ​ 当然 此时可修改本地博客路径下的_config文件对博客进行全局设置，里边设置项挺多就不一一列举啦！自行百度 ​ Step6 同步到远程Github仓库在本地Blog路径下找到_config.yml，把deploy节点修改为： deploy: type: git repo: git@github.com:username/username.github.io.git branch: master （其中 username为你的Github用户名） 为了能够使Hexo部署到GitHub上，需安装一个插件 npm install hexo-deployer-git --save 然后输入以下命令 hexo cleanhexo generatehexo deploy 这时候就可以在浏览器通过输入username.github.io就可以访问你的博客了 Step7 配置主题​ 前边写过配置主题的博文 抛出一个传送门： ​ 滴滴，我是传送门 ​ （主题在github上 知乎上 hexo官网上有很多很多 适合自己就好） ​ 注意点！！！！一些主题的功能需要我们自己预先创建好对应的页面，例如标签tags 关于about等等等等 此时我们需要在本地Blog路径下 ​ 1 添加关于页面（可选） 使用：hexo new page &quot;about&quot;新建一个 关于我 页面。主题的 _config.yml文件中的 menu中进行匹配 menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可） ​ 也可在本地博客路径 –&gt; source –&gt; about文件下，通过修改其中的index.md对其页面进行配置 ​ 2 添加标签页面（可选） 使用： hexo new page tags新建一个 标签 页面。主题的 _config.yml文件中的 menu中进行匹配 menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 （添加此行即可） about: /about //关于 ​ 也可在本地博客路径 –&gt; source –&gt; tags文件下，通过修改其中的index.md对其页面进行配置 ​ ​ 除了上边两个之外还有分类categories，自定义页面等等就不一一列举啦 自行百度吧！ Step8 发布博文​ 接着抛链接： ​ 滴滴，我也是一个传送门 Step9 绑定个人域名​ 步骤： ​ 1 购买域名 建议从阿里云平台啦之类的国内大型平台购买（这一步通常需要身份验证之类的 大概需要几天时间吧也记不清楚了 反正挺麻烦挺磨唧的） ​ 2 配置DNS地址 进入阿里云控制台 –&gt; 域名 –&gt; 域名列表 找到自己的域名 点击下图红圈圈的“管理”​ ​ ​ 3 进行域名解析 找到管理界面下的域名解析 在其中添加3条记录（username是github的用户名） @ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io. ​ 4添加CNAME文件新建一个名为CNAME的文件(无后缀)，内容为你的域名地址。将该文件放到本地博客的source文件夹里面，并更新到Github ​ 这时候你的博客就建完啦！ ​ 最后附上主页地址： 戳我 ​ 一起造作吧！！！！ 参考链接：https://segmentfault.com/a/1190000008040387 https://blog.csdn.net/ganzhilin520/article/details/79047249 https://www.jianshu.com/p/e5f95eb990ad]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-09-29博客搭建进度]]></title>
    <url>%2F2018%2F09%2F29%2F18-09-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[特点:简约 流畅 死宅 进度表：​ ——新增标签页，方便查找（感谢帮忙拍版的鹏飞） ​ ——新增返回顶部的小火箭 ​ ——优化布局 ​ ——新增巨巨们的友情链接]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo发表博客常用命令]]></title>
    <url>%2F2018%2F09%2F28%2Fhexo%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[以下命令需要在本地Blog路径下执行Step1 创建文章$ hexo new "My New Post"$ hexo n "My New Post" //安装hexo-asset-image后可使用 Step2 编辑文章文章头部加---title: //此处填写文章名date: //此处填写发布日期tags: - //此处填写标签名(可多个)--- 由于在首页中显示文章内容使用的是 post.content 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个 &lt;!-- more --&gt; 标记。添加了这个标记之后，post.excerpt 将会获取到标记之前的内容 之后的内容大家可以随意Diy啦 编辑md文件建议使用Typora软件 特别推荐！！！ 关于文章添加图片：​ 1 把本地Blog文件下的配置文件（非主题下）_config.yml里的post_asset_folder:选项设置为true ​ 2 在本地Blog路径下执行npm install hexo-asset-image --save （用于下载安装一个可以上传本地图片的插件） ​ 3 运行hexo n &quot;xxxx&quot;来生成md博文 ​ 会发现在/source/_posts文件夹中除了xxxx.md`文件还生成了一个同名文件夹 ​ 4最后在xxxx.md引入图片时，先把图片复制到xxxx文件夹中 然后在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) Step3 清除缓存 （可省略 建议使用）$ hexo clean 清除缓存文件 db.json 和已生成的静态文件 public 当网站显示异常时可以执行这条命令试试 Step4 生成静态文件$ hexo generate$ hexo g //简写 这步骤就相当于程序的编译，如果有错误的话，在终端会有相应的提示信息 如果没有错误的话 可以继续往下执行 Step5 启动本地服务器 （可省略）$ hexo server$ hexo s //简写 用于预览主题，默认地址： http://localhost:4000/ Step6 部署到远程站点$ hexo deploy$ hexo d //简写 上述步骤结束后 恭喜你 一篇博文完成啦！]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo更换主题流程]]></title>
    <url>%2F2018%2F09%2F28%2Fhexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Step1: 下载​ cd到本地博客路径 $ cd 你的博客目录路径 ​ ​ 用clone命令将想要的主题下载下来 $ git clone 主题链接 ​ 注意 需要git到当地Glob文件夹下的theme文件夹内 Step2: 修改配置文件并安装​ git克隆完成后，打开本地Blog下的“_config.yml”配置文件（非主题文件下） ​ 找到theme配置选项(一般在文件的最后) 将theme选项配置为新下载的主题即可（“：”冒号之后空格不可少 空格后为新下载的主题名） Step3 修改主题配置文件​ 打开主题路径下的“_config.yml”配置文件 按照作者要求进行相关配置 Step4:调试，发布​ 在本地Blog路径下 输入调试命令： $ hexo server --debug ​ ​ 在浏览器中输入localhost:4000查看 ​ ​ 在本地查看无误之后，输入生成和发布命令, 就可将新主题发布到自己的博客网站上了 $ hexo g$ hexo d ​ 如出现缓存引起的异常，可在生成命令执行前执行清除缓存命令 $ hexo clean Step5 自己DIY​ 如果主题没有想象中好 忍无可忍无需再忍 那就自己动手修改它的源码吧！（建议事先备份 推荐使用Webstrom）]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2018%2F09%2F28%2FFirst-Blog%2F</url>
    <content type="text"><![CDATA[​ ​ ​ 距离明年秋招不到一年，有对未来的忐忑，也有期待。 ​ 不知道自己未来会怎样，但希望能像阿甘那样，永远不被挫折打倒。 ​ 今天搭建了个人博客，希望自己能坚持写下去，从一而终。 ​ 加油 坚持！ ​ 愿接下来的一年自己能收到满意的答卷！]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
