<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>img</title>
      <link href="/2019/09/16/img/"/>
      <url>/2019/09/16/img/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src="/2019/09/16/img/a.jpg" alt="a"></p><p><img src="/2019/09/16/img/b.jpg" alt="b"></p><p><img src="/2019/09/16/img/c.jpg" alt="c"></p><p><img src="/2019/09/16/img/d.jpg" alt="d"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set sw=4</span><br><span class="line">set ts=4</span><br><span class="line">set et</span><br><span class="line">set smarttab</span><br><span class="line">set smartindent</span><br><span class="line">set lbr</span><br><span class="line">set fo+=mB</span><br><span class="line">set sm</span><br><span class="line">set selection=inclusive</span><br><span class="line">set wildmenu</span><br><span class="line">set mousemodel=popup</span><br><span class="line"></span><br><span class="line">au FileType php setlocal dict+=~/.vim/dict/php_funclist.dict</span><br><span class="line">au FileType css setlocal dict+=~/.vim/dict/css.dict</span><br><span class="line">au FileType c setlocal dict+=~/.vim/dict/c.dict</span><br><span class="line">au FileType cpp setlocal dict+=~/.vim/dict/cpp.dict</span><br><span class="line">au FileType scale setlocal dict+=~/.vim/dict/scale.dict</span><br><span class="line">au FileType javascript setlocal dict+=~/.vim/dict/javascript.dict</span><br><span class="line">au FileType html setlocal dict+=~/.vim/dict/javascript.dict</span><br><span class="line">au FileType html setlocal dict+=~/.vim/dict/css.dict</span><br><span class="line"></span><br><span class="line">&quot;</span><br><span class="line">&quot;syntastic相关</span><br><span class="line">execute pathogen#infect()</span><br><span class="line">let g:syntastic_python_checkers=[&apos;pylint&apos;]</span><br><span class="line">let g:syntastic_php_checkers=[&apos;php&apos;, &apos;phpcs&apos;, &apos;phpmd&apos;]</span><br><span class="line">&quot;golang</span><br><span class="line">&quot;Processing... % (ctrl+c to stop)</span><br><span class="line">let g:fencview_autodetect=0</span><br><span class="line">set rtp+=$GOROOT/misc/vim</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 显示相关</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">syntax on</span><br><span class="line">set cul &quot;高亮光标所在行</span><br><span class="line">set cuc</span><br><span class="line">set shortmess=atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示</span><br><span class="line">set go=             &quot; 不要图形按钮</span><br><span class="line">&quot;color desert     &quot; 设置背景主题</span><br><span class="line">color ron     &quot; 设置背景主题</span><br><span class="line">&quot;color torte     &quot; 设置背景主题</span><br><span class="line">&quot;set guifont=Courier_New:h10:cANSI   &quot; 设置字体</span><br><span class="line">&quot;autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行</span><br><span class="line">autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行</span><br><span class="line">set ruler           &quot; 显示标尺</span><br><span class="line">set showcmd         &quot; 输入的命令显示出来，看的清楚些</span><br><span class="line">&quot;set whichwrap+=&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)</span><br><span class="line">set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;   &quot;状态行显示的内容</span><br><span class="line">set laststatus=2    &quot; 启动显示状态行(1),总是显示状态行(2)</span><br><span class="line">&quot;set foldenable      &quot; 允许折叠</span><br><span class="line">&quot;&quot;set foldmethod=manual   &quot; 手动折叠</span><br><span class="line">set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限</span><br><span class="line">&quot; 显示中文帮助</span><br><span class="line">if version &gt;= 603</span><br><span class="line">    set helplang=cn</span><br><span class="line">    set encoding=utf-8</span><br><span class="line">endif</span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line">&quot; Tab键的宽度</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot; 统一缩进为4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot; 使用空格代替制表符</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 在行和段开始处使用制表符</span><br><span class="line">set smarttab</span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line">&quot; 历史记录数</span><br><span class="line">set history=1000</span><br><span class="line">&quot;搜索逐字符高亮</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">&quot;语言设置</span><br><span class="line">set langmenu=zh_CN.UTF-8</span><br><span class="line">set helplang=cn</span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">set cmdheight=2</span><br><span class="line">&quot; 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line">&quot; 保存全局变量</span><br><span class="line">set viminfo+=!</span><br><span class="line">&quot; 带有如下符号的单词不要被换行分割</span><br><span class="line">set iskeyword+=_,$,@,%,#,-</span><br><span class="line">&quot; 字符间插入的像素行数目</span><br><span class="line"></span><br><span class="line">&quot;markdown配置</span><br><span class="line">au BufRead,BufNewFile *.&#123;md,mdown,mkd,mkdn,markdown,mdwn&#125;   set filetype=mkd</span><br><span class="line">au BufRead,BufNewFile *.&#123;go&#125;   set filetype=go</span><br><span class="line">au BufRead,BufNewFile *.&#123;js&#125;   set filetype=javascript</span><br><span class="line">&quot;rkdown to HTML</span><br><span class="line">nmap md :!~/.vim/markdown.pl % &gt; %.html &lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap fi :!firefox %.html &amp; &lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap \ \cc</span><br><span class="line">vmap \ \cc</span><br><span class="line"></span><br><span class="line">&quot;将tab替换为空格</span><br><span class="line">nmap tt :%s/\t/    /g&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;新文件标题</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;新建.c,.h,.sh,.java文件，自动插入文件头</span><br><span class="line">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.rb,*.java,*.py exec &quot;:call SetTitle()&quot;</span><br><span class="line">&quot;&quot;定义函数SetTitle，自动插入文件头</span><br><span class="line">func SetTitle()</span><br><span class="line">    &quot;如果文件类型为.sh文件</span><br><span class="line">    if &amp;filetype == &apos;sh&apos;</span><br><span class="line">        call setline(1,&quot;\#!/bin/bash&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;), &quot;&quot;)</span><br><span class="line">    elseif &amp;filetype == &apos;python&apos;</span><br><span class="line">        call setline(1,&quot;#!/usr/bin/env python&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;),&quot;# coding=utf-8&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">    elseif &amp;filetype == &apos;ruby&apos;</span><br><span class="line">        call setline(1,&quot;#!/usr/bin/env ruby&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;),&quot;# encoding: utf-8&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">&quot;    elseif &amp;filetype == &apos;mkd&apos;</span><br><span class="line">&quot;        call setline(1,&quot;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;/head&gt;&quot;)</span><br><span class="line">    else</span><br><span class="line">        call setline(1, &quot;/*************************************************************************&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;))</span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;  &gt; Author: Zcy&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;  &gt; Mail: 296763002@qq.com&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;  &gt; Created Time: &quot;.strftime(&quot;%c&quot;))</span><br><span class="line">        call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+5, &quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line">    if expand(&quot;%:e&quot;) == &apos;cpp&apos;</span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+8, &quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line">    if &amp;filetype == &apos;c&apos;</span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7, &quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line">    if expand(&quot;%:e&quot;) == &apos;h&apos;</span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;#ifndef _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7, &quot;#define _&quot;.toupper(expand(&quot;%:r&quot;)).&quot;_H&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+8, &quot;#endif&quot;)</span><br><span class="line">    endif</span><br><span class="line">    if &amp;filetype == &apos;java&apos;</span><br><span class="line">        call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%:r&quot;))</span><br><span class="line">        call append(line(&quot;.&quot;)+7,&quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line">    &quot;新建文件后，自动定位到文件末尾</span><br><span class="line">endfunc</span><br><span class="line">autocmd BufNewFile * normal G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;键盘命令</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">:nmap &lt;silent&gt; &lt;F9&gt; &lt;ESC&gt;:Tlist&lt;RETURN&gt;</span><br><span class="line">&quot; shift tab pages</span><br><span class="line">map &lt;S-Left&gt; :tabp&lt;CR&gt;</span><br><span class="line">map &lt;S-Right&gt; :tabn&lt;CR&gt;</span><br><span class="line">map! &lt;C-Z&gt; &lt;Esc&gt;zzi</span><br><span class="line">map! &lt;C-O&gt; &lt;C-Y&gt;,</span><br><span class="line">map &lt;C-A&gt; ggVG$&quot;+y</span><br><span class="line">map &lt;Esc&gt;&lt;Esc&gt; :w&lt;CR&gt;</span><br><span class="line">map &lt;F12&gt; gg=G</span><br><span class="line">map &lt;C-w&gt; &lt;C-w&gt;w</span><br><span class="line">imap &lt;C-k&gt; &lt;C-y&gt;,</span><br><span class="line">imap &lt;C-t&gt; &lt;C-q&gt;&lt;TAB&gt;</span><br><span class="line">imap &lt;C-j&gt; &lt;ESC&gt;</span><br><span class="line">&quot; 选中状态下 Ctrl+c 复制</span><br><span class="line">&quot;map &lt;C-v&gt; &quot;*pa</span><br><span class="line">imap &lt;C-v&gt; &lt;Esc&gt;&quot;*pa</span><br><span class="line">imap &lt;C-a&gt; &lt;Esc&gt;^</span><br><span class="line">imap &lt;C-e&gt; &lt;Esc&gt;$</span><br><span class="line">vmap &lt;C-c&gt; &quot;+y</span><br><span class="line">set mouse=v</span><br><span class="line">&quot;set clipboard=unnamed</span><br><span class="line">&quot;去空行</span><br><span class="line">nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt;</span><br><span class="line">&quot;比较文件</span><br><span class="line">nnoremap &lt;C-F2&gt; :vert diffsplit</span><br><span class="line">&quot;nnoremap &lt;Leader&gt;fu :CtrlPFunky&lt;Cr&gt;</span><br><span class="line">&quot;nnoremap &lt;C-n&gt; :CtrlPFunky&lt;Cr&gt;</span><br><span class="line">&quot;列出当前目录文件</span><br><span class="line">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">imap &lt;F3&gt; &lt;ESC&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">&quot;打开树状文件目录</span><br><span class="line">map &lt;C-F3&gt; \be</span><br><span class="line">:autocmd BufRead,BufNewFile *.dot map &lt;F5&gt; :w&lt;CR&gt;:!dot -Tjpg -o %&lt;.jpg % &amp;&amp; eog %&lt;.jpg  &lt;CR&gt;&lt;CR&gt; &amp;&amp; exec &quot;redr!&quot;</span><br><span class="line">&quot;C，C++ 按F5编译运行</span><br><span class="line">map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;</span><br><span class="line">func! CompileRunGcc()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &apos;c&apos;</span><br><span class="line">        exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">        exec &quot;!time ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;cpp&apos;</span><br><span class="line">        exec &quot;!g++ % -std=c++11 -o %&lt;&quot;</span><br><span class="line">        exec &quot;!time ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;java&apos;</span><br><span class="line">        exec &quot;!javac %&quot;</span><br><span class="line">        exec &quot;!time java %&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;sh&apos;</span><br><span class="line">        :!time bash %</span><br><span class="line">    elseif &amp;filetype == &apos;python&apos;</span><br><span class="line">        exec &quot;!time python2.7 %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;html&apos;</span><br><span class="line">        exec &quot;!firefox % &amp;&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;go&apos;</span><br><span class="line">&quot;        exec &quot;!go build %&lt;&quot;</span><br><span class="line">        exec &quot;!time go run %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;mkd&apos;</span><br><span class="line">        exec &quot;!~/.vim/markdown.pl % &gt; %.html &amp;&quot;</span><br><span class="line">        exec &quot;!firefox %.html &amp;&quot;</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">&quot;C,C++的调试</span><br><span class="line">map &lt;F8&gt; :call Rungdb()&lt;CR&gt;</span><br><span class="line">func! Rungdb()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!g++ % -std=c++11 -g -o %&lt;&quot;</span><br><span class="line">    exec &quot;!gdb ./%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;代码格式优化化</span><br><span class="line"></span><br><span class="line">map &lt;F6&gt; :call FormartSrc()&lt;CR&gt;&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;定义FormartSrc()</span><br><span class="line">func FormartSrc()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &apos;c&apos;</span><br><span class="line">        exec &quot;!astyle --style=ansi -a --suffix=none %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;cpp&apos; || &amp;filetype == &apos;hpp&apos;</span><br><span class="line">        exec &quot;r !astyle --style=ansi --one-line=keep-statements -a --suffix=none %&gt; /dev/null 2&gt;&amp;1&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;perl&apos;</span><br><span class="line">        exec &quot;!astyle --style=gnu --suffix=none %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;py&apos;||&amp;filetype == &apos;python&apos;</span><br><span class="line">        exec &quot;r !autopep8 -i --aggressive %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;java&apos;</span><br><span class="line">        exec &quot;!astyle --style=java --suffix=none %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;jsp&apos;</span><br><span class="line">        exec &quot;!astyle --style=gnu --suffix=none %&quot;</span><br><span class="line">    elseif &amp;filetype == &apos;xml&apos;</span><br><span class="line">        exec &quot;!astyle --style=gnu --suffix=none %&quot;</span><br><span class="line">    else</span><br><span class="line">        exec &quot;normal gg=G&quot;</span><br><span class="line">        return</span><br><span class="line">    endif</span><br><span class="line">    exec &quot;e! %&quot;</span><br><span class="line">endfunc</span><br><span class="line">&quot;结束定义FormartSrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;实用设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">if has(&quot;autocmd&quot;)</span><br><span class="line">      autocmd BufReadPost *</span><br><span class="line">          \ if line(&quot;&apos;\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&apos;\&quot;&quot;) &lt;= line(&quot;$&quot;) |</span><br><span class="line">          \   exe &quot;normal g`\&quot;&quot; |</span><br><span class="line">          \ endif</span><br><span class="line">endif</span><br><span class="line">&quot;当打开vim且没有文件时自动打开NERDTree</span><br><span class="line">autocmd vimenter * if !argc() | NERDTree | endif</span><br><span class="line">&quot; 只剩 NERDTree时自动关闭</span><br><span class="line">autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTreeType&quot;) &amp;&amp; b:NERDTreeType == &quot;primary&quot;) | q | endif</span><br><span class="line"></span><br><span class="line">&quot; 设置当文件被改动时自动载入</span><br><span class="line">set autoread</span><br><span class="line">&quot; quickfix模式</span><br><span class="line">autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;</span><br><span class="line">&quot;代码补全</span><br><span class="line">set completeopt=preview,menu</span><br><span class="line">&quot;允许插件</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;共享剪贴板</span><br><span class="line">&quot;set clipboard+=unnamed</span><br><span class="line">&quot;自动保存</span><br><span class="line">set autowrite</span><br><span class="line">&quot;set ruler                   &quot; 打开状态栏标尺</span><br><span class="line">&quot;set cursorline              &quot; 突出显示当前行</span><br><span class="line">set magic                   &quot; 设置魔术</span><br><span class="line">set guioptions-=T           &quot; 隐藏工具栏</span><br><span class="line">set guioptions-=m           &quot; 隐藏菜单栏</span><br><span class="line">&quot;&quot;set foldcolumn=0</span><br><span class="line">&quot;&quot;set foldmethod=indent</span><br><span class="line">&quot;&quot;set foldlevel=3</span><br><span class="line">&quot; 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 去掉输入错误的提示声音</span><br><span class="line">set noeb</span><br><span class="line">&quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set confirm</span><br><span class="line">&quot;禁止生成临时文件</span><br><span class="line">set nobackup</span><br><span class="line">set noswapfile</span><br><span class="line">&quot;搜索忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set linespace=0</span><br><span class="line">&quot; 增强模式中的命令行自动完成操作</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set backspace=2</span><br><span class="line">&quot; 允许backspace和光标键跨越行边界</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l</span><br><span class="line">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line">&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line">set report=0</span><br><span class="line">&quot; 在被分割的窗口间显示空白，便于阅读</span><br><span class="line">set fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line">set matchtime=1</span><br><span class="line">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set scrolloff=3</span><br><span class="line">&quot; 为C程序提供自动缩进</span><br><span class="line">&quot;自动补全</span><br><span class="line">&quot;&quot;:inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">&quot;&quot;:inoremap ) &lt;c-r&gt;=ClosePair(&apos;)&apos;)&lt;CR&gt;</span><br><span class="line">&quot;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br><span class="line">&quot;:inoremap &#125; &lt;c-r&gt;=ClosePair(&apos;&#125;&apos;)&lt;CR&gt;</span><br><span class="line">&quot;&quot;:inoremap [ []&lt;ESC&gt;i</span><br><span class="line">&quot;&quot;:inoremap ] &lt;c-r&gt;=ClosePair(&apos;]&apos;)&lt;CR&gt;</span><br><span class="line">&quot;&quot;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line">&quot;&quot;:inoremap &apos; &apos;&apos;&lt;ESC&gt;i</span><br><span class="line">&quot;&quot;function! ClosePair(char)</span><br><span class="line">&quot;&quot;  if getline(&apos;.&apos;)[col(&apos;.&apos;) - 1] == a:char</span><br><span class="line">&quot;&quot;      return &quot;\&lt;Right&gt;&quot;</span><br><span class="line">&quot;&quot;  else</span><br><span class="line">&quot;&quot;      return a:char</span><br><span class="line">&quot;&quot;  endif</span><br><span class="line">&quot;&quot;endfunction</span><br><span class="line">filetype plugin indent on</span><br><span class="line">&quot;打开文件类型检测, 加了这句才可以用智能补全</span><br><span class="line">set completeopt=longest,menu</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; CTags的设定</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">let Tlist_Sort_Type = &quot;name&quot;    &quot; 按照名称排序</span><br><span class="line">let Tlist_Use_Right_Window = 1  &quot; 在右侧显示窗口</span><br><span class="line">let Tlist_Compart_Format = 1    &quot; 压缩方式</span><br><span class="line">let Tlist_Exist_OnlyWindow = 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer</span><br><span class="line">&quot;&quot;let Tlist_File_Fold_Auto_Close = 0  &quot; 不要关闭其他文件的tags</span><br><span class="line">&quot;&quot;let Tlist_Enable_Fold_Column = 0    &quot; 不要显示折叠树</span><br><span class="line">&quot;let Tlist_Show_One_File=1            &quot;不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">&quot;设置tags</span><br><span class="line">set tags=tags;</span><br><span class="line">set autochdir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;其他东东</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;默认打开Taglist</span><br><span class="line">let Tlist_Auto_Open=0</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; Tag list (ctags)</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">let Tlist_Ctags_Cmd = &apos;/usr/local/bin/ctags&apos;</span><br><span class="line">let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">let Tlist_File_Fold_Auto_Close = 1</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口</span><br><span class="line">&quot; minibufexpl插件的一般设置</span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1</span><br><span class="line">let g:miniBufExplMapWindowNavArrows = 1</span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1</span><br><span class="line">let g:miniBufExplModSelTarget = 1</span><br><span class="line">nmap tl :Tlist&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">&quot;python补全</span><br><span class="line">let g:pydiction_location = &apos;~/.vim/after/complete-dict&apos;</span><br><span class="line">let g:pydiction_menu_height = 20</span><br><span class="line">let Tlist_Ctags_Cmd=&apos;/usr/local/bin/ctags&apos;</span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1</span><br><span class="line">let g:miniBufExplMapWindowNavArrows = 1</span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1</span><br><span class="line">let g:miniBufExplModSelTarget = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set iskeyword+=.</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf8</span><br><span class="line">set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030</span><br><span class="line"></span><br><span class="line">autocmd FileType python set omnifunc=pythoncomplete#Complete</span><br><span class="line"></span><br><span class="line">&quot;set nocompatible               &quot; be iMproved</span><br><span class="line">&quot;filetype off                   &quot; required!</span><br><span class="line"></span><br><span class="line">set rtp+=~/.vim/bundle/vundle/</span><br><span class="line">call vundle#rc()</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle</span><br><span class="line">&quot; required!</span><br><span class="line">Bundle &apos;gmarik/vundle&apos;</span><br><span class="line"></span><br><span class="line">&quot; My Bundles here:</span><br><span class="line">&quot;</span><br><span class="line">&quot; original repos on github</span><br><span class="line">Bundle &apos;tpope/vim-fugitive&apos;</span><br><span class="line">Bundle &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;</span><br><span class="line">Bundle &apos;Yggdroot/indentLine&apos;</span><br><span class="line">let g:indentLine_char = &apos;┊&apos;</span><br><span class="line">&quot;ndle &apos;tpope/vim-rails.git&apos;</span><br><span class="line">&quot; vim-scripts repos</span><br><span class="line">Bundle &apos;L9&apos;</span><br><span class="line">Bundle &apos;FuzzyFinder&apos;</span><br><span class="line">&quot; non github repos</span><br><span class="line">Bundle &apos;https://github.com/wincent/command-t.git&apos;</span><br><span class="line">Bundle &apos;Auto-Pairs&apos;</span><br><span class="line">Bundle &apos;python-imports.vim&apos;</span><br><span class="line">Bundle &apos;CaptureClipboard&apos;</span><br><span class="line">Bundle &apos;ctrlp-modified.vim&apos;</span><br><span class="line">Bundle &apos;last_edit_marker.vim&apos;</span><br><span class="line">Bundle &apos;synmark.vim&apos;</span><br><span class="line">&quot;Bundle &apos;Python-mode-klen&apos;</span><br><span class="line">Bundle &apos;SQLComplete.vim&apos;</span><br><span class="line">Bundle &apos;Javascript-OmniCompletion-with-YUI-and-j&apos;</span><br><span class="line">&quot;Bundle &apos;JavaScript-Indent&apos;</span><br><span class="line">&quot;Bundle &apos;Better-Javascript-Indentation&apos;</span><br><span class="line">Bundle &apos;jslint.vim&apos;</span><br><span class="line">Bundle &quot;pangloss/vim-javascript&quot;</span><br><span class="line">Bundle &apos;Vim-Script-Updater&apos;</span><br><span class="line">Bundle &apos;ctrlp.vim&apos;</span><br><span class="line">Bundle &apos;tacahiroy/ctrlp-funky&apos;</span><br><span class="line">Bundle &apos;jsbeautify&apos;</span><br><span class="line">Bundle &apos;The-NERD-Commenter&apos;</span><br><span class="line">&quot;django</span><br><span class="line">Bundle &apos;django_templates.vim&apos;</span><br><span class="line">Bundle &apos;Django-Projects&apos;</span><br><span class="line"></span><br><span class="line">&quot;Bundle &apos;FredKSchott/CoVim&apos;</span><br><span class="line">&quot;Bundle &apos;djangojump&apos;</span><br><span class="line">&quot; ...</span><br><span class="line">let g:html_indent_inctags = &quot;html,body,head,tbody&quot;</span><br><span class="line">let g:html_indent_script1 = &quot;inc&quot;</span><br><span class="line">let g:html_indent_style1 = &quot;inc&quot;</span><br><span class="line"></span><br><span class="line">filetype plugin indent on     &quot; required!</span><br><span class="line">&quot;</span><br><span class="line">&quot;ctrlp设置</span><br><span class="line">&quot;</span><br><span class="line">set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.png,*.jpg,*.gif     &quot; MacOSX/Linux</span><br><span class="line">set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe,*.pyc,*.png,*.jpg,*.gif  &quot; Windows</span><br><span class="line"></span><br><span class="line">let g:ctrlp_custom_ignore = &apos;\v[\/]\.(git|hg|svn)$&apos;</span><br><span class="line">let g:ctrlp_custom_ignore = &apos;\v\.(exe|so|dll)$&apos;</span><br><span class="line">let g:ctrlp_extensions = [&apos;funky&apos;]</span><br><span class="line"></span><br><span class="line">let NERDTreeIgnore=[&apos;\.pyc&apos;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim精简版（常用）</title>
      <link href="/2019/06/02/Vim%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/"/>
      <url>/2019/06/02/Vim%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/06/02/Vim精简版（常用）/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//光标</span><br><span class="line">h、j、k、l分别代表左下上右</span><br><span class="line">0代表行首，$代表行尾</span><br><span class="line">gg代表文件的开头，G代表文件的末尾</span><br><span class="line">nG或者ngg代表第n行</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">x删除所在字符</span><br><span class="line">dw删除所在单词</span><br><span class="line">d0从行首删到光标前</span><br><span class="line">d$从光标删到行尾</span><br><span class="line">dd删除所在行</span><br><span class="line">ndd 删除光标所在行开始的n行</span><br><span class="line"></span><br><span class="line">//撤销</span><br><span class="line">u撤销</span><br><span class="line">ctrl+r反撤销</span><br><span class="line"></span><br><span class="line">//复制粘贴</span><br><span class="line">yy复制一行</span><br><span class="line">nyy 从光标所在行起复制n行</span><br><span class="line">p粘贴到光标所在下一行</span><br><span class="line">P粘贴到光标所在上一行</span><br><span class="line"></span><br><span class="line">//查找</span><br><span class="line">/string从顶部开始查找文件中所有string</span><br><span class="line">?string 从底部开始查找文件中所有string</span><br><span class="line">n/N通过n/N进行下一个/上一个依次遍历</span><br><span class="line"># 查找光标所在字符串</span><br><span class="line"></span><br><span class="line">//代码格式化</span><br><span class="line">&gt;&gt;/&lt;&lt;当前行右移/左移一个tab</span><br><span class="line">n&gt;&gt;/n&lt;&lt;当前光标所在行向下n行右移/左移一个tab</span><br><span class="line">gg=G一键格式化</span><br><span class="line"></span><br><span class="line">//MAN手册</span><br><span class="line">K查看光标所在函数的man手册（若指定类型，需在K前加数字类型）</span><br><span class="line"></span><br><span class="line">//可视模式</span><br><span class="line">v进入可视模式，然后通过y(复制),p(粘贴),d（删除）进行操作</span><br><span class="line"></span><br><span class="line">//插入模式</span><br><span class="line">i/a光标前，光标后进入插入模式</span><br><span class="line">o/O光标下一行，上一行进入插入模式</span><br><span class="line"></span><br><span class="line">//末行模式</span><br><span class="line">:进入末行模式</span><br><span class="line">!shell在末行模式下加!和shell命令可以执行shell命令</span><br><span class="line">s/s1/s2/ 替换光标后第一个匹配的s1</span><br><span class="line">s/s1/s2/g 替换该行所有匹配的s1</span><br><span class="line">%s/s1/s2/替换每一行第一个匹配的s1</span><br><span class="line">%s/s1/s2/g替换所有匹配的s1</span><br><span class="line">sp/vspfilename 横着/竖着分屏</span><br><span class="line">q/qall退出/全部退出</span><br><span class="line">w/wall保存/全部保存</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳10-tcpdump和Wireshark下篇</title>
      <link href="/2019/06/02/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B310-tcpdump%E5%92%8CWireshark%E4%B8%8B%E7%AF%87/"/>
      <url>/2019/06/02/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B310-tcpdump%E5%92%8CWireshark%E4%B8%8B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/06/02/Linux复习归纳10-tcpdump和Wireshark下篇/title10.jpg" alt="title10"></p><a id="more"></a><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux复习归纳10～</p><h2 id="tcpdump和Wirshark"><a href="#tcpdump和Wirshark" class="headerlink" title="tcpdump和Wirshark"></a>tcpdump和Wirshark</h2><h4 id="抓到的报文格式"><a href="#抓到的报文格式" class="headerlink" title="抓到的报文格式"></a>抓到的报文格式</h4><p><img src="/2019/06/02/Linux复习归纳10-tcpdump和Wireshark下篇/2.png" alt="2"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一列：时间戳,分别代表时、分、秒、微秒</span><br><span class="line">第二列：网际网路协议名称</span><br><span class="line">第三列：报文发送方的网际网路协议地址和端口</span><br><span class="line">第四列：&gt; (用于指向接收方)</span><br><span class="line">第五列：报文接收方的网际网路协议地址和端口(有时不是端口而是协议名比如http)</span><br><span class="line">第六列：:</span><br><span class="line">第七列：Flags标识，可能取值是[S.] [.] [P.] [F.]等(标识有SYN表示建立连接,FIN表示关闭连接,ACK表示相应,PSH表示有数据传输，RST表示连接重置，其中ACK可能与SYN、FIN等同时使用，SYN与FIN不可能同时为1，RST一般在FIN后才会出现1的情况，PSH表示有真正的tcp数据包内容被传递)</span><br><span class="line">之后列是tcp协议报文头的一些变量值，比如seq为请求同步的序列号，ack是已同步的序列号,win是当前可用窗口大小，length是tcp协议报文体的长度</span><br></pre></td></tr></table></figure><h4 id="tcpdump抓取网站网络数据实例"><a href="#tcpdump抓取网站网络数据实例" class="headerlink" title="tcpdump抓取网站网络数据实例"></a>tcpdump抓取网站网络数据实例</h4><ol><li>通过tcpdump截取主机<a href="http://www.baidu.com发送与接收的所有数据包" target="_blank" rel="noopener">www.baidu.com发送与接收的所有数据包</a></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i en0 host www.baidu.com</span><br></pre></td></tr></table></figure><ol start="2"><li>访问这个网站</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget www.baidu.com</span><br></pre></td></tr></table></figure><ol start="3"><li>此时tcpdump会出现以下包信息：</li></ol><p><img src="/2019/06/02/Linux复习归纳10-tcpdump和Wireshark下篇/1.png" alt="1"></p><p>​    我们发现三次握手中第三次时ACK为1，其实这是相对值，我们可以通过下面命令获取ACK的绝对值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -S -i en0 host www.baidu.com</span><br></pre></td></tr></table></figure><ol start="4"><li>若想要看到详细的http报文，可以通过下面命令：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -A -i en0 host www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="关于Wireshark"><a href="#关于Wireshark" class="headerlink" title="关于Wireshark"></a>关于Wireshark</h3><h4 id="关于Wireshark-1"><a href="#关于Wireshark-1" class="headerlink" title="关于Wireshark"></a>关于Wireshark</h4><p>​    Wireshark用于捕获机器上某块网卡的网络包（如果一个机器有多个网卡，可以指定其中一个网卡）。出于安全考虑，它不可以修改封包的内容或者发送封包。它也不能解密https（也就是所看不懂https中的内容，如果只处理http和https，可以考虑Fiddler）</p><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ol><li>抓包来分析测试自己的软件</li><li>用wireshark来检查网络问题</li><li>socket编程会用wireshark来调试</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>先选定需要捕获哪个网卡的网络包</li><li>主界面中从上往下依次是显示过滤器（用于过滤）、封包列表（显示捕获到的封包）、封包详细信息、16进制数据、地址栏（杂项）</li><li>右键想要查找的报文-&gt;跟踪流-&gt;tcp流即可</li></ol><h4 id="关于过滤器"><a href="#关于过滤器" class="headerlink" title="关于过滤器"></a>关于过滤器</h4><p>​    封包列表中会有大量的冗余无用信息，我们可以利用过滤器将其过滤掉。过滤器有两种，一种是显示过滤器（主界面最上面），另一种是捕获过滤器（设置捕获的数据类型，在捕获-&gt;捕获过滤器中设置）</p><p>​    过滤分为协议过滤（比如tcp、udp等）、ip过滤（比如ip.src==192.168.1.30代表显示原地址为192.168.1.30的数据报，ip.dst==192.168.2.31代表显示目标地址为192.168.2.31的数据包）、端口过滤（比如tcp.port==80代表显示端口号为80的，tcp.srcport==80代表源端口号为80的）、http模式过滤（比如http.request.method==”GET”代表只显示get方法），它们可以通过逻辑运算符连接（AND/OR）</p><h4 id="关于封包详细信息"><a href="#关于封包详细信息" class="headerlink" title="关于封包详细信息"></a>关于封包详细信息</h4><p>​    封包详细信息最多有5行，分别是Frame（物理层的数据帧概况）、Ethernet II（数据链路层以太网帧头部信息）、Internet Protocol Version 4（网络层IP包头部信息）、Transmission Control Protocol（传输层的数据段头部信息，此处是TCP）、Hypertext Transfer Protocol（应用层的信息，此处是HTTP协议）</p><p>​    其中对于传输层的详细信息来说，source port为源端口，destination port为目的端口，sequence number为序列号，acknowledgment. number为确认号，Header Length为报头长度，flags为标志位，window size value 为窗口大小，checksum为校验和，</p><h3 id="关于三次握手四次挥手"><a href="#关于三次握手四次挥手" class="headerlink" title="关于三次握手四次挥手"></a>关于三次握手四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>由客户端向服务器端发起TCP连接请求（同步序列编号SYN置为1，发送序号Seq为一个随机数（避免黑客通过伪装发送数据报）假设为X）</li><li>服务器端接收到连接请求（同步序列编号SYN置为1，并将确认序号ACK置为X+1，然后生成一个随机数Y（与X同理）作为发送序号Seq）</li><li>客户端对接收到的确认进行确认（将确认序号ACK置为Y+1，然后将发送序号Seq置为X+1）</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>​    双方完成数据传输后就需要断开连接，由于tcp属于全双工通道，因此可以在一条tcp连接上相互传输数据，因此在一方失去发送数据的能力时，存在一个半关闭的状态，使得其还可以接收数据。这时就需要四次挥手</p><ol><li>A向B发起断开连接请求（关闭序列编号FIN置为1，发送序号Seq假设为X），A进入FIN-WAIT-1状态；(第一次挥手)</li><li>B收到断开请求后向A发送确认（ACK置为1，发送序号Seq假设为Y，然后ack为X+1），然后进入CLOSE-WAIT状态；(第二次挥手)</li><li>A收到B的确认后，进入FIN-WAIT-2状态（半关闭状态）</li><li>过一段时间后，B向A发出断开连接请求（ACK置为1，关闭序列编号FIN置为1，发送序号Seq假设为Z，然后ack为X+1），然后进入LAST-ACK状态 (第三次挥手)</li><li>A接收到请求后发送确认（ACK置为1，发送序号Seq为X+1，然后ack为Z+1），进入TIME-WAIT状态，等待2MSL之后进入CLOSED状态 (第四次挥手)</li><li>B收到确认后进入CLOSED状态</li></ol><h4 id="问题一：为什么至少三次挥手"><a href="#问题一：为什么至少三次挥手" class="headerlink" title="问题一：为什么至少三次挥手"></a>问题一：为什么至少三次挥手</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. tcp是一个全双工通道，它建立连接的基础是双方都需要确保自己具有接收对方信息和给对方发送信息的能力，而三次则是理论上的最小值(第一次服务端能确认自己有接收能力，客户端有发送能力；第二次客户端能确认客户端和服务端都有接收和发送能力；第三次服务端能确定服务端和客户端都有接收和发送能力)</span><br><span class="line">2. 客户端向服务端发送一个请求，服务端收到后会返回一个确认报文。而此时客户端断开连接，服务端却单方面认为连接成功，而等待客户端的动作，从而导致服务端开销增大</span><br></pre></td></tr></table></figure><h4 id="问题二：第四次挥手为什么需要等待2MSL"><a href="#问题二：第四次挥手为什么需要等待2MSL" class="headerlink" title="问题二：第四次挥手为什么需要等待2MSL"></a>问题二：第四次挥手为什么需要等待2MSL</h4><ol><li>确保A最后发送的确认能够到达B(如果B收不到会超时重传FIN给A)，至于2MSL能够保证A游足够的时间去再次发送确认</li><li>如果没有等待2MSL直接到close状态。那么当A再次向B发起连接请求，若该请求报文的包比上一次连接的最后一次挥手确认的包更早的到达B。那么B会以为这个连接为失效连接。等待2MSL可以尽量避免这种情况的出现</li></ol><h4 id="问题三：为什么断开连接请求报文只有三个，而不是4个？"><a href="#问题三：为什么断开连接请求报文只有三个，而不是4个？" class="headerlink" title="问题三：为什么断开连接请求报文只有三个，而不是4个？"></a>问题三：为什么断开连接请求报文只有三个，而不是4个？</h4><p>​    在tcp连接过程中，确认的发送有一个延时，一端在发送确认的时候将等待一段时间。如果在这段时间内自己也有数据要发送，那就跟确认一起发送，如果没有则单独发送。（服务端先断开连接，客户端在确认的时延内有也有请求断开连接需要发送，于是和确认一起发送，因此只有三个数据报）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习与归纳9-tcpdump和wirshark上篇</title>
      <link href="/2019/05/23/Linux%E5%A4%8D%E4%B9%A0%E4%B8%8E%E5%BD%92%E7%BA%B39-tcpdump%E4%B8%8A%E7%AF%87/"/>
      <url>/2019/05/23/Linux%E5%A4%8D%E4%B9%A0%E4%B8%8E%E5%BD%92%E7%BA%B39-tcpdump%E4%B8%8A%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/23/Linux复习与归纳9-tcpdump上篇/title7.jpg" alt="title7"></p><a id="more"></a><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux复习与归纳9～</p><h2 id="tcpdump和Wirshark"><a href="#tcpdump和Wirshark" class="headerlink" title="tcpdump和Wirshark"></a>tcpdump和Wirshark</h2><p>​    tcpdump可用于网络问题的调试，它是基于Unix系统命令行式的数据包嗅探工具，可以抓取流动在网卡上的数据包。</p><p>​    tcpdump只能抓取流经本机的数据包。如果要抓取其它主机MAC地址的数据包，必须开启网卡混杂模式(就是允许网卡抓取任何经过它的数据包，不管该数据包是不是发给它的)</p><p>​    开启混杂模式的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ifconfig en0 promisc//en0时要打开混杂模式的网卡</span><br></pre></td></tr></table></figure><h3 id="抓包原理"><a href="#抓包原理" class="headerlink" title="抓包原理"></a>抓包原理</h3><p>​    通过注册一种虚拟的底层网络协议来获取对网络报文的处理权。当网卡接收到一个网络报文后，它会遍历系统中所有已经注册的网络协议来尝试对报文进行解析。</p><p>​    此时抓包模块会把自己伪装成一个网络协议，系统也会让这个伪协议对报文进行处理。这时候模块就会趁机对报文进行窥探(也就是拷贝)，然后汇报给抓包模块。</p><h3 id="tcpdump和Wireshark优劣"><a href="#tcpdump和Wireshark优劣" class="headerlink" title="tcpdump和Wireshark优劣"></a>tcpdump和Wireshark优劣</h3><p>​    linux可以直接使用tcpdump，有图形界面平台下可以使用Wireshark。其中，tcpdump用来抓取数据非常方便，Wireshark用于分析抓取到的数据比较方便</p><h3 id="关于tcpdump"><a href="#关于tcpdump" class="headerlink" title="关于tcpdump"></a>关于tcpdump</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>格式和常用参数为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump [options] [expression]</span><br></pre></td></tr></table></figure><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//-D 列出可用于抓包的接口(包括编号和接口名)</span><br><span class="line">//-c 用于指定最终要获取的包数量(满足条件的包数量)</span><br><span class="line">//-i 用于指定tcpdump要监听的接口(若没有指定，系统会从接口列表中搜寻编号最小的已配置好的接口)</span><br><span class="line">//-e 输出每行都包括数据链路层头部信息，例如源MAC和目标MAC</span><br><span class="line">//-nn 对地址、端口以数字的方式显示(否则为主机名、端口服务名)</span><br><span class="line">//-XX 输出包的头部数据，会以16进制和ASCII两种方式同时输出(相比-X更详细)</span><br><span class="line">//-vvv当分析和打印的时候，产生详细的输出(相比-v，-vv更详细)</span><br><span class="line">//-s len 设置tcpdump数据包抓取长度为len(默认为65535字节)，长度不够会产生包截断，但是长度过长会导致包的处理时间越长(在保证能抓到想要包的前提下，长度越小越好)</span><br><span class="line">//-w 将抓包数据输出到文件中，配合&quot;-G time&quot;每time秒就自动切换到另外一个文件</span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>​    表达式用于筛选输出哪些类型的数据包，表达式出现元字符建议用单引号扩起。</p><p>​    表达式由一个或多个”单元”组成，每个单元一般包含ID的修饰符和一个ID：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表达式的单元格式为：proto dir type ID</span><br><span class="line"></span><br><span class="line">type: 指定ID的类型(包括host(指明主机,例如host 210.27.48.2)、net(指明网络地址,例如net 202.0.0.0)、port(指明端口号，例如port 70)、protrange(指明)，默认为host)</span><br><span class="line"></span><br><span class="line">dir: 指定ID的方向(包括src（源）、dst（目的）、src or dst（源或目的）、src and dst（源和目的），默认为src or dst)</span><br><span class="line"></span><br><span class="line">proto: 通过给定协议限定匹配的数据包类型(常用协议有tcp、udp、arp、ip、ether、icmp)</span><br></pre></td></tr></table></figure><p>​    除了上述表达式单元外，还有关键字表达式单元：gateway、broadcast、less、greater以及算术表达式。</p><p>​    表达式单元之间可以通过&amp;&amp;、||、!、and、or、not连接，从而组成更复杂的条件表达式。</p><p>​    使用()可以改变表达式优先级，注意()需要用\转义</p><h4 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 直接启动，默认抓取所有经过第一个网络接口上(一般是eth0)的数据包</span><br><span class="line">$ tcpdump</span><br><span class="line"></span><br><span class="line">2. 抓取所有经过指定网络接口上的数据包</span><br><span class="line">$ tcpdump -i en0</span><br><span class="line"></span><br><span class="line">3. 抓取所有经过en0，目的或源地址是10.37.63.255的网络数据</span><br><span class="line">$ tcpdump -i en0 host 10.37.63.255</span><br><span class="line"></span><br><span class="line">4. 抓取主机10.37.63.255和主机10.37.63.61或10.37.63.95的通信</span><br><span class="line">$ tcpdump host 10.37.63.255 &amp;&amp; \( 10.37.63.61 || 10.37.63.95 \)</span><br><span class="line"></span><br><span class="line">5. 抓取主机192.168.13.210除了和10.37.63.61以外的所有主机通信的数据包</span><br><span class="line">$ tcpdump host 192.168.13.210 &amp;&amp; \( ! 10.37.63.61 \)</span><br><span class="line"></span><br><span class="line">6. 抓取主机192.168.13.210和10.37.63.61通信的ip包</span><br><span class="line">$ tcpdump ip host 192.168.13.210 &amp;&amp; 10.37.63.61</span><br><span class="line"></span><br><span class="line">7. 抓取主机10.37.63.3发送的所有数据</span><br><span class="line">$ tcpdump -i en0 src host 10.37.63.3</span><br><span class="line"></span><br><span class="line">8. 抓取主机10.37.63.3接收的所有数据</span><br><span class="line">$ tcpdump -i en0 dst host 10.37.63.3</span><br><span class="line"></span><br><span class="line">9. 抓取主机10.37.63.3所有在TCP 80端口的数据包</span><br><span class="line">$ tcpdump -i en0 host 10.37.63.3 &amp;&amp; tcp port 80</span><br><span class="line"></span><br><span class="line">10. 抓取HTTP主机10.37.63.3在80端口接收到的数据包</span><br><span class="line">$ tcpdump -i en0 http host 10.37.63.3 &amp;&amp; dst port 80</span><br><span class="line"></span><br><span class="line">11. 抓取所有经过en0，目的或源端口是25的网络数据</span><br><span class="line">$ tcpdump -i en0 port 25</span><br><span class="line"></span><br><span class="line">12. 抓取所有经过 en0，网络是 192.168上的数据包</span><br><span class="line">$ tcpdump -i en0 net 192.168</span><br><span class="line"></span><br><span class="line">13. 抓取所有经过en0，目的地址是192.168.1.254或192.168.1.200，端口是80的TCP数据</span><br><span class="line">$ tcpdump -i en0 tcp &amp;&amp; dst &amp;&amp; port 80 &amp;&amp; \( host 192.168.1.254 || host 192.168.1.20 \)</span><br><span class="line"></span><br><span class="line">14. 抓取所有经过en0，目标MAC地址是00:01:02:03:04:05的ICMP数据</span><br><span class="line">$ tcpdump -i en0 icmp &amp;&amp; ether dst host 00:01:02:03:04:05</span><br><span class="line"></span><br><span class="line">15. 抓取所有经过en0，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据</span><br><span class="line">$ tcpdump -i en0 tcp &amp;&amp; \( dst net 192.168 &amp;&amp; \( ! dst host 192.168.1.200 \) \)</span><br><span class="line"></span><br><span class="line">16. 只抓SYN包</span><br><span class="line">$ tcpdump -i en0 &apos;tcp[tcpflags] = tcp-syn&apos;</span><br><span class="line"></span><br><span class="line">17. 抓SYN, ACK</span><br><span class="line">$ tcpdump -i en0 &apos;tcp[tcpflags]&apos;</span><br><span class="line"></span><br><span class="line">18. 抓SMTP数据，抓取数据区开始为”MAIL”的包，”MAIL”的十六进制为0x4d41494c</span><br><span class="line">$ tcpdump -i en0 &apos;port 25 &amp;&amp; tcp[(tcp[12]&gt;&gt;2):4] = 0x4d41494c&apos;</span><br><span class="line"></span><br><span class="line">19. 抓 HTTP GET数据，”GET “的十六进制是0x47455420</span><br><span class="line">$ tcpdump -i en0 &apos;tcp[ \( tcp[12]&gt;&gt;2 \) :4] = 0x47455420&apos;</span><br><span class="line"></span><br><span class="line">20. 抓ssh返回，”SSH-“的十六进制是 0x5353482D</span><br><span class="line">$ tcpdump -i en0 &apos;tcp[ \( tcp[12]&gt;&gt;2 \) :4] = 0x5353482D&apos;</span><br><span class="line"></span><br><span class="line">21. 抓取端口大于1024的tcp数据包</span><br><span class="line">$ tcpdump -i en0 &apos;tcp[0:2] &gt; 1024&apos;</span><br><span class="line"></span><br><span class="line">22. 抓DNS请求数据</span><br><span class="line">$ tcpdump -i en0 udp dst port 53</span><br><span class="line"></span><br><span class="line">23. 通过抓n个SYN包花费多少时间，可以用于判断访问量</span><br><span class="line">time tcpdump -i en0 &apos;tcp[tcpflags] = tcp-syn&apos; -c 10000 &gt; /dev/null</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳8-练习题</title>
      <link href="/2019/05/23/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B38-%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2019/05/23/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B38-%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/23/Linux复习归纳8-练习题/title6.jpg" alt="title6"></p><a id="more"></a><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux复习归纳8～</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><img src="/2019/05/23/Linux复习归纳8-练习题/h.png" alt="h"></p><p>Case 1:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $[`tr -s -c '0-9' '+' '+' &lt; test.txt`0]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test.txt | tr 'A-Z' 'a-z'</span><br></pre></td></tr></table></figure><p>文件重命名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv Words.sh `echo Words.sh | tr &apos;a-z&apos; &apos;A-Z&apos;`</span><br></pre></td></tr></table></figure><p>Case 2:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH | tr ':' '\n' | tail -1</span><br></pre></td></tr></table></figure><p>*Case 3:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export | cut -c 12-</span><br></pre></td></tr></table></figure><p>Case 4:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">last | grep shutdown</span><br></pre></td></tr></table></figure><p>Case 5:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | sort -t : -k 1</span><br></pre></td></tr></table></figure><p>Case 6:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | sort -n -t : -k 3</span><br></pre></td></tr></table></figure><p>*Case 7:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">last | grep [a-zA-Z] | grep -v "wtmp begins" | grep -v "reboot" | grep -v "shutdown" | wc -l</span><br></pre></td></tr></table></figure><p>*Case 8:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">last | grep [a-zA-Z] | grep -v "wtmp begins" | grep -v "reboot" | grep -v "shutdown" | cut -d ' ' -f 1 | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure><p>Case 9:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc &gt; ml.txt</span><br><span class="line">split -l 10 ml.txt</span><br></pre></td></tr></table></figure><p>*Case 10:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | head -n 20 | tail -n 10 | cut -d : -f 1 | xargs -n 1 id</span><br></pre></td></tr></table></figure><p>Case 11:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d : -f 1 /etc/passwd | xargs -e"sync" -n 1 id</span><br></pre></td></tr></table></figure><p>Case 12:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat a.txt | tr -s ' ' '\n' | sort | uniq -c | sort -r</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳7-awk</title>
      <link href="/2019/05/23/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B37-awk/"/>
      <url>/2019/05/23/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B37-awk/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/23/Linux复习归纳7-awk/title5.jpg" alt="title5"></p><a id="more"></a><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux复习归纳7～</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>​    AWK适合文本处理和报表生成，最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息。它是以文件的一行作为处理单位。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &apos;&#123;pattern + action&#125;&apos; &#123;filenames&#125;//其中pattern表示查找的内容，action是找到匹配内容后执行的一系列命令</span><br></pre></td></tr></table></figure><p>​    举个简单的例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. echo ok | awk &apos;&#123;print &quot;hello,world&quot;&#125;&apos;//输出hello,world</span><br><span class="line"></span><br><span class="line">2. echo ok | awk &apos;&#123;print $0&#125;&apos;//输出ok</span><br><span class="line"></span><br><span class="line">3. awk &apos;&#123;print &quot;ok&quot;&#125;&apos; /etc/passwd//若passwd文件有n行，那么会输出n行ok</span><br><span class="line"></span><br><span class="line">4. awk &apos;&#123;print $0&#125;&apos; /etc/passwd//原样输出passwd文件</span><br></pre></td></tr></table></figure><p>​    对于一条数据<code>nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false</code>来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$0//代表一整行的数据</span><br><span class="line">$1~$n//分别代表一行中不同段的数据</span><br><span class="line">NF//代表字段的数量</span><br><span class="line">NR//代表记录的数量(一行代表一条记录)</span><br><span class="line">FS//代表字段的分隔符(默认为空格，对于上面的数据为:)</span><br><span class="line">RS//代表记录的分隔符(默认为\n)</span><br></pre></td></tr></table></figure><h3 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h3><p>对于这个字段分隔符，我们可以通过-F来指定(可以同时指定多个分隔符)，具体用法是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &quot;:&quot; &apos;&#123;print &quot;name:&quot; $1 &quot;\tuid:&quot; $3&#125;&apos; /etc/passwd</span><br><span class="line"></span><br><span class="line">除此之外还有另一种方法：</span><br><span class="line">$ awk &apos;&#123;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print &quot;name:&quot; $1 &quot;\tuid:&quot; $3&#125;&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure><p>​    比如查找一个文件从第5行到第8行的内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;if(NR&gt;=5 &amp;&amp; NR&lt;=8) print $0&#125;&apos; test.txt</span><br></pre></td></tr></table></figure><h3 id="BEGIN和END模块"><a href="#BEGIN和END模块" class="headerlink" title="BEGIN和END模块"></a>BEGIN和END模块</h3><p>​    在一些情况下，需要在awk处理文本文件前执行初始化代码（比如用于定义全局变量），该代码存储在BEGIN块中。</p><p>​    在一些情况下，也需要在awk处理完文本文件的全部内容后执行某些代码块（比如用于最终计算）。这时可以将该代码存储在END块中。</p><p>​    比如输出passwd文件内容并计算得到行数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;count=0;&#125; &#123;count+=count;print $0&#125; END &#123;print &quot;count is &quot;,count&#125;&apos;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 关系运算符可以用作数值比较，也可用作字符串比较(双方都是数字，自动看作数值比较，否则即为字符串比较)</span><br></pre></td></tr></table></figure><ol start="2"><li>所有算术运算符的操作，都会将操作数自动转为数值(字符串也会自动转为数值，非数值都变为0)</li></ol><h3 id="支持的结构"><a href="#支持的结构" class="headerlink" title="支持的结构"></a>支持的结构</h3><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>​    awk支持if、elseif、else的条件语句</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>​    awk支持while、do…while循环语句，也支持for循环语句(for循环支持标准和for…in)</p><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p>​    awk支持break、continue等跳转语句</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>​    awk数组属于关联数组，数字索引会转变为字符串索引(数组的下角标为字符串)，因此数组默认是无序的。</p><p>printf()输出</p><p>​    当然，awk也兼容C中的printf()函数的用法，两者用法一致。</p><h3 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub(Ere, Repl, [ln])//用Repl替换ln中Ere指定的正则表达式的第一个匹配值，返回替换的数量</span><br><span class="line">gsub(Ere, Repl, [ln])//用Repl替换ln中Ere指定的正则表达式的全部匹配值，返回替换的数量</span><br><span class="line">index(string1, string2) //判断string2是否在string1中出现，若出现返回第一次出现的下标(下标从1开始)，否则返回0</span><br><span class="line">length(string)//返回string的长度</span><br><span class="line">match(string, Ere)//返回string中出现Ere指定的正则表达式的位置(下标从1开始)，否则返回0</span><br><span class="line">substr(string, M, [N])//截取string中[M, M+N-1]的子串，若未指定N，则直到string尾部</span><br><span class="line">tolower(string)//全部转小写</span><br><span class="line">toupper(string)//全部转大写</span><br><span class="line">sprintf(Format, Expr...)//格式化字符串</span><br><span class="line">split(string, A, [Ere])//将string根据指定分隔符Ere将其分割为字符串数组A[1]..A[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳6-sed</title>
      <link href="/2019/05/20/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B36-sed/"/>
      <url>/2019/05/20/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B36-sed/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/20/Linux复习归纳6-sed/title2.jpg" alt="title2"></p><a id="more"></a><h1 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h1><p>Linux复习归纳6～</p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>​    sed是一种流编辑器，能够完美配合正则表达式。</p><p>​    它会先把要处理的行存储在临时缓冲区，接着用sed命令处理缓冲区的内容。处理完成后把缓冲区的内容输出到屏幕，接着处理下一行直到文件末尾。</p><p>​    sed常见的参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-n//取消默认的完整输出，只要需要的</span><br><span class="line">-e//允许多项编辑</span><br><span class="line">-i//修改文件内容</span><br><span class="line">-r//不需要转义</span><br></pre></td></tr></table></figure><p>​    sed常见命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a\在当前行最后添加一行或多行（多行除了最后一行外，其余每行末尾都要加\）</span><br><span class="line">c\此符号后的内容替换当前行的内容（多行除了最后一行外，其余每行末尾都要加\）</span><br><span class="line">i\当前行之前插入一行或多行（多行除了最后一行外，其余每行末尾都要加\）</span><br><span class="line">&amp;代表上次匹配的结果</span><br><span class="line">p//输出</span><br><span class="line">d//删除</span><br><span class="line">=//打印匹配行的行号</span><br><span class="line">l//列出非打印字符</span><br><span class="line">$//最后一行</span><br><span class="line">n//读入下一个输入行，并从下一条命令开始对其处理</span><br><span class="line">r//从文件中读取输入行到匹配行后，仅用于显示</span><br><span class="line">w//从文件中读取输入行到匹配行后，会实际写入</span><br><span class="line">!//对所选行以外的所有行应用命令</span><br><span class="line">s//用一个字符串替换另一个</span><br><span class="line">y//将字符替换为另一个字符</span><br><span class="line">g//在行内进行全局替换</span><br><span class="line">h//把模式空间的内容复制到缓冲区</span><br><span class="line">H//把模式空间的内容追加到缓冲区</span><br><span class="line">g//把缓冲区的内容复制到模式空间</span><br><span class="line">G//把缓冲区的内容追加到模式空间</span><br><span class="line">x//交换缓冲区和模式空间的内容</span><br><span class="line">q//结束退出</span><br><span class="line"></span><br><span class="line">//关于命令匹配、删除、替换等操作的范围可以用数字、正则表达式或者两者的组合表示</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 打印文件第一行：</span><br><span class="line">$ sed -n &apos;1p&apos;文件名</span><br><span class="line"></span><br><span class="line">2. 打印1-3行</span><br><span class="line">$ sed -n &apos;1,3p&apos; 文件名</span><br><span class="line"></span><br><span class="line">3. 打印所有包含特定字符串&quot;string&quot;的行</span><br><span class="line">$ sed -n &apos;/string/p&apos; 文件名</span><br><span class="line"></span><br><span class="line">4. 打印从包含&quot;string1&quot;的行到包含&quot;string2&quot;的所有行</span><br><span class="line">$ sed -n &apos;/string1/,/string2/p&apos; 文件名</span><br><span class="line"></span><br><span class="line">5. 打印包含&quot;string&quot;的行号</span><br><span class="line">$ sed -n &apos;/string/=&apos; 文件名</span><br><span class="line"></span><br><span class="line">6. 打印包含&quot;string&quot;的行和行号</span><br><span class="line">$ sed -n -e &apos;/string/p&apos; -e &apos;/string/=&apos; 文件名</span><br><span class="line"></span><br><span class="line">7. 打印最后一行</span><br><span class="line">$ sed -n &apos;$p&apos; 文件名</span><br><span class="line"></span><br><span class="line">8. 用字符串&quot;string1&quot;替换为&quot;string2&quot;</span><br><span class="line">$ sed -i &apos;s/string1/string2/g&apos; 文件名（其中s为替换，g为全部替换）</span><br><span class="line"></span><br><span class="line">9. 文件第一行添加&quot;string1&quot;，最后一行添加&quot;string2&quot;</span><br><span class="line">$ sed -i -e &apos;1i string1&apos; -e &apos;$a string2&apos; 文件名(1代表第一行，$代表最后一行)</span><br><span class="line"></span><br><span class="line">10. 文件第1-4行每行下面添加&quot;string&quot;</span><br><span class="line">$ sed -i &apos;1,4a string&apos; 文件名</span><br><span class="line"></span><br><span class="line">11. 删除从1-3行</span><br><span class="line">$ sed -i &apos;1,3d&apos; 文件名</span><br><span class="line"></span><br><span class="line">12.删除从&apos;string1&apos;到第10行的所有行</span><br><span class="line">$ sed -i &apos;/string1/,10d&apos; 文件名</span><br><span class="line"></span><br><span class="line">13. 将a.txt文件中的内容显示到包含“string”的行后</span><br><span class="line">$ sed &apos;/sring/ r a.txt&apos; 文件名</span><br><span class="line"></span><br><span class="line">14. 将a.txt文件中的内容写入到包含“string”的行后</span><br><span class="line">$ sed &apos;/sring/ w a.txt&apos; 文件名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳5-top</title>
      <link href="/2019/05/18/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B35-top/"/>
      <url>/2019/05/18/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B35-top/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/18/Linux复习归纳5-top/title9.jpg" alt="title9"></p><a id="more"></a><p>用于实时显示进程的状态，默认显示cpu密集型的进程，5秒更新一次。信息包括：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行为任务队列信息：包括当前时间、系统启动持续时间、当前登录用户数、系统负载（也就是任务队列的平均长度）</span><br><span class="line">第二行为进程信息：包括进程总数、正在运行数、睡眠进程数、已停止数、僵尸进程数</span><br><span class="line">第三行为CPU信息：包括us(用户空间占用CPU百分比)、sy(内核空间占用CPU百分比)、ni(用户进程空间内改变过优先级的进程占用CPU百分比)、id(空闲CPU百分比)、wa(等待输入输出的CPU时间百分比)、hi（服务终端）、si（服务软中断）</span><br><span class="line">第三行为内存信息：包括物理内存总量、使用的物理内存总量、空闲内存总量、用作内核缓存的内存量</span><br><span class="line">第四行为swap交换区信息：包括交换区总量、已使用的交换去总量、空闲交换区总量、缓冲的交换区总量（内存中内容被换出到交换区，而后再被换到内存，但使用过的交换区尚未覆盖，该使用过的交换区大小即为缓冲的交换区总量）</span><br><span class="line"></span><br><span class="line">下一部分为有关进程信息的区域，包括：</span><br><span class="line">pid（进程id），user（所有者用户），pr（进程优先级）、ni（nice值，越小优先级越高），virt（进程使用的虚拟内存总量），res（进程使用且未被换出的物理内存大小），shr（共享内存大小），s（进程状态，包括运行、休眠、停止、僵尸、不可中断），time（进程使用cpu总时间），%cpu（CPU时间占用比），%mem（物理内存百分比），command（命令名），swap（进程使用虚拟内存中被换出的大小），code（可执行代码所占内存大小），data（数据段(栈)所占内存大小），ppid（父进程id），uid（所属用户），group（所数组）</span><br></pre></td></tr></table></figure><p>​    常用参数有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -a //按照内存使用情况对进程排序</span><br><span class="line">top -n n//更新n次后终止更新显示</span><br><span class="line">top -d m//每m秒更新一次</span><br><span class="line">top -p n//显示指定进程n的信息</span><br><span class="line">top -s //以强制的安全模式启动top</span><br><span class="line">top -u n//只监视指定uid或用户名的进程</span><br></pre></td></tr></table></figure><p>常用命令有（在top下直接输入，可以在全屏模式和交替显示模式下使用，安全模式下可能有些不能用）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;h&apos; 或者 &apos;?&apos;:帮助</span><br><span class="line">&apos;=&apos;: 退出任务限制</span><br><span class="line">&apos;u&apos;: 选择用户，提示并输入uid或用户名，只显示选定用户的进程</span><br><span class="line">‘k’: 杀死任务，提示并输入pid，然后再发送信号。如果希望中止终止进程，在PID提示符下，按Enter。在信号提示处，键入0</span><br><span class="line">&apos;q&apos;: 退出</span><br><span class="line">&apos;r&apos;: 重新设置任务优先级，提示并输入pid，然后将值设置为nice</span><br><span class="line">&apos;w&apos;: 写入配置文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳4-高级命令</title>
      <link href="/2019/05/18/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B34-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/05/18/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B34-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/18/Linux复习归纳4-高级命令/title3.jpg" alt="title3"></p><a id="more"></a><p>[TOC]</p><h1 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h1><p>LInux复习归纳4～</p><h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>​    用于排序，具体用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort 文件//将文件的每一行作为单位进行比较</span><br><span class="line">-u//用于去除重复行</span><br><span class="line">-n//对于数字文件来说，按照数字进行排序</span><br><span class="line">-o//排序结果重定向到文件（不能用&gt;符）</span><br><span class="line">-r//反序输出</span><br><span class="line">-t 分隔符 -f n//按照分隔符分开的第n段进行排序</span><br></pre></td></tr></table></figure><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>​    用于切割，具体用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -c 范围 文件名//用于指定保留每行的范围(以字符为单位进行分割)</span><br><span class="line">cut -b 范围 文件名//用于指定保留每行的范围(以字节为单位进行分割，用于汉字等)</span><br><span class="line">cut -d &apos;分隔符&apos; -f 范围</span><br><span class="line"></span><br><span class="line">范围格式:a-b（a和b之间），a（a-a），-b（1-b），a-（a到最后），每行下角标从1开始，也可以通过,分隔符分割多个范围</span><br></pre></td></tr></table></figure><p>​    注意，cut命令不会对范围进行指令重排</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>​    用于将一个大文件切分为多个小文件，提高可读性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">split -b size file //将file切分为多个size大小的文件</span><br><span class="line">split -l n file    //将file切分为多个最长为n行的文件</span><br><span class="line">split -d //使用数字作为小文件名后缀（默认为字母）</span><br></pre></td></tr></table></figure><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>​    用于去重，常用参数-c（记录重复次数），-d（只显示重复的行）</p><p>​    可以利用先排序，再uniq的方式，保证文件中每个值的唯一</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>​    可以将tr看作sed的简化版，可以用来进行替换操作，也可以去除一些字符、去重等，具体用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tr [选项] &lt;字符集&gt; &lt;字符集&gt;</span><br><span class="line">tr &apos;12&apos; &apos;34&apos;//将1替换为3，将2替换为4</span><br><span class="line">tr -d &apos;12&apos; //删除所有属于第一个字符集中的字符</span><br><span class="line">tr -s &apos;12&apos; //将字符集中包含的连续重复的字符以单个字符表示（去重）</span><br><span class="line">tr -c &apos;[a-z][0-9]&apos; &apos; &apos; //不满足第一个字符集的字符用字符集二代替</span><br></pre></td></tr></table></figure><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>​    在屏幕上显示的同时，将读取的内容也重定向到指定文件，例如<code>cat file | tee file1</code></p><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>​    常常和管道连用，用于将管道前的输出作为参数传给后面的命令，例如显示查找到的文件的详细信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.c&quot; | xargs ls -al</span><br></pre></td></tr></table></figure><p>​    常见参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xargs -eEOF//xargs读到EOF停止</span><br><span class="line">xargs -e&quot;string&quot;//xargs读到string停止</span><br><span class="line">xargs -n n//后面命令一次需要读入n个参数</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>​        用于检索和过滤，也常常和管道连用，例如检索普通文件类型中包含txt的文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -type f | grep txt</span><br></pre></td></tr></table></figure><p>​    除此之外，还可以检索文件中的内容，具体格式为<code>grep [选项] 内容 文件</code> （当然也可以<code>cat 文件 | grep [选项] 内容</code>），选项比如-w（精确查找），-c（统计查找到的次数），-i（忽略大小写），-n（带行号），-v（反向检索，也就是除内容以外的行）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳3-特殊符号和命令</title>
      <link href="/2019/05/16/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B33-%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/05/16/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B33-%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/16/Linux复习归纳3-特殊符号和命令/title4.jpg" alt="title4"></p><a id="more"></a><h1 id="LINUx"><a href="#LINUx" class="headerlink" title="LINUx"></a>LINUx</h1><p>linux复习归纳3～</p><h2 id="特殊符号和命令"><a href="#特殊符号和命令" class="headerlink" title="特殊符号和命令"></a>特殊符号和命令</h2><h3 id="ctrl-z"><a href="#ctrl-z" class="headerlink" title="ctrl+z"></a>ctrl+z</h3><p>​    对程序进行挂起</p><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>​    对挂起的命令后台运行</p><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>​    可以将后台执行的命令转为前台</p><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>​    可以查看所有在后台执行和挂起的任务</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>​    在命令后加&amp;代表后台执行</p><h3 id=""><a href="#" class="headerlink" title=""></a><code></code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令中如果包含另一个命令，则用``将它括起来，在执行时优先执行``中的子命令，然后将其结果带入父命令继续执行</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>​    具体有以下几种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 内容覆盖</span><br><span class="line">&gt;&gt; 内容追加</span><br><span class="line">&lt; 从文件到命令的重定向</span><br><span class="line">&lt;&lt; 结束符</span><br><span class="line">例如： cat &gt; a &lt;&lt; B //代表直到输入中存在&apos;B&apos;才会结束输入</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*匹配任意多字符</span><br><span class="line">?匹配任意一个字符</span><br><span class="line">[list]匹配list中任意单个字符</span><br><span class="line">[!list]匹配除list的任意单个字符</span><br><span class="line">[c1-c2]匹配c1-c2中任意单个字符</span><br></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">=  变量赋值，左右不能有空格</span><br><span class="line">`` 取命令的执行结果</span><br><span class="line">$  变量值替换，为避免混淆，可使用$&#123;&#125;</span><br><span class="line">|  管道</span><br><span class="line">;  命令结束符</span><br><span class="line">!  执行历史记录中的命令</span><br></pre></td></tr></table></figure><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&apos; 硬转义，内部所有的shell元字符、通配符都会被关掉</span><br><span class="line">&quot;&quot; 软转义，内部只允许出现特定的shell元字符($ ` \)</span><br><span class="line">\  反斜杠，转义，去除后面紧跟着的元字符或通配符的特殊意义</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳2-其它常用命令</title>
      <link href="/2019/05/16/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B32-%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/05/16/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B32-%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/16/Linux复习归纳2-其它常用命令/title1.jpg" alt="title1"></p><a id="more"></a><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><p>复习归纳2～</p><h2 id="查找和检索"><a href="#查找和检索" class="headerlink" title="查找和检索"></a>查找和检索</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>​    find命令用于查找文件，格式为：<code>find 路径 [选项] 内容</code>，它有很多选项，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-name（按照名字查找，比如查找*.c文件，则为-name &quot;*.c&quot;）</span><br><span class="line">-type（按照类型查找，比如查找目录，则为 -type d）</span><br><span class="line">-size（按照大小查找，比如大于1M小于5M，则为-size +1M -size -5M）</span><br><span class="line">-maxdepth（用于规定查找的最深路径，如只查找当前直接路径下，则为-maxdepth 1）</span><br></pre></td></tr></table></figure><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>​    常常和管道连用，用于将管道前的输出作为参数传给后面的命令，例如显示查找到的文件的详细信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -name &quot;*.c&quot; | xargs ls -al</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>​    用于检索和过滤，也常常和管道连用，例如检索普通文件类型中包含txt的文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./ -type f | grep txt</span><br></pre></td></tr></table></figure><p>​    除此之外，还可以检索文件中的内容，具体格式为<code>grep [选项] 内容 文件</code> （当然也可以<code>cat 文件 | grep [选项] 内容</code>），选项比如-w（精确查找），-c（统计查找到的次数），-i（忽略大小写），-n（带行号），-v（反向检索，也就是除内容以外的行）</p><h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>​    zip用于压缩打包，具体用法为:<code>zip -r 压缩文件.zip 目录或文件（可多个空格隔开）</code></p><p>​    unzip用于解压文件，具体用法为：<code>unzip 压缩文件</code></p><p>​    除此之外，还有gzip与gunzip，rar a和rar x等压缩命令，分别生成.gz和.rar</p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>​    最常用的打包工具，后缀一般是.tar.gz</p><p>​    tar命令常用的选项有-z（gz格式压缩，如果不加只是tar包，只打包不压缩），-c（代表压缩文件），-v（代表显示信息），-f（代表指定压缩包的名字），-x（代表解压文件）</p><p>​    压缩文件格式为：<code>tar zcvf 压缩文件.tar.gz 目录或文件</code></p><p>​    解压文件格式为：<code>tar zxvf 压缩文件.tar.gz</code></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="brew或apt-get"><a href="#brew或apt-get" class="headerlink" title="brew或apt-get"></a>brew或apt-get</h3><p>​    linux有apt-get，MacOS有brew等等不同的包管理工具，具体用法也不再重复，详细请看个人博客：<a href="http://www.ivan-zcy.top/%2F2019%2F02%2F25%2FMAC下brew安装与使用以及坑%2F">跳转</a></p><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>​    具体流程大概如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 解压源码代码包</span><br><span class="line">2. cd到解压后的目录</span><br><span class="line">3. ./configure//用于检测文件是否缺失并创建makefile，并检测编译环境</span><br><span class="line">4. make//用于编译源码，生成库和可执行程序</span><br><span class="line">5. sudo make install //把库和可执行程序安装到系统路径下</span><br><span class="line">6. sudo make distclean //删除和卸载软件</span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>​    用于创建用户，常用选项有：-g（指定组），-d（指定用户家目录），-m（家目录不存在自动创建），-s（指定shell）</p><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>​    用户创建用户组</p><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>​    用于切换用户，加-带有环境变量的切换</p><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>​    用于删除用户，选项-r（连带删除家目录）</p><h2 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h2><p>这些先简略占位，日后根据详细应用补～</p><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>​    查看登录设备</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>​    查看进程信息，常用的有<code>ps -aux</code>(显示所有包含其他使用者的进程)`</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>​    用于杀死进程，常用的有<code>kill 9 pid</code></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>​    用于实时查看系统信息</p><h2 id="关于网络"><a href="#关于网络" class="headerlink" title="关于网络"></a>关于网络</h2><p>这些先简略占位，日后根据详细应用补～</p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>​    主要用于查看ip信息。除此之外，eth0代表本地第一块网卡</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>​    用于检测主机，执行ping指令会使用icmp传输协议，发出要求回应的信息。若对方主机网络没问题，就会回应该信息，从而得知主机运行正常</p><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>​    该命令用于通过域名得到ip</p><h2 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>​    用于获取时间的指令，可自定义格式，例如：<code>date +&quot;%Y-%m-%d&quot;</code>等</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>​    用于输出变量或字符</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>​    用于对命令进行重命名，有以下几种用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法1: alias//用于列出目前所有的别名设置</span><br><span class="line">用法2: alias 别名=&apos;指令&apos;//仅作用于本次终端登录</span><br><span class="line">用法3: 在~/.bashrc文件中写入用法2，永久作用于本用户</span><br><span class="line">用法4: 在/etc/profile中写入用法2，永久作用于本计算机中所有用户</span><br><span class="line"></span><br><span class="line">//用法3、4需要在写入后source一下</span><br></pre></td></tr></table></figure><h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>​    用于指定创建文件时预设的权限掩码，umask与0777的补码&amp;666，得到的就是创建文件时预设的权限掩码（哈哈哈），可通过<code>umask -S 权限掩码</code>来设置</p><h3 id="shutdown和reboot"><a href="#shutdown和reboot" class="headerlink" title="shutdown和reboot"></a>shutdown和reboot</h3><p>​    像关机命令有shutdown，常用<code>shutdown -h now</code>立即关机，除此之外还有<code>init 0</code>或者<code>poweroff</code>等</p><p>​    reboot为重启，两者都需要sudo权限</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习归纳1-文件和基本命令</title>
      <link href="/2019/05/15/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B31-%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/05/15/Linux%E5%A4%8D%E4%B9%A0%E5%BD%92%E7%BA%B31-%E6%96%87%E4%BB%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/15/Linux复习归纳1-文件和基本命令/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>​    把自己所学的linux整理归并一下～</p><h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><p>​    Linux一切皆文件！！！！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin存放系统可执行程序</span><br><span class="line">/sbin存放超级管理员可执行程序</span><br><span class="line">/boot存放内核和启动程序相关文件</span><br><span class="line">/lib存放库文件（动态共享库）</span><br><span class="line">/etc存放系统配置文件,比如用户存放信息文件/etc/passwd</span><br><span class="line">/dev存放设备文件</span><br><span class="line">/tmp存放临时文件（关机清空）</span><br><span class="line">/home存放用户的主目录</span><br><span class="line">/usr应用会安装到此目录，比如软件安放到/usr/local下</span><br><span class="line">/proc存储系统内存的映射（保留进程运行的信息）</span><br><span class="line">/media挂载u盘光驱等外接设备（自动挂载）</span><br><span class="line">/mnt手动挂载外接设备</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>​    说命令之前需要说一个神键：自动补齐Tab键，简直不能再好用</p><h3 id="与命令相关"><a href="#与命令相关" class="headerlink" title="与命令相关"></a>与命令相关</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>​    用于查询命令的用法(英文版)，MAC可按照这个教程-&gt; <a href="https://www.jianshu.com/p/bb3edf4d16ce" target="_blank" rel="noopener">跳转</a> 去安装汉化版cman</p><p>​    不懂就查，感觉这是最最最最最有用的命令了</p><h4 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h4><p>​    man真的是好长好长，如果是查询命令的简单应用，可以安装tldr命令来查看用法(too long don’t read，2333)</p><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>​    在终端输出历史命令（当然也可以方向键），可使用<code>!序号</code>来执行指定历史编号的命令</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>​    该命令一般用于临时获取管理员权限，一般常用的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su 切换为管理员</span><br><span class="line">sudo -i 切换为普通用户</span><br><span class="line">sudo !! 当上一条命令权限被拒绝时，可直接这</span><br></pre></td></tr></table></figure><h3 id="与目录相关"><a href="#与目录相关" class="headerlink" title="与目录相关"></a>与目录相关</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>​    list的缩写，用于查看指定目录下的所有文件和目录（支持通配符）。常用参数：-a(显示全部，包括隐藏)，-l（查看详细文件信息）-R（递归查看子目录文件），-t（按照文件修改时间排序）</p><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>​    用于显示当前工作目录</p><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>​    用于显示目录的树形结构</p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>​    用于切换路径（以/开头的路径为绝对路径，否则为相对路径）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd或cd ~或 cd $HOME返回家目录</span><br><span class="line">cd -返回上次目录</span><br><span class="line">cd ..返回上级目录</span><br><span class="line">cd 绝对或相对路径</span><br></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>​    用于创建目录，常用参数-p（可以用于递归创建目录）</p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>​    用于创建文件（若文件已创建，则只是修改一下文件的访问时间，并不会新创建一个文件）</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>​    rm命令用于删除目录或文件，常用参有-r(循环递归删除)，-f(强制删除)</p><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>​    -r（用于递归拷贝）</p><p>​    当目标为目录时，则将当前文件或目录拷贝到目标目录</p><p>​    若目标不是目录时，则在目标的上一层创建该目标并拷贝过去</p><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>​    用于远程拷贝，具体格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp file 用户名@ip地址:./path路径</span><br></pre></td></tr></table></figure><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>​    移动一个文件或文件到另一个目录下（也可用它来重命名），与mv用法差不多，只不过是移动</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>​    用于显示对应命令的所在路径</p><h3 id="与文件相关"><a href="#与文件相关" class="headerlink" title="与文件相关"></a>与文件相关</h3><p>​    文件的详细信息包括：文件权限标志位（包括所属者、组、其它权限(rwx)以及文件类型）、硬连接数、所属者、所属用户、文件大小、时间、文件名</p><p>​    文件类型包括：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 普通文件</span><br><span class="line">d 目录文件</span><br><span class="line">c 字符设备文件（鼠标，键盘等）</span><br><span class="line">b 块设备（也就是硬盘）</span><br><span class="line">p 命名管道文件</span><br><span class="line">l link链接文件</span><br><span class="line">s socket套接字文件</span><br><span class="line"></span><br><span class="line">//隐藏文件以.开头</span><br></pre></td></tr></table></figure><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>​    将文件信息显示到终端</p><h4 id="more和less"><a href="#more和less" class="headerlink" title="more和less"></a>more和less</h4><p>​    也是显示文件，可以分屏显示</p><p>​    more会车是按行显示，空格按页显示</p><p>​    less可以回车或者上下方向键可以反复查看文件内容</p><h4 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h4><p>​    head是查看文件头，tail是查看文件尾（默认显示10行），可以通过参数-n更改显示行数</p><p>​    其中tail中-f可以一直跟踪文件尾部（比如用于查看实时日志啥的）</p><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>​    用于建立软或硬链接（硬链接实际上是两个文件映射同一磁盘地址上的内容；软连接就是创建了源文件的快捷方式，新文件映射到源文件）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln 文件 文件对两个文件建立硬链接</span><br><span class="line">ln -s 文件 文件 对两个文件或文件夹进行软连接（不会增加硬链接计数）</span><br></pre></td></tr></table></figure><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h4><p>​    用于删除硬链接（当然也可以rm），感觉有点类似于智能指针的shard_ptr</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>​    用于改变文件权限，大概格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [a|g|o|a] [+|-] [r|w|x] 文件名//方法一</span><br><span class="line">chmod 数字表示法文件名//方法二</span><br></pre></td></tr></table></figure><h4 id="chown与chgrp"><a href="#chown与chgrp" class="headerlink" title="chown与chgrp"></a>chown与chgrp</h4><p>​    chown用于改变所属用户和组，chgrp用于改变所属组（这两个命令需要管理员权限，chgrp有些鸡肋）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown 用户 文件//改变所属用户</span><br><span class="line">sudo chown 用户:组 文件 //改变所属用户和组</span><br><span class="line">sudo chgrp 组 文件//改变所属组</span><br></pre></td></tr></table></figure><h3 id="与统计相关"><a href="#与统计相关" class="headerlink" title="与统计相关"></a>与统计相关</h3><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>​    该命令用于计数，分别输出行数（可单独-l）、单词数(可单独-w)、字节数(可单独-c)</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>​    用于显示当前目录下文件的大小。可选参-h(human，适合人类观看模式)</p><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p>​    显示当前用户</p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>​    显示当前登录系统的用户信息</p><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>​    显示当前系统的磁盘空间(使用情况)。可选参-h(human，适合人类观看模式)</p><h4 id="W"><a href="#W" class="headerlink" title="W"></a>W</h4><p>​    获取当前登录用户和正在执行的进程</p><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>​    获取系统运行时长和平均负载</p><h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>​    打印当前系统信息</p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>​    显示用户最近登录信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/13/数据库索引/title.jpeg" alt="title"></p><a id="more"></a><p>[TOC]</p><p>​    索引用于帮助我们快速找到想要的数据，Mysql的索引是B+树，Redis的索引是hash，HBase的索引是LSM树等等</p><p>​    没有最好的索引，只有最适合的索引。不同的索引是为了解决不同的问题而实现的</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>​    这里就不详细将Hash的原理了。Hash查询的时间复杂度是O（1）的，速度快。但是hash只适合随机查找，不适合范围查找，因为它是无序的，因此也不支持排序。</p><p>​    而且当key多到内存装不下的时候，hash索引必然有一部分会存储到磁盘上。而磁盘上hash的效率就特别慢了。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>​    B+树查找的时间复杂度为O(logn)，但它支持范围查找和排序</p><p>​    说B+树前，先说一下它的基石，对于平衡树中的各种细分的种类，它们的大概关系为：</p><p>​    平衡树是对二叉搜索树的改进，红黑树是对平衡树的改进，B树是对红黑树的改进，B+树是对B树的改进。</p><p>​    对于二叉搜索树而言，它综合了数组和链表的优点，它无论是插入还是查找某个元素，平均复杂度都是O(logn)</p><p>​    二叉搜索树可能造成最坏情况O（n）的复杂度（当成一条直线时），这时候我们对二叉搜索树进行改进，让其在插入元素后仍保持平衡（这样就可以维持O(logn)的时间复杂度），它们是通过左旋右旋操作实现的</p><p>​    红黑树相比平衡树，通过引入红黑节点变色操作。损失了一定的平衡性，但是减少了旋转操作的次数，增强了效率。</p><p>​    当数据量特别大的时候，就需要将数据存到磁盘上。由于磁盘的IO查找速度很慢，如果二叉树的层数很多，就需要多次转动磁盘，效率很低。如果我们允许一个节点存储多个元素（由于磁盘实际读取会读取一个磁盘快大小到内存，大概为4k，这样我们把一个节点的大小设置为4k刚好），这样就可以降低树的高度，减少IO磁盘转动的次数，这就是B树</p><p>​    我们可以在B树的基础上，尽可能更多的一个节点读取更多的信息，这就有了B+树。B+树在内部节点中只存储索引字段而不是数据内容，这样节点的存放数据量更多，树的高度更低，IO磁盘转动的次数更少。除此之外，sql中经常会有范围查找，B树只能遍历范围内的每个节点，然后挨个查找。而B+树会将叶子结点会通过指针链接起来。这样范围查找可以直接通过这条链表从范围的起始位置走到结尾。</p><p>​    大概1TB的内容只需要B+树的4层。在此基础上，我们可以一直把B+树的根节点保存在内存中减少一次IO操作。</p><p>​    当B+树面对海量数据的时候也会显得力不从心，毕竟每次写入数据前都先要查找数据应该写入的位置。而且当需要分库分表时（当数据超过两千万左右时，避免B+树的高度增加于是分库分表）特别麻烦。</p><h3 id="LSM-TREE"><a href="#LSM-TREE" class="headerlink" title="LSM TREE"></a>LSM TREE</h3><p>​    在NoSql数据库中（非关系型数据库）使用LSM Tree，它将磁盘的顺序写发挥到极致，适用于大规模数据量写入。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>​    用于全文检索（例如搜索一个词，把所有出现这个词的网页都显示出来）。是通过分词和字典树来实现的。</p><p>​    它会把每个网页中的词都单独拿出来，扔到集合中，比如hashmap（这里的key是单词，value是包含这个单词的所有文章的编号列表）</p><p>​    当数据量少的可以用hashmap或者平衡树，当数据量大的时候就可以使用字典树了（在字典树节点中存储这个单词所有文章的编号列表）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保持DB和缓存一致性</title>
      <link href="/2019/05/13/%E4%BF%9D%E6%8C%81DB%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2019/05/13/%E4%BF%9D%E6%8C%81DB%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/13/保持DB和缓存一致性/title6.jpg" alt="title6"></p><a id="more"></a><p>[TOC]</p><p>​    对于维持DB和缓存的一致性，我们先假设更新数据库和更新缓存都可以成功的情况。    </p><p>​    主要有以下几种方法：</p><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p>​    对于一致性更新，先把数据存到数据库中，成功后再让缓存失效</p><p>​    这时，对于并发的更新和查询操作，并发查询操作拿到的是脏数据，而更新成功后的查询操作都是更新后的数据。</p><p>​    不过理论上也有一直出现脏读的可能性：并发读和写，读操作缓存不命中，读操作从数据库取数据。此时写操作修改完数据库，让缓存失效。然后之前读的操作把脏数据存入缓存，造成缓存中脏数据存在。（可能性特别低，因为写操作比读操作慢很多，读操作在写操作前进入数据库操作并在写操作结束后就结束可能性特别低）</p><h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><p>​    应用认为后端就是一个单一的存储，后台数据库自己维护缓存。其中Read Through Pattern策略是在查询时更新缓存（当缓存失效的时候，后台服务器自动加载），而Write Through Pattern策略是在更新时更新缓存（当有数据更新时，如果没有命中缓存，则更新数据库并发返回。否则更新缓存再由缓存更新数据库）</p><h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>​    在更新数据的时候，只更新缓存，不更新数据库，然后缓存会异步地批量更新数据库。这样效率非常快。缺点是数据库和缓存不能保持强一致性，还可能造成数据丢失</p><h3 id="mysql更新缓存方式"><a href="#mysql更新缓存方式" class="headerlink" title="mysql更新缓存方式"></a>mysql更新缓存方式</h3><p>​    先更新缓存，然后异步把数据写到磁盘上。为了保证数据不丢失，采用WAL方法：数据进来后先把数据以log方式写到磁盘（由于是顺序写，所以很快）。写完后进行更新缓存操作，若出现死机等情况，重启后可以从log文件中重新把数据读出来然后再更新到缓存，最后异步更新到数据库。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务隔离级别、脏读、不可重复读、幻读</title>
      <link href="/2019/05/13/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/"/>
      <url>/2019/05/13/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%81%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/13/事务隔离级别、脏读、幻读、不可重复读/title3.jpg" alt="title3"></p><a id="more"></a><p>[TOC]</p><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p>​    事务隔离是多个事务同时进行时的隔离。它们之间的相互影响与隔离级别有关</p><p>​    数据库隔离级别数据库事务的隔离级别有4个，分别是读未提交（可能出现脏读、不可重复读、幻读）、读已提交（可能出现不可重复读、幻读）、可重复读（可能出现幻读）、可串形化。隔离级别越来越高，事务之间的影响越来越小，效率越来越低</p><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>​    举个例子：两个窗口卖最后一张票，第一个窗口有一个人买票，但是该事务未提交。第二个窗口另一个人再买票发现票已经有人买，然后就离开了。结果第一个窗口的人不买了，于是回滚了事务并提交，最后票没卖出去。</p><p>​    上述情况中，第二个窗口的人读到的”票已经有人买了”是一个脏数据，它并不是最后事务提交的数据。因此读未提交可能会出现脏读的情况。</p><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p>​    它解决了上面脏读的情况</p><p>​    举个例子：A拿银行卡消费，查询卡里有100元钱。同时B将该卡的100元转走，在A之前提交了事务，当A进行消费时，扣款失败。</p><p>​    也就是说，A先读数据，B跟着更新了数据并提交了事务，当A再次读取数据时，数据已经发生变化，这就是所谓的不可重复读。Oracle默认为读已提交</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>​    它保证同一事务中只会读取到当前事务对数据的修改，其它事务修改的数据不会影响当前事务的读取。（意为可重复读到相同的东西）</p><p>​    也就是在上述情况下，当A拿银行卡消费时，B不能进行转账。</p><p>​    但是在这个级别下，还可能出现幻读的情况。</p><p>​    幻读的例子：比如当前有20元钱，A事务查询钱数得到20，此时B事务更新了钱数为0并提交了事务。然后A事务执行更新update操作，然后再查询钱数得到0。mysql默认为读已提交</p><h4 id="可串形化"><a href="#可串形化" class="headerlink" title="可串形化"></a>可串形化</h4><p>​    串形将所有的事务一个一个的进行，所以穿行化的事务隔离级别不会出现脏读、不可重复读、幻读等问题。代价就是性能特别低</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2019/05/13/%E7%BC%93%E5%AD%98/"/>
      <url>/2019/05/13/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/13/缓存/title4.jpg" alt="title4"></p><a id="more"></a><p>[TOC]</p><p>​    之前也有说过缓存的三大问题及解决方案：可以 <a href="http://www.ivan-zcy.top/%2F2019%2F03%2F12%2F浅谈缓存三大问题%2F">跳转</a> 到这儿看一下</p><p>​    结合网上查阅的博文，整体说一下缓存的概念</p><h3 id="缓存出现的原因"><a href="#缓存出现的原因" class="headerlink" title="缓存出现的原因"></a>缓存出现的原因</h3><p>​    缓存出现的目的只有一个：缓冲不同介质IO速度，从而加快访问速度</p><p>​    对于不同介质之间的数据传输，速度快和速度慢的不匹配，会导致速度快的长时间处于等待状态，造成资源的浪费，最典型的例子就是CPU和磁盘之间的不匹配。</p><p>​    至于我们为什么选择磁盘而不选择速度更快的内存等进行大量存储。因为内存的不可靠性(断电不保存)以及受体积、价格因素的影响。既然不能在存储介质上做文章，那么聪明的人类又引入了缓存这个概念，来尽量匹配磁盘和CPU的工作效率。</p><p>​    缓存的概念就是：我们提前将可能将要使用的数据，从速度慢的介质里面放到速度快的介质里面。这样下次用到某个数据时，CPU就可以直接从速度快的介质中获取。其中，提前准备的数据就是缓存</p><p>​    可以说，缓存的技术无处不在。在操作系统、计算机网络、数据库中均有体现。</p><h3 id="缓存模型"><a href="#缓存模型" class="headerlink" title="缓存模型"></a>缓存模型</h3><p>​    对于整个计算机而言：</p><p><img src="/2019/05/13/缓存/1.png" alt="1"></p><p>​    对于整个网络而言：    </p><p><img src="/2019/05/13/缓存/2.png" alt="2"></p><h3 id="缓存数据的方法"><a href="#缓存数据的方法" class="headerlink" title="缓存数据的方法"></a>缓存数据的方法</h3><h4 id="局部性原理缓存"><a href="#局部性原理缓存" class="headerlink" title="局部性原理缓存"></a>局部性原理缓存</h4><p>​    局部性原理的核心在于赌用到某些数据，也会马上用到该数据相邻的数据。比如我们获取一个乒乓球拍信息，可能还会有很大概率获取乒乓球信息。我们获取一个用户的个人信息，可能还会有很大概率获取他的动态。于是，我们获取一个信息时，会一次性把与之相关的信息全部从磁盘读出来放到内存。</p><p>​    运用局部性原理，CPU会把相邻的指令一起从L1缓存读到寄存器。从磁盘读取数据时，也会一次性把所在磁盘扇区的数据全部读进来（前提是程序设计者在存储数据时把相关数据存在一起）</p><h4 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法"></a>缓存淘汰算法</h4><p>​    当缓存满时需要对已经缓存的数据进行替换，这时候就需要进行缓存数据的替换。常见的有先进先出（FIFO），LRU（最近最少使用，Java的LinkedHashMap，Redis，MySQL的BufferPool的缓存都是基于LRU实现的），OPT（最优置换，无法实现）</p><p>​    对于mysql来说，系统上线后会先把常用的数据筛选一遍，找到热点数据放入MySQL的BufferPool中。除此之外还做了优化，把缓存划分成两部分，一部分用来存热点数据（永远不被淘汰），另一部分用来存可以被淘汰的冷数据，对冷数据部分进行LRU。当一些数据被频繁访问时，可以作为热数据存到第一部分中</p><h3 id="缓存命中和缓存失效"><a href="#缓存命中和缓存失效" class="headerlink" title="缓存命中和缓存失效"></a>缓存命中和缓存失效</h3><p>​    失效：程序先从缓存中查找数据，没有找到然后在数据库中取数据，若成功则把数据加入到缓存当中</p><p>​    命中：程序从缓存中查找数据，成功后返回</p>]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储介质</title>
      <link href="/2019/05/13/%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8/"/>
      <url>/2019/05/13/%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/13/存储介质/title2.jpg" alt="title2"></p><a id="more"></a><p>[TOC]</p><p>​        影响程序运行效率最大的两个因素：算法和IO快慢。其中影响IO快慢，就是各种存储介质的工作原理了。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>​    内存由晶体管和电容组成，晶体管是控制电容充放电的开关（电容充满电是0，放完电是1），一个基本单元可以存储1bit数据。内存单元按照一定顺序排列成矩阵，就是内存。然后给它们的每个单元编上号，这个编号就是内存地址。</p><p>​    从内存单元的构成可知，一旦断电，内存所存储的信息全部都会消失，所以内存是不安全的。</p><p>​    至于为什么断电后信息全部消失，是因为电容中的电荷会天然流失，需要每隔1～3ms进行充电补充电荷来维持0状态位。因此一旦断电，所有位都会变为1</p><h4 id="结合实际"><a href="#结合实际" class="headerlink" title="结合实际"></a>结合实际</h4><p>​    由于对于0状态位需要不断的进行充电来维持状态，因此运行占用内存大的程序，电脑的耗电会更多，比如玩游戏。（当然只是其中一个原因）</p><h3 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h3><p>​    SSD和内存一样，都是通过电容中的电荷量来模拟0和1状态位，相比内存，它多了两大功能：</p><pre><code>1. 一个存储单元可以存储多个比特位，比如电荷容量在3/4～1时代表00，1/2～3/4代表01，1/4～1/2代表10，低于1/4代表11。可以表示的比特位越多，价格也就越贵 2. 相比内存&quot;晶体管+电容&quot;的结构，SSD增加了一层绝缘装置，断电后电荷不会流失，所以不需要持续充电。（当然电荷不流失不是绝对的，当绝缘层出问题的时候，可能就会造成数据的破坏）</code></pre><h4 id="为什么内存会被固态硬盘快"><a href="#为什么内存会被固态硬盘快" class="headerlink" title="为什么内存会被固态硬盘快"></a>为什么内存会被固态硬盘快</h4><p>​    内存和固态硬盘的结构差不多，至于为什么内存更快，原因有以下几点：</p><pre><code>1. 内存相比SSD，距离CPU更近  2. SSD的数据需要通过内存再到达CPU，而无法直接与CPU进行交互  3. 受限于SSD的SATA接口数据传输</code></pre><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>​    磁盘与内存和SSD存储原理不同，磁盘的表面是一层磁性涂料，整个磁盘表面被称为磁面，一圈一圈的同心环称为磁道，每个磁道又可以切分成一个个的扇区()，扇区里有一个个的存储单元被称为磁针。除此之外，还有磁臂支撑起的磁头，通过加电后对磁针进行磁化来实现写数据，通过不加电时感应小磁针磁场的作用来实现读数据。</p><p>​    其中，对同一磁道的不同扇区进行操作时，依靠磁盘的主轴转动（速度快）。对不同磁道的数据进行操作时，依靠磁盘的磁臂进行移动（速度慢），这时就引出了磁盘调度算法（包括电梯算法，先来先服务，最近优先等）</p><p>​    被磁化的数据几乎可以持久保存（但是遇到高强度的磁场就会GG）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唯一id生成算法</title>
      <link href="/2019/05/11/%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
      <url>/2019/05/11/%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/11/唯一id生成算法/title5.jpg" alt="title5"></p><a id="more"></a><p>[TOC]</p><p>​    我们在很多情况下都需要用到一个唯一标识，比如一个用户id，一个订单号等等。因此，我们需要设计一种算法来保证标识的唯一性。</p><p>​    具体算法：</p><h3 id="UUID-和-GUID"><a href="#UUID-和-GUID" class="headerlink" title="UUID 和 GUID"></a>UUID 和 GUID</h3><p>​    UUID含义是通用唯一识别码，让分布式系统中的所有元素，都能有唯一的辨识</p><h3 id="数据库自增主键"><a href="#数据库自增主键" class="headerlink" title="数据库自增主键"></a>数据库自增主键</h3><p>​    这种实现方式特别简单，但是不能对数据库进行分表操作，否则id就会重复。</p><h3 id="数据库自增主键优化"><a href="#数据库自增主键优化" class="headerlink" title="数据库自增主键优化"></a>数据库自增主键优化</h3><p>​    让数据库中不同的表从不同的下标开始，每次自增n（n为表的个数），这样就解决了重复问题。</p><p>​    但是不便于日后维护，因为以后再新扩建一个表就十分麻烦</p><h3 id="数据库自增主键再优化"><a href="#数据库自增主键再优化" class="headerlink" title="数据库自增主键再优化"></a>数据库自增主键再优化</h3><p>​    单独使用一张（或固定几张）数据库表专门来产生自增id。后序不再重新分表，数据量大时可以删除早一些时候产生的数据。</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>​    用当前时间戳作为唯一id。这样有个缺点，在同一时间生成的id重复</p><h3 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h3><p>​    对于时间戳来说，如果同一时间有多个请求进来，可以在时间戳后接上一个数字（通过锁机制来实现每次递增，每毫秒清零重新计数）</p><p>​    上述解决了高并发问题，而无法解决分布式环境下。我们可以在时间戳+计数的基础上拼接上机器的id。</p><p>​    但是可能在不同的数据中心，机器id编号相同，这样就可以继续拼接上数据中心的id。</p><p>​    这样做可以实现id的唯一性，且长度适中，算法较为简单。</p><h3 id="算法为递增的优势"><a href="#算法为递增的优势" class="headerlink" title="算法为递增的优势"></a>算法为递增的优势</h3><p>​    递增对IO友好，尽可能的使数据靠近在一起，就不需要频繁的抬起磁头，一直写会快很多。对于一些大型分布式数据库，比如HBase，ElasticSearch等都是利用顺序写来提高写性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希</title>
      <link href="/2019/05/11/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
      <url>/2019/05/11/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/11/一致性哈希/title1.jpg" alt="title1"></p><a id="more"></a><p>[TOC]</p><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>​    一致性哈希是一种特殊的哈希，当哈希表的大小发生变化的时候，平均只有n / m（n为key总数，m为哈希表的大小）个key值需要重新计算映射关系。解决了一般哈希算法，当hash表发生变化几乎所有key都要重新映射的问题。</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><pre><code>1. 一致性hash通过一个hash环来实现，将环分为2^32份2. 数据key经过hash函数得到的整型一定在环上，机器和用户（比如ip或者机器名）hash后得到的整型也一定在环上（因为整型的范围为2^32）3. 如果key的hash值和机器的hash值映射在环上的同一个位置，那么就将key存在这个节点，否则就沿着环顺时针找第一个存在机器hash映射的位置，然后将key值映射到该位置处4. 删除节点时，从被删除节点开始沿着环顺时针找第一个存在机器hash映射的位置，然后把被删除节点的所有key值映射到到该位置处5. 增加节点时，把增加节点位置处到逆时针的前一个节点处的所有key值都映射新的节点位置处</code></pre><p><img src="/2019/05/11/一致性哈希/1.png" alt="1"></p><h4 id="改进和扩展"><a href="#改进和扩展" class="headerlink" title="改进和扩展"></a>改进和扩展</h4><p>​    我们会发现，可能利用这种方式会照成数据分配严重不均的情况，比如只有两个机器，映射位置分别为1，3，那么2～3位置的key会在3中进行存储，而4～2^32范围和1都在1中存储。因此会造成数据分配的不均问题。</p><p>​    因此，我们可以通过在hash环中添加一些虚拟节点（分配均匀），然后使得可以key尽量均匀的分配到不同的虚拟节点当中，然后把虚拟节点的数据映射到真实节点即可。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>​    比如我们在做分布式存储的时候（将数据分片存储到多态机器上），我们通过hash来将数据进行映射到不同机器中。这时候我们可能会遇到机器出状况可能会挂掉一个，有时候数据量太大需要对机器数量进行扩大。</p><p>​    这时候机器数量一旦变动就需要对数据重新取模造成大量缓存失效，这时我们就可以用到一致性哈希来解决大量数据失效的问题了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2019/05/10/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/05/10/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/10/布隆过滤器/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>​    用于判断一个元素是否在某个集合中。相比hash，它不需要存储key值更加节省空间，而且由于不存储key值保密性更好。但是有一定概率判断出错，且无法删除集合中的元素。（以差错率换取空间）</p><h4 id="算法内容："><a href="#算法内容：" class="headerlink" title="算法内容："></a>算法内容：</h4><p>​    它主要就是对hash的扩展和更改，牺牲了一部分的准确性来换取时空的效率。它的算法核心是：</p><p>添加时：</p><p>​    1.开一个n比特的数组全部初始化为0</p><p>​    2.对一个key值分别映射到k个哈希函数，得到k个整型值</p><p>​    3.将这k个整数所对应的位设置为1</p><p>查询时：</p><p>​    1.对一个key值分别映射到k个哈希函数，得到k个整形值</p><p>​    2.查询k个整数所对应的位是否全为1，如果全为1则认为存在（可能会有一定的误差）</p><h4 id="布隆过滤器的概率推导："><a href="#布隆过滤器的概率推导：" class="headerlink" title="布隆过滤器的概率推导："></a>布隆过滤器的概率推导：</h4><p>​    对于一次hash函数映射，位数为m的数组某一位仍然为0的概率：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(m - 1) / m</span><br></pre></td></tr></table></figure><p>​    对于k次hash映射，位数为m的数组某一位仍然为0的概率：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((m - 1) / m) ^ k</span><br></pre></td></tr></table></figure><p>​    插入n个元素，每个元素k次映射，位数为m的数组某一位仍为0的概率：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((m - 1) / m) ^ (kn)</span><br></pre></td></tr></table></figure><p>​    那么某一位为1的概率为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - ((m - 1) / m) ^ (kn)</span><br></pre></td></tr></table></figure><p>​    因此我们查询一个key，它在k个映射位都为1的概率为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1 - ((m - 1) / m) ^ (kn)) ^ k</span><br></pre></td></tr></table></figure><h4 id="推导结论"><a href="#推导结论" class="headerlink" title="推导结论"></a>推导结论</h4><p>​    当固定key个数(n)和数组位数(m)，那么哈希函数个数k最好为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln2 * m / n</span><br></pre></td></tr></table></figure><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>​    我们可以用布隆过滤器来对数据进行过滤。比如通过设置布隆过滤器来避免缓存穿透，每次需要查询后端时，先判断key值是否在后端存在，就能避免频繁查询不存在的key值请求后端导致压力过大。除此之外，对于垃圾邮件的过滤等操作，也可以应用布隆过滤器</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库和静态库相关</title>
      <link href="/2019/05/09/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/05/09/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/09/动态库和静态库相关/title4.jpg" alt="title4"></p><a id="more"></a><p>[TOC]</p><p>​    讲静态库和动态库之前，先说一下gcc的编译流程：</p><p><img src="/2019/05/09/动态库和静态库相关/1.jpg" alt="1"></p><p>​    （图片来自室友男神，地址：<a href="https://zhangkingsasa.com/2019/04/30/linux丨gcc编译过程/" target="_blank" rel="noopener">跳转</a>）    </p><p>​    至于静态库和动态库，他们的区别在于链接阶段的处理不同（一个静态链接方式，一个动态链接方式）</p><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>​    目标文件.o与静态库一起链接成可执行文件，对应的链接方式为静态链接。它和.o文件类似，可以简单看成是一组目标文件的集合（也就是多个目标文件压缩打包后的一个文件）</p><p>​    静态库的命名规则：前缀时lib，后缀是.a</p><h4 id="静态库特点"><a href="#静态库特点" class="headerlink" title="静态库特点"></a>静态库特点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.静态库对函数库的链接是放在编译时期完成的，执行快</span><br><span class="line">2.发布应用时不需要发布库</span><br><span class="line">3.浪费空间和资源，所有的相关目标文件和牵扯的函数库被链接成可执行文件，体积大</span><br><span class="line">4.不利于程序的更新。如果静态库更新了，使用它的应用程序都需要重新编译发布</span><br></pre></td></tr></table></figure><h4 id="静态库的创建"><a href="#静态库的创建" class="headerlink" title="静态库的创建"></a>静态库的创建</h4><p>​    1.先将代码文件编译成.o文件</p><p>​    2.通过ar命令将目标文件打包成.a静态库文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar -crv libtest.a *.o//.o文件可以有多个</span><br></pre></td></tr></table></figure><h4 id="静态库的查看"><a href="#静态库的查看" class="headerlink" title="静态库的查看"></a>静态库的查看</h4><p>​    利用nm命令查看静态库的信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm libtest.a</span><br></pre></td></tr></table></figure><h4 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h4><p>​    在编译的时候，利用-L选项指定静态库的搜索路径，利用-l指定静态库名(由于查找有隐含命名规则，因此无需在前加lib后加.a或.so)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ p.cpp -L../Test -ltest//如果有头文件的话，需要将头文件和静态库一起发布，并引用头文件</span><br></pre></td></tr></table></figure><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>​    动态库命名规则：前缀是lib，后缀是.so</p><h4 id="动态库特点"><a href="#动态库特点" class="headerlink" title="动态库特点"></a>动态库特点</h4><p>​    动态库可以解决静态库空间浪费的问题，也能解决静态库更新麻烦的问题。</p><p>​    动态库在程序编译时不回被链接到目标代码中，直到程序运行才被载入（避免了更新麻烦，用户只需要更新动态库即可）。不同的应用程序如果调用相同的库，那么在内存里只需要一份该共享库的实例（避免了空间浪费），也就是在栈区和堆区之间的共享库映射。（而静态库是直接将代码加载到程序的代码段中）</p><p><img src="/2019/05/09/动态库和静态库相关/2.png" alt="2"></p><p>​    当然动态库的缺点，就是相对于静态库而言，速度较慢。且在发布应用的时候同时需要发布动态库</p><h4 id="动态库的创建"><a href="#动态库的创建" class="headerlink" title="动态库的创建"></a>动态库的创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -c *.cpp//首先生成目标文件，注意需要加选项-fpic，它代表创建与地址无关的编译程序，以便能够在多个应用程序中共享</span><br><span class="line"></span><br><span class="line">g++ -shared -o libtest.so *.o//生成动态库，需要-shared选项指定生成动态链接库</span><br><span class="line"></span><br><span class="line">//上面两个命令可以合并为：</span><br><span class="line">g++ -fPIC -shared -o libtest.so *.cpp</span><br></pre></td></tr></table></figure><h4 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h4><p>​    和静态库一样，在编译的时候，利用-L选项指定动态库的搜索路径，利用-l指定动态库名(由于查找有隐含命名规则，因此无需在前加lib后加.a或.so)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ p.cpp -L../Test -ltest</span><br></pre></td></tr></table></figure><p>​    这样可能会出现动态链接没有找到动态库的问题，这时解决方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：直接把.so拷贝过去或者将libxxx.so在/lib下面做一个软连接指向该文件（注意，软连接必须写绝对路径），这种方式不推荐</span><br><span class="line">方法二：将库路径加到环境变量 LD_LIBRARY_PATH中（通过export LD_LIBRARY_PATH=路径设置:$export LD_LIBRARY_PATH），也不推荐</span><br><span class="line">方法三：编辑/etc/ld.so.conf文件，加入动态库文件所在目录的路径，然后运行ldconfig</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对象内存模型</title>
      <link href="/2019/05/08/C-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1/"/>
      <url>/2019/05/08/C-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/08/C-对象内存模型-1/title2.jpg" alt="title2"></p><a id="more"></a><p>[TOC]</p><h2 id="C-对象内存模型"><a href="#C-对象内存模型" class="headerlink" title="C++对象内存模型"></a>C++对象内存模型</h2><p>​    一般来说，类成员变量存储顺序按照声明的顺序从低地址到高地址顺序存储。</p><p>​    对于类的静态成员变量，它单独存储在程序的.data段中，不与特定的对象相关联。</p><p>​    如果子类和父类的成员变量（或成员函数）同名，则父类的成员变量（或成员函数）会被隐藏（当然它可以通过类名受限的方式来访问），具体如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    void f() &#123; </span><br><span class="line">    printf(&quot;A f\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B : public A &#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    void f() &#123;</span><br><span class="line">        printf(&quot;B f\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.a = 0;        // 访问的是 B::a</span><br><span class="line">    b.f();          // 访问的是 B::f()</span><br><span class="line">    b.A::a = 1;     // 访问的是 A::a</span><br><span class="line">    b.A::f();       // 访问的是 A::f()</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承情况"><a href="#多继承情况" class="headerlink" title="多继承情况"></a>多继承情况</h3><p>​    对于下面情况来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A: public B, public C &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这时在A的对象中，由低地址到高地址依次存B的成员变量、C的成员变量、A的成员变量</p><h3 id="虚继承情况"><a href="#虚继承情况" class="headerlink" title="虚继承情况"></a>虚继承情况</h3><p>​    <img src="/2019/05/08/C-对象内存模型-1/a.png" alt="a"></p><p>​    关于虚继承，大概就是虚基类在子类中只保留一份成员变量，它是通过虚基类表来找到虚基类成员来实现的。</p><h3 id="存在虚函数情况"><a href="#存在虚函数情况" class="headerlink" title="存在虚函数情况"></a>存在虚函数情况</h3><p>​    存在虚函数的通过低地址的虚函数指针找到对应的虚函数表，来指向对应的虚函数地址。</p><h3 id="虚函数多继承情况"><a href="#虚函数多继承情况" class="headerlink" title="虚函数多继承情况"></a>虚函数多继承情况</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"c\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>  <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"d\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    C *a = <span class="keyword">new</span> D();</span><br><span class="line">    a-&gt;a();<span class="comment">//输出c</span></span><br><span class="line">    <span class="comment">//((D *)a)-&gt;a();      //两个同名虚函数，报错 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在这儿需要说明一下动态多态和静态多态。只有通过基类的引用或者指针调用虚函数时，才能发生动态绑定，如果使用对象来操作虚函数的话，仍然会采用静态绑定的方式</p><p>​    在存在虚函数的多继承情况下，会存在多个虚函数表。而父类指针指向子类对象时，父类指针只能得知父类有的虚函数表。因此上面第一个输出c，第二个会报错</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++顺序内存模型</title>
      <link href="/2019/05/08/C-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/08/C-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/08/C-内存顺序模型/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="强顺序内存模型"><a href="#强顺序内存模型" class="headerlink" title="强顺序内存模型"></a>强顺序内存模型</h3><p>​    CPU按照正确的指令顺序执行</p><h3 id="弱顺序内存模型"><a href="#弱顺序内存模型" class="headerlink" title="弱顺序内存模型"></a>弱顺序内存模型</h3><p>​    CPU为了性能提升，采用流水线技术，进一步挖掘指令的并行性，一段连续指令使用了不同的寄存器和内存地址，因此一些处理器可能会讲指令执行的顺序打乱执行。这就是弱顺序的内存模型。这种可能会导致错误发生，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int thread_1()&#123;</span><br><span class="line">    int t = 1;</span><br><span class="line">    a = t;</span><br><span class="line">    b = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int thread_2&#123;</span><br><span class="line">    while(b != 2);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可能会导致输出的a为0</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>​    C++11之前，采用内存栅栏解决。C++11之后，可指定内存顺序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory_order_relaxed   不对执行顺序做任何保证</span><br><span class="line"></span><br><span class="line">memory_order_consume   本线程所有后续有关本操作的必须在本操作完成后执行</span><br><span class="line"></span><br><span class="line">memory_order_acquire   本线程所有后续的读操作必须在本条操作完成才能执行</span><br><span class="line"></span><br><span class="line">memory_order_release   本线程所有之前的写操作完成后才执行本操作</span><br><span class="line"></span><br><span class="line">memory_order_acq_rel   同时包含acquire和release</span><br><span class="line"></span><br><span class="line">memory_order_seq_cst  全部顺序执行</span><br></pre></td></tr></table></figure><p>​    因此我们可以通过下面代码来避免该情况的发生：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int thread_1()&#123;</span><br><span class="line">    int t = 1</span><br><span class="line">    a.store(t,memory_order_relaxed);</span><br><span class="line">    b.store(2,memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int thread_2()&#123;</span><br><span class="line">    while(b.load(memory_order_acquire) != 2);</span><br><span class="line">    cout &lt;&lt; a.load(memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存模型</title>
      <link href="/2019/05/08/C-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/08/C-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/08/C-对象内存模型/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><p>​    C++内存由高地址到低地址依次是栈区（向下增长，用于存放函数内的局部变量，形参和函数返回值。系统会自动管理栈区的内存分配与回收）、堆区（向上增长，由程序员主动申请和释放，容易造成内存泄漏）、静态区（也叫全局区，静态变量和全局变量的存储区域一样，静态区的内存直到程序完全结束才会被释放）、常量区（用于存放常量）、代码区（用于存放代码）</p><h3 id="分成多个区的原因"><a href="#分成多个区的原因" class="headerlink" title="分成多个区的原因"></a>分成多个区的原因</h3><p>​    通过对不同数据进行分类，可以方便访问、节约空间和方便管理。对于临时数据和多次使用的代码因为生命周期短，因此放入栈区。全局和静态变量可能在整个程序中都需要访问，因此需要单独管理。堆区可由用户自行分配方便管理</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>​    栈区内存由系统自动分配释放，栈区是先进后出原则，且栈区地址是向下增长的。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>​    堆区是向上增长的，因此后申请的内存地址会依次增大</p><h3 id="静态区（全局区）"><a href="#静态区（全局区）" class="headerlink" title="静态区（全局区）"></a>静态区（全局区）</h3><p>​    静态全局变量、静态局部变量、全局变量都存储在静态区。若未初始化，那么系统会自动为其初始化为0。对于静态局部变量来说，多次调用函数编译器只会为第一次初始化分配内存。</p><h3 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h3><p>​    用于存储常量，不可被修改。举个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p = &quot;abc&quot;;</span><br><span class="line">//此时指针变量p存储在栈区，而它指向存储在常量区的字符串常量&quot;abc&quot;，我们可以改变p的指向，但是不可以改变指向的内容</span><br><span class="line"></span><br><span class="line">char s[] = &quot;abc&quot;</span><br><span class="line">//定义了一个字符串数组s，存储在栈区，它的内容是通过字符串常量“abc”拷贝过去的。因此可以改变s中的内容</span><br></pre></td></tr></table></figure><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>​    代码区的内存由系统控制，用于存放程序编译后的指令。函数的名称也是一个指针，可以通过查询函数名所处的内存地址，查询函数存放的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统杂谈-1</title>
      <link href="/2019/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%82%E8%B0%88/"/>
      <url>/2019/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/07/操作系统杂谈/itle3.jpg" alt="itle3"></p><a id="more"></a><p>[TOC]</p><h3 id="操作系统作为系统资源的管理者："><a href="#操作系统作为系统资源的管理者：" class="headerlink" title="操作系统作为系统资源的管理者："></a>操作系统作为系统资源的管理者：</h3><p>比如打开QQ视频聊天：</p><p>​    1.找QQ文件的时候，逐层打开文件夹，涉及到文件管理</p><p>​    2.打开QQ，系统会为其分配内存，涉及到内存管理</p><p>​    3.QQ开始运行，相应的进程被CPU处理，涉及到处理器管理</p><p>​    4.开始视频聊天，需要将摄像头资源分配给QQ进程，涉及到设备管理</p><h3 id="操作系统为上层提供服务："><a href="#操作系统为上层提供服务：" class="headerlink" title="操作系统为上层提供服务："></a>操作系统为上层提供服务：</h3><p>1.命令接口允许用户直接使用（命令分批处理或者交互式）</p><p>2.程序接口允许用户通过程序间接使用（系统调用）</p><p>3.图形用户接口GUI（比如通过拖拽到垃圾桶删除）</p><h3 id="操作系统为下层实现的功能："><a href="#操作系统为下层实现的功能：" class="headerlink" title="操作系统为下层实现的功能："></a>操作系统为下层实现的功能：</h3><p>​    实现对硬件机器的扩展，比如1.基于磁盘信息的抽象，管理磁盘数据2.防止程序直接与物理资源接触3.将物理资源抽象为进程，方便了多个程序在系统中同时运行</p><h3 id="操作系统的四个特征：并发、共享、虚拟、异步。"><a href="#操作系统的四个特征：并发、共享、虚拟、异步。" class="headerlink" title="操作系统的四个特征：并发、共享、虚拟、异步。"></a>操作系统的四个特征：并发、共享、虚拟、异步。</h3><ol><li>并发：操作系统会负责协调多个程序交替运行，需要引入中断技术才能实现并发执行</li><li>共享：是指系统的资源可以供内存中多个并发执行的进程共同使用，分为互斥共享（摄像头）和同时共享（访问资源）</li><li>虚拟：把一个物理上的实体（实际存在的）变为若干逻辑上的对应物（用户感受到的）。分为时分复用（虚拟处理器）和空分复用（虚拟存储器）</li><li>异步：多个进程并发执行，由于资源有限，进程是以不可预知的速度交替执行的。</li></ol><h3 id="指令和代码的区别："><a href="#指令和代码的区别：" class="headerlink" title="指令和代码的区别："></a>指令和代码的区别：</h3><p>指令是CPU能识别、执行的最基本命令，代码通过翻译可生成机器语言指令。由于指令权限很高，因此分为特权指令和非特权指令（用户态只能执行非特权指令，内核态可以执行非特权指令，CPU中有程序状态寄存器来识别，0用户态1内核态），因此程序叶分为内核程序和用户程序（内核程序在内核空间，应用程序运行在用户空间）</p><h3 id="内核的核心："><a href="#内核的核心：" class="headerlink" title="内核的核心："></a>内核的核心：</h3><p>时钟管理（计时用于进程切换等）、中断处理、原语（最接近硬件的部分，具有原子性。有设备驱动、CPU切换等）、进程管理、存储器管理、设备管理等 </p><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3><p>（其中后三个在有些操作系统中不将其定义为内核的核心，它属于对系统资源的管理功能，这就是大内核和微内核之分，大内核代码庞大，性能快；微内核结构清晰方便维护，但需要在内核态和用户态频繁切换）</p><h3 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h3><p>只要发生中断，就意味着需要操作系统介入（也就是从用户态到内核态）流程：比如CPU收到计时器部件发出的中断信号/或发出系统调用/或内中断信号等，然后切换为核心态对中断进行处理（因为特权指令只有内核态有权限）</p><ol><li><p>用户态-&gt;内核态：通过中断实现；内核态-&gt;用户态：通过执行一个特权指令，将CPU中程序状态寄存器的标识位改为用户态</p></li><li><p>外中断的处理过程：CPU执行一个进程的多个指令，每执行完一个指令CPU都会检查是否有外部中断信号，若不存在继续执行，若存在保护进程的状态进行保存（通过状态寄存器、指令计数器等等），然后CPU根据中断信号的类型转入相应的中断处理程序（中断处理程序位于内核态</p></li></ol><h3 id="进程控制块："><a href="#进程控制块：" class="headerlink" title="进程控制块："></a>进程控制块：</h3><p>每个进程被创建时，系统会为其配置一个数据结构，称之为进程控制块（PCB），用于描述进程的各个信息（包括对内存地址的映射、进程切换时信息的存储（也就是各种寄存器值）、进程号和所属用户、状态（就绪、运行、阻塞）、优先级等），PCB是进程存在的唯一标示，位于内核态。创建进程实质是创建PCB，撤销进程实质是撤销PCB</p><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>（也就是系统中对多个进程之间的组织）：分为链接方式（按进程状态分为多个队列，系统有指向各个队列的指针）和索引方式（按照进程状态的不同建立几张索引表，系统有指向各个索引表的指针）</p><h3 id="进程控制："><a href="#进程控制：" class="headerlink" title="进程控制："></a>进程控制：</h3><p>主要时实现进程状态的转换，通过原语实现。原语的特点是执行期间不可中断，运行前有关中断指令，结束后有开中断指令。在此期间外部中断信号是被忽略的。原语的功能：更新PCB的信息，将PCB插入合适的队列，分配回收资源</p><h3 id="进程间通信："><a href="#进程间通信：" class="headerlink" title="进程间通信："></a>进程间通信：</h3><p>由于进程拥有的内存地址相互独立，因此一个进程不能直接访问另一个进程的地址空间。因此操作系统为保证安全性会提供一些方法让其进行通信。</p><h3 id="通信之共享内存："><a href="#通信之共享内存：" class="headerlink" title="通信之共享内存："></a>通信之共享内存：</h3><p>两个进程对共享内存的访问必须互斥，操作系统负责提供共享空间和P、V操作</p><h3 id="通信之管道："><a href="#通信之管道：" class="headerlink" title="通信之管道："></a>通信之管道：</h3><p>用于连接读写进程的一个共享文件（实质就是在内存中开辟一个固定大小的缓冲区，它是一个半双工通信，同一时间段只能单向）。广义上讲同步，两端必须各有一个进程，狭义上互斥，因为一端进程写的时候另一个端不能读。数据以字符流的形式写入管道，当管道写满，write()会被阻塞，然后等待读进程取走管道变空，然后读进程阻塞。循环这个过程</p><h3 id="线程控制块和线程切换："><a href="#线程控制块和线程切换：" class="headerlink" title="线程控制块和线程切换："></a>线程控制块和线程切换：</h3><p>也有线程控制块也有状态（就绪、阻塞、运行）。线程切换不一定进程切换，进程切换线程一定切换。</p><h3 id="用户级线程和内核级线程。"><a href="#用户级线程和内核级线程。" class="headerlink" title="用户级线程和内核级线程。"></a>用户级线程和内核级线程。</h3><p>用户级线程由程序通过线程库来实现的。所有线程管理工作由应用程序负责（包括线程切换），因此线程切换可以在用户态下完成，操作系统意识不到线程的存在。</p><p>而内核级线程的管理工作是由操作系统内核完成。因此线程调度、切换等工作都由内核负责。操作系统能看到线程的存在</p><p>对于同时支持用户级线程和内核级线程的操作系统，可采用两者组合方式，将n个用户级线程映射到m个内核级线程（n&gt;=m），这时即使系统是四核，也最多只能有两个用户线程并行执行。（也就是说，内核级线程才是资源分配的单位）</p><p>用户级线程映射到内核级线程有几个模式：1.多对一（线程并发性低，线程切换无须到内核态，线程管理开销小） 2.一对一（线程并发性高，线程切换需要到内核态（因为涉及到内核级线程的切换），线程管理开销大） 3.多对多（集二者的优缺点）</p><h3 id="高级调度（作业调度）："><a href="#高级调度（作业调度）：" class="headerlink" title="高级调度（作业调度）："></a>高级调度（作业调度）：</h3><p>属于内存与外存之间的调度，每个作业只调入一次（调入时创建PCB），调出一次（调出时撤销PCB）。按一定原则从外存上处于后备队列的作业中挑选一个或多个作业，给他们分配内存等必要资源，并建立相应的进程，使他们获得竞争处理器的权利。（大概就是无-&gt;创建态-&gt;就绪态）</p><h3 id="中级调度（内存调度）："><a href="#中级调度（内存调度）：" class="headerlink" title="中级调度（内存调度）："></a>中级调度（内存调度）：</h3><p>也就是内存调度（详细自己想）就是决定把哪个处于挂起状态的进程重新调入内存，一个进程可能多次调入调出。暂时调到外存等待的进程状态为挂起状态，PCB不会被调到外存，而是常驻内存，只是把PCB放到挂起队列中。（这涉及到起状态模型，多了一个就绪挂起（和就绪态双向），一个阻塞挂起（和阻塞态双向），然后阻塞挂起可以到就绪挂起）（大概就是挂起态-&gt;就绪态）</p><h3 id="低级调度（CPU调度）："><a href="#低级调度（CPU调度）：" class="headerlink" title="低级调度（CPU调度）："></a>低级调度（CPU调度）：</h3><p>也就是CPU调度（详细自己想）就是从就绪队列中选取一个进程变为运行态。它的发生频率最高（大概就是就绪态-&gt;运行态）</p><p>阻塞、就绪、运行态都在内存，而就绪挂起、阻塞挂起都在外存上</p><h3 id="在什么时候不能进行进程间切换："><a href="#在什么时候不能进行进程间切换：" class="headerlink" title="在什么时候不能进行进程间切换："></a>在什么时候不能进行进程间切换：</h3><p>1.处理中断的过程 2. 进程在操作系统内核程序临界区中 3.原子操作过程中</p><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>是指一个时间段只允许一个进程使用的资源，临界区是执行临界资源的代码</p><h3 id="操作系统的性能指标"><a href="#操作系统的性能指标" class="headerlink" title="操作系统的性能指标"></a>操作系统的性能指标</h3><p>CPU利用率：指CPU忙碌时间占总时间的比</p><p>系统吞吐量：总共完成多少道作业/总共</p><p>周转时间：作业从提交系统开始到完成结束所需时间</p><p>带权周转时间：周转时间/所需时间</p><p>平均周转时间：所有作业的平均值</p><h3 id="CPU虚拟轮转法为什么优先I-O繁忙型进程："><a href="#CPU虚拟轮转法为什么优先I-O繁忙型进程：" class="headerlink" title="CPU虚拟轮转法为什么优先I/O繁忙型进程："></a>CPU虚拟轮转法为什么优先I/O繁忙型进程：</h3><p>因为I/O设备可以和CPU并行工作，如果优先I/O繁忙型进程，更有可能让I/O设备尽早工作，资源利用率得到提高</p><h3 id="管程："><a href="#管程：" class="headerlink" title="管程："></a>管程：</h3><p>一种高级的进程互斥、同步机制。管程是一种特殊的软件模块（类似于类），它有对应的数据结构、对数据结构进行操作的函数、初始化语句以及管程的名字。因此管程的数据只能被管程的函数所访问，一个进程只能通过调用管程的函数才能访问管程的数据，每次只允许一个进程在管程中执行某个函数。编译器负责实现各进程互斥的进入管程中的过程</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步：这些进程因为需要在某些位置上协调它们的工作次序而产生制约关系。而异步是多个进程并发执行，由于资源有限，进程是以不可预知的速度交替执行的。</p><h3 id="实现进程互斥的方法："><a href="#实现进程互斥的方法：" class="headerlink" title="实现进程互斥的方法："></a>实现进程互斥的方法：</h3><p>1单标志法，2双标志先检查，3双标志后检查，4.Peterson算法</p><p>单标志法：用于两个进程之间，一个进程在访问完临界区后会把权限转交给另一个进程。有一个标志位，标志为几就允许几号进程访问临界区（缺点是一个进程想访问，另一个进程不访问，而标志位在另一个进程，这时无法继续）</p><p>双标志先检查法：设置一个布尔数组，用来标记各进程想要进入临界区的意愿。如果没有其它的进程为true，它就把自己的所在位设为true，访问完临界区再修改为false（这种访问bug特别多，因为检查过程和设置true的过程不是原子操作）</p><p>双标志后检查法：先上锁后检查，避免双标志先检查法的bug，但是又有新的bug（两个进程都true，结果都在等待）</p><p>Peterson算法：孔融让梨的思想，设置一个布尔型数组，用来标记各进程想要进入临界区的意愿，再设置一个单标志，用于优先哪个进程进入临界区。进程想要进入临界区时，会设置意愿为true，并礼让另一个 进程，把单标志设置为对方。如果对方有想进入的意愿且单标志位为对方，那么就等待，否则就进入临界区，出临界区把意愿设置为false</p><h3 id="进程互斥的硬件实现方法："><a href="#进程互斥的硬件实现方法：" class="headerlink" title="进程互斥的硬件实现方法："></a>进程互斥的硬件实现方法：</h3><p>中断屏蔽，TestAndSet(TS指令)，Swap指令</p><p>中断屏蔽：就是先关中断，然后再开中断。1.它只是用于单核处理机。因为对于多核处理器来说，关中断开中断只对它所属的处理机有效，可能其它进程在另一个处理机处理。2.开关中断权限高，只适用于内核进程</p><p>Ts指令：通过硬件来实现的，执行的过程不允许被中断。（原理就是利用新旧bool，循环利用Ts函数检查新的bool是否为false，为true循环检测，为false则访问资源，访问完毕将新bool设置为false。在Ts函数中，若为true，则更新旧的为true，新的也为true，返回旧的；若为false，则更新旧的为false，新的为true，返回旧的）</p><p>信号量机制：用户进程可以通过一对原语（wait和signal）来对信号量进行操作。信号量其实就是一个变量，可以用来表示系统中某种资源的数量。分为整型信号量和记录型信号量</p><p>整型信号量；wait简易来说就是一个while循环直到变量&gt;0，然后进行—操作，signal建立来说就是进行++操作</p><p>记录型信号量；相比整型信号量多了一个等待队列，wait就是对信号量进行- -操作，若该值小于0，就把进程从运行态转变为阻塞态。signal就是对信号量进行++操作，若信号量值小于等于0，那么就唤醒等待队列中的一个进程（也就是让进程从阻塞态变为就绪态）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker简单使用</title>
      <link href="/2019/05/04/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/05/04/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/04/Docker简单使用/title.jpg" alt="title"></p><a id="more"></a><h4 id="什么是docker？"><a href="#什么是docker？" class="headerlink" title="什么是docker？"></a>什么是docker？</h4><p>​    Docker是一个开源引擎，可以为应用创建一个轻量级的容器。我们在电脑上编译测试通过的容器可以批量在生产环境中部署。</p><h4 id="什么是docker容器？"><a href="#什么是docker容器？" class="headerlink" title="什么是docker容器？"></a>什么是docker容器？</h4><p>​    docker容器可以理解为在沙盒中运行的进程，沙盒包含了该进程运行所必须的资源。包括文件系统、系统类库、shell环境等等。沙盒默认不运行任何程序，我们需要在沙盒中运行一个进程来启动某个容器。这个进程是该容器的唯一进程，当进程结束，容器也会完全停止</p><h4 id="docker的用途"><a href="#docker的用途" class="headerlink" title="docker的用途"></a>docker的用途</h4><ul><li>web应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li></ul><h4 id="docker的结构"><a href="#docker的结构" class="headerlink" title="docker的结构"></a>docker的结构</h4><p>​    Docker系统有两个程序：docker服务端和docker客户端。</p><p>​    docker服务端是一个服务进程，管理所有容器。</p><p>​    docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。</p><p>​    大部分情况下，docker服务端和客户端运行在一台机器上。</p><h4 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h4><h5 id="Step1-查找想使用的镜像"><a href="#Step1-查找想使用的镜像" class="headerlink" title="Step1:查找想使用的镜像"></a>Step1:查找想使用的镜像</h5><p>​    使用命令<code>$docker search 镜像名</code>查找想使用的镜像</p><h5 id="Step2-下载镜像"><a href="#Step2-下载镜像" class="headerlink" title="Step2:下载镜像"></a>Step2:下载镜像</h5><p>​    使用命令<code>$docker pull 用户名/镜像名</code>。注意：大部分的镜像都是按照用户名/镜像名来存储的，还有一些ubuntu等基础镜像，可以直接用镜像名来检索到。</p><h5 id="Step3-在镜像中运行命令"><a href="#Step3-在镜像中运行命令" class="headerlink" title="Step3:在镜像中运行命令"></a>Step3:在镜像中运行命令</h5><p>​    使用命令<code>$docker run 用户名/镜像名 命令</code>来运行，比如安装ping：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$docker run learn/tutorial apt-get install -y ping</span><br></pre></td></tr></table></figure><h5 id="Step4-保存对容器的修改"><a href="#Step4-保存对容器的修改" class="headerlink" title="Step4: 保存对容器的修改"></a>Step4: 保存对容器的修改</h5><p>​    我们可以先利用<code>$docker ps -l</code>命令获取安装完程序后容器的id。</p><p>​    利用<code>$docker commit 容器id 保存路径</code>，命令返回新版本镜像的id号</p><h5 id="Step5：运行新镜像"><a href="#Step5：运行新镜像" class="headerlink" title="Step5：运行新镜像"></a>Step5：运行新镜像</h5><p>​    利用<code>$docker run 保存的路径 命令</code>来运行</p><h5 id="查看运行中的镜像"><a href="#查看运行中的镜像" class="headerlink" title="查看运行中的镜像"></a>查看运行中的镜像</h5><p>​    利用<code>$docker ps</code>查看所有正在运行中的容器列表，利用<code>docker inspect 容器id</code>查看某个容器更详细的信息</p><h5 id="发布自己的映像"><a href="#发布自己的映像" class="headerlink" title="发布自己的映像"></a>发布自己的映像</h5><p>​    用<code>docker images</code>命令列出所有安装过的镜像</p><p>​    用<code>docker push</code>命令可以将一个镜像发布到官网（当然只是发布到自己的空间下面）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题反思</title>
      <link href="/2019/04/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8D%E6%80%9D/"/>
      <url>/2019/04/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/28/面试题反思/title.jpg" alt="title"></p><a id="more"></a><p>​    自己好紧张啊。。。。紧张到我自己都不知道自己说什么，对方问的什么。。脑子像浆一样。。。挂了电话强行清醒了一下。。</p><p>​    第一个问题，给一个链表，问把其中的偶数逆序一下，要求O(1)空间复杂度。挂了电话想到一个方法，利用两个头指针把奇数的正序连接，偶数的逆序连接，再奇数-&gt;next偶数，发现不满足题意。暂时没想到除了数组更好的办法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    第二个问题，给出一个字符串a，一个字符串b，问能否得到字符串c（不能改变a，b内部的顺序）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp[1005][1005] = &#123;0&#125;;</span><br><span class="line">//假设字符串都是从1开始,str1的长度为n，str2的长度为m</span><br><span class="line">//dp[i][j]代表字符串c的前i个字符串，其中由j个字符串a组成，i - j 个字符串b组成。</span><br><span class="line">dp[0][0] = 1;//初始化前0个字符可以由0个字符串a，0个字符串b组成</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= str3.size(); i++)  &#123;</span><br><span class="line">for (int j = 0; j &lt;= i &amp;&amp; j &lt;= n; j++) &#123;</span><br><span class="line">if (str3[i] == str1[j] &amp;&amp; dp[i - 1][j - 1]) &#123;</span><br><span class="line">dp[i][j] = 1;</span><br><span class="line">&#125; else if (str3[i] == str2[i - j] &amp;&amp; dp[i - 1][j]) &#123;</span><br><span class="line">dp[i][j] = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dp[i][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这道题动态规划入门题。。。挂了电话就立刻想到了。。。冷静冷静，感觉自己应该5.1期间出去旅游走走放松放松。。自己面试心态太炸了，冷静，冷静，冷静！！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode84</title>
      <link href="/2019/04/24/Leetcode84/"/>
      <url>/2019/04/24/Leetcode84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/24/Leetcode84/title1.jpg" alt="title1"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode84.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 二  4/23 19:51:20 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//求n个连续柱子组成的最大矩形面积</span><br><span class="line">//方法：单调栈来维护</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt;sta;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int len = heights.size();</span><br><span class="line">        int maxx = 0;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (sta.empty() || heights[sta.top()] &lt;= heights[i]) &#123;</span><br><span class="line">                sta.push(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while(!sta.empty() &amp;&amp; heights[sta.top()] &gt; heights[i]) &#123;</span><br><span class="line">                    int inx = sta.top();</span><br><span class="line">                    sta.pop();</span><br><span class="line">                    </span><br><span class="line">                    int s = -1, e = i;</span><br><span class="line">                    if (!sta.empty()) &#123;</span><br><span class="line">                        s = sta.top();</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    maxx = max(maxx, (e - s - 1) * heights[inx]);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                sta.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int e;</span><br><span class="line">        if (!sta.empty()) &#123;</span><br><span class="line">            e = sta.top();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!sta.empty()) &#123;</span><br><span class="line">            int s = -1, inx = sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            </span><br><span class="line">            if (!sta.empty()) &#123;</span><br><span class="line">                s = sta.top();</span><br><span class="line">            &#125;</span><br><span class="line">            maxx = max(maxx, (e - s) * heights[inx]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">int largestRectangleArea(int* heights, int heightsSize) &#123;</span><br><span class="line">    </span><br><span class="line">    int *stack = (int *)malloc(sizeof(int) * heightsSize);</span><br><span class="line">    int *left = (int *)malloc(sizeof(int) * heightsSize);</span><br><span class="line">    int *right = (int *)malloc(sizeof(int) * heightsSize);</span><br><span class="line"></span><br><span class="line">    //找以该节点往左扩的长度</span><br><span class="line">    int top = -1;</span><br><span class="line">    for (int i = 0; i &lt; heightsSize; i++) &#123;</span><br><span class="line">        while (top != -1 &amp;&amp; heights[stack[top]] &gt;= heights[i]) --top;</span><br><span class="line">        left[i] = (top == -1 ? i + 1 : i - stack[top]);</span><br><span class="line">        stack[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //找以该节点往右扩的长度</span><br><span class="line">    top = -1;</span><br><span class="line">    for (int i = heightsSize - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        while (top != -1 &amp;&amp; heights[stack[top]] &gt;= heights[i]) --top;</span><br><span class="line">        right[i] = (top == -1 ? heightsSize - i : stack[top] - i);</span><br><span class="line">        stack[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //维护最大范围</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; heightsSize; i++) &#123;</span><br><span class="line">        ans = fmax(ans, (left[i] + right[i] - 1) * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(stack);</span><br><span class="line">    free(left);</span><br><span class="line">    free(right);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode42</title>
      <link href="/2019/04/24/Leetcode42/"/>
      <url>/2019/04/24/Leetcode42/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/24/Leetcode42/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode42.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 二  4/23 19:45:30 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//给出n个宽度为1的柱子的高度，问最多存多少水</span><br><span class="line">//方法：利用单调栈来维护（只有保持V型才能存水，因此递减就添加到栈，递增就维护和</span><br><span class="line">//因此我们需要维护一个单调递减栈，在出栈的时候维护和）</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    stack &lt;int&gt; sta;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; height.size(); i++) &#123;</span><br><span class="line">        //单调递减就增加</span><br><span class="line">            if (sta.empty() || height[sta.top()] &gt; height[i]) &#123;</span><br><span class="line">                sta.push(i);</span><br><span class="line">            &#125; else &#123;//出现递增就维护</span><br><span class="line"></span><br><span class="line">                while(!sta.empty() &amp;&amp; height[sta.top()] &lt;= height[i]) &#123;</span><br><span class="line">                    int inx = sta.top();</span><br><span class="line">                    sta.pop();</span><br><span class="line"></span><br><span class="line">                    //避免sta.top()访问错误</span><br><span class="line">                    if (sta.empty()) break;</span><br><span class="line">                    </span><br><span class="line">                    int x = min(height[sta.top()] - height[inx], height[i] - height[inx]);</span><br><span class="line">                    int y = i - sta.top() - 1;</span><br><span class="line">                    sum += x * y;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sta.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return sum;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 结构数据 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode236</title>
      <link href="/2019/04/19/Leetcode236/"/>
      <url>/2019/04/19/Leetcode236/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode236/title1.jpg" alt="title1"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode236.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 18:50:12 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//二叉树求公共最近祖先</span><br><span class="line">//方法一：递归（最近祖先有一个特点，要么是左右点各有一个节点，要么是祖先是其中一个节点）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (!root || !p || !q) return NULL;</span><br><span class="line">        </span><br><span class="line">        if (root == p || root == q) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode *temp1 = lowestCommonAncestor(root -&gt; left, p, q);</span><br><span class="line">        TreeNode *temp2 = lowestCommonAncestor(root -&gt; right, p, q);</span><br><span class="line">        </span><br><span class="line">        if (temp1 &amp;&amp; temp2) return root;</span><br><span class="line">        if (temp1) return temp1;</span><br><span class="line">        if (temp2) return temp2;</span><br><span class="line">        </span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode235</title>
      <link href="/2019/04/19/Leetcode235/"/>
      <url>/2019/04/19/Leetcode235/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode235/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode235.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 17:41:59 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//二叉搜索树的最近公共祖先</span><br><span class="line">//方法一：递归从上往下，若都小于该节点递归左节点，若都大于递归右节点，否则直接返回</span><br><span class="line">//方法二：非递归</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (!root || !p || !q) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; val &lt; p -&gt; val &amp;&amp; root -&gt; val &lt; q -&gt; val) &#123;</span><br><span class="line">            return lowestCommonAncestor(root -&gt; right, p, q);</span><br><span class="line">        &#125; else if(root -&gt; val &gt; p -&gt; val &amp;&amp; root -&gt; val &gt; q -&gt; val) &#123;</span><br><span class="line">            return lowestCommonAncestor(root -&gt; left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;TreeNode*&gt;que;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (!root || !p || !q) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            TreeNode *temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if (temp -&gt; val &lt; p -&gt; val &amp;&amp; temp -&gt; val &lt; q -&gt; val) &#123;</span><br><span class="line">                if (temp -&gt; right) &#123;</span><br><span class="line">                    que.push(temp -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (temp -&gt; val &gt; p -&gt; val &amp;&amp; temp -&gt; val &gt; q -&gt; val) &#123;</span><br><span class="line">                if (temp -&gt; left) &#123;</span><br><span class="line">                    que.push(temp -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode226</title>
      <link href="/2019/04/19/Leetcode226/"/>
      <url>/2019/04/19/Leetcode226/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode226/title9.jpg" alt="title9"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode226.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 15:52:44 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//翻转二叉树</span><br><span class="line">//方法一：递归从上往下递归替换</span><br><span class="line">//方法二：非递归</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return NULL;</span><br><span class="line">        </span><br><span class="line">        TreeNode *temp = root -&gt; left;</span><br><span class="line">        </span><br><span class="line">        root -&gt; left = invertTree(root -&gt; right);</span><br><span class="line">        root -&gt; right = invertTree(temp);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;TreeNode *&gt;que;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return NULL;</span><br><span class="line">        </span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            TreeNode *temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            </span><br><span class="line">            TreeNode *p = temp -&gt; left;</span><br><span class="line">            temp -&gt; left = temp -&gt; right;</span><br><span class="line">            temp -&gt; right = p;</span><br><span class="line">            </span><br><span class="line">            if (temp -&gt; left) que.push(temp -&gt; left);</span><br><span class="line">            if (temp -&gt; right) que.push(temp -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode114</title>
      <link href="/2019/04/19/Leetcode114/"/>
      <url>/2019/04/19/Leetcode114/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode114/title8.jpg" alt="title8"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode114.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 11:28:59 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//将二叉树转变为单向链表（前序规则）</span><br><span class="line">//方法一：递归，利用一个vec进行存进行前序遍历，然后设置</span><br><span class="line">//方法二：非递归</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode *&gt;vec;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode *root) &#123;</span><br><span class="line">        </span><br><span class="line">        vec.push_back(root);</span><br><span class="line">        if (root -&gt; left) dfs(root -&gt; left);</span><br><span class="line">        if (root -&gt; right) dfs(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        </span><br><span class="line">        dfs(root);</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; vec.size() - 1; i++) &#123;</span><br><span class="line">            vec[i] -&gt; right = vec[i + 1];</span><br><span class="line">            vec[i] -&gt; left = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[vec.size() - 1] -&gt; left = NULL;</span><br><span class="line">        vec[vec.size() - 1] -&gt; right = NULL;</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;TreeNode *&gt;sta;</span><br><span class="line">    vector&lt;TreeNode *&gt;vec;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        </span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        TreeNode *temp = new TreeNode(0);</span><br><span class="line">        </span><br><span class="line">        while(!sta.empty() || p) &#123;</span><br><span class="line">            while(p) &#123;</span><br><span class="line">                vec.push_back(p);</span><br><span class="line">                sta.push(p);</span><br><span class="line">                p = p -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(!sta.empty()) &#123;</span><br><span class="line">                p = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                p = p -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; vec.size() - 1; i++) &#123;</span><br><span class="line">            vec[i] -&gt; left = NULL;</span><br><span class="line">            vec[i] -&gt; right = vec[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">        vec[vec.size() - 1] -&gt; left = NULL;</span><br><span class="line">        </span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode111</title>
      <link href="/2019/04/19/Leetcode111/"/>
      <url>/2019/04/19/Leetcode111/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode111/title7.jpg" alt="title7"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode111.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 10:11:38 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//求二叉树的最小深度（最小深度是指从根节点到叶节点的最短距离）</span><br><span class="line">//方法一：递归，若节点存在左右节点，则该节点为左右节点深度的最小值+1；否则为左右节点深度的最大值+1</span><br><span class="line">//方法二：非递归层次遍历，遍历到第一个出现无左右节点的节点深度返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; left &amp;&amp; root -&gt; right) &#123;</span><br><span class="line">            return min(minDepth(root -&gt; left), minDepth(root -&gt; right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max(minDepth(root -&gt; left), minDepth(root -&gt; right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;TreeNode*&gt;que;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        </span><br><span class="line">        int deep = 0;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            deep ++;</span><br><span class="line">            int len = que.size();</span><br><span class="line">            </span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode *temp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                if (!temp -&gt; left &amp;&amp; !temp -&gt; right) &#123;</span><br><span class="line">                    return deep;</span><br><span class="line">                &#125;</span><br><span class="line">                if (temp -&gt; left) &#123;</span><br><span class="line">                    que.push(temp -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (temp -&gt; right) &#123;</span><br><span class="line">                    que.push(temp -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return deep;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode113</title>
      <link href="/2019/04/19/Leetcode113/"/>
      <url>/2019/04/19/Leetcode113/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode113/title6.jpg" alt="title6"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode113.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 10:53:18 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//给出一个二叉树和一个目标和，找到所有根节点到叶子节点路径等于目标和的路径</span><br><span class="line">//方法：递归dfs，到根节点判断是否相同，相同就加进去</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//代码：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode *root, int &amp;now, int &amp;sum) &#123;</span><br><span class="line">        now += root -&gt; val;</span><br><span class="line">        temp.push_back(root -&gt; val);</span><br><span class="line">        </span><br><span class="line">        //当节点为叶节点时</span><br><span class="line">        if (!root -&gt; left &amp;&amp; !root -&gt; right) &#123;</span><br><span class="line">            if (now == sum) &#123;</span><br><span class="line">                vec.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            now -= root -&gt; val;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //当节点不为叶节点</span><br><span class="line">        if (root -&gt; left) &#123;</span><br><span class="line">            dfs(root -&gt; left, now, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; right) &#123;</span><br><span class="line">            dfs(root -&gt; right, now, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        now -= root -&gt; val;</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if (!root) return vec;</span><br><span class="line">        </span><br><span class="line">        int now = 0;</span><br><span class="line">        dfs(root, now, sum);</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode110</title>
      <link href="/2019/04/19/Leetcode110/"/>
      <url>/2019/04/19/Leetcode110/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode110/title5.jpg" alt="title5"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode110.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 09:50:46 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//判断是否是平衡二叉树</span><br><span class="line">//方法一：对于每个节点的左右儿子进行dfs查找深度，然后再dfs左子树和右子树是否符合条件，三个同时满足返回真</span><br><span class="line">//方法二：引用传参代表深度，然后一次dfs判断是否为平衡二叉树即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二代码：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool istrue(TreeNode* root, int &amp;h) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            h = 1;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if(!istrue(root -&gt; left, h)) return false;</span><br><span class="line">        int h1 = h;</span><br><span class="line">        if(!istrue(root -&gt; right, h)) return false;</span><br><span class="line">        int h2 = h;</span><br><span class="line">        </span><br><span class="line">        h = max(h1, h2) + 1;</span><br><span class="line">        </span><br><span class="line">        if (abs(h1 - h2) &lt;= 1) return true;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        int h = 0;</span><br><span class="line">        return istrue(root, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode107</title>
      <link href="/2019/04/19/Leetcode107/"/>
      <url>/2019/04/19/Leetcode107/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode107/title4.jpg" alt="title4"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode107.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 09:14:10 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//二叉树层次遍历，从下往上</span><br><span class="line">//方法一：递归+交换（反转）</span><br><span class="line">//方法二：非递归+交换（反转）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector &lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">    int num = -1;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int deep) &#123;</span><br><span class="line">        if (deep &gt; num) &#123;</span><br><span class="line">            vec.push_back(vector&lt;int&gt;());</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vec[deep].push_back(root -&gt; val);</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; left) &#123;</span><br><span class="line">            dfs(root -&gt; left, deep + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; right) &#123;</span><br><span class="line">            dfs(root -&gt; right, deep + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return vec;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(root, 0);</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; (num + 1) / 2; i++) &#123;</span><br><span class="line">            vector&lt;int&gt; temp = vec[i];</span><br><span class="line">            vec[i] = vec[num - i];</span><br><span class="line">            vec[num - i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    queue&lt;TreeNode *&gt;que;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return vec;</span><br><span class="line">        </span><br><span class="line">        que.push(root);</span><br><span class="line">        int deep = 0;</span><br><span class="line">        </span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            int len = que.size();</span><br><span class="line">            deep ++;</span><br><span class="line">        </span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode *k = que.front();</span><br><span class="line">                temp.push_back(k -&gt; val);</span><br><span class="line">                if (k -&gt; left) &#123;</span><br><span class="line">                    que.push(k -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (k -&gt; right) &#123;</span><br><span class="line">                    que.push(k -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            vec.push_back(temp);</span><br><span class="line">            temp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; deep / 2; i++) &#123;</span><br><span class="line">            temp = vec[i];</span><br><span class="line">            vec[i] = vec[deep - 1 - i];</span><br><span class="line">            vec[deep - 1 - i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode105</title>
      <link href="/2019/04/19/Leetcode105/"/>
      <url>/2019/04/19/Leetcode105/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode105/title3.jpg" alt="title3"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode105.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/19 08:55:40 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//根据前序、中序构造二叉树</span><br><span class="line">//递归方式，参数传6个（前序、中序数组，前序开始结尾下标，中序开始结尾下标），当开始&gt;结束为终止条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        return dfs(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* dfs(vector&lt;int&gt;&amp; p, int ps, int pe, vector&lt;int&gt;&amp; q, int qs, int qe) &#123;</span><br><span class="line">        if (ps &gt; pe || qs &gt; qe) return NULL;</span><br><span class="line">        </span><br><span class="line">        TreeNode *temp = new TreeNode(p[ps]);</span><br><span class="line">        int inx = qs;</span><br><span class="line">        </span><br><span class="line">        for (int i = qs; i &lt;= qe; i++) &#123;</span><br><span class="line">            if (q[i] == p[ps]) &#123;</span><br><span class="line">                inx = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //左个数：inx - qs, 右个数：qe - inx</span><br><span class="line">        temp -&gt; left = dfs(p, ps + 1, ps + inx - qs, q, qs, inx - 1);</span><br><span class="line">        temp -&gt; right = dfs(p, ps + inx - qs + 1, pe, q, inx + 1, qe);</span><br><span class="line">            </span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode102</title>
      <link href="/2019/04/19/Leetcode102/"/>
      <url>/2019/04/19/Leetcode102/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode102/title2.jpg" alt="title2"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode102.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 四  4/18 21:12:59 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//二叉树的层次遍历</span><br><span class="line">//方法一：非递归遍历（利用一个变量deep记录深度，一个滚动数组num[2]记录每一层的个数）</span><br><span class="line">//方法二：递归遍历 (参数传深度deep，再用一个num记录当前最深的深度，只要deep &gt; num就再push一个vector一维数组)</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector &lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">    queue &lt;TreeNode *&gt; que;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return vec;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        </span><br><span class="line">        que.push(root);</span><br><span class="line">        int deep = 1;</span><br><span class="line">        int num[2] = &#123;0, 1&#125;;</span><br><span class="line">        </span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            TreeNode *p = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            temp.push_back(p -&gt; val);</span><br><span class="line">            num[deep % 2] --;</span><br><span class="line">            </span><br><span class="line">            if (!num[deep % 2]) &#123;</span><br><span class="line">                vec.push_back(temp);</span><br><span class="line">                temp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (p -&gt; left) &#123;</span><br><span class="line">                que.push(p -&gt; left);</span><br><span class="line">                num[(deep + 1) % 2]++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (p -&gt; right) &#123;</span><br><span class="line">                que.push(p -&gt; right);</span><br><span class="line">                num[(deep + 1) % 2]++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (!num[deep % 2]) deep ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector &lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">    int num = -1;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int deep) &#123;</span><br><span class="line">        if (deep &gt; num) &#123;</span><br><span class="line">            vec.push_back(vector&lt;int&gt;());</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vec[deep].push_back(root -&gt; val);</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; left) &#123;</span><br><span class="line">            dfs(root -&gt; left, deep + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (root -&gt; right) &#123;</span><br><span class="line">            dfs(root -&gt; right, deep + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return vec;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(root, 0);</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode101</title>
      <link href="/2019/04/19/Leetcode101/"/>
      <url>/2019/04/19/Leetcode101/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode101/title1.jpg" alt="title1"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode101.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 四  4/18 20:20:23 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//判断对称二叉树</span><br><span class="line">//方法一：递归（函数包含两个参数）</span><br><span class="line">//方法二：非递归（注意存BFS的次序，还有根存两次）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isTrue(TreeNode *l, TreeNode *r) &#123;</span><br><span class="line">        if (!l &amp;&amp; !r) return true;</span><br><span class="line">        if (!l || !r) return false;</span><br><span class="line">        if (l -&gt; val != r -&gt; val) return false;</span><br><span class="line">        return isTrue(l -&gt; left, r -&gt; right) &amp;&amp; isTrue(l -&gt; right, r -&gt; left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return true;</span><br><span class="line">        return isTrue(root -&gt; left, root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return true;</span><br><span class="line">        que.push(root);</span><br><span class="line">        que.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            TreeNode *p = que.front(); que.pop();</span><br><span class="line">            TreeNode *q = que.front(); que.pop();</span><br><span class="line">            </span><br><span class="line">            if ((p &amp;&amp; !q) || (!p &amp;&amp; q)) return false;</span><br><span class="line">            if (p &amp;&amp; q) &#123;</span><br><span class="line">                if (p -&gt; val != q -&gt; val) return false;</span><br><span class="line">                que.push(p -&gt; left);</span><br><span class="line">                que.push(q -&gt; right);</span><br><span class="line">                que.push(p -&gt; right);</span><br><span class="line">                que.push(q -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode100</title>
      <link href="/2019/04/19/Leetcode100/"/>
      <url>/2019/04/19/Leetcode100/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/19/Leetcode100/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode100.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 四  4/18 19:20:48 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//判断两个树是否相同</span><br><span class="line">//方法一：递归判断</span><br><span class="line">//方法二：非递归判断</span><br><span class="line"></span><br><span class="line">//方法一：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (p == NULL &amp;&amp; q == NULL) return true;</span><br><span class="line">        if (p == NULL || q == NULL) return false;</span><br><span class="line">        if (p -&gt; val != q -&gt; val) return false;</span><br><span class="line">        return isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    queue &lt;TreeNode *&gt; t1, t2;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (!p &amp;&amp; !q) return true;</span><br><span class="line">        if (!p || !q) return false;</span><br><span class="line">        </span><br><span class="line">        t1.push(p);</span><br><span class="line">        t2.push(q);</span><br><span class="line">        </span><br><span class="line">        while(!t1.empty() &amp;&amp; !t2.empty()) &#123;</span><br><span class="line">            TreeNode *temp1 = t1.front();</span><br><span class="line">            TreeNode *temp2 = t2.front();</span><br><span class="line">            t1.pop();</span><br><span class="line">            t2.pop();</span><br><span class="line">            </span><br><span class="line">            if (temp1 -&gt; val != temp2 -&gt; val) return false;</span><br><span class="line">            </span><br><span class="line">            if (temp1 -&gt; left &amp;&amp; temp2 -&gt; left) &#123;</span><br><span class="line">                t1.push(temp1 -&gt; left);</span><br><span class="line">                t2.push(temp2 -&gt; left);</span><br><span class="line">            &#125; else if (temp1 -&gt; left || temp2 -&gt; left)  &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (temp1 -&gt; right &amp;&amp; temp2 -&gt; right) &#123;</span><br><span class="line">                t1.push(temp1 -&gt; right);</span><br><span class="line">                t2.push(temp2 -&gt; right);</span><br><span class="line">            &#125; else if (temp1 -&gt; right || temp2 -&gt; right)  &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (t1.empty() &amp;&amp; t2.empty()) return true;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode232栈实现队列</title>
      <link href="/2019/04/18/Leetcode232%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/18/Leetcode232%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/18/Leetcode232栈实现队列/title1.jpg" alt="title1"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode232.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 四  4/18 18:54:37 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//栈实现队列</span><br><span class="line">//方法一：两个队列，一个队列用于存，另一个队列用于反转（删除头，返回头操作），之后再反转回去</span><br><span class="line">//方法二：把队列反转，需要用一个临时队列</span><br><span class="line"></span><br><span class="line">//方法一代码：</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; p, q;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x to the back of queue. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        p.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element from in front of queue and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        while(!p.empty()) &#123;</span><br><span class="line">            q.push(p.top());</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int k = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            p.push(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the front element. */</span><br><span class="line">    int peek() &#123;</span><br><span class="line">        while(!p.empty()) &#123;</span><br><span class="line">            q.push(p.top());</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int k = q.top();</span><br><span class="line">        </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            p.push(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return k;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the queue is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return p.empty();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; p, q;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x to the back of queue. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        while(!p.empty()) &#123;</span><br><span class="line">            q.push(p.top());</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q.push(x);</span><br><span class="line">        </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            p.push(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element from in front of queue and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int k = peek();</span><br><span class="line">        p.pop();</span><br><span class="line">        </span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the front element. */</span><br><span class="line">    int peek() &#123;</span><br><span class="line">        return p.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the queue is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return p.empty();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="line"> * MyQueue* obj = new MyQueue();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;peek();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode225队列实现栈</title>
      <link href="/2019/04/18/Leetcode225%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2019/04/18/Leetcode225%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/18/Leetcode225队列实现栈/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode225.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 四  4/18 18:35:39 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//用两个队列实现栈</span><br><span class="line"></span><br><span class="line">//方法：把队列反转即可，需要一个临时队列</span><br><span class="line"></span><br><span class="line">class MyStack &#123;</span><br><span class="line">private:</span><br><span class="line">    queue &lt;int&gt; p, q;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        p.push(x);</span><br><span class="line">        </span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            p.push(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!p.empty()) &#123;</span><br><span class="line">            q.push(p.front());</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int k = top();</span><br><span class="line">        q.pop();</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode20括号匹配</title>
      <link href="/2019/04/18/Leetcode20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/04/18/Leetcode20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/18/Leetcode20括号匹配/title4.jpg" alt="title4"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode20.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 四  4/18 18:25:07 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//一个字符串只包含()[]&#123;&#125;六种符号，判断字符串是否闭合</span><br><span class="line"></span><br><span class="line">//方法：使用一个栈来进行匹配操作</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;char&gt;sta;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &apos;(&apos; || s[i] == &apos;[&apos; || s[i] == &apos;&#123;&apos;) &#123;</span><br><span class="line">                sta.push(s[i]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (sta.empty()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (s[i] == &apos;)&apos;) &#123;</span><br><span class="line">                    if (sta.top() != &apos;(&apos;) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sta.pop();</span><br><span class="line">                &#125; else if (s[i] == &apos;]&apos;) &#123;</span><br><span class="line">                    if (sta.top() != &apos;[&apos;) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sta.pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (sta.top() != &apos;&#123;&apos;) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sta.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!sta.empty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>落谷P3379最近公共祖先</title>
      <link href="/2019/04/17/%E8%90%BD%E8%B0%B7P3379%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2019/04/17/%E8%90%BD%E8%B0%B7P3379%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/17/落谷P3379最近公共祖先/titile.jpg" alt="titile"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行包含三个正整数N、M、S，分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来N-1行每行包含两个正整数x、y，表示x结点和y结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来M行每行包含两个正整数a、b，表示询问a结点和b结点的最近公共祖先。</p><p>输出格式：</p><p>输出包含M行，每行包含一个正整数，依次为每一个询问的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5 4</span><br><span class="line">3 1</span><br><span class="line">2 4</span><br><span class="line">5 1</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>时空限制：1000ms,128M</p><p>数据规模：</p><p>对于30%的数据：N&lt;=10，M&lt;=10</p><p>对于70%的数据：N&lt;=10000，M&lt;=10000</p><p>对于100%的数据：N&lt;=500000，M&lt;=500000</p><p>思路：</p><p>​    一个lca算法求最近公共祖先的算法，查找时间复杂度O(logn)。中心思想就是利用一个二维数组数组<code>gas[i][j]</code>存储i节点向上2^k步后的节点。核心公式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gas[i][j] = gas[gas[i][j - 1]][j - 1];</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: cfsTree.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 六  4/13 18:33:07 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX_M 1000000</span><br><span class="line">#define MAX_N 500000</span><br><span class="line">#define MAX_K 32</span><br><span class="line"></span><br><span class="line">//边的结构体</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to, next; //to为边的末尾，next为上一个相同起始点的边的下角标</span><br><span class="line">&#125; g[MAX_M + 5];</span><br><span class="line"></span><br><span class="line">//链式前向星</span><br><span class="line">int head[MAX_N + 5] = &#123;0&#125;;  //head[i]代表以i为起始点的最后一个边的下角标</span><br><span class="line"></span><br><span class="line">//边的数量</span><br><span class="line">int cnt = 0;</span><br><span class="line"></span><br><span class="line">//链式前向星实现</span><br><span class="line">inline void add(int a, int b) &#123;</span><br><span class="line">    g[++cnt].to = b;   //我们将第cnt条边存到数组的cnt位置处，边的起点是a，终点是b</span><br><span class="line">    g[cnt].next = head[a]; //那么以a为起点的上一个边的位置为head[a]</span><br><span class="line">    head[a] = cnt;     //然后更新head[a]</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//gas[i][j]用于存储节点i向上走2^j步到达的节点编号</span><br><span class="line">int gas[MAX_N + 5][MAX_K + 5] = &#123;0&#125;;</span><br><span class="line">int deep[MAX_N + 5] = &#123;0&#125;;  //存储当前节点的深度</span><br><span class="line"></span><br><span class="line">//一次dfs维护gas数组和deep数组</span><br><span class="line">void dfs1(int fa, int inx) &#123;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= MAX_K; i++) &#123;</span><br><span class="line">        gas[inx][i] = gas[gas[inx][i - 1]][i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = head[inx]; i != 0; i = g[i].next) &#123;</span><br><span class="line">        if (g[i].to == fa) continue;</span><br><span class="line">        int to = g[i].to;</span><br><span class="line">        deep[to] = deep[inx] + 1;</span><br><span class="line">        gas[to][0] = inx;</span><br><span class="line">        dfs1(inx, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int x, int y) &#123;</span><br><span class="line">    if (deep[x] &lt; deep[y]) &#123;</span><br><span class="line">        swap(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = MAX_K; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (deep[gas[x][i]] &lt; deep[y]) continue;</span><br><span class="line">        x = gas[x][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x == y) return x;</span><br><span class="line"></span><br><span class="line">    for (int i = MAX_K; i&gt;= 0; i--) &#123;</span><br><span class="line">        if (gas[x][i] == gas[y][i]) continue;</span><br><span class="line">        x = gas[x][i], y = gas[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return gas[x][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, s, a, b;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">        add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deep[0] = -1;</span><br><span class="line">    dfs1(0, s);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        printf(&quot;%d\n&quot;, lca(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 最近公共祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 234</title>
      <link href="/2019/04/12/Leetcode-234/"/>
      <url>/2019/04/12/Leetcode-234/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-234/title1.jpg" alt="title1"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_234.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 16:25:26 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//判断链表是否为回文链表</span><br><span class="line">//方法一：遍历链表将元素存到数组中，然后判断数组是否为回文数组</span><br><span class="line">//方法二：递归遍历链表，将元素存到队列中，然后在递归后判断队头是否和当前节点val相同</span><br><span class="line">//方法三：将后半段或者前半段链表反转，然后用两个指针同时遍历，若相同则为回文链表</span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if (head == NULL) return true;</span><br><span class="line">        que.push(head -&gt; val);</span><br><span class="line">        bool k = isPalindrome(head -&gt; next);</span><br><span class="line">        if (que.front() != head -&gt; val) &#123;</span><br><span class="line">            k = false;</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法三</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //获取链表长度</span><br><span class="line">    int getlen(ListNode *head) &#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(head) &#123;</span><br><span class="line">            num ++;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    //反转链表</span><br><span class="line">    void r(ListNode *k, ListNode *p) &#123;</span><br><span class="line">        ListNode *last = NULL, *q;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            q = p -&gt; next;</span><br><span class="line">            p -&gt; next = last;</span><br><span class="line">            last = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        k -&gt; next = last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line"></span><br><span class="line">    //获取链表长度并特判</span><br><span class="line">        int len = getlen(head);</span><br><span class="line">        if (len == 0 || len == 1) return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int step = (len + 1) / 2 - 1;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        while(step --) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //反转后半段链表</span><br><span class="line">        r(p, p -&gt; next);</span><br><span class="line"></span><br><span class="line">        //两个指针分别遍历前半段和后半段</span><br><span class="line">        ListNode *q = head;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        for (int i = 1; i &lt;= len / 2; i++) &#123;</span><br><span class="line">            if(p -&gt; val != q -&gt; val) return false;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 206</title>
      <link href="/2019/04/12/Leetcode-206/"/>
      <url>/2019/04/12/Leetcode-206/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-206/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_206.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 16:07:08 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//反转链表</span><br><span class="line">//方法一 迭代法：设置一个虚拟指针指向当前节点的前一个节点，然后依此遍历链表的节点，让当前节点的next指向前一个节点</span><br><span class="line">//方法二</span><br><span class="line">//方法二 递归法：遇到当前节点或当前节点的next为空时，返回当前节点；否则递归下一个节点，递归后将当前节点的next-&gt;next设置为当前节点，然后当前节点的next设置为NULL</span><br><span class="line"></span><br><span class="line">//迭代法</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode temp(0);</span><br><span class="line">        temp.next = NULL;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            ListNode *q = p -&gt; next;</span><br><span class="line">            p -&gt; next = temp.next;</span><br><span class="line">            temp.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//递归法</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (head == NULL || head -&gt; next == NULL) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *root = reverseList(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = NULL;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 237</title>
      <link href="/2019/04/12/Leetcode-237/"/>
      <url>/2019/04/12/Leetcode-237/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-237/title.jpg" alt="title"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_237.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 11:54:23 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//只给定待删除节点，让你从链表中删除该节点，前提条件：该删除节点不是链表的最后一个节点</span><br><span class="line">//由于我们不知道待删除节点的前一个节点，因此我们可以把该节点的下一个节点的值赋值给待删除节点，然后让待删除节点的next指向下一个节点的下一个节点，这样我们删除待删除节点的下一个节点即可</span><br><span class="line"></span><br><span class="line">//代码实现</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        ListNode *p = node -&gt; next;</span><br><span class="line">        node -&gt; val = p -&gt; val;</span><br><span class="line">        node -&gt; next = p -&gt; next;</span><br><span class="line">        delete(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 202</title>
      <link href="/2019/04/12/LeetCode-202/"/>
      <url>/2019/04/12/LeetCode-202/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/LeetCode-202/title5.jpg" alt="title5"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_202.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 11:36:36 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//对于一个整数，每次将该数替换为它每个位置的数字的平方和，若最终能得到1，就为快乐数，让我们判断一个数是否为快乐数</span><br><span class="line">//对于int型正整数1～2e9左右，因此转变完一次后最大为730（由1999999999得到），因此这个题的最大范围为730。它具备链表的性质（即通过一个状态能唯一的确定下一个状态）</span><br><span class="line">//方法一：我们只要转变次数超过730还没有得到1，那么2～730中必定存在重复的数，也就代表着一定成环，因此不是快乐数</span><br><span class="line">//方法二：利用map映射，若某个数经历变换之后某个状态出现两次，则不是快乐数</span><br><span class="line">//方法三：就是将其当作链表，利用快慢指针原理判断其是否存在环</span><br><span class="line"></span><br><span class="line">//方法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int add(int n) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(n) &#123;</span><br><span class="line">            int k = n % 10;</span><br><span class="line">            sum += k * k;</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(n != 1) &#123;</span><br><span class="line">            n = add(n); </span><br><span class="line">            num++;</span><br><span class="line">            if (num &gt; 730) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    map&lt;int, int&gt;m;</span><br><span class="line">public:</span><br><span class="line">    int add(int n) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(n) &#123;</span><br><span class="line">            int k = n % 10;</span><br><span class="line">            sum += k * k;</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        while(n != 1) &#123;</span><br><span class="line">            m[n]++;</span><br><span class="line">            if (m[n] &gt; 1) return false;</span><br><span class="line">            n = add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法三</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    map&lt;int, int&gt;m;</span><br><span class="line">public:</span><br><span class="line">    int add(int n) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(n) &#123;</span><br><span class="line">            int k = n % 10;</span><br><span class="line">            sum += k * k;</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int p = n;</span><br><span class="line">        int q = n;</span><br><span class="line">        do &#123;</span><br><span class="line">            p = add(p);</span><br><span class="line">            q = add(add(q));</span><br><span class="line">        &#125; while(p != q);</span><br><span class="line">        return p == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 160</title>
      <link href="/2019/04/12/Leetcode-160/"/>
      <url>/2019/04/12/Leetcode-160/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-160/title3.jpg" alt="title3"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_160.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 10:50:18 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//判断两个链表是否相交</span><br><span class="line">//方法一：对两个链表节点的哈希值映射一下，若存在映射关系则代表相交</span><br><span class="line">//方法二：对两个链表进行遍历确定两个链表的长度，然后进行第二次遍历：长的链表先走差值步，然后两个链表同时走，若存在相同，则代表相交</span><br><span class="line">//方法三：两个链表同时走，若第一个链表走到头，则第一个链表走第二个链表；若第二个链表走到头，则第二个链表走第一个链表。若存在相同，则代表相交</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    map&lt;ListNode *, int&gt;m;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        while(headA) &#123;</span><br><span class="line">            m[headA] ++;</span><br><span class="line">            headA = headA -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(headB) &#123;</span><br><span class="line">            if (m[headB]) &#123;</span><br><span class="line">                return headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法三</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == NULL || headB == NULL) return NULL;</span><br><span class="line">        </span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        </span><br><span class="line">        while(p != q) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">            if (p == NULL) &#123;</span><br><span class="line">                p = headB;</span><br><span class="line">                headB = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            if (q == NULL) &#123;</span><br><span class="line">                q = headA;</span><br><span class="line">                headA = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法三的技巧实现</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == NULL || headB == NULL) return NULL;</span><br><span class="line">        </span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        </span><br><span class="line">        //当第二次遍历结束后，两者都变成了NULL</span><br><span class="line">        while(p != q) &#123;</span><br><span class="line">            if(!p) p = headB;</span><br><span class="line">            else p = p -&gt; next;</span><br><span class="line">            if(!q) q = headA;</span><br><span class="line">            else q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 141</title>
      <link href="/2019/04/12/Leetcode-141/"/>
      <url>/2019/04/12/Leetcode-141/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-141/title1.jpg" alt="title1"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_141.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 10:27:44 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//判断是否存在环形链表</span><br><span class="line">//先设置虚拟头节点</span><br><span class="line">//方法一：对于每个节点的地址进行map映射，若已存在映射关系则证明成环</span><br><span class="line">//方法二：对于遍历过的节点把节点的next指向自己，遍历过程中若存在指向自己的节点则证明成环</span><br><span class="line">//方法三：利用快慢指针，慢指针一次走一个单位，快指针一次走两个单位，若出现快慢指针相同，则成环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法一</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    map&lt;ListNode *, int&gt;m;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if (head == NULL) return false;</span><br><span class="line">        if (m[head] &gt; 0) return true;</span><br><span class="line">        m[head] ++;</span><br><span class="line">        return hasCycle(head -&gt; next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if (head == NULL) return false;</span><br><span class="line">        if (head -&gt; next == head) return true;</span><br><span class="line">        ListNode *p = head -&gt; next;</span><br><span class="line">        head -&gt; next = head;</span><br><span class="line">        return hasCycle(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法三</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if (head == NULL) return false;</span><br><span class="line">        </span><br><span class="line">        ListNode temp(0);</span><br><span class="line">        temp.next = head;</span><br><span class="line">        ListNode *p = &amp;temp, *q = &amp;temp;</span><br><span class="line">        while(q &amp;&amp; q -&gt; next != NULL) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next -&gt; next;</span><br><span class="line">            if (p == q) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> -数据结构 -链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 24</title>
      <link href="/2019/04/12/Leetcode-24/"/>
      <url>/2019/04/12/Leetcode-24/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-24/title7.jpg" alt="title7"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_24.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 10:13:48 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//两两交换链表中的节点</span><br><span class="line">//我们设置虚拟头节点</span><br><span class="line">//方法一：我们利用一个变量进行计数，若遇到奇数，若存在下一个节点，就和下一个节点进行数值的交换</span><br><span class="line">//方法二：我们可以利用两个临时指针（p用来指向要交换的两个节点的之前节点，q用来指向要交换的两个节点的第一个节点），来实现对实际节点的交换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法二实现</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        //虚拟头节点</span><br><span class="line">        struct ListNode temp(0);</span><br><span class="line">        temp.next = head;</span><br><span class="line">        </span><br><span class="line">        //两个临时指针</span><br><span class="line">        struct ListNode *p = &amp;temp, *q = temp.next;</span><br><span class="line">        while(q &amp;&amp; q -&gt; next) &#123;</span><br><span class="line">            p -&gt; next = q -&gt; next;</span><br><span class="line">            q -&gt; next = p -&gt; next -&gt; next;</span><br><span class="line">            p -&gt; next -&gt; next = q;</span><br><span class="line">            p = q;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 19</title>
      <link href="/2019/04/12/Leetcode-19/"/>
      <url>/2019/04/12/Leetcode-19/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/12/Leetcode-19/title6.jpg" alt="title6"></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: Leetcode_19.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 五  4/12 09:19:32 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">//删除链表的倒数第N个节点</span><br><span class="line">//(1)为了避免删除第一个节点的特殊操作，我们可以设置一个虚拟头节点</span><br><span class="line">//方法一：我们可以第一次遍历得到链表的长度len，然后第二遍遍历找第len - N + 1个节点</span><br><span class="line">//方法二：我们可以使用递归的方式，参数为上一个节点的地址和当前节点，返回值为之后有多少个节点。若返回值 == N - 1，我们就删除该节点</span><br><span class="line">//方法三：利用两个指针，第一个指针走到N+1步，也就是走到N+2节点处，然后两个指针同时走，当第一个指针走到空后，第二个指针就是待删除节点的上一个位置，然后就可以删除下一个节点了</span><br><span class="line"></span><br><span class="line">//方法二代码：</span><br><span class="line">/*</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dfs(ListNode *last, ListNode *now, int len) &#123;</span><br><span class="line">        if (now == NULL) return 0;</span><br><span class="line">        int k = dfs(now, now -&gt; next, len);</span><br><span class="line">        if (k == len - 1) &#123;</span><br><span class="line">            last -&gt; next = now -&gt; next;</span><br><span class="line">            delete(now);</span><br><span class="line">        &#125;</span><br><span class="line">        return k + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        if (head == NULL || n &lt;= 0) return NULL;</span><br><span class="line">        </span><br><span class="line">        //虚拟头指针</span><br><span class="line">        ListNode temp(0);</span><br><span class="line">        temp.next = head;</span><br><span class="line">        </span><br><span class="line">        //遍历</span><br><span class="line">        dfs(&amp;temp, temp.next, n);</span><br><span class="line">        </span><br><span class="line">        return temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法三代码：</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    //特判特殊情况</span><br><span class="line">    if (head == NULL || n &lt;= 0) return NULL;</span><br><span class="line">    </span><br><span class="line">    //设置虚拟指针</span><br><span class="line">    struct ListNode temp;</span><br><span class="line">    temp.next = head;</span><br><span class="line">    </span><br><span class="line">    struct ListNode *p = &amp;temp, *q = &amp;temp;</span><br><span class="line">        </span><br><span class="line">    while(n &amp;&amp; p) &#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n != 0 || p == NULL) &#123;</span><br><span class="line">        return temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">    </span><br><span class="line">    while(p) &#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        q = q -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //删除节点</span><br><span class="line">    p = q -&gt; next;</span><br><span class="line">    q -&gt; next = p -&gt; next;</span><br><span class="line">    free(p);</span><br><span class="line">    </span><br><span class="line">    return temp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构相关实现</title>
      <link href="/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/10/数据结构相关实现/title.jpg" alt="title"></p><a id="more"></a><p>​    平时布置的数据结构作业代码实现，持续上传到Github中～</p><p>​    Github地址：<a href="https://github.com/ivan-zcy/Data-structure" target="_blank" rel="noopener">跳转</a></p><p>​    也可从博客中查看：<a href="http://www.ivan-zcy.top/project/">跳转</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Contest 122 D We Like AGC</title>
      <link href="/2019/04/04/AtCoder-Contest-122-D-We-Like-AGC/"/>
      <url>/2019/04/04/AtCoder-Contest-122-D-We-Like-AGC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/04/04/AtCoder-Contest-122-D-We-Like-AGC/title.jpg" alt="title"></p><a id="more"></a><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>You are given an integer N. Find the number of strings of length N that satisfy the following conditions, modulo 109+7:</p><ul><li>The string does not contain characters other than <code>A</code>, <code>C</code>, <code>G</code> and <code>T</code>.</li><li>The string does not contain <code>AGC</code> as a substring.</li><li>The condition above cannot be violated by swapping two adjacent characters once.</li></ul><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p>A substring of a string T is a string obtained by removing zero or more characters from the beginning and the end of T.</p><p>For example, the substrings of <code>ATCODER</code> include <code>TCO</code>, <code>AT</code>, <code>CODER</code>, <code>ATCODER</code> and <code></code> (the empty string), but not <code>AC</code>.</p><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>3≤N≤100</li></ul><hr><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input is given from Standard Input in the following format:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N</span><br></pre></td></tr></table></figure><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the number of strings of length N that satisfy the following conditions, modulo 109+7.</p><hr><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">61</span><br></pre></td></tr></table></figure><p>There are 43=64 strings of length 3 that do not contain characters other than <code>A</code>, <code>C</code>, <code>G</code> and <code>T</code>. Among them, only <code>AGC</code>, <code>ACG</code> and <code>GAC</code> violate the condition, so the answer is 64−3=61.</p><hr><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><p>Copy</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">230</span><br></pre></td></tr></table></figure><hr><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">388130742</span><br></pre></td></tr></table></figure><p>Be sure to print the number of strings modulo 109+7.</p><p>​    题目大意就是字符串只能由A、C、G、T组成，然后子串中不能出现AGC，还有任意两个相邻的字符交换后不能出现AGC。也就是说排除一下几种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AGC</span><br><span class="line">ACG</span><br><span class="line">GAC</span><br><span class="line">AXGC//X代表A C G T</span><br><span class="line">AGXC</span><br></pre></td></tr></table></figure><p>​    所以我只需要定义<code>dp[i][j][p][q]</code>代表前i个字符，最后3个字符为j，p，q的方案数(0代表A，1代表C，2代表G，3代表T)。详细见代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define mod 1000000007</span><br><span class="line"></span><br><span class="line">ll dp[105][4][4][4] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">bool pan(int a, int b, int c) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 2 &amp;&amp; c == 1) return false;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 1 &amp;&amp; c == 2) return false;</span><br><span class="line">    if (a == 2 &amp;&amp; b == 0 &amp;&amp; c == 1) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool pan1(int a, int b, int c) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 2 &amp;&amp; c == 1) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;4\n&quot;);</span><br><span class="line">    &#125; else if(n == 2) &#123;</span><br><span class="line">        printf(&quot;16\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                for (int p = 0; p &lt; 4; p++) &#123;</span><br><span class="line">                    if (pan(i, j, p)) &#123;</span><br><span class="line">                        dp[3][i][j][p] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int k = 4; k &lt;= n; k++) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    for (int p = 0; p &lt; 4; p++) &#123;</span><br><span class="line">                        //dp[k][i][j][p]</span><br><span class="line">                        if (pan(i, j, p)) &#123;</span><br><span class="line">                            for (int q = 0; q &lt; 4; q++) &#123;</span><br><span class="line">                                if (pan(q, i, j) &amp;&amp; pan1(q, j, p) &amp;&amp; pan1(q, i, p)) &#123;</span><br><span class="line">                                    dp[k][i][j][p] = (dp[k][i][j][p] + dp[k - 1][q][i][j]) % mod;</span><br><span class="line">                                &#125; </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                for (int p = 0; p &lt; 4; p++) &#123;</span><br><span class="line">                    ans = (ans + dp[n][i][j][p]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(9)epoll函数</title>
      <link href="/2019/03/27/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9-epoll%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/27/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9-epoll%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/27/沉下心学操作系统-9-epoll函数/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h3 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h3><p>​    epoll用于在一段时间内同时等待多个产生I/O事件的文件</p><p>​    返回值为这段时间产生等待的I/O事件的文件数量，并允许我们通过一个指针遍历产生的所有事件</p><p>​    例如多个子进程向父进程建立通道，所有子进程向管道写入数据，那么在父进程端加入epoll()等待，它就会在一段时间后返回写入数据的子进程数量</p><h4 id="epoll-创建"><a href="#epoll-创建" class="headerlink" title="epoll()创建"></a>epoll()创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure><p>​    参数size表示监控的文件描述符的总量（由于如今系统具备动态分配内存的能力，size参数自动忽略，但我们仍需要加入一个大于0的数保证兼容）</p><p>​    若成功返回一个非零的文件描述符，代表一个epoll()实例</p><p>​    最后需要close()关闭epoll创建的对象</p><h4 id="epoll-加入、删除、修改"><a href="#epoll-加入、删除、修改" class="headerlink" title="epoll()加入、删除、修改"></a>epoll()加入、删除、修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);</span><br></pre></td></tr></table></figure><p>​    第一个参是是epoll的实例的文件描述符，第二个参op代表有加入，删除，修改三个选项，第三个参是与I/O事件关联的文件，第四个参数指向我们需要监控的事件</p><p>​    关于event的结构体：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void* ptr;</span><br><span class="line">    int fd;</span><br><span class="line">    unsigned int u32;</span><br><span class="line">    unsigned long long u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t     events;</span><br><span class="line">    epoll_data_t data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    data可以自由使用，方便进程在事件发生后获取有关事件信息的。一般我们会将与事件关联的文件描述符存储在data.fd里，这样事件发生后我们才能知道事件是哪个文件产生的。</p><p>​    events是由多个或运算连接在一起的事件（比如文件可读，可写，错误，挂起）</p><h4 id="等待I-O事件发生"><a href="#等待I-O事件发生" class="headerlink" title="等待I/O事件发生"></a>等待I/O事件发生</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>​    第一个参数是epoll实例的文件描述符，第二个参指向我们需要监控的事件，第三个参数为最多产生的事件数，第四个参数记录我们在timeout毫秒内产生的事件（当timeout为0立即返回，当&lt;0就是等到有事件发生时再返回）</p><p>​    它的返回值是该时间实际产生的事件数，然后根据该数量遍历events的每一项</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(8)进程间通信之消息队列</title>
      <link href="/2019/03/25/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2019/03/25/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/25/沉下心学操作系统-8-进程间通信之消息队列/title.jpg" alt="title"></p><a id="more"></a><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​    相比管道，消息队列不需要读取和写入进程同时出现，它就类似于邮箱，一个进程发送到邮箱，另一个进程看。消息队列可以和信号连用，然后每次来消息，就可以利用信号让收方得到通知。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;mqueue.h&gt;</span><br><span class="line">mqd_t mq_open(const char* name, int oflag, mode_t mode, struct mq_attr* attr);</span><br></pre></td></tr></table></figure><p>​    第一个参数是消息队列的名字，它是通过名字来识别的。用相同的名字打开消息队列，它们就会打开同一个消息队列。消息队列的名字格式是以/开头，由空字符结尾，中间最多包含255个不是/的字符串</p><p>​    第二个参是访问消息队列的模式（只读、只写、可读可写，没有就创建），第三个参数第四个参分别代表消息队列的权限和性质（只有在创建的时候定义）</p><p>​    其中第四个参数是一个结构体，里边存储最大消息数量、一个消息的最大长度、当前消息的数量等信息</p><p>​    它的返回值是一个消息队列描述符。我们可以利用这个消息队列描述符来对消息队列进行发送或接收</p><h4 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;mqueue.h&gt;</span><br><span class="line">int mq_send(mqd_t mqdes, const char* msg_ptr, size_t msg_len, unsigned msg_prio);</span><br><span class="line">ssize_t mq_receive(mqd_t mqdes, char* msg_ptr, size_t msg_len, unsigned* msg_prio);</span><br></pre></td></tr></table></figure><p>​    发送和接收函数的第一个参数代表消息队列描述符，第二个参数为发送/接收的消息，第三个参数为消息的长度，最后一个参数为存储消息优先等级的指针</p><h4 id="获得新消息得到通知"><a href="#获得新消息得到通知" class="headerlink" title="获得新消息得到通知"></a>获得新消息得到通知</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;mqueue.h&gt;</span><br><span class="line">int mq_notify(mqd_t mqdes, const struct sigevent* sevp);</span><br></pre></td></tr></table></figure><p>​    第一个参数消息队列描述符，第二个参数为一个结构体，只要结构体中的sigev_notify的值为SIGEV_SIGNAL，每当有消息时，就可以让拥有标识符为mqdes的消息队列的进程获得信号提醒。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(7)进程间通信之信号</title>
      <link href="/2019/03/25/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E4%BF%A1%E5%8F%B7/"/>
      <url>/2019/03/25/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/25/沉下心学操作系统-7-进程间通信之信号/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>​    在unix中，信号是由一个个整数表示，比较常用的信号比如SIGINT,SIGHUP,SIGILL等等，分别是ctrl+c，中断挂起或进程终止，非法指令。</p><p>​    每个信号系统都有自己的默认处理方法，我们可以利用sigaction()函数来更改信号的处理方式。</p><p>​    注意！！信号处理方式是在进程范围内有效，如果一个进程用fork()产生一个子进程，那么在父进程中被忽略的信号在子进程仍然会被忽略（子进程开辟进程空间并将父进程的状态等copy到子进程）</p><h4 id="更改信号的处理方式"><a href="#更改信号的处理方式" class="headerlink" title="更改信号的处理方式"></a>更改信号的处理方式</h4><h5 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction* act, struct sigaction* oldact);</span><br></pre></td></tr></table></figure><p>​    第一个参数代表信号，第二个参数act为新的处理方式，第三个参数oldact是将旧的处理方式存到oldact</p><h5 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure><p>​    signal()可以达到和sigaction()同样的目的（相当于sigaction的简化版），第一个参数为信号，第二个参数为收到该信号重写的函数。</p><p>​    由于它在不同的unix系统的实现不同，可能存在移植性问题，不建议使用</p><h4 id="信号的接收"><a href="#信号的接收" class="headerlink" title="信号的接收"></a>信号的接收</h4><h5 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure><p>​    我们可以利用kill来实现发送信号。它的第一个参数为进程号，第二个参数为信号。</p><p>​    当pid &gt; 0，代表给某个指定进程发送；当pid == -1，会给除第一个进程（系统进程，所有用户的祖先）以外所有正在运行的进程发送（在linux下不给自己发）；当pid &lt; -1代表给所有进程组等于-pid的发送信号</p><p>​    当sig&gt;0，代表发送指定信号，sig==0不会发送任何信号，但是还会检查是否存在以pid为标识符的进程。常用于检查是否存在该进程（或组）</p><p>​    返回值有成功时为0，错误时-1。有三种错误码：分别代表无效信号、无权发送、进程不存在</p><h4 id="信号的接收-1"><a href="#信号的接收-1" class="headerlink" title="信号的接收"></a>信号的接收</h4><p>​    信号发出后会被内核检查到，然后内核调用do_signal()执行收到的信号。如果用户定义了某信号的处理方式，那么它可能会在用户空间内处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(6)进程间通信之共享内存</title>
      <link href="/2019/03/24/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>/2019/03/24/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/24/沉下心学操作系统-6-进程间通信之共享内存/title.jpg" alt="title"></p><a id="more"></a><h3 id="mmap共享内存"><a href="#mmap共享内存" class="headerlink" title="mmap共享内存"></a>mmap共享内存</h3><p>​    共享内存可用于进程间通信，而且还可以提高读写文件的效率。还可以方便我们对文件进行随机的读写</p><h4 id="开启共享内存"><a href="#开启共享内存" class="headerlink" title="开启共享内存"></a>开启共享内存</h4><p>​    mmap能够通过将外存中的文件映射到一段内存中，使多个进程在其地址空间中共享一端内存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">void *mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure><p>​    第一个参数addr为希望映射文件的大概位置（0则代表选择任意地址进行映射），第二参数代表映射内存的长度，第三个参数prot表示映射内存区的使用权限（可读、可写、可执行），第四个参flags决定了内存映射的模式（具体有四个），第五个参数fd是被映射文件对应的文件描述符，第六个参数offset代表映射的起始位置（相对于文件开头的偏移）</p><p>​    mmap()以页为单位分配映射内存区，因此它返回的大小一定是页的整数倍（若申请的不是整数倍，我们访问未被使用部分会返回SIGBUS产生错误）</p><h4 id="关闭共享内存"><a href="#关闭共享内存" class="headerlink" title="关闭共享内存"></a>关闭共享内存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int munmap(void* addr, size_t length);</span><br></pre></td></tr></table></figure><p>​    munmap用于关闭映射，参数addr必须是页面的整数倍，长度可以与一开始映射的内存大小不同。</p><p>​    注意，close(fd)并不能关掉映射，只有munmap()可以。</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* window = (char*) mmap(0, 30, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</span><br><span class="line">pid_t child = fork();</span><br><span class="line">if (!child) &#123;</span><br><span class="line">    sprintf(window, &quot;Greeting from child.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">wait(NULL);</span><br><span class="line">printf(&quot;%s\n&quot;, window);//通过mmap()使父进程和子进程共享了这段内存</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(5)进程间通信之管道</title>
      <link href="/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/"/>
      <url>/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/沉下心学操作系统-5-进程间通信之管道/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h4 id="匿名通道"><a href="#匿名通道" class="headerlink" title="匿名通道"></a>匿名通道</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int pipefd[2]);</span><br></pre></td></tr></table></figure><p>​    作为进程间共享区，只用于通信，通信结束后就自动移除。它是一个单向的数据传输通道，参数第一个值为读取的文件描述符（对应输入），第二个值为写入的文件描述符（对应输出）</p><p>​    它只能用于拥有公共祖先进程的进程（也就是必须继承同一个文件描述符表，保证它们的文件描述符必须指向同一文件）</p><p>​    下面是匿名通道的实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[]) &#123;</span><br><span class="line">    //创建管道</span><br><span class="line">    int fd[2];</span><br><span class="line">    if (pipe(fd) == -1) &#123;</span><br><span class="line">        perror(&quot;pipe faild&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (pid == -1) &#123;</span><br><span class="line">        perror(&quot;fork faild&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!pid) &#123;   //子进程</span><br><span class="line">        char *s = (char *)malloc(sizeof(char) * 100);</span><br><span class="line">        strcpy(s, &quot;hello, ACM!&quot;);</span><br><span class="line">        //关掉读取</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        //写入</span><br><span class="line">        write(fd[1], s, strlen(s) + 1);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;      //父进程</span><br><span class="line">        char buffer[100];</span><br><span class="line">        //关掉写入</span><br><span class="line">        close(fd[1]);</span><br><span class="line">        //读取</span><br><span class="line">        read(fd[0], buffer, sizeof(buffer));</span><br><span class="line">        printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">//创建命名管道，它采取先进先出的策略</span><br><span class="line">int mkfifo(const char* pathname, mode_t mode);</span><br><span class="line">//访问命名管道</span><br></pre></td></tr></table></figure><p>​    参数一为文件路径，参数二表示这个命名管道的权限可被umask修改</p><p>​    命名管道可以任意进程间进行通信，且创建它的进程退出后它仍然存在，只有在被删除后才消失。它不同于一般文件在于读取和写入数据的进程必须同时出现（也就是说只有读或写，命名管道就会被阻塞）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(4)关于文件</title>
      <link href="/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4/"/>
      <url>/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/沉下心学操作系统-4/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>​    每个进程控制块都有一个文件描述符表，可以把它看作一个数组，里面存储指向以打开文件地址的指针，这个数组的下角标就是文件描述符。每次open都会把新打开的文件地址存储到表中的某个空行，并返回下角标作为文件描述符。</p><p>​    其中0～2为特殊的文件描述符，分别为标准输入，标准输出，标准错误输出，这三个文件描述符在进程初始时自动打开，其中标准输出就是printf输出的对象</p><h3 id="关于I-O的系统调用函数"><a href="#关于I-O的系统调用函数" class="headerlink" title="关于I/O的系统调用函数"></a>关于I/O的系统调用函数</h3><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int open(const char* pathname, int flags, mode_t mode);</span><br></pre></td></tr></table></figure><p>​    相比fopen()处于系统的更低层，可以对文件进行更基础的操作，但是也失去了一些库函数的帮助</p><p>​    参数分别是被打开文件路径、进行的操作、创建文件时的使用权限（可省略）</p><p>​    它的返回值为文件描述符</p><h4 id="dup2"><a href="#dup2" class="headerlink" title="dup2()"></a>dup2()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd, int newfd);</span><br></pre></td></tr></table></figure><p>​    该函数可以使newfd指向oldfd指向的文件</p><h4 id="dup"><a href="#dup" class="headerlink" title="dup()"></a>dup()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br></pre></td></tr></table></figure><p>​    该函数会选择最小的空闲文件描述符让它指向oldfd，并返回新的指向该文件的描述符</p><h4 id="read-、write"><a href="#read-、write" class="headerlink" title="read()、write()"></a>read()、write()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void* buf, size_t count);</span><br><span class="line">ssize_t write(int fd, const void* buf, size_t count);</span><br></pre></td></tr></table></figure><p>​    参数分别为文件描述符，写入/读入的内容，写入/读入的最大长度。若调用成功返回实际读写的长度，否则返回-1</p><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br></pre></td></tr></table></figure><p>​    参数分别为文件描述符，移动的长度，移动目标的起点。whence有3个常用值，SEEK_SET，SEEK_END，SEEK_CUR，分别代表开头，结尾和当前位置</p><h4 id="fsync"><a href="#fsync" class="headerlink" title="fsync()"></a>fsync()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fsync(int fd);</span><br></pre></td></tr></table></figure><p>​    由于向磁盘写入数据很花时间，因此内核为了提高效率会推迟写入数据。而fsync()可以同步内存中所有已修改的文件写入到储存设备</p><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure><p>​    用于关掉文件，fd为文件描述符</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(3)进程的使用</title>
      <link href="/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/沉下心学操作系统-3-进程的使用/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h2 id="进程的使用"><a href="#进程的使用" class="headerlink" title="进程的使用"></a>进程的使用</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t fork();</span><br></pre></td></tr></table></figure><p>​    函数位于unistd.h头文件中，它会直接创建一个新进程。新进程的返回值为0，父进程的返回值为子进程的pid。该函数会把父进程的处理器状态、地址空间直接拷贝到新进程，而新进程也会从fork()指令的开始处运行。</p><p>​    为了避免子进程不用拷贝的信息造成拷贝时间浪费，系统只有在其中一个数据被修改时才会把那个数据实际复制到子进程的地址空间。</p><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><p>​    exit()是一个系统调用指令，它位于stdlib.h头文件中，用于让内核结束该进程。status是进程的结束状态信息（成功为0，否则为对应的错误数字），可返回作为wait()函数的第一个参</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br></pre></td></tr></table></figure><p>​    wait()位于sys/wait.h头文件中，参数为该进程所等待进程的结束状态值，也可以把它设为NULL，函数返回值为已结束子进程的pid。</p><p>​    该函数会让父进程进入等待态，直到父进程所有子进程的一个成功返回结束状态值，父进程才可进入就绪态并再进入运行态。</p><p>​    注意点：如果wait()被调用时已经有可用的结束状态值，那么wait()会立刻返回。如果已经没有可等待的子进程，wait()会返回-1</p><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br></pre></td></tr></table></figure><p>​    它与wait()相比，可以通过指定进程pid来等待指定进程。当pid &gt; 0时等待指定pid子进程，当pid = -1时等待任意子进程，当pid == 0时等待所有进程组标识符与该进程相同的子进程，当pid &lt; -1时等待任何进程组标识为pid的绝对值的进程。options为特殊控制选项</p><h3 id="execve"><a href="#execve" class="headerlink" title="execve()"></a>execve()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execve(const char *filename, char* const argv[], char* const envp[])</span><br></pre></td></tr></table></figure><p>​    系统调用函数，用于运行完全不同的程序并覆盖掉当前进程正在运行的程序。filename指向可执行程序，argv[]第一个参数与filename一致，从第二个以后为运行可执行程序的参，envp存储键值对作为环境变量代入程序</p><p>​    由于该函数会覆盖掉当前进程正在运行的程序，因此只有在函数调用失败后才会执行该进程函数后的代码。</p><p>​    除系统调用函数外，还有execve()六函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(2)进程</title>
      <link href="/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/"/>
      <url>/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/沉下心学操作系统-2/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h2 id="进程、进程地址空间、进程控制块"><a href="#进程、进程地址空间、进程控制块" class="headerlink" title="进程、进程地址空间、进程控制块"></a>进程、进程地址空间、进程控制块</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​    进程作为运行程序的抽象，包含了一个程序的运行状态、所占用的抽象内存和存储的数据。</p><p>​    （1）进程中必须包含进程运行状态的结构，使系统能够将进程的运行状态放入内存中，方便下次调用继续执行。</p><p>​    解决方法：通过存储处理器状态寄存器、指令计数器、栈指针、通用寄存器来代表进程目前的运行状态。</p><p>​    （2）进程在用户一侧对内存进行了抽象，在系统一侧需要包含从抽象内存向实际内存和磁盘的映射，以便获得存储的数据。</p><p>​    解决方案：通过地址转换来实现虚拟内存到物理内存和磁盘的映射。主要方法有分页存储、分段存储等</p><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>​    我们可以将一个进程可以使用的全部内存地址和存储的数据称为这个进程的地址空间。</p><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>​    为了能在进程开始运行时方便的加载转换地址和状态信息，我们引入进程控制块的概念。除此之外，进程控制块还包含进程号、进程优先级等信息。对内核来说，线程控制块是进程的唯一标识符</p><p>​    由于进程控制块包含了优先级还有地址转换的实际物理地址等用户进程无权修改的信息，所以进程控制存储在系统空间</p><h2 id="进程的状态模型"><a href="#进程的状态模型" class="headerlink" title="进程的状态模型"></a>进程的状态模型</h2><p>​    新建态、就绪态、运行态、等待态、终止态</p><p>​    五态相比三态，新建态可以避免一个进程还没有加载完全部资源就进入就绪态再进入运行态，造成运行错误。终止态可以避免进程结束后直接被系统销毁，使得其它进程无法获取该进程的信息。但是终止态可能导致僵尸进程的出现</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沉下心学操作系统(1)操作系统概念</title>
      <link href="/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/"/>
      <url>/2019/03/23/%E6%B2%89%E4%B8%8B%E5%BF%83%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/沉下心学操作系统-1/title2.jpg" alt="title2"></p><a id="more"></a><p>[TOC]</p><p>​    以前觉得操作系统是一块难啃的骨头，自己不想去碰。然后问面试官，自己哪些地方需要学习一下，面试官说操作系统和内核等等，如果学会了，对自己的发展会更有帮助。因为越底层的东西懂得越多，才能对编程有更加深入的了解和体会。自己很赞同这个思想，不多说，沉下心来学操作系统吧，路一步步地走～</p><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>​    不同的电脑硬件设备不同，运行网络环境不同。为了避免对不同的硬件写不同的程序，因此需要在硬件和软件之间加一个抽象层，从而方便软件利用硬件资源。而这个抽象层就是操作系统</p><p>​    （1）基于磁盘信息的抽象：操作系统帮我们管理了磁盘上的数据，能够将一次存储在多个位置的数据结合在一起命名为文件，方便我们直接读取磁盘上的信息</p><p>​    （2）对物理资源的抽象：操作系统通过将物理资源抽象为进程，大大方便了多个程序在系统中同时运行，而程序设计者无需考虑其它软件的内存占用以及上下文切换，保留处理器状态等复杂过程</p><p>​    （3）防止程序直接与物理资源接触，避免通过程序修改磁盘信息和对其它程序破坏的情况</p><h2 id="内核与用户进程"><a href="#内核与用户进程" class="headerlink" title="内核与用户进程"></a>内核与用户进程</h2><p>​    我们一般把操作系统核心功能部分称为内核（包括物理资源管理，协调进程调度，构建虚拟机，公共服务等）</p><p>​    一般把处理器运算时间分成两部分：一部分是内核在处理器运行，一部分是用户进程运行。有关两者：</p><p>​    （1）用户进程必须通过内核获取资源，并且不能接触除了自己以外的资源。</p><p>​    （2）用户进程比内核拥有更少的权限和资源</p><p>​    （3）内核与用户进程使用不同的存储空间，内核所用的空间为系统空间，用户进程所用的空间为用户空间</p><h2 id="双模式操作"><a href="#双模式操作" class="headerlink" title="双模式操作"></a>双模式操作</h2><p>​    处理器中的一个位用于区分内核和用户进程，当处理器要执行某些只允许在内核态执行的特权操作时，它会先通过这个位判断当前是否处于内核态。若用户进程越权操作，处理器会触发异常，该进程被内核终止</p><h2 id="用户态到内核态的三种方式："><a href="#用户态到内核态的三种方式：" class="headerlink" title="用户态到内核态的三种方式："></a>用户态到内核态的三种方式：</h2><ol><li>系统调用</li><li>异常</li><li>中断</li></ol><h2 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h2><p>​    为了使用户进程在保证安全的情况下实现文件读写、进程间通信等“内核级操作”，操作系统给用户进程提供系统调度，允许用户进程在特定的位置进入系统空间并使用系统提供的服务。</p><p>​    而所有的系统调用程序地址都被存放在存储器的某一个位置，该位置称为系统调度表。</p><p>​    为了避免恶意进程通过空指针、超出缓冲区大小范围攻击内核。在实现系统调用时必须检查用户空间指针的合理性，再将参数复制到系统空间进行操作</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>​    又被称为内中断或同步中断。是由于进程运行时的非法操作或者硬件故障导致，然后引起内核中对应的异常处理机制。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>​    又被称为外中断或异步中断，来自处理器外的中断信号。包括时钟中断、设备I/O中断</p><p>​    当同时出现多个中断时处理器会优先处理优先度高的中断。如果处理一个中断的过程中出现一个优先度更高的中断，处理器可能会切换到新的中断信号，从而造成多重中断。对此我们可以采用屏蔽方式处理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二面遗漏点填坑</title>
      <link href="/2019/03/23/%E4%BA%8C%E9%9D%A2%E5%A1%AB%E5%9D%91/"/>
      <url>/2019/03/23/%E4%BA%8C%E9%9D%A2%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/23/二面填坑/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><p>​    感觉自己答的普普通通，通过这次面试发现自己在基础上的不足。自己学习了一下当时有些迷糊的知识点，整理如下：</p><h3 id="迷糊点1"><a href="#迷糊点1" class="headerlink" title="迷糊点1:"></a>迷糊点1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[] = “hello!” ;</span><br><span class="line">char *p = str ;</span><br><span class="line">请写出下面输出的结果</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof (str ) );</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof ( p );</span><br></pre></td></tr></table></figure><p>对于sizeof()，在对数组名进行操作时，返回的大小为数组所占用的内存大小，而对指向数组的指针进行操作时，返回的大小为指针的大小（自己对指针返回的大小很犹豫，现在记住了，从这里也可以看出，数组名并不是完全等同于指针）</p><p>​    关于上面的问题，自己学了数组名和指针的区别。（1）在本质上，数组名其实指代一种数据结构，这个数据结构就是数组的全体（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量！（3）和数组名不同，指向数组的指针则是另外一种变量类型，它用于存放数组的地址（4）如果数组名作函数行参时，在函数体内它就失去了本身的数据机构特性，仅仅只是一个指向改数组的指针</p><p>​    而且通过这个问题，自己查找了一下有关sizeof，发现自己一直以为它是一个函数，而它实质上是一个操作符（从sizeof(int)上就可以看出，因为函数接纳的形参不能是一个int的类型数据）</p><p>下面是辨析的几个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test 1:</span><br><span class="line"> 　char str[10];</span><br><span class="line"> 　char *pStr = str;</span><br><span class="line"> 　cout &lt;&lt; sizeof(str) &lt;&lt; endl;//10(此时数组名表现为前面的性质(1))</span><br><span class="line"> 　cout &lt;&lt; sizeof(pStr) &lt;&lt; endl;//4(在32位系统下)</span><br><span class="line"></span><br><span class="line">Test 2:</span><br><span class="line">　 char str1[10] = &quot;hello&quot;;</span><br><span class="line">　 char str2[10];</span><br><span class="line"> 　strcpy(str2,str1);//此时数组名表现为前面的性质(2)</span><br><span class="line">  </span><br><span class="line">Test 3:</span><br><span class="line">void arrayTest(char str[])</span><br><span class="line">&#123;</span><br><span class="line"> 　 cout &lt;&lt; sizeof(str) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">char str1[10] = &quot;hello&quot;;</span><br><span class="line">arrayTest(str1);//此时数组名表现为前面的性质(4)</span><br></pre></td></tr></table></figure><h3 id="迷糊点2"><a href="#迷糊点2" class="headerlink" title="迷糊点2"></a>迷糊点2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fork();printf(&quot;#&quot;);</span><br><span class="line">fork();printf(&quot;#&quot;);</span><br></pre></td></tr></table></figure><p>​    当时自己回答的是6，结果电脑测出来是8。记得之前学到的子进程从fork()后开始执行，百思不得其解。。然后百度了一下，不得不说自己确实欠缺好多～</p><p>​    从网上整理了一下思路，大概就是说这是由printf的缓冲机制 + 进程间的继承机制造成的。因为操作系统只是把printf的内容放到了stdout缓冲队列里,并没有实际写到屏幕上。而再运行到fork时,缓冲里面的内容被子进程继承了，所以最后这4个进程一共输出了8次</p><p>​    但是只要系统看到\n就会立刻刷新stdout，或者我们用fflush()函数强制刷新缓冲区这两种方式，就会输出6个#</p><p>​    具体辨析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test 1:</span><br><span class="line">fork();printf(&quot;#&quot;);</span><br><span class="line">fflush(stdout);</span><br><span class="line">fork();printf(&quot;#&quot;);</span><br><span class="line">//输出6个</span><br><span class="line"></span><br><span class="line">Test 2:</span><br><span class="line">fork();printf(&quot;#\n&quot;);</span><br><span class="line">    fork();printf(&quot;#\n&quot;);</span><br><span class="line">    //输出6行，每行1个</span><br></pre></td></tr></table></figure><h3 id="迷糊点3"><a href="#迷糊点3" class="headerlink" title="迷糊点3"></a>迷糊点3</h3><p>​    由于迷糊点2的题没有答好，面试官问到关于进程间的继承问题，自己找了一个经典题理解了一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t pid1 = fork();</span><br><span class="line">pid_t pid2 = fork();</span><br><span class="line">printf(&quot;pid1:%d, pid2:%d\n&quot;, pid1, pid2);</span><br></pre></td></tr></table></figure><p>​    以前对于fork只停留在“新建一个进程，父进程返回一个子进程的pid，子进程返回一个0，然后系统就有两个进程，并开始向下执行内容”这个初步认识的阶段。</p><p>​    其实fork的新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是它是一个全新的进程并作为原进程的子进程</p><p>​    对于上面这个例子的有一下几个步骤：</p><p>(1)首先有一个主进程root，执行完第一个fork()创建一个进程son1，son1继承root的所有变量，环境变量，计数器等，然后更新pid1，假设此时root的pid1为1001，那么son1的pid1为0</p><p>(2)root执行完第二个fork()创建一个进程son2，son2继承root的所有变量，环境变量，计数器等，然后更新pid2，假设此时root的pid2为1002，那么son2的pid2为0，它们两个的pid1都为1001</p><p>(3)son1执行完第二个fork()创建一个进程grandson，grandson继承son1的所有变量，环境变量，计数器等，然后更新pid2，假设此时son1的pid2为1003，那么grandson的pid2为0，它们两个的pid1都为0</p><h3 id="迷糊点4"><a href="#迷糊点4" class="headerlink" title="迷糊点4"></a>迷糊点4</h3><p>​    对于编程中常用的函数参数记忆不清。加强自己的记忆力吧，面试官问到listen()函数的第二个参是什么？当时给忘了，然后越想越着急，苦笑。。事后我说起这个第二个参，同学说不是最大连接数吗。。突然惊醒，感觉自己应该结合实际好好想想，其实这些东西也都不是死记硬背的。。</p><p>​    最后，就是感觉到了自己的不足。自己学的东西好像是一个空中楼阁，经不起实战的打磨。继续沉下心来磨砺自己吧，把以后的重心先放在操作系统入门与系统编程上。凡事都要讲求一个透彻明白吧。。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈缓存三大问题</title>
      <link href="/2019/03/12/%E6%B5%85%E8%B0%88%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/12/%E6%B5%85%E8%B0%88%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/12/浅谈缓存三大问题/title1.jpg" alt="title1"></p><a id="more"></a><h1 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h1><p>​    大部分系统都存在缓存机制，防止过多直接对数据库的请求操作，增加系统的稳定性与效率。</p><p>##可能导致的问题</p><p>###问题一：缓存穿透</p><p>​    缓存穿透是指查询一个不存在的数据，由于缓存不存在该数据，因此该请求会直接去数据库查询（直接穿透了缓存层）。若有人恶意多次进行该操作可能导致数据库瘫痪</p><p>####解决方案</p><ol><li><p>把所有可能的查询生成一个类似于哈希表的结构，在进行数据库查询前会利用该结构进行过滤，如果不在其中直接过滤掉，从而减轻数据库层面的压力</p></li><li><p>在第一次查询不到某个key对应的val值时，我们把该key和空值存入缓存中</p></li></ol><p>###问题二：缓存雪崩</p><p>​    一般缓存都会有一个失效时间，如果所有缓存的实效时间相同，可能会导致在某一时刻同时失效后，所有请求都发送到数据库层从而导致数据库崩溃</p><p>####解决方案</p><ol><li><p>只让一个线程构建缓存，其它线程等待构建缓存的线程执行完毕后再重新从缓存中获取数据。</p><ol start="2"><li>错开不同失效时间即可从一定长度上避免这种问题，因此我们设置缓存实效时间时可以在一个范围内取随机值</li></ol></li></ol><p>###问题三：缓存击穿</p><p>​    缓存击穿是缓存雪崩的特例，缓存击穿是指某一个缓存失效后有大量请求发送到数据库层导致其崩溃。与雪崩相比，它只是一个点并不是全部（比如微博的一个热点缓存失效后依然有大量该热点信息的请求）</p><p>####解决方案</p><ol><li><p>对热点数据进行二级缓存，并对不同级别的缓存设定不同的失效时间</p></li><li><p>采用LRU算法，即最近最少使用。依据“长期不被使用的数据，未来用到的概率也不大“，因此当内存达到阈值时，首先淘汰最近最少被使用的数据，具体实现过程为：</p><p>（1）创建一个缓存哈希链表用于存储数据（相比哈希表多了一个指针用于链表排序）</p><p>（2）添加新节点的时候，将新节点添加到链表尾部</p><p>（3）若该节点以存在，把该节点移动到链表的尾部</p><p>（4）当缓存链表已满时，添加新节点的时候，会把链表头部移除，然后将新节点添加到尾部</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈大小端</title>
      <link href="/2019/03/12/%E6%B5%85%E8%B0%88%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
      <url>/2019/03/12/%E6%B5%85%E8%B0%88%E5%A4%A7%E5%B0%8F%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/12/浅谈大小端/title4.jpg" alt="title4"></p><a id="more"></a><h1 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h1><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>​    每个地址单元都对应一个字节，一个字节是8比特。除了char型是一个字节为，其余比如short是2字节，int4字节等等，他们的宽度大于1字节，就会存在多个字节安排顺序的规则。</p><p>​    根据不同计算机的字节顺序可以分为大端数据模式和小端数据模式</p><p>​    我们在不同端模式的主机进行数据传递时需要考虑端模式的不同，因此TCP/IP协议规定在网络上必须采用网络字节排序（大端模式）</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    大端是数据的高字节保存在内存的低地址，数据的低字节保存在内存的高地址，类似于把数据当作字符串处理（像Mac是大端）</p><p>​    小端是数据的高字节保存在内存的高地址，数据的低字节保存在内存的低地址（像windows，Linux都是小端）</p><h2 id="测试大小端"><a href="#测试大小端" class="headerlink" title="测试大小端"></a>测试大小端</h2><p>利用通用体：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union t&#123;</span><br><span class="line">    int val;</span><br><span class="line">    char s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    t a;</span><br><span class="line">    a.val = 1;</span><br><span class="line">    if (a.s) &#123;</span><br><span class="line">        printf(&quot;小端\n&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;大端\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux C实现线程池</title>
      <link href="/2019/03/11/Linux-C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/03/11/Linux-C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/11/Linux-C实现线程池/title3.jpg" alt="title3"></p><a id="more"></a><p>[TOC]</p><h1 id="池"><a href="#池" class="headerlink" title="池"></a>池</h1><p>​    池是一组资源的集合，这组资源在服务器启动之初就被创建和初始化，这称为静态资源分配。它避免了服务器对内核的频繁访问，提高了效率。</p><p>​    常见的池有进程池，线程池，内存池    </p><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>​    先申请一定数量，大小相等的内存块备用。有新的内存需求时，就从内存池中分出一部分内存块，若内存不足则继续申请新的内存。内存池使内存分配效率得到提升</p><h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p>​    进程池线先由服务器创建一组子进程，子进程数量应和CPU数量差不多。所有子程序具有相同的属性，运行着同样的代码</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    在Linux中线程实际上是由轻量级进程实现的。线程的创建和清理都需要耗费时间和系统资源，当处理高并发时，线程池就有必要引入了。</p><p>​    线程池提升了多线程程序的性能，因为线程池中线程都是现成且可重复使用的。理想的线程池能够合理地动态调节池内线程数量</p><p>​    线程池是典型的生产者消费者同步问题，主程序不定时将任务任务添加到一个队列中。池中多个工作线程同时执行出队操作（需保证同一时刻只能一个线程出队成功）。这时候生产者是主程序（用于生产任务），消费者是工作线程（用于执行任务）</p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>​    线程池主要包括4个部分：</p><ol><li>线程管理器：用于创建并管理线程池</li><li>工作线程：线程池中实际执行任务的线程，在创建线程池后会创建好固定数目的线程在池中</li><li>任务接口：每个任务必须实现的接口。当队列中有任务时，被池中线程执行，把任务抽象成一个接口，可以做到线程池与具体任务无关</li><li>任务队列：用于存放没有处理的任务</li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>​    主要应用于需要大量线程来完成任务且任务时间较短，例如Web服务器完成网页请求。或者是突发性的大量请求</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>test.h文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">//任务接口(节点)</span><br><span class="line">struct Work &#123;</span><br><span class="line">    void* (*func) (void *arg);</span><br><span class="line">    void *arg;</span><br><span class="line">    Work *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//线程池中线程执行的回掉函数</span><br><span class="line">void* thread_poll_func(void *arg);</span><br><span class="line"></span><br><span class="line">//线程池</span><br><span class="line">struct thread_poll&#123;</span><br><span class="line">    //任务队列</span><br><span class="line">    Work *head;</span><br><span class="line">    //线程指针</span><br><span class="line">    pthread_t *pd;</span><br><span class="line"></span><br><span class="line">    //条件变量和锁</span><br><span class="line">    pthread_mutex_t mutex;</span><br><span class="line">    pthread_cond_t cond;</span><br><span class="line"></span><br><span class="line">    //线程池是否被销毁</span><br><span class="line">    bool shutdown;</span><br><span class="line"></span><br><span class="line">    //线程池中线程的总量</span><br><span class="line">    int pthread_num;</span><br><span class="line">    //当前任务队列中任务数量</span><br><span class="line">    int work_num;</span><br><span class="line"></span><br><span class="line">    //初始化函数</span><br><span class="line">    thread_poll(int pthread_num) &#123;</span><br><span class="line">        this -&gt; pthread_num = pthread_num;</span><br><span class="line">        this -&gt; work_num = 0;</span><br><span class="line">        this -&gt; shutdown = 0;</span><br><span class="line">        pthread_mutex_init(&amp;this -&gt;mutex, NULL);</span><br><span class="line">        pthread_cond_init(&amp;this -&gt; cond, NULL);</span><br><span class="line">        this -&gt; head = NULL;</span><br><span class="line">        pd = (pthread_t *)malloc(sizeof(pthread_t) * pthread_num);</span><br><span class="line">        for (int i = 0; i &lt; pthread_num; i++) &#123;</span><br><span class="line">            pthread_create(&amp;this -&gt; pd[i], NULL, thread_poll_func, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //向线程池投递任务</span><br><span class="line">    void add_work(Work *work);</span><br><span class="line"></span><br><span class="line">    //销毁线程池</span><br><span class="line">    int del();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>test.cpp文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">//线程池中线程执行的回掉函数</span><br><span class="line">void* thread_poll_func(void *arg) &#123;</span><br><span class="line">    thread_poll *t = (thread_poll *)arg;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        //上锁</span><br><span class="line">        pthread_mutex_lock(&amp;t -&gt; mutex);</span><br><span class="line"></span><br><span class="line">        //循环等待接收任务</span><br><span class="line">        while(!(t -&gt; work_num) &amp;&amp; !(t -&gt; shutdown)) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;t -&gt; cond, &amp;t -&gt; mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果线程池被销毁</span><br><span class="line">        if (t -&gt; shutdown) &#123;</span><br><span class="line">            //解锁并退出线程</span><br><span class="line">            pthread_mutex_unlock(&amp;t -&gt; mutex);</span><br><span class="line">            pthread_exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //取出队首任务</span><br><span class="line">        t -&gt; work_num --;</span><br><span class="line">        Work *p = t -&gt; head;</span><br><span class="line">        t -&gt; head = p -&gt; next;</span><br><span class="line"></span><br><span class="line">        //解锁</span><br><span class="line">        pthread_mutex_unlock(&amp;t -&gt; mutex);</span><br><span class="line"></span><br><span class="line">        //执行任务回掉函数</span><br><span class="line">        (p -&gt; func)(p -&gt; arg);</span><br><span class="line">        //释放该任务空间</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//向线程池投递任务</span><br><span class="line">void thread_poll::add_work(Work *work) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;this -&gt; mutex);</span><br><span class="line">    //将任务加入到等待队列</span><br><span class="line">    Work *p = this -&gt; head;</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        this -&gt; head = work;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while(p -&gt; next != NULL) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; next = work;</span><br><span class="line">    &#125;</span><br><span class="line">    this -&gt; work_num ++;</span><br><span class="line">    pthread_mutex_unlock(&amp;this -&gt; mutex);</span><br><span class="line"></span><br><span class="line">    //唤醒一个等待线程</span><br><span class="line">    pthread_cond_signal(&amp;this -&gt; cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//销毁线程池</span><br><span class="line">int thread_poll::del() &#123;</span><br><span class="line">    if (this -&gt; shutdown) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    this -&gt; shutdown = 1;</span><br><span class="line"></span><br><span class="line">    //唤醒所有线程</span><br><span class="line">    pthread_cond_broadcast(&amp;this -&gt; cond);</span><br><span class="line"></span><br><span class="line">    //等待所有线程结束,避免僵尸线程</span><br><span class="line">    for (int i = 0; i &lt; this -&gt; pthread_num; i++) &#123;</span><br><span class="line">        pthread_join(this -&gt; pd[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //释放掉所有线程标识符</span><br><span class="line">    free(pd);</span><br><span class="line"></span><br><span class="line">    //销毁任务队列的所有任务</span><br><span class="line">    Work *p = this -&gt; head;</span><br><span class="line">    while(p != NULL) &#123;</span><br><span class="line">        p = this -&gt; head;</span><br><span class="line">        this -&gt; head = p -&gt; next;</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //销毁条件变量和锁</span><br><span class="line">    pthread_cond_destroy(&amp;this -&gt; cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;this -&gt; mutex);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//任务的回掉函数</span><br><span class="line">void* myfunc(void *arg) &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, *(int *)arg);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    thread_poll poll(3);</span><br><span class="line">    int *nuu = (int *)malloc(sizeof(int) * 10);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        nuu[i] = i;</span><br><span class="line">        Work *work = (Work *)malloc(sizeof(Work));</span><br><span class="line">        work -&gt; next = NULL;</span><br><span class="line">        work -&gt; func = myfunc;</span><br><span class="line">        work -&gt; arg = (void *)&amp;nuu[i];</span><br><span class="line">        poll.add_work(work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(5);</span><br><span class="line">    poll.del();</span><br><span class="line">    free(nuu);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> Linux </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈哈希表</title>
      <link href="/2019/03/08/%E6%B5%85%E8%B0%88%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2019/03/08/%E6%B5%85%E8%B0%88%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/08/浅谈哈希表/title3.jpg" alt="title3"></p><a id="more"></a><p>[TOC]</p><p>##为什么要用hash？</p><p>​    在讲哈希表之前，我们来说说链表和数组的优缺点：</p><h3 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h3><p>​    优点是链表长度可变，可以方便的进行链表的插入和删除</p><p>​    缺点是由于不是申请的一块连续地址空间，所以无法快速定位元素，只能通过遍历链表的方式获取其中元素，需要O(n)时间复杂度</p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>​    优点是可以快速定位元素</p><p>​    缺点是数组长度固定，难以扩充大小。且数组中元素进行增删操作需要O(n)时间复杂度</p><p>​    </p><p>​    我们发现，链表和数组的优缺点正好互补，那么我们可不可以用一种新的数据结构来代替链表和数组，使其继承它们各自的优点呢？</p><p>​    于是，哈希表出现了。它的长度可变，可以快速定位，能够方便的进行增删改查，时间复杂度几乎为O(1)</p><h2 id="哈希表与哈希函数"><a href="#哈希表与哈希函数" class="headerlink" title="哈希表与哈希函数"></a>哈希表与哈希函数</h2><p>​    哈希表：是可以根据key值通过某种映射关系而直接访问的数据结构，用于存放记录</p><p>​    哈希函数：上述映射关系即为哈希函数</p><p>​    因此，在将哈希表之前，我们先来说一下哈希函数</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>​    哈希函数就像高中所学的函数f()，代表一种映射关系，它可以把字符串，数字等等映射为一个无符号整型，以便快速找到存储该元素信息的位置</p><p>​    注意！我们在自定义哈希函数时，要根据关键字key的长度，表长，关键字分布是否均匀等条件来相应的进行自定义！！</p><p>​    哈希函数的映射关系有很多，比较常用的有一下几种：</p><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>​    一般形式为<code>f(x) = a * x + b</code>，a，b为自定义常数，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned val = 0;</span><br><span class="line">for (int i = 0; i &lt; strlen(s); i++) &#123;</span><br><span class="line">    val = val * 33 + s[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>​    线球关键值的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址，比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned val = 0;</span><br><span class="line">for (int i = 0; i &lt; strlen(s); i++) &#123;</span><br><span class="line">    val = val * 33 + s[i];</span><br><span class="line">&#125;</span><br><span class="line">val = val * val / p % q;//p,q为常数</span><br></pre></td></tr></table></figure><h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>​    一般形式为：<code>f(x) = x % p</code>，其中p为不超过表长的质数（因为这样可以减少地址重复）</p><h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>​    一般形式为：<code>f(x)=random(x)</code> </p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>​    由上边的哈希函数我们可以看出，可能多个不同的key值通过哈希函数最后映射得到的值为同一个数，这样会导致哈希冲突。我们有一下两个常用的方法解决哈希冲突：</p><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>​    如果遇到哈希冲突，我们就找hash表中剩余的空间，然后将其插入（比如将值插入到下一位）</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>​    上个方法有一个局限性，就是当表的内容已经填满时就无法进行插入，而该方法可以解决这个问题。这也是哈希表最常用的方法。</p><p>​    该方法如果遇到哈希冲突，他就会在原地址新建一个空间，然后以链表节点的形式插入到该空间。</p><h2 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h2><p>​    我们以链地址法为例，代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(key); i++) &#123;</span><br><span class="line">        val = val * <span class="number">33</span> + key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val % MAXN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">char</span> *val;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span></span><br><span class="line">    Node *head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    Hash() &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span> -&gt; head[i] = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span> -&gt; len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="function">Node* <span class="title">query</span><span class="params">(Hash *h, <span class="keyword">char</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> inx = hash(key);</span><br><span class="line">    Node *p = h -&gt; head[inx];</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(p -&gt; key, key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增或改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Hash *h, <span class="keyword">char</span> *key, <span class="keyword">char</span> *val)</span> </span>&#123;</span><br><span class="line">  Node *p = query(h, key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> inx = hash(key);</span><br><span class="line">        p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p -&gt; key = key;</span><br><span class="line">        p -&gt; next = h -&gt; head[inx];</span><br><span class="line">        head[inx] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p -&gt; val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(Hash *h, <span class="keyword">char</span> *key)</span> </span>&#123;</span><br><span class="line">    Node *p = query(h, key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> inx = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(h -&gt; head[inx] -&gt; key, key)) &#123;</span><br><span class="line">        h -&gt; head[inx] = p -&gt; next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *q = h -&gt; head[inx];</span><br><span class="line">    <span class="keyword">while</span>(q -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(q -&gt; next -&gt; key, key)) &#123;</span><br><span class="line">            q -&gt; next = p -&gt; next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        q = q -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式树莓派集群健康监控系统</title>
      <link href="/2019/03/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9B%86%E7%BE%A4%E5%81%A5%E5%BA%B7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/03/08/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9B%86%E7%BE%A4%E5%81%A5%E5%BA%B7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/08/分布式树莓派集群健康监控系统/title.jpg" alt="title"></p><a id="more"></a><p>​    最近两个星期打算写分布式树莓派集群健康监控系统，主要是对树莓派集群的健康状态进行实时监控。</p><p>​    实时更新中～</p><p>​    源码可以从Github <a href="https://github.com/ivan-zcy/Health_monitoring_system" target="_blank" rel="noopener">跳转</a> 或者主页 <a href="http://www.ivan-zcy.top/project/">跳转</a> 的项目页面 进行查看</p><p>​    期待您的指正和贡献源码～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 进程间通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2120仓库建设</title>
      <link href="/2019/03/04/%E6%B4%9B%E8%B0%B7P2120%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE/"/>
      <url>/2019/03/04/%E6%B4%9B%E8%B0%B7P2120%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/04/洛谷P2120仓库建设/title2.jpg" alt="title2"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>L公司有N个工厂，由高到底分布在一座山上。</p><p>工厂1在山顶，工厂N在山脚。 由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。</p><p>突然有一天，L公司的总裁L先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是L先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。</p><p>由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第i个工厂目前已有成品Pi件，在第i个工厂位置建立仓库的费用是Ci。</p><p>对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于L公司产品的对外销售处设置在山脚的工厂N，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送1个单位距离的费用是1。</p><p>假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p><ul><li>工厂i距离工厂1的距离Xi（其中X1=0）; </li><li>工厂i目前已有成品数量Pi; </li><li>在工厂i建立仓库的费用Ci; </li></ul><p>请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行包含一个整数N，表示工厂的个数。接下来N行每行包含两个整数Xi, Pi, Ci, 意义如题中所述。</p><p>输出格式：</p><p>仅包含一个整数，为可以找到最优方案的费用。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 5 10</span><br><span class="line">5 3 100</span><br><span class="line">9 6 10</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在工厂1和工厂3建立仓库，建立费用为10+10=20，运输费用为(9-5)*3 = 12，总费用32。</p><p>如果仅在工厂3建立仓库，建立费用为10，运输费用为(9-0)<em>5+(9-5)</em>3=57，总费用67，不如前者优。</p><p>对于20%的数据， N ≤500；</p><p>对于40%的数据， N ≤10000；</p><p>对于100%的数据， N ≤1000000。 所有的Xi, Pi, Ci均在32位带符号整数以内，保证中间计算结果不超过64位带符号整数。</p><p>思路：</p><p>​    这是一道比较难的斜率优化变形题，我们可以设<code>dp[i]</code>代表前i个工厂的最小费用，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[j] + c[i] + [j+1, i]的所有工厂的p[k] * (x[i] - x[k])的和</span><br></pre></td></tr></table></figure><p>  我们可以设<code>A[i]</code>代表前i个工厂的<code>p[i]</code>和，<code>B[i]</code>代表前i个工厂的<code>p[i]*x[i]</code>和，那么化简上面的式子，得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[j] + c[i] + x[i] * (A[i] - A[j]) - (B[i] - B[j])</span><br></pre></td></tr></table></figure><p>我们发现里边有不变量，变量以及混合值，所以这是一道典型的斜率优化问题</p><p>这时我们可以设k &lt; j且j结果优于k，那么化简得：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] - x[i]A[j] + B[j] &lt; dp[k] - x[i]A[k] + B[k]</span><br></pre></td></tr></table></figure><p>移项得：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((dp[j] + B[j]) - (dp[k] + B[k])) / (A[j] - A[k]) &lt; x[i]</span><br></pre></td></tr></table></figure><p>我们设<code>f[i] = dp[i] + B[i]</code>，代入得：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(f[j] - f[k]) / (A[j] - A[k]) &lt; x[i]</span><br></pre></td></tr></table></figure><p>我们就得到了斜率，剩下的步骤所有题都雷同不再多说，直接上代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">#define N 1000000</span><br><span class="line"></span><br><span class="line">ll x[N + 5] = &#123;0&#125;;</span><br><span class="line">ll c[N + 5] = &#123;0&#125;;</span><br><span class="line">ll A[N + 5] = &#123;0&#125;;</span><br><span class="line">ll B[N + 5] = &#123;0&#125;;</span><br><span class="line">ll f[N + 5] = &#123;0&#125;;</span><br><span class="line">ll dp[N + 5] = &#123;0&#125;;</span><br><span class="line">int q[N + 5] = &#123;0&#125;;</span><br><span class="line">int head = 0, tail = 0;</span><br><span class="line"></span><br><span class="line">double get(int j, int k) &#123;</span><br><span class="line">    return 1.0 * (f[j] - f[k]) / (A[j] - A[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set(int i, int j) &#123;</span><br><span class="line">    dp[i] = dp[j] + c[i] + x[i] * (A[i] - A[j]) - (B[i] - B[j]);</span><br><span class="line">    f[i] = dp[i] + B[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, p;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld%d%lld&quot;, &amp;x[i], &amp;p, &amp;c[i]);</span><br><span class="line">        A[i] = A[i - 1] + p;</span><br><span class="line">        B[i] = B[i - 1] + p * x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q[tail++] = 0;</span><br><span class="line">    q[tail++] = 1;</span><br><span class="line">    set(1, 0);</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        while(tail - head &gt; 1 &amp;&amp; get(q[head + 1], q[head]) &lt;= x[i]) &#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">        set(i, q[head]);</span><br><span class="line">        while(tail - head &gt; 1 &amp;&amp; get(i, q[tail - 1]) &lt;= get(q[tail - 1], q[tail - 2])) &#123;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[tail++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P3195玩具装箱TOY</title>
      <link href="/2019/03/04/%E6%B4%9B%E8%B0%B7P3195%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY/"/>
      <url>/2019/03/04/%E6%B4%9B%E8%B0%B7P3195%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/04/洛谷P3195玩具装箱TOY/title4.jpg" alt="title4"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>P教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。P教授有编号为 1⋯N1⋯<em>N</em> 的 N<em>N</em> 件玩具，第 i<em>i</em> 件玩具经过压缩后变成一维长度为 Ci<em>C**i</em> .为了方便整理，P教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第 i<em>i</em> 件玩具到第 j<em>j</em> 个玩具放到一个容器中，那么容器的长度将为 x=j−i+∑k=ijCk<em>x</em>=<em>j</em>−<em>i</em>+<em>k</em>=<em>i</em>∑<em>j<strong>C</strong>k</em> 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 x<em>x</em> ,其制作费用为 (X−L)(<em>X</em>−<em>L</em>)2 .其中 L<em>L</em> 是一个常量。P教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 L<em>L</em> 。但他希望费用最小.</p><p>感谢@ACの666 提供的Latex题面</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行输入两个整数N，L.接下来N行输入Ci.1&lt;=N&lt;=50000,1&lt;=L,Ci&lt;=10^7</p><p>输出格式：</p><p>输出最小费用</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这是一道斜率优化题，我们可以设<code>dp[i]</code>代表前i个玩具的最小费用值，那么我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (i - j - 1 + [j+1, i]的Ck和 - L)^2)    (j &lt; i)</span><br></pre></td></tr></table></figure><p>​    我们可以设<code>sum[i]</code>代表前i个玩具的Ck值的和，于是算式化简为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (i - j - 1 + sum[i] - sum[j] - L)^2)   (j &lt; i)</span><br></pre></td></tr></table></figure><p>​    我们继续设不变量<code>A[i] = i - 1 + sum[i] - L</code>，变量<code>B[j] = j + sum[j]</code>，那么算式就化简为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (A[i] - B[j])^2)</span><br><span class="line">      = min(dp[j] + A[i]^2 + B[j]^2 - 2*A[i]*B[j])</span><br></pre></td></tr></table></figure><p>​    我们看到算式中存在不变量，变量，混合值，因此推断其为斜率优化题，于是我们可以设k &lt; j且 j比k更优，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] + A[i]^2 + B[j]^2 - 2*A[i]*B[j] &lt; dp[k] + A[i]^2 + B[k]^2 - 2*A[i]*B[k]</span><br></pre></td></tr></table></figure><p>​    最终化简，得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((dp[j] + B[j]^2) - (dp[k] + B[k]^2)) / (B[j] - B[k]) &lt; 2 * A[i]</span><br></pre></td></tr></table></figure><p>​    我们再设<code>F[i] = dp[i] + B[i]^2</code>，于是得：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(F[j] - f[k]) / (B[j] - B[k]) &lt; 2 * A[i]</span><br></pre></td></tr></table></figure><p>​    我们得到了斜率，根据斜率优化的基操，剩下的通用步骤就不一一赘述，直接上代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">#define N 50000</span><br><span class="line"></span><br><span class="line">ll sum[N + 5] = &#123;0&#125;; </span><br><span class="line">ll A[N + 5] = &#123;0&#125;;</span><br><span class="line">ll B[N + 5] = &#123;0&#125;;</span><br><span class="line">ll F[N + 5] = &#123;0&#125;;</span><br><span class="line">ll dp[N + 5] = &#123;0&#125;;</span><br><span class="line">int q[N + 5] = &#123;0&#125;;</span><br><span class="line">int head = 0, tail = 0;</span><br><span class="line"></span><br><span class="line">double get(int j, int k) &#123;</span><br><span class="line">    return 1.0 * (F[j] - F[k]) / (B[j] - B[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set(int i, int j) &#123;</span><br><span class="line">    dp[i] = dp[j] + (A[i] - B[j]) * (A[i] - B[j]);</span><br><span class="line">    F[i] = dp[i] + B[i] * B[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, L, a;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;L);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        sum[i] = sum[i - 1] + a;</span><br><span class="line">        A[i] = i - 1 + sum[i] - L;</span><br><span class="line">        B[i] = i + sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q[tail++] = 0;</span><br><span class="line">    q[tail++] = 1;</span><br><span class="line">    set(1, 0);</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        while(tail - head &gt; 1 &amp;&amp; get(q[head + 1], q[head]) &lt;= 2 * A[i]) &#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set(i, q[head]);</span><br><span class="line"></span><br><span class="line">        while(tail - head &gt; 1 &amp;&amp; get(i, q[tail - 1]) &lt;= get(q[tail - 1], q[tail - 2])) &#123;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q[tail++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1280尼克的任务</title>
      <link href="/2019/03/04/%E6%B4%9B%E8%B0%B7P1280%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/03/04/%E6%B4%9B%E8%B0%B7P1280%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/04/洛谷P1280尼克的任务/title1.jpg" alt="title1"></p><a id="more"></a><p>题目描述</p><p>尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。</p><p>尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。</p><p>写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。</p><p>接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。</p><p>输出格式：</p><p>输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 6</span><br><span class="line">1 2</span><br><span class="line">1 6</span><br><span class="line">4 11</span><br><span class="line">8 5</span><br><span class="line">8 1</span><br><span class="line">11 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    我们先按照任务开始时间排序，然后设<code>dp[i]</code>代表前i个任务（其中第i个任务一定执行）的最大空闲时间。可以得：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[j] + task[i].star - task[j].end - 1); </span><br><span class="line">//需要保证j结束后第一个开始的任务是i</span><br></pre></td></tr></table></figure><p>​    我们再用一个数组<code>book[i]</code>判断第i个任务后面是否还有任务（0无1有），然后遍历所有任务，取<code>dp[i] + n - task[i].end</code>的最大值即可（i需要满足book[i] == 0且dp[i] != -1）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int star, endd;</span><br><span class="line">&#125;task[10005];</span><br><span class="line"></span><br><span class="line">bool cmp(node A, node B) &#123;</span><br><span class="line">    return A.star &lt; B.star;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dp[10005];</span><br><span class="line">bool book[10005];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, a, b;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        task[i].star = a;</span><br><span class="line">        task[i].endd = a + b - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(task + 1, task + m + 1, cmp);</span><br><span class="line">    memset(dp, -1, sizeof(dp));</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        if (task[i].star != task[1].star) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = task[i].star - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[1] = task[1].star - 1;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        if (dp[i] == -1) continue;</span><br><span class="line">        int endd = task[i].endd;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int j = i + 1; j &lt;= m; j++) &#123;</span><br><span class="line">            if (task[j].star &lt;= endd) continue;</span><br><span class="line">            flag = 1;</span><br><span class="line">            for (int p = j; p &lt;= m; p++) &#123;</span><br><span class="line">                if (task[p].star != task[j].star) break;</span><br><span class="line">                dp[p] = max(dp[p], dp[i] + (task[p].star - endd -1));</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            book[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        if (dp[i] == -1 || book[i]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, dp[i] + n - task[i].endd);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1272重建道路</title>
      <link href="/2019/03/04/%E6%B4%9B%E8%B0%B7P1272%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/"/>
      <url>/2019/03/04/%E6%B4%9B%E8%B0%B7P1272%E9%87%8D%E5%BB%BA%E9%81%93%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/04/洛谷P1272重建道路/title2.jpg" alt="title2"></p><a id="more"></a><p>​    一场可怕的地震后，人们用N个牲口棚(1≤N≤150，编号1..N)重建了农夫John的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是惟一的。因此，牧场运输系统可以被构建成一棵树。John想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有P(1≤P≤N)个牲口棚的子树和剩余的牲口棚分离，John想知道这些道路的最小数目。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行：2个整数，N和P</p><p>第2..N行：每行2个整数I和J，表示节点I是节点J的父节点。</p><p>输出格式：</p><p>单独一行，包含一旦被破坏将分离出恰含P个节点的子树的道路的最小数目。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">2 7</span><br><span class="line">2 8</span><br><span class="line">4 9</span><br><span class="line">4 10</span><br><span class="line">4 11</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    一道树形dp题，用<code>dp[i][j]</code>来代表以i节点为根结点能形成j个节点的子树最少需要破坏的道路数（一定包含根节点）。那么我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][1]一定等于子节点个数</span><br><span class="line">对于i的每个子节点，我们可以得到：</span><br><span class="line">dp[i][j] = min(dp[i][j], dp[k][p] + dp[i][j - p] - 1); //k为子节点，p为当前子节点保留的节点数，那么j-p就为父节点和其余节点保留的节点数</span><br><span class="line"></span><br><span class="line">那么结果就为dp[1][m]或者dp[i][m] + 1的最小值，(2 &lt;= i &lt;= n, m为目标子树节点，n为牲口棚总数)</span><br><span class="line">//至于为什么dp[i][m]需要+1，因为以i为节点需要把其与父节点的道路破坏</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector &lt;int&gt; v[155];</span><br><span class="line">int dp[155][155];</span><br><span class="line">int num[155] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; v[inx].size(); i++) &#123;</span><br><span class="line">        if (v[inx][i] == father) continue;</span><br><span class="line">        dfs(v[inx][i], inx);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[inx][1] = count;</span><br><span class="line">    num[inx] = 1;</span><br><span class="line">    for (int i = 0; i &lt; v[inx].size(); i++) &#123;</span><br><span class="line">        if (v[inx][i] == father) continue;</span><br><span class="line">        int to = v[inx][i];</span><br><span class="line">        for (int p = num[inx] + num[to]; p &gt;= 2; p--) &#123;     //???????</span><br><span class="line">            for (int q = min(p - 1, num[to]); q &gt;= 1; q--) &#123;</span><br><span class="line">                if (p - q &gt; num[inx]) break;</span><br><span class="line">                dp[inx][p] = min(dp[inx][p], dp[to][q] + dp[inx][p - q] - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num[inx] += num[to];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, k, a, b;</span><br><span class="line">    memset(dp, 0x3f, sizeof(dp));</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        v[a].push_back(b);</span><br><span class="line">        v[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1, 0);</span><br><span class="line">    int ans = dp[1][k];</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = min(ans, dp[i][k] + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间同步:读者写者问题</title>
      <link href="/2019/03/01/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/01/%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/01/进程间同步-读者写者问题/title1.jpg" alt="title1"></p><a id="more"></a><p>下面讲的是读者写者问题中写者优先的实现过程</p><p>该问题需要满足：</p><ol><li>读写互斥</li><li>写写互斥</li><li>读读不互斥</li><li>同时有读、写，写优先</li></ol><p>需要用到两个全局变量，分别为：</p><p>writeCount：写者人数</p><p>readCount：读者人数</p><p>需要用到5个全局信号量，分别为：</p><p>mutex1：目的是控制每次只有一个写者进出写者队列。为1时，写者可以进或出队列，为0时，写者需等待</p><p>mutex2：目的是控制每次只有一个读者进出读者队列。为1时，读者可以进或出队列，为0时，读者需等待</p><p>mutex3：通过读者的RWMutex比mutex3后申请先释放，使得同种情况下写者比读者先获取RWMutex信号量（实现写者优先）</p><p>RWMutex：目的是控制读写互斥。第一个写者需要等待申请RWMutex信号量，以后的写者无需申请直到写者为空释放。而读者每次都需要申请RWMutex信号量，因此会优先写者操作。</p><p>wrt：保证每次只有一种类型对文件进行操作（类型1:一个写 类型2:一个读或多个读）</p><p>为1时，代表可以对文件进行操作，为0时，代表已有一种类型对文件进行操作。第一个读者需要等待申请wrt信号量，以后的读者无需申请直到读者为空释放。而写者每次都需要申请wrt信号量，因此实现了每次只能有一个写者对文件进行操作，可以有多个读者同时对文件进行操作。</p><p>写者的流程：</p><p>1.申请mutex1信号量，等待进入写者队列</p><p>2.进入队列后writeCount++，若writeCount为1需等待申请RWMutex信号量</p><p>3.成功进入写者队列后释放mutex1信号量</p><p>4.申请wrt信号量等待写操作</p><p>5.进行写操作</p><p>6.写入完毕后释放wrt信号量</p><p>7.申请mutex1信号量，等待出写者队列</p><p>8.出队列后writeCount—，若writeCount为0需释放RWMutex信号量</p><p>9.成功出队后释放mutex1信号量</p><p>读者的流程：</p><p>1.申请mutex3信号，作用是同时等待读者写者，使得写者优先获取RWMutex信号</p><p>2.申请RWMutex信号</p><p>3.申请mutex2信号，等待进入读者队列</p><p>4.进入队列后readCount++，若readCount为1则申请wrt信号量</p><p>5.成功进入队列后释放mutex2信号量</p><p>6.释放RWMutex信号量</p><p>7.释放mutex3信号量</p><p>8.进行读操作</p><p>9.申请mutex2信号量，等待出读者队列</p><p>10.出队列后readCount—，若readCount为0则释放掉wrt信号量</p><p>11.成功出队后释放mutex2信号量</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">int readCount, writeCount;</span><br><span class="line">sem_t mutex1, mutex2, mutex3, RWmutex, wrt;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int num, time1, time2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    readCount = 0;</span><br><span class="line">    writeCount = 0;</span><br><span class="line">    sem_init(&amp;mutex1, 0, 1);</span><br><span class="line">    sem_init(&amp;mutex2, 0, 1);</span><br><span class="line">    sem_init(&amp;mutex3, 0, 1);</span><br><span class="line">    sem_init(&amp;RWmutex, 0, 1);</span><br><span class="line">    sem_init(&amp;wrt, 0, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void over() &#123;</span><br><span class="line">    sem_destroy(&amp;mutex1);</span><br><span class="line">    sem_destroy(&amp;mutex2);</span><br><span class="line">    sem_destroy(&amp;mutex3);</span><br><span class="line">    sem_destroy(&amp;RWmutex);</span><br><span class="line">    sem_destroy(&amp;wrt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* read_t(void *t) &#123;</span><br><span class="line">    node *tt = (node *)t;</span><br><span class="line">    sleep(tt -&gt; time1);</span><br><span class="line">    printf(&quot;reader %d: start run\n&quot;, tt -&gt; num);</span><br><span class="line"></span><br><span class="line">    //进读者队列</span><br><span class="line">    sem_wait(&amp;mutex3);</span><br><span class="line">    sem_wait(&amp;RWmutex);</span><br><span class="line">    sem_wait(&amp;mutex2);</span><br><span class="line">    readCount ++;</span><br><span class="line">    if (readCount == 1) &#123;</span><br><span class="line">        sem_wait(&amp;wrt);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;mutex2);</span><br><span class="line">    sem_post(&amp;RWmutex);</span><br><span class="line">    sem_post(&amp;mutex3);</span><br><span class="line"></span><br><span class="line">    //读操作</span><br><span class="line">    printf(&quot;reader %d: start read\n&quot;, tt -&gt; num);</span><br><span class="line">    sleep(tt -&gt; time2);</span><br><span class="line">    printf(&quot;reader %d: end read\n&quot;, tt -&gt; num);</span><br><span class="line"></span><br><span class="line">    //出读者队列</span><br><span class="line">    sem_wait(&amp;mutex2);</span><br><span class="line">    readCount --;</span><br><span class="line">    if (readCount == 0) &#123;</span><br><span class="line">        sem_post(&amp;wrt);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;mutex2);</span><br><span class="line">    pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* write_t(void *t) &#123;</span><br><span class="line">    node *tt = (node *)t;</span><br><span class="line">    sleep(tt -&gt; time1);</span><br><span class="line">    printf(&quot;writer %d: start run\n&quot;, tt -&gt; num);</span><br><span class="line"></span><br><span class="line">    //进写者队列</span><br><span class="line">    sem_wait(&amp;mutex1);</span><br><span class="line">    writeCount ++;</span><br><span class="line">    if (writeCount == 1) &#123;</span><br><span class="line">        sem_wait(&amp;RWmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;mutex1);</span><br><span class="line"></span><br><span class="line">    //写操作</span><br><span class="line">    sem_wait(&amp;wrt);</span><br><span class="line">    printf(&quot;writer %d: start write\n&quot;, tt -&gt; num);</span><br><span class="line">    sleep(tt -&gt; time2);</span><br><span class="line">    printf(&quot;writer %d: end write\n&quot;, tt -&gt; num);</span><br><span class="line">    sem_post(&amp;wrt);</span><br><span class="line"></span><br><span class="line">    //出写者队列</span><br><span class="line">    sem_wait(&amp;mutex1);</span><br><span class="line">    writeCount --;</span><br><span class="line">    if (writeCount == 0) &#123;</span><br><span class="line">        sem_post(&amp;RWmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;mutex1);</span><br><span class="line">    pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main () &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    pthread_t pid;</span><br><span class="line">    pthread_attr_t attr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;num) != EOF) &#123;</span><br><span class="line">        char chooes;</span><br><span class="line">        int time1, time2;</span><br><span class="line">        scanf(&quot;%c%d%d&quot;, &amp;chooes, &amp;time1, &amp;time2);</span><br><span class="line">        node *t = (node *)malloc(sizeof(node));</span><br><span class="line">        t -&gt; num = num;</span><br><span class="line">        t -&gt; time1 = time1;</span><br><span class="line">        t -&gt; time2 = time2;</span><br><span class="line">        if (chooes == &apos;R&apos;) &#123;</span><br><span class="line">            printf(&quot;reader %d: start waiting\n&quot;, num);</span><br><span class="line">            pthread_create(&amp;pid, &amp;attr, read_t, t);</span><br><span class="line">        &#125; else if(chooes == &apos;W&apos;) &#123;</span><br><span class="line">            printf(&quot;writer %d: start waiting\n&quot;, num);</span><br><span class="line">            pthread_create(&amp;pid, &amp;attr, write_t, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    over();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reader 1: start waiting</span><br><span class="line">writer 2: start waiting</span><br><span class="line">reader 3: start waiting</span><br><span class="line">reader 4: start waiting</span><br><span class="line">writer 5: start waiting</span><br><span class="line">reader 1: start run</span><br><span class="line">reader 1: start read</span><br><span class="line">writer 2: start run</span><br><span class="line">reader 3: start run</span><br><span class="line">reader 4: start run</span><br><span class="line">writer 5: start run</span><br><span class="line">reader 1: end read</span><br><span class="line">writer 2: start write</span><br><span class="line">writer 2: end write</span><br><span class="line">writer 5: start write</span><br><span class="line">writer 5: end write</span><br><span class="line">reader 3: start read</span><br><span class="line">reader 4: start read</span><br><span class="line">reader 3: end read</span><br><span class="line">reader 4: end read</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程间同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重定向输入输出流-freopen</title>
      <link href="/2019/03/01/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-freopen/"/>
      <url>/2019/03/01/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-freopen/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/01/重定向输入输出流-freopen/title.jpg" alt="title"></p><a id="more"></a><p>##重定向</p><p>​    freopen()函数用于重定向输入输出，也就是说可以把终端输入(stdin)指定到相应的文件，使得输入的内容从文件中进行读取。也可以把终端输出(stdout)指定到相应的文件，使得内容输出到相应的文件中</p><p>​    具体格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE *freopen(const char *filename, const char *mode, FILE *stream);</span><br></pre></td></tr></table></figure><p>​    第一个参数filename代表对应的文件，mode代表读取文件的格式（包括w,w+,r,r+,a,a+等），stream为被重定向的文件流</p><p>​    返回值为指向该输出流的文件指针，失败返回NULL</p><p>例如从in.txt读取数据计算a+b的和并输出到out.txt</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    freopen(&quot;out.txt&quot;, &quot;a&quot;, stdout);</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(stdin);</span><br><span class="line">    fclose(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##恢复</p><p>​    将文件输入输出流重定向某个文件后如何恢复呢？对于linux用户，可以使用下面方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">freopen(&quot;/dev/tty&quot;, &quot;w&quot;, stdout);</span><br><span class="line">freopen(&quot;/dev/tty&quot;, &quot;r&quot;, stdin);</span><br></pre></td></tr></table></figure><p>​    对于windows用户来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">freopen(&quot;CON&quot;, &quot;w&quot;, stdout);</span><br><span class="line">freopen(&quot;CON&quot;, &quot;r&quot;, stdin);</span><br></pre></td></tr></table></figure><p>##关闭</p><p>​    重定向用完可以利用fclose()函数关掉，当然，fclose()不仅可以关闭标准输入输出流，还可以关掉各种文件流。具体格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fclose(FILE *stream);</span><br></pre></td></tr></table></figure><p>​    若返回-1代表关闭失败，否则成功</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix多线程</title>
      <link href="/2019/02/28/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/02/28/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/28/C语言多线程/title.jpg" alt="title"></p><a id="more"></a><p>​    关于多线程的使用，需要添加头文件pthread.h。</p><p>​    注意！！！由于其不是Linux系统默认库，因此编译时需要加上-lpthread参数以调用静态链接库。</p><p>​    关于其大体就是关于两个函数的应用，分别是pthread_create()和pthread_join()函数</p><p>###pthread_create()</p><p>​    该函数用来创建线程，它的函数原型是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,</span><br><span class="line">(void*)(*start_rtn)(void*),void *arg);</span><br></pre></td></tr></table></figure><p>​    第一个参数tidp代表指向线程标识符的指针，第二个参数attr用来设置线程属性（可为空），第三参数start_rtn是线程所运行的回调函数，第四个参数是回掉函数的参数（可为NULL）</p><p>​    它的返回值为0代表运行成功，否则返回出错编号</p><p>​    关于其回掉函数的格式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *函数名(void *参数名);</span><br></pre></td></tr></table></figure><p>###pthread_join()</p><p>​    该函数用来等待指定线程的结束，它的函数原型是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br></pre></td></tr></table></figure><p>​    其中第一个参数thread代表线程标识符，第二个参数retval用来存储回掉函数的返回值（可以为NULL），注意，第二个参数是二级指针</p><p>​    该函数如果成功运行返回0，否则返回错误编号</p><p>###pthread_exit()</p><p>​    在线程中使用，用于终止调用它的线程</p><p>###注意点</p><p>​    系统默认创建的线程是非分离式的，在非分离式的情况下一个线程结束后其所占用的系统资源并没有真正的释放（也就是说线程并未真正结束），因为我们需要与pthread_join()函数联用才可以确保线程释放</p><p>​    或者采用方法二：设置线程属性为分离式，这样就可以保证线程结束后立即释放所占用的资源。注意！！！设置为分离式的线程不可以用pthread_join()函数等待！！</p><p>​    具体做法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void *run(void *arg) &#123;</span><br><span class="line">    printf(&quot;ok\n&quot;);</span><br><span class="line">    pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">pthread_attr_t attr;</span><br><span class="line">//获取默认信息</span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">//再设置为分离式</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, 1);</span><br><span class="line">//创建线程</span><br><span class="line">pthread_create(&amp;thread, &amp;attr, run, NULL);</span><br><span class="line">sleep(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级版聊天室</title>
      <link href="/2019/02/27/%E5%8D%87%E7%BA%A7%E7%89%88%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
      <url>/2019/02/27/%E5%8D%87%E7%BA%A7%E7%89%88%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/27/升级版聊天室/title.jpg" alt="title"></p><a id="more"></a><p>主要是利用所学网络编程来实现聊天室功能，包括客户端和服务端两个部分。</p><p>代码以上传至github，可通过<a href="https://github.com/ivan-zcy/Chat" target="_blank" rel="noopener">github</a>或者<a href="http://www.ivan-zcy.top/project/">个人主页</a>查看</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端的内容如下：</p><ol><li><p>使用配置文件配置自己的监听端口，服务器的监听端口等信息</p></li><li><p>用户之间可以通过”@用户名 信息”来实现私聊</p></li><li><p>客户端在一个固定端口上监听服务器转发的来自其他用户的私聊、公聊以及系统信息</p></li><li><p>客户端所接受到的所有信息保存日志文件中，可利用tail -f 文件名获取实时聊天信息</p></li><li><p>客户端解析来自服务端的结构体，内容如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Message&#123;  </span><br><span class="line"> char from[20];  </span><br><span class="line"> int flag;//若flag为1则为私聊信息，0为公聊信息，2则为服务器的通知信息  </span><br><span class="line"> char message[1024]; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>服务端在固定接口接收来自所有客户端的消息</p></li><li><p>每收到一条公聊消息，都转发给所有在线用户</p></li><li><p>每收到私聊消息，只转发给目标用户</p></li><li><p>当私聊用户不存在或下线，通过通知信息告知该用户</p></li><li><p>在用户上线的时候，发送欢迎信息并告知所有在线用户该用户上线</p></li><li><p>在收到用户信息#时，发送给该用户当前在线人数以及所有用户信息</p></li></ol><p>具体效果如下：</p><p>用户界面：</p><p><img src="/2019/02/27/升级版聊天室/user.jpg" alt="user"></p><p>服务端界面：</p><p><img src="/2019/02/27/升级版聊天室/socket.jpg" alt="socket"></p><p>用户的log日志显示：</p><p><img src="/2019/02/27/升级版聊天室/log.jpg" alt="log"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑:引用头文件导致重复定义问题-extern</title>
      <link href="/2019/02/26/%E8%B8%A9%E5%9D%91-%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98-extern/"/>
      <url>/2019/02/26/%E8%B8%A9%E5%9D%91-%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98-extern/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/26/踩坑-引用头文件导致重复定义问题-extern/title2.jpg" alt="title2"></p><a id="more"></a><p>​    今天在一个.h头文件中定义了一个全局变量，然后在两个.cpp文件中引用了该头文件，导致变量重复定义问题。</p><p>​    我们知道，变量有声明和定义，声明可以有多次，但是定义只能有一次。打个比方：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a.h文件</span><br><span class="line">int a;</span><br></pre></td></tr></table></figure><p>​    然后我们在b.cpp和c.cpp中引用a.h文件，这样就会出现重复定义。int a;会在每一个文件中重新定义一次</p><p>​    而我们如果再前边加上关键字extern，那么就代表<code>extern int a</code>为一个关于a的声明，此时并没有定义，这时我们就在b.cpp和c.pp中引用a.h不会报错，因为声明可以多次。</p><p>​    举个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a.h</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">extern int a</span><br><span class="line"></span><br><span class="line">void fun();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a.cpp</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">int a = 1;//有且只有一个引用a.h的cpp文件中定义全局变量a</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">printf(&quot;%d\n&quot;, a);</span><br><span class="line">a = 2;</span><br><span class="line">fun();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串-sprintf()函数</title>
      <link href="/2019/02/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-sprintf-%E5%87%BD%E6%95%B0/"/>
      <url>/2019/02/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2-sprintf-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/26/格式化字符串-sprintf-函数/title1.jpg" alt="title1"></p><a id="more"></a><p>​    有时候我们需要格式化一个字符串的内容，这时侯使用sprintf()函数特别方便，它的使用格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sprintf( char *buffer, const char *format, [ argument] … );</span><br></pre></td></tr></table></figure><p>​    buffer代表字符串指针，format为格式化的样式，其余为参数。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char s[105];</span><br><span class="line">sprintf(s, &quot;hello, %s, Im %d years old\n&quot;, &quot;Zcy&quot;, 18);</span><br></pre></td></tr></table></figure><p>​    这样，s字符串就变为了”hello, Zcy, Im 18 years old\n”</p><p>​    大概就是酱紫～</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC下brew安装、换源、使用以及坑</title>
      <link href="/2019/02/25/MAC%E4%B8%8Bbrew%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9D%91/"/>
      <url>/2019/02/25/MAC%E4%B8%8Bbrew%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/25/MAC下brew安装与使用以及坑/title.jpg" alt="title"></p><a id="more"></a><p>###安装</p><p>​    我们可以利用官方提供的网址进行brew安装：<a href="https://brew.sh" target="_blank" rel="noopener">brew</a></p><p>​    官网上就是让你复制下面这段内容到终端执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>坑点一：</p><p>​    有时候安装会告诉你该用户无法执行，这时候你需要切换到拥有管理员权限的用户，这时候你需要</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su 拥有管理员权限的用户</span><br></pre></td></tr></table></figure><p>​    注意！！！不是root用户而是拥有管理员权限的用户！！</p><p>坑点二：</p><p>​    安装成功后切换回自己平常使用的用户后，使用<code>brew update</code>时，会报在/usr/local无权限执行，这时我们需要利用chomd命令让其拥有可读可写权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /usr/local</span><br></pre></td></tr></table></figure><p>###换源</p><p>​    源是Linux操作系统的必备的概念，源解决的是软件之间的依赖关系。可以直观的把源堪称一个软件仓库。而默认的brew的源在境外，因此下载网速特别慢。因此，我们需要将源由国外的官方源改为大陆的镜像源，比如中科大的源</p><p>​    具体方法：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git" target="_blank" rel="noopener">中科大换源</a></p><p>​    按照上述方法换源成功后重新<code>brew update</code>即可</p><p>###使用</p><p>1.更新brew软件仓库信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><p>2.安装某个程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install xxx</span><br></pre></td></tr></table></figure><p>3.检查所有已有程序是否有新版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew outdated</span><br></pre></td></tr></table></figure><p>4.升级程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew upgrade//升级所有</span><br><span class="line">brew upgrade xxx//升级指定程序</span><br></pre></td></tr></table></figure><p>5.搜索程序（既搜索本地该程序，也搜索brew库里该程序）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew search xxx</span><br></pre></td></tr></table></figure><p>6.清理落后版本和缓存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cleanup</span><br></pre></td></tr></table></figure><p>7.删除某程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall xxx</span><br></pre></td></tr></table></figure><p>8.查询某程序的依赖关系</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info xxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> brew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug小技巧</title>
      <link href="/2019/02/24/Debug%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/02/24/Debug%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/24/Debug小技巧/title2.jpg" alt="title2"></p><a id="more"></a><p>​    平时我们写程序需要Debug的时候，在自己觉得会出错的地方加上printf输出相关信息用于测试。当printf的行过多的时候，如果我们忘记了删除，会导致多余的输出。</p><p>​    这时候，一个非常好用的Debug技巧分享给大家</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG//若有宏定义DEBUG</span><br><span class="line">#define DBG(...) printf(__VA_ARGS__)  //则将DBG()替换为printf(),其中__VA_ARGS__代表可变参</span><br><span class="line">#else</span><br><span class="line">#define DBG(...)//否则将DBG()替换为空</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">DBG(&quot;hello, %s!\n&quot;, &quot;zcy&quot;);</span><br><span class="line">DBG(&quot;hello, %d\n&quot;, 2019);</span><br><span class="line">DBG(&quot;hello, ACM!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果我们g++编译的时候 -D DEBUG，就会输出DBG()的相关内容，如果直接g++编译，测试用的DBG不会输出。这样就非常方便的进行DEBUG啦</p><p>​    以下是运行效果图：</p><p><img src="/2019/02/24/Debug小技巧/1.jpg" alt="1"></p><p>当然啦，宏定义的方式不唯一，比如这样定义也可以：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define DBG(a,b...) printf(a, ##b)</span><br><span class="line">#else</span><br><span class="line">#define DBG(a,b...)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑:父进程怎么知道子进程是否结束</title>
      <link href="/2019/02/24/%E8%B8%A9%E5%9D%91-%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%93%E6%9D%9F/"/>
      <url>/2019/02/24/%E8%B8%A9%E5%9D%91-%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%93%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/24/踩坑-父进程怎么知道子进程是否结束/title3.jpg" alt="title3"></p><a id="more"></a><p>​    该方法主要是用于实现父子进程同时运行，且父进程能查看子进程是否结束</p><p>​    从网上看，大部分人都说在父进程中使用kill(pid, 0) (其中pid为子进程id)来获取子进程是否退出，若是0代表没退，-1代表退了。结果自己实验了几次，发现无论子进程是否退出，都返回0。。。</p><p>​    也就是说，单纯使用kill()函数无法检查子进程的状态。通过使用waitpid()和wait()函数的等待子进程结束后父进程继续运行的功能后，kill()函数就可以检查子进程的状态了。具体原因一直没有想明白。。。</p><p>​    学了进程间通信后，学到了一个函数：sign()函数，格式为：<code>sign(int signum, void(*handler)(int))</code>，其中signum代表某种信号，handler代表该信号得处理方式</p><p>​    我们知道在一个进程终止或者停止时，将<em>SIGCHLD</em>信号发送给其父进程，而系统默认将忽略此信号。此时，我们只需要利用handler函数，就可以判断子进程是否已经停止。具体方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void handler(int sig) &#123;</span><br><span class="line">    if (sig == SIGCHLD) &#123;</span><br><span class="line">        int status;</span><br><span class="line">        waitpid(-1, &amp;status, WNOHANG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int pid = fork();</span><br><span class="line">    if (pid&lt;0) &#123;</span><br><span class="line">    perror(&quot;fork faild&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!pid) &#123;</span><br><span class="line">        sleep(5);</span><br><span class="line">        printf(&quot;子：子进程over\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line"> signal(SIGCHLD, handler);</span><br><span class="line">        while(1) &#123;</span><br><span class="line">            sleep(1);</span><br><span class="line">            int ret = kill(pid, 0);</span><br><span class="line">            if (ret &lt; 0) &#123;</span><br><span class="line">                printf(&quot;父：子进程已经结束\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf(&quot;父：子进程还没有结束\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;程序结束!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf输出带颜色</title>
      <link href="/2019/02/24/printf%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2/"/>
      <url>/2019/02/24/printf%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/24/printf输出带颜色/title6.jpg" alt="title6"></p><a id="more"></a><p>​    要想让printf()函数输出的内容带颜色，格式为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[背景颜色;字体颜色m你要输出的内容\033[0m"</span>);</span><br><span class="line"><span class="comment">// \033[背景颜色;字体颜色m 代表你从这儿开始输出的内容选择某种背景颜色的某种颜色字体</span></span><br><span class="line"><span class="comment">// \033[0m 代表自定义颜色结束，恢复系统默认</span></span><br></pre></td></tr></table></figure><p>背景颜色范围：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 40: 黑                             </span><br><span class="line"> 41: 红                                  </span><br><span class="line"> 42: 绿                          </span><br><span class="line"> 43: 黄                                   </span><br><span class="line"> 44: 蓝                                       </span><br><span class="line"> 45: 紫              </span><br><span class="line"> 46: 深绿        </span><br><span class="line"> 47: 白色</span><br></pre></td></tr></table></figure><p>字体颜色范围：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30: 黑                 </span><br><span class="line">31: 红                </span><br><span class="line">32: 绿                </span><br><span class="line">33: 黄                </span><br><span class="line">34: 蓝               </span><br><span class="line">35: 紫                 </span><br><span class="line">36: 深绿                 </span><br><span class="line">37: 白色</span><br></pre></td></tr></table></figure><p>​    大概就是酱紫～</p>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1156垃圾陷阱</title>
      <link href="/2019/02/24/%E6%B4%9B%E8%B0%B7P1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1/"/>
      <url>/2019/02/24/%E6%B4%9B%E8%B0%B7P1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/24/洛谷P1156垃圾陷阱/title5.jpg" alt="title5"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>卡门――农夫约翰极其珍视的一条<code>Holsteins</code>奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为D(2≤D≤100)<em>D</em>(2≤<em>D</em>≤100)英尺。</p><p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p><p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p><p>假设卡门预先知道了每个垃圾扔下的时间t(0&lt;t≤1000)<em>t</em>(0&lt;<em>t</em>≤1000)，以及每个垃圾堆放的高度h(1≤h≤25<em>h</em>(1≤<em>h</em>≤25)和吃进该垃圾能维持生命的时间f(1≤f≤30)<em>f</em>(1≤<em>f</em>≤30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续1010小时的能量，如果卡门1010小时内没有进食，卡门就将饿死。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行为22个整数，D<em>D</em>和 G(1≤G≤100)<em>G</em>(1≤<em>G</em>≤100)，G<em>G</em>为被投入井的垃圾的数量。</p><p>第二到第G+1<em>G</em>+1行每行包括33个整数：T(0&lt;T&lt;=1000)<em>T</em>(0&lt;<em>T</em>&lt;=1000)，表示垃圾被投进井中的时间；F(1≤F≤30)<em>F</em>(1≤<em>F</em>≤30)，表示该垃圾能维持卡门生命的时间；和 H(1≤H≤25)<em>H</em>(1≤<em>H</em>≤25)，该垃圾能垫高的高度。</p><p>输出格式：</p><p>如果卡门可以爬出陷阱，输出一个整表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 4</span><br><span class="line">5 4 9</span><br><span class="line">9 3 2</span><br><span class="line">12 6 10</span><br><span class="line">13 1 1</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><p>思维：</p><p>​    我们可以设<code>dp[i][j]</code>代表第第i个垃圾投入后奶牛所处高度为j的最大存活时间，初始化<code>dp[0][0] = 10</code>，其余为-1，那么我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j] - (cow[i].t - cow[i - 1].t) + cow[i].f, dp[i - 1][j - cow[i].h] - (cow[i].t - cow[i - 1].t);</span><br></pre></td></tr></table></figure><p>​    由于一次投入的垃圾最多可以上升25，所以奶牛若有可能上来，最终所处位置为<code>[h, h + 25)</code>的集合，所以j的遍历范围为<code>[h, h + 25)</code>，最后遍历垃圾，若在<code>[h, h + 25)</code>存在非-1的数，那么奶牛上来的时间为所处垃圾的投入位置。否则奶牛就上不来</p><p>​    上不来我们只需要遍历垃圾，若<code>dp[i][0]</code>为-1，那么存活时间为<code>dp[i - 1][0] + cow[i - 1].t</code>，注意若遍历完垃圾还没有死，那么存活时间为<code>dp[n][0] + cow[n].t</code></p><p>​    注意一下细节和边界条件即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int t, f, h;</span><br><span class="line">&#125;lj[105];</span><br><span class="line"></span><br><span class="line">bool cmp(node A, node B) &#123;</span><br><span class="line">return A.t &lt; B.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dp[105][150];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int h, n, flag = 0;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;h, &amp;n);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;lj[i].t, &amp;lj[i].f, &amp;lj[i].h);</span><br><span class="line">&#125;</span><br><span class="line">sort(lj + 1, lj + n + 1, cmp);</span><br><span class="line">lj[0].t = 0;</span><br><span class="line">memset(dp, -1, sizeof(dp));</span><br><span class="line">dp[0][0] = 10;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; h + 25; j++) &#123;</span><br><span class="line">if (dp[i - 1][j] - (lj[i].t - lj[i - 1].t) &gt;= 0) &#123;</span><br><span class="line">dp[i][j] = max(dp[i - 1][j] - (lj[i].t - lj[i - 1].t)+ lj[i].f, dp[i][j]); //吃</span><br><span class="line">&#125;</span><br><span class="line">if (j - lj[i].h &gt;= 0 &amp;&amp; dp[i - 1][j - lj[i].h] - (lj[i].t -lj[i - 1].t) &gt;= 0) &#123;</span><br><span class="line">dp[i][j] = max(dp[i - 1][j - lj[i].h] - (lj[i].t - lj[i - 1].t), dp[i][j]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = h; j &lt; h + 25; j++) &#123;</span><br><span class="line">if (dp[i][j] != -1) &#123;</span><br><span class="line">flag = 1;</span><br><span class="line">printf(&quot;%d\n&quot;, lj[i].t);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!flag) &#123;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">if (dp[i][0] == -1) &#123;</span><br><span class="line">flag = 1;</span><br><span class="line">printf(&quot;%d\n&quot;, dp[i - 1][0] + lj[i - 1].t);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!flag) &#123;</span><br><span class="line">printf(&quot;%d\n&quot;, dp[n][0] + lj[n].t);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1103书本整理</title>
      <link href="/2019/02/24/%E6%B4%9B%E8%B0%B7P1103%E4%B9%A6%E6%9C%AC%E6%95%B4%E7%90%86/"/>
      <url>/2019/02/24/%E6%B4%9B%E8%B0%B7P1103%E4%B9%A6%E6%9C%AC%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/24/洛谷P1103书本整理/title1.jpg" alt="title1"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><code>Frank</code>是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以<code>Frank</code>首先将书按高度顺序排列在书架上。但是<code>Frank</code>发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉k本书，使得书架可以看起来整齐一点。</p><p>书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有4本书：</p><p>1×21×2<br>5×35×3<br>2×42×4<br>3×13×1<br>那么<code>Frank</code>将其排列整齐后是：</p><p>1×21×2<br>2×42×4<br>3×13×1<br>5×35×3<br>不整齐度就是2+3+2=72+3+2=7</p><p>已知每本书的高度都不一样，请你求出去掉k本书后的最小的不整齐度。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行两个数字n<em>n</em>和k<em>k</em>，代表书有几本，从中去掉几本。(1≤n≤100,1≤k&lt;n1≤<em>n</em>≤100,1≤<em>k</em>&lt;<em>n</em>)</p><p>下面的n<em>n</em>行，每行两个数字表示一本书的高度和宽度，均小于200200。</p><p>保证高度不重复</p><p>输出格式：</p><p>一行一个整数，表示书架的最小不整齐度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 1</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    我们先把书本从低到高排序，然后我们设<code>dp[i][j]</code>代表前i本书去掉j本（一定包含第i本）的最小不整齐度。我们初始<code>dp[0][0] = 0</code>，其余为无穷大，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(j + 1 == i) </span><br><span class="line">dp[i][j] == 0;</span><br><span class="line">else</span><br><span class="line">dp[i][j] = min(dp[k][j - (book[i].h - book[k].h - 1)] + book[i].w - book[k].w)  (1 &lt;= k &lt; i)</span><br></pre></td></tr></table></figure><p>​    最后<code>dp[k][j - (n - k)]</code>最小的即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[105][105];//前i本书去掉j本的最小不整齐度，i本必取</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int h, w;</span><br><span class="line">&#125;book[105];</span><br><span class="line"></span><br><span class="line">bool cmp(node A, node B) &#123;</span><br><span class="line">return A.h &lt; B.h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n, k, minn = 0x3f3f3f3f;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;book[i].h, &amp;book[i].w);</span><br><span class="line">&#125;</span><br><span class="line">sort(book + 1, book + n + 1, cmp);</span><br><span class="line">memset(dp, 0x3f3f3f3f, sizeof(dp));</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt;= k &amp;&amp; j &lt; i; j++) &#123;</span><br><span class="line">if (i == j + 1) &#123;</span><br><span class="line">dp[i][j] = 0;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for (int p = 0; p &lt; i; p++) &#123;</span><br><span class="line">if (j - (i - p - 1) &gt;= 0) &#123;</span><br><span class="line">dp[i][j] = min(dp[p][j - (i - p - 1)] + abs(book[i].w - book[p].w), dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">if (k - (n - i) &gt;= 0) &#123;</span><br><span class="line">minn = min(dp[i][k - (n - i)], minn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, minn);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1681最大正方形2</title>
      <link href="/2019/02/24/%E6%B4%9B%E8%B0%B7P1681%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A22/"/>
      <url>/2019/02/24/%E6%B4%9B%E8%B0%B7P1681%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A22/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/24/洛谷P1681最大正方形2/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>忙完了学校的事，v神终于可以做他的“正事”：陪女朋友散步。一天，他和女朋友走着走着，不知不觉就来到了一个千里无烟的地方。v神正要往回走，如发现了一块牌子，牌子上有有一行小字和一张图，小字说道：“找到图上最大的交错正方形之后和我联系，这块地就是你的了。”在房价疯长的年代，v神当然不愿错过这个机会，于是开始找了起来……以v神的能力当然找不出来了，你能帮v神找出来吗？</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>图上有一个矩阵，由N*M个格子组成，这些格子由两种颜色构成，黑色和白色。请找到面积最大的且内部是黑白交错（即两个相连的正方形颜色不能相同）的正方形。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行两个整数N和M，分别表示行数和列数。接下来有N行，每行M个数，0或1分别表示这个格子是黑色或白色。</p><p>输出格式：</p><p>仅有一行，表示满足条件最大正方形的 边长</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">0 1 0</span><br><span class="line">1 0 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>样例解释：</p><p>(1,1)到(2,2)这个正方形是满足条件的，它的边长是2</p><p>数据范围约定：</p><p>对于30%的数据，N &lt;= 20</p><p>对于60%的数据，N &lt;=300</p><p>对于100%的数据，N &lt;= 1500</p><p>思路：</p><p>​    这道题可以<code>h[i]</code>代表i行中当前点往左扩的最长距离，<code>l[j]</code>代表i列中当前点往上扩的最长距离，<code>dp[i][j]</code>代表以(i, j)点为右下角的正方形最长边长。那么我们可以得到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min(dp[i - 1][j - 1] + 1, l[i], h[j]);</span><br></pre></td></tr></table></figure><p>​    我们用一个maxx维护<code>dp[i][j]</code>的最大值即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool maps[1550][1550];</span><br><span class="line">int h[1550], l[1550];</span><br><span class="line">int dp[1550][1550] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n, m, a, maxx = 1;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;maps[i][j]);</span><br><span class="line">if (i == 1) &#123;</span><br><span class="line">l[j] = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (maps[i][j] != maps[i - 1][j]) &#123;</span><br><span class="line">l[j] += 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">l[j] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (j == 1) &#123;</span><br><span class="line">h[i] = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (maps[i][j] != maps[i][j - 1]) &#123;</span><br><span class="line">h[i] += 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">h[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = min(min(h[i], l[j]), dp[i - 1][j - 1] + 1);</span><br><span class="line">maxx = max(dp[i][j], maxx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, maxx);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C网络编程实现聊天室</title>
      <link href="/2019/02/23/C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
      <url>/2019/02/23/C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/23/C网络编程实现聊天室/title.jpg" alt="title"></p><a id="more"></a><p>主要是利用所学的C语言网络编程来实现聊天室功能，包括客户端和服务端两个部分，common用于封装网络编程的相关函数。</p><p>​    客户端接收两个参数，分别是IP地址和端口号</p><p>​    代码已上传至github：<a href="https://github.com/ivan-zcy/homework" target="_blank" rel="noopener">跳转</a></p><p>​    或者从个人博客项目上查看：<a href="http://www.ivan-zcy.top/project/">跳转</a></p><p>效果如下：</p><p>用户1的输入：</p><p><img src="/2019/02/23/C网络编程实现聊天室/User1.png" alt="User1"></p><p>用户2的输入：</p><p><img src="/2019/02/23/C网络编程实现聊天室/User2.png" alt="User2"></p><p>聊天室（服务器）的显示：</p><p><img src="/2019/02/23/C网络编程实现聊天室/Socket.png" alt="Socket"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1651塔</title>
      <link href="/2019/02/23/%E6%B4%9B%E8%B0%B7P1651%E5%A1%94/"/>
      <url>/2019/02/23/%E6%B4%9B%E8%B0%B7P1651%E5%A1%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/23/洛谷P1651塔/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢摆积木，现在他正在玩的积木是由N个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行为一个整数N，表示木块个数。</p><p>第二行是N个整数，表示N块木块的高度。</p><p>【数据规模】</p><p>对于100%的数据，N≤50，每块木块的高度h满足1≤h≤500000，所有木块的高度总和≤500000。</p><p>输出格式：</p><p>仅一个整数，表示能搭建的塔的最大高度，若不能搭建两座相同高度的塔，则输出“-1”。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题我们可以设<code>dp[i][j]</code>代表用前i个木块拼出的塔相差j时的较低塔的高度，初始化<code>dp[1][a[1]]=0;(使用第一个木块) dp[1][0]=0;(不使用第一个木块)</code>，其余初始化为-1，这样这道题会有4种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.当不使用第i个木块：dp[i][j] = dp[i - 1][j];</span><br><span class="line">2.当使用第i个木块且将第i个木块加到较长木块上：dp[i][j] = dp[i - 1][j - a[i]];</span><br><span class="line">3.当使用第i个木块且将第i个木块加到较短木块，此时较短木块还是较短木块：dp[i][j] = dp[i - 1][j + a[i]] + a[i];</span><br><span class="line">4.当使用第i个木块且将第i个木块加到较短木块，此时较短木块称为较长木块：dp[i][j] = dp[i - 1][a[i] - j] + a[i] - j;</span><br></pre></td></tr></table></figure><p>​    要考虑周全每种情况，最后<code>dp[n][0]</code>即为答案，若<code>dp[n][0] == 0 || dp[n][0] == -1</code>时输出-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[55];</span><br><span class="line">int sum[55] = &#123;0&#125;;</span><br><span class="line">int dp[55][500005];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">sum[i] = sum[i - 1] + a[i];</span><br><span class="line">&#125;</span><br><span class="line">memset(dp, -1, sizeof(dp));</span><br><span class="line">dp[1][0] = 0;</span><br><span class="line">dp[1][a[1]] = 0;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">for(int j = 0; j &lt;= sum[i]; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">if (a[i] - j &gt;= 0) &#123;</span><br><span class="line">if (j + a[i] &lt;= sum[i - 1] &amp;&amp; dp[i - 1][j + a[i]] != -1) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - 1][j + a[i]] + a[i]);</span><br><span class="line">&#125;</span><br><span class="line">int t = a[i] - j;</span><br><span class="line">if (dp[i - 1][t] != -1) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - 1][t] + t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (j + a[i] &lt;= sum[i - 1] &amp;&amp; dp[i - 1][j + a[i]] != -1) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - 1][j + a[i]] + a[i]);</span><br><span class="line">&#125;</span><br><span class="line">if (j - a[i] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i]] != -1) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (dp[n][0] == 0) &#123;</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printf(&quot;%d\n&quot;, dp[n][0]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本获取系统相关信息</title>
      <link href="/2019/02/22/shell%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/02/22/shell%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/22/shell脚本获取系统相关信息/title5.jpg" alt="title5"></p><a id="more"></a><p>​    这次布置了六个作业，分别是获取磁盘、内存、CPU、用户信息、系统运行概况以及恶意进程检测等六个方面的内容</p><p>​    具体如下：</p><p>磁盘：主要用于获取DISK磁盘信息，输出时间，每个分区的名称，总量，剩余量，占用比，以及磁盘总量，剩余量，占用比等</p><p>内存：大概就是写一个获取当前时间，内存总量，内存剩余量，内存占用比，占用比动态平均值的shell脚本。唯一参数代表上一次占用比动态平均值</p><p>CPU：该脚本主要负责CPU信息的获取，包括时间，负载（1分钟 5分钟 15分钟），CPU占用率（时间间隔0.5），当前温度以及警告</p><p>用户信息：该脚本主要用来实现用户信息的获取，包括查看用户总数（非系统用户），查看近期最活跃的三个用户，查看具有root权限的用户，以及当前登陆的用户及其相关信息等</p><p>系统运行概况：主要用于获取当前时间，主机名，OS版本及运行时间，平均负载，磁盘总量，磁盘已用百分比以及内存大小和内存已用百分比，磁盘报警级别，内存报警级别，CPU报警级别等</p><p>恶意进程检测：主要是用于恶意进程的检测（脚本将5s内占用CPU或内存资源超过百分之50的进程定义为恶意进程），通过脚本检测并输出恶意进程的进程名，PID，所属用户以及它的CPU占用，内存占用</p><p>​    代码已上传至Github：<a href="https://github.com/ivan-zcy/homework" target="_blank" rel="noopener">跳转</a> </p><p>​    或者通过我个人主页的项目homework进行查看：<a href="http://www.ivan-zcy.top/project/">跳转</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简单用法(三)</title>
      <link href="/2019/02/20/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%89/"/>
      <url>/2019/02/20/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/20/Git简单用法-三/title2.jpg" alt="title2"></p><a id="more"></a><p>[TOC]</p><p>​    前面两个讲了Git的最基本用法，三稍微进阶一点，讲一下比较、标签以及一些问题</p><p>##比较</p><p>###比较修改的内容</p><p>​    当修改的文件还没有添加到内存缓冲区时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><p>​    当修改的文件添加到内存缓冲区时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></table></figure><p>###比较分支</p><p>​    比较当前分支和另一分支差别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff 分支名</span><br></pre></td></tr></table></figure><p>​    比较两个分支差别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff 分支一 分支二</span><br></pre></td></tr></table></figure><p>​    比较当前分支和另一个分支某一个文件或目录的差别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff 分支名 文件名</span><br></pre></td></tr></table></figure><p>##Git标签</p><p>###创建标签</p><p>​    我们可以利用<code>git tag</code>创建一个标签来指向某个提交</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag 标签名 提交编号</span><br></pre></td></tr></table></figure><p>​    提交编号可通过<code>git log</code>查看，很长，我们一般写前8位即可</p><p>​    如果想为标签添加注释或签名，那么就需要创建标签对象</p><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>​    利用<code>git tag</code>来查看所有标签</p><p>###标签对象</p><p>利用-a，-s或-u中任意一个都会创建一个标签对象并且需要-m或者-F为其添加标签消息（注释），例如：    </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a 标签名 提交编号 -m &quot;注释&quot;</span><br></pre></td></tr></table></figure><p>​    这时标签对象被添加到Git对象库中，此时标签指向标签对象而不是一次提交</p><p>###签名标签</p><p>​    签名标签可以让提交和标签更加完整可信，以下步骤的前提是配有GPG key</p><p>####通过-s来创建签名标签</p><p>​    我们要想通过<code>$ git tag -s 标签名 提交编号</code>创建签名标签，就需要以下两种方式之一进行配置：</p><p>方法一：</p><p>​    在.git/config或~/.gitconfig里配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">signingkey = &lt;gpg-key-id&gt;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>​    通过命令行配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config (--global) user.signingkey &lt;gpg-key-id&gt;</span><br></pre></td></tr></table></figure><p>####通过-u来创建签名标签</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git tag -u &lt;gpg-key-id&gt; 标签名 提交编号</span><br></pre></td></tr></table></figure><p>##问题</p><p>###推送失败</p><p>​    当本地修改的同时远端仓库已经变化，这时推送会出现推送失败。这时我们需要先<code>git pull</code>合并远程最新的修改后，再进行<code>git push</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简单用法(二)</title>
      <link href="/2019/02/20/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%BA%8C/"/>
      <url>/2019/02/20/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/20/Git简单用法-二/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><p>​    接上次Git简单用法-一 <a href="http://www.ivan-zcy.top/2019/01/21/Git简单用法-一/">跳转 </a> ，二主要讲关于Git的分支用法和Git日志：</p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>​    分支的主要用于多人开发，可以让开发人员在主线（master分支）之外进行代码提交，同时又不会影响主线。比如我负责项目的一个功能模块，我就创建一个分支，把这部分代码提交到这个分支中，而其它模块的同事</p><p>仍可以利用主线开发，我的提交不会对他们造成任何影响。直到我的功能模块完成通过测试后，最后把我创建的分支合并到主线</p><p>###创建分支</p><p>​    利用<code>$ git branch 分支名</code>便可以创建一个分支</p><p>###查看全部分支</p><p>​    利用<code>$ git branch</code> 可以查看全部分支，以及当前所在分支（带*）</p><p>###切换分支</p><p>​    利用<code>$ git checkout 分支名</code>来切换到其它分支</p><p>###合并分支</p><pre><code>切换到主分支(master)后，利用`$ git merge -m &quot;注释&quot; 分支名`来合并创建的分支</code></pre><p>​    合并分支会出现两种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（一）当两个分支修改的文件不同时：自动合并，不会有冲突</span><br><span class="line">（二）当两个分支修改了相同文件时：系统将两个分支的修改都保存到了该文件中，通过&lt;&lt;&lt;&lt;,&gt;&gt;&gt;,===来分隔，此时我们根据需要手动更改该文件，然后去掉上述分隔符。然后使用git add和git commit命令来提交冲突的文件</span><br></pre></td></tr></table></figure><h3 id="撤销合并"><a href="#撤销合并" class="headerlink" title="撤销合并"></a>撤销合并</h3><p>​    利用<code>$ git reset --hard HEAD^</code>返回合并之前的状态</p><p>###删除分支</p><p>​    利用<code>$ git branch -d 分支名</code>可以删除已经被主分支合并的分支</p><p>​    利用<code>$ git branch -D 分支名</code>可以强制删除某个分支</p><p>###关于如何获取远程分支</p><p>​    我们通过<code>$ git pull</code>命令能够将远程的所有分支都拉过来，但是利用<code>$ git branch</code> 命令查看发现，当前显示的分支只有自己创建的还有主分支，而远程分支虽然拉下来了，但是无法切换</p><p>​    我们要想切换远程分支，只能退而求其次，先把远程分支的内容拷贝到自己新创建的分支上，然后在新分支进行操作，具体做法是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b 新建分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p>​    上一行命令就是创建一个新分支，然后把远程分支的内容拷贝到新分支中，我们只需要切换到新分支进行开发就可</p><h2 id="Git可能出现的问题"><a href="#Git可能出现的问题" class="headerlink" title="Git可能出现的问题"></a>Git可能出现的问题</h2><p>​    当在本地创建了一个分支后，在该分支下我们无法实现<code>$git pull</code>    和<code>$git push</code>命令，我们要想在该分支下使用上面两个命令，必须与远程分支关联</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream 分支名 origin/远程分支名</span><br></pre></td></tr></table></figure><p>​    这时就Ok了</p><p>##Git日志</p><p>###查看日志</p><p>​    利用<code>$ git log</code>可以查看所有的提交</p><p>###日志统计</p><p>​    利用<code>$ git log --stat</code>回显示详细的提交记录</p><p>###日志格式化输出</p><p>​    利用<code>$ git log --pretty=格式类型</code>来指定格式输出日志，主要格式有oneline，short，medium，full，fuller，email，raw等，也可通过<code>--pretty=format:&#39;自定义格式&#39;</code>来输出日志</p><p>###日志可视化输出</p><p>​    利用<code>$ git log --graph</code>可视化显示提交图</p><p>###日志排序</p><p>​    默认按时间线逆序显示，可制定<code>--topo-order</code>参数来按自提交在父提交前显示的排序规则，或者<code>--reverse</code>参数时间线正序显示</p><p>###其它</p><p>​    除此之外日志还有很多用法，具体可通过<code>git help log</code>来查看相应参数用法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于zsh踩过的坑</title>
      <link href="/2019/02/20/%E5%85%B3%E4%BA%8Ezsh%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
      <url>/2019/02/20/%E5%85%B3%E4%BA%8Ezsh%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/20/关于zsh踩过的坑/title1.jpg" alt="title1"></p><a id="more"></a><p>​    当时自己不知情稀里糊涂的从bash切换到了zsh还不自知，其它都还好。就是没次执行sql命令的时候都告诉我sql command not found，然后把<code>/usr/local/mysql/bin</code>添加到环境变量PATH中。然后sql就好用了。然后关掉终端重新打开，发现sql又not found了。。。。。</p><p>​    这时我才意识到，我原来这两个月一直用的是zsh。。。我这反射弧也没谁了～</p><p>​    只要你确定命令存在却找不到，解决这类问题共需要三步：</p><p>步骤一：检查是否添加到环境变量中，如果没有，请添加到环境变量，具体流程就是在家目录下（~）的.bash_profile文件下添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH=对应命令的路径:$JAVA_HOME/bin:$PATH://假如有Java环境的话，加$JAVA_HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><p>步骤二:让.bash_profile文件生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>步骤三：若这时命令好使，但是重启终端发现命令又not found了，这时需要检查你用的是不是不是bash，如果时zsh的话，则需要在~/.zshrc文件最后增加一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>​    最后附上bash和zsh切换的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash//切换到bash</span><br><span class="line">chsh -s /bin/zsh//切换到zsh</span><br></pre></td></tr></table></figure><p>​    如果输入密码后提示no change made，那么命令前加上sudo获取临时管理员权限</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1131时态同步</title>
      <link href="/2019/02/18/%E6%B4%9B%E8%B0%B7P1131%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/02/18/%E6%B4%9B%E8%B0%B7P1131%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/18/洛谷P1131时态同步/title7.jpg" alt="title7"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q<em>Q</em>在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字1,2,3…1,2,3….进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。</p><p>在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。</p><p>激励电流在导线上的传播是需要花费时间的，对于每条边e<em>e</em>，激励电流通过它需要的时间为te<em>t**e</em>，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小Q<em>Q</em>有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行包含一个正整数N<em>N</em>，表示电路板中节点的个数。</p><p>第二行包含一个整数S<em>S</em>，为该电路板的激发器的编号。</p><p>接下来N−1<em>N</em>−1行，每行三个整数a,b,t<em>a</em>,<em>b</em>,<em>t</em>。表示该条导线连接节点a<em>a</em>与节点b<em>b</em>，且激励电流通过这条导线需要t<em>t</em>个单位时间。</p><p>输出格式：</p><p>仅包含一个整数V<em>V</em>，为小Q<em>Q</em>最少使用的道具次数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于40%40%的数据，N≤1000<em>N</em>≤1000</p><p>对于100%100%的数据，N≤500000<em>N</em>≤500000</p><p>对于所有的数据，te≤1000000<em>t**e</em>≤1000000</p><p>思路：</p><p>​    由“都存在且仅存在一条通路”这句话我们可知这是树形结构。我们可以设<code>f[i]</code>代表以节点i为根结点到叶节点的最远距离，设<code>dp[i]</code>代表以节点i为根结点最少使用道具次数。</p><p>​    那么我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i] = max(f[j] + c) //j为i的子节点，c为i到j的距离</span><br><span class="line">dp[i] += dp[j] + f[i] - (f[j] + c);  //j为i的子节点</span><br></pre></td></tr></table></figure><p>​    下面给大家提供一种通过树深度来实现非递归的求法</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">typedef pair&lt;int, ll&gt;PIL;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;PIL&gt; m;</span><br><span class="line">int sd;</span><br><span class="line">&#125;point[500005];</span><br><span class="line"></span><br><span class="line">int num[500005];</span><br><span class="line">ll dp[500005] = &#123;0&#125;;</span><br><span class="line">ll f[500005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(int inx) &#123;</span><br><span class="line">for (int i = 0; i &lt; point[inx].m.size(); i++) &#123;</span><br><span class="line">int to = point[inx].m[i].first;</span><br><span class="line">if (point[to].sd == 0) &#123;</span><br><span class="line">point[to].sd = point[inx].sd + 1;</span><br><span class="line">dfs(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(int a, int b) &#123;</span><br><span class="line">return point[a].sd &gt; point[b].sd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n, c, s, e;</span><br><span class="line">ll v;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;c);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">num[i] = i;</span><br><span class="line">point[i].sd = 0;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d%lld&quot;, &amp;s, &amp;e, &amp;v);</span><br><span class="line">point[s].m.push_back(PIL(e, v));</span><br><span class="line">point[e].m.push_back(PIL(s, v));</span><br><span class="line">&#125;</span><br><span class="line">point[c].sd = 1;</span><br><span class="line">dfs(c);</span><br><span class="line">sort(num + 1, num + 1 + n, cmp);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">int inx = num[i];</span><br><span class="line">ll maxx = 0;</span><br><span class="line">for (int j = 0; j &lt; point[inx].m.size(); j++) &#123;</span><br><span class="line">int to = point[inx].m[j].first;</span><br><span class="line">if (point[to].sd &gt; point[inx].sd) &#123;</span><br><span class="line">maxx = max(maxx, f[to] + point[inx].m[j].second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[inx] = maxx;</span><br><span class="line">for (int j = 0; j &lt; point[inx].m.size(); j++) &#123;</span><br><span class="line">int to = point[inx].m[j].first;</span><br><span class="line">if (point[to].sd &gt; point[inx].sd) &#123;</span><br><span class="line">dp[inx] += dp[to] + (maxx - (f[to] + point[inx].m[j].second));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[c]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1220关路灯</title>
      <link href="/2019/02/18/%E6%B4%9B%E8%B0%B7P1220%E5%85%B3%E8%B7%AF%E7%81%AF/"/>
      <url>/2019/02/18/%E6%B4%9B%E8%B0%B7P1220%E5%85%B3%E8%B7%AF%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/18/洛谷P1220关路灯/title6.jpg" alt="title6"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某一村庄在一条路线上安装了n盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。</p><p>为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。</p><p>现在已知老张走的速度为1m/s，每个路灯的位置（是一个整数，即距路线起点的距离，单位：m）、功率（W），老张关灯所用的时间很短而可以忽略不计。</p><p>请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>文件第一行是两个数字n(1&lt;=n&lt;=50，表示路灯的总数)和c(1&lt;＝c&lt;=n老张所处位置的路灯号)；</p><p>接下来n行，每行两个数据，表示第1盏到第n盏路灯的位置和功率。数据保证路灯位置单调递增。</p><p>输出格式：</p><p>一个数据，即最少的功耗(单位：J，1J＝1W·s)。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 10</span><br><span class="line">3 20</span><br><span class="line">5 20</span><br><span class="line">6 30</span><br><span class="line">8 10</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">270</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    老张肯定经过某个路灯的时候顺手关掉，而不会出现跳着关灯的情况（否则一定不是最小）。因此，我们可以设<code>dp[i][j]</code>代表从第i盏灯到第j盏灯全部关掉的最小功率。这时会出现一个问题，此时老张是在i灯处还是j灯处，因此，我们需要设置一个三维数组来表示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j][0]代表关掉区间[i, j]的灯且此时老张在i灯处的最小功率</span><br><span class="line">dp[i][j][0]代表关掉区间[i, j]的灯且此时老张在j灯处的最小功率</span><br><span class="line">将dp[c][c][0],dp[c][c][1]初始化为0，其余为无穷大</span><br><span class="line"></span><br><span class="line">我们会得到：</span><br><span class="line">dp[i][j][0] = min(dp[i + 1][j][0] + (l[i + 1] - l[i]) * W1, dp[i + 1][j][1] + (l[j] - l[i]) * W1);</span><br><span class="line"></span><br><span class="line">dp[i][j][1] = min(dp[i][j - 1][0] + (l[j] - l[i]) * W2, dp[i][j - 1][1] + (l[j] - l[j - 1]) * W2);</span><br></pre></td></tr></table></figure><p>​    最后再注意一下边界条件，最后<code>min(dp[1][n][0], dp[1][n][1])</code>即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int inx, val;</span><br><span class="line">&#125;box[55];</span><br><span class="line"></span><br><span class="line">int dp[55][55][2] = &#123;0&#125;;</span><br><span class="line">int w[55][55] = &#123;0&#125;;</span><br><span class="line">int val[4];</span><br><span class="line">int ww[55] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n, c;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;c);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;box[i].inx, &amp;box[i].val);</span><br><span class="line">ww[i] = ww[i - 1] + box[i].val;</span><br><span class="line">&#125;</span><br><span class="line">w[c][c] -= box[c].val;</span><br><span class="line">memset(dp, 0x3f, sizeof(dp));</span><br><span class="line">dp[c][c][0] = 0;</span><br><span class="line">dp[c][c][1] = 0;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">w[i][j] = ww[n] - ww[j] + ww[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = c; i &gt;= 1; i--) &#123;</span><br><span class="line">for (int j = c; j &lt;= n; j++) &#123;</span><br><span class="line">if (i == c &amp;&amp; j == c) continue;</span><br><span class="line">memset(val, 0x3f, sizeof(int));</span><br><span class="line">if (i != c) &#123;</span><br><span class="line">val[0] = dp[i + 1][j][0] + (box[i + 1].inx - box[i].inx) * w[i + 1][j];</span><br><span class="line">val[1] = dp[i + 1][j][1] + (box[j].inx - box[i].inx) * w[i + 1][j]; </span><br><span class="line">dp[i][j][0] = min(val[0], val[1]);</span><br><span class="line">//printf(&quot;%d %d %s %d %d\n&quot;, i, j, &quot;左&quot;, dp[i][j][0], w[i + 1][j]);</span><br><span class="line">&#125; </span><br><span class="line">if (j != c) &#123;</span><br><span class="line">val[2] = dp[i][j - 1][0] + (box[j].inx - box[i].inx) * w[i][j - 1];</span><br><span class="line">val[3] = dp[i][j - 1][1] + (box[j].inx - box[j - 1].inx) * w[i][j - 1];</span><br><span class="line">dp[i][j][1] = min(val[2], val[3]);</span><br><span class="line">//printf(&quot;%d %d %s %d %d\n&quot;, i, j, &quot;右&quot;, dp[i][j][1], w[i][j - 1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, min(dp[1][n][0], dp[1][n][1]));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++定义模版</title>
      <link href="/2019/02/12/C-%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88/"/>
      <url>/2019/02/12/C-%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/12/C-定义模版/title4.jpg" alt="title4"></p><a id="more"></a><p>​    C++支持泛型编程（即独立于任何特定类型），而模版是泛型编程的基础，因此模版对于C++来说十分重要</p><p>​    定义模版分为函数模版定义和类模版定义</p><p>##函数模版</p><p>对于函数模版定义，一般形式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename type&gt; ret-type func-name(parameter list) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    type 是函数所使用的数据类型的占位符名称，ret-type是返回值类型，func-name为函数名，parameter list为参数列表</p><p>​    例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; inline T const&amp; Max (T const&amp; a, T const&amp; b) </span><br><span class="line">&#123; </span><br><span class="line">    return a &lt; b ? b:a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##类模版</p><p>对于类模版的定义，一般形式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename type&gt; class class-name &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt; class Stack &#123; </span><br><span class="line">private: </span><br><span class="line">    vector&lt;T&gt; elems;     // 元素 </span><br><span class="line">public: </span><br><span class="line">    void push(T const&amp;);  // 入栈</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt; void Stack&lt;T&gt;::push (T const&amp; elem) &#123; </span><br><span class="line">    elems.push_back(elem);   // 追加传入元素的副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟栈实现逆波兰表达式</title>
      <link href="/2019/02/12/%E6%A8%A1%E6%8B%9F%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/02/12/%E6%A8%A1%E6%8B%9F%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/12/模拟栈实现逆波兰表达式/title3.jpg" alt="title3"></p><a id="more"></a><p>​    用C++模拟栈来实现逆波兰表达式求解算式～</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename type&gt; class S&#123;</span><br><span class="line">private:</span><br><span class="line">type *val;</span><br><span class="line">int head;</span><br><span class="line">public:</span><br><span class="line">void push(type val) &#123;</span><br><span class="line">this -&gt; head ++;</span><br><span class="line">this -&gt; val[this -&gt; head] = val;</span><br><span class="line">&#125;</span><br><span class="line">void pop() &#123;</span><br><span class="line">this -&gt; head --;</span><br><span class="line">&#125;</span><br><span class="line">bool empty() &#123;</span><br><span class="line">return this -&gt; head &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line">type top() &#123;</span><br><span class="line">return this -&gt; val[this -&gt; head];</span><br><span class="line">&#125;</span><br><span class="line">bool bj(char c) &#123;</span><br><span class="line">if ((c == &apos;+&apos; || c == &apos;-&apos;) &amp;&amp; (top() == &apos;*&apos; || top() == &apos;/&apos;)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else if ((c == &apos;+&apos; || c == &apos;-&apos;) &amp;&amp; (top() == &apos;+&apos; || top() == &apos;-&apos;))&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else if ((c == &apos;*&apos; || c == &apos;/&apos;) &amp;&amp; (top() == &apos;*&apos; || top() == &apos;/&apos;))&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">this -&gt; val = (type *)malloc(sizeof(type) * 25);</span><br><span class="line">this -&gt; head = -1;</span><br><span class="line">&#125;</span><br><span class="line">void clear() &#123;</span><br><span class="line">free(this -&gt; val);</span><br><span class="line">free(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int jsx(char c, int a, int b) &#123;</span><br><span class="line">switch(c) &#123;</span><br><span class="line">case &apos;*&apos;:</span><br><span class="line">return a * b;</span><br><span class="line">break;</span><br><span class="line">case &apos;/&apos;:</span><br><span class="line">return a / b;</span><br><span class="line">break;</span><br><span class="line">case &apos;+&apos;:</span><br><span class="line">return a + b;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">return a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void js(S&lt;int&gt; *num, S&lt;char&gt; *ch) &#123;</span><br><span class="line">int b = num -&gt; top();</span><br><span class="line">num -&gt; pop();</span><br><span class="line">int a = num -&gt; top();</span><br><span class="line">num -&gt; pop();</span><br><span class="line">num -&gt; push(jsx(ch -&gt; top(), a, b));</span><br><span class="line">ch -&gt; pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">char *buffer = (char *)malloc(sizeof(char) * 25);</span><br><span class="line">scanf(&quot;%s&quot;, buffer);</span><br><span class="line">int val = 0;</span><br><span class="line">S&lt;int&gt; *num = (S&lt;int&gt; *)malloc(sizeof(S &lt;int&gt;));</span><br><span class="line">S&lt;char&gt; *ch = (S&lt;char&gt; *)malloc(sizeof(S &lt;char&gt;));</span><br><span class="line">num -&gt; init();</span><br><span class="line">ch -&gt; init();</span><br><span class="line">for (int i = 0; buffer[i]; i++) &#123;</span><br><span class="line">if (isdigit(buffer[i])) &#123;</span><br><span class="line">val = val * 10 + buffer[i] - &apos;0&apos;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">num -&gt; push(val);</span><br><span class="line">val = 0;</span><br><span class="line">while(!ch -&gt; empty() &amp;&amp; ch -&gt; bj(buffer[i])) &#123;</span><br><span class="line">js(num, ch);</span><br><span class="line">&#125;</span><br><span class="line">ch -&gt; push(buffer[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num -&gt; push(val);</span><br><span class="line">while(!ch -&gt; empty()) &#123;</span><br><span class="line">js(num, ch);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, num -&gt; top());</span><br><span class="line">free(buffer);</span><br><span class="line">num -&gt; clear();</span><br><span class="line">ch -&gt; clear();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 逆波兰表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟队列</title>
      <link href="/2019/02/12/%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"/>
      <url>/2019/02/12/%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/02/12/模拟队列/title.jpg" alt="title"></p><a id="more"></a><p>C++模拟队列的实现～</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename type&gt; class Que&#123;</span><br><span class="line">private:</span><br><span class="line">    type *data;</span><br><span class="line">    int head, tail;</span><br><span class="line">public:</span><br><span class="line">    Que() &#123;</span><br><span class="line">        head = 0;</span><br><span class="line">        tail = -1;</span><br><span class="line">        data = (type *)malloc(sizeof(type) * 105);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Que() &#123;</span><br><span class="line">        free(this -&gt; data);</span><br><span class="line">    &#125;</span><br><span class="line">    void add(type data) &#123;</span><br><span class="line">        tail++;</span><br><span class="line">        this -&gt; data[tail] = data;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if (!empty()) &#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return head &gt; tail;</span><br><span class="line">    &#125;</span><br><span class="line">    void output() &#123;</span><br><span class="line">        for (int i = head; i &lt;= tail; i++) &#123;</span><br><span class="line">            printf(&quot;%d%c&quot;, data[i], i == tail? &apos;\n&apos;: &apos; &apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int gethead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    int gettail() &#123;</span><br><span class="line">        return tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, val;</span><br><span class="line">    Que&lt;int&gt; que;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;val);</span><br><span class="line">        que.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    que.output();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19-01-31博客搭建进度</title>
      <link href="/2019/01/31/19-01-31%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2019/01/31/19-01-31%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/31/19-01-31博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>​    特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页 (11.30更新)</p><p>​    ——调整底部布局 (12.02更新)</p><p>​    ——新增小游戏——见缝插针 (12.02更新)</p><p>​    ——修复音乐弹出、小火箭移动端错误问题 （12.04更新）</p><p>​    ——更新“关于我”页面特效（12.04更新）</p><p>​    ——主页新增搜索博文功能 （01.31更新）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟链表</title>
      <link href="/2019/01/30/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/01/30/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/30/模拟链表/title.jpg" alt="title"></p><a id="more"></a><p>​    主要是用C++实现了链表的增删改查以及反转、遍历等功能，具体实现请看代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OK 1</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt; class Point &#123;</span><br><span class="line">public:</span><br><span class="line">    Type data;</span><br><span class="line">    Point&lt;Type&gt; *next;</span><br><span class="line">    Point() &#123;</span><br><span class="line">        this -&gt; next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(Type data) &#123;</span><br><span class="line">        this -&gt; data = data;</span><br><span class="line">        this -&gt; next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt; class Train &#123;</span><br><span class="line">private:</span><br><span class="line">    Point&lt;Type&gt; *head;</span><br><span class="line">    int len;</span><br><span class="line">public:</span><br><span class="line">    Train() &#123;</span><br><span class="line">        head = NULL;</span><br><span class="line">        len = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Train() &#123;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            Point&lt;Type&gt; *old = p;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            free(old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void set(int len) &#123;</span><br><span class="line">        this -&gt; len = len;</span><br><span class="line">    &#125;</span><br><span class="line">    int get() &#123;</span><br><span class="line">        return this -&gt; len;</span><br><span class="line">    &#125;</span><br><span class="line">    bool insert(Point&lt;Type&gt; *t, int inx) &#123;</span><br><span class="line">        if (inx &lt; 0 || inx &gt; this -&gt; len) &#123;</span><br><span class="line">            return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            this -&gt; len ++;</span><br><span class="line">            this -&gt; head = t;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">        if (inx == 0) &#123;</span><br><span class="line">            t -&gt; next = this -&gt; head;</span><br><span class="line">            this -&gt; head = t;</span><br><span class="line">            this -&gt; len ++;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        while(tot &lt; inx - 1) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        t -&gt; next = p -&gt; next;</span><br><span class="line">        p -&gt; next = t;</span><br><span class="line">        this -&gt; len ++;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    int query(Type val) &#123;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            if (p -&gt; data == val) &#123;</span><br><span class="line">                return tot;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    void output() &#123;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            cout &lt;&lt; tot++ &lt;&lt; &quot;:&quot; &lt;&lt; p -&gt; data &lt;&lt; &quot; &quot;;</span><br><span class="line">            p = p -&gt; next; </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bool del(int inx) &#123;</span><br><span class="line">        if (inx &lt; 0 || inx &gt;= this -&gt; len) &#123;</span><br><span class="line">            return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = this -&gt; head;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        if (inx == 0) &#123;</span><br><span class="line">            this -&gt; head = this -&gt; head -&gt; next;</span><br><span class="line">            free(p);</span><br><span class="line">            this -&gt; len --;</span><br><span class="line">            return OK;</span><br><span class="line">        &#125;</span><br><span class="line">        while(tot &lt; inx - 1) &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *del = p -&gt; next;</span><br><span class="line">        p -&gt; next = del -&gt; next;</span><br><span class="line">        free(del);</span><br><span class="line">        this -&gt; len --;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    void reverse() &#123;</span><br><span class="line">        if (this -&gt; head == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Point&lt;Type&gt; *p = head -&gt; next;</span><br><span class="line">        head -&gt; next = NULL;</span><br><span class="line">        while(p != NULL) &#123;</span><br><span class="line">            Point&lt;Type&gt; *p2 = p -&gt; next;</span><br><span class="line">            p -&gt; next = head;</span><br><span class="line">            head = p;</span><br><span class="line">            p = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Train&lt;int&gt; trian;</span><br><span class="line">    int m, a, b, t;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        switch (t) &#123;</span><br><span class="line">            case 1: &#123;</span><br><span class="line">                cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">                Point &lt;int&gt; *p = (Point &lt;int&gt; *)malloc(sizeof(Point &lt;int&gt;));</span><br><span class="line">                p -&gt; data = b;</span><br><span class="line">                p -&gt; next = NULL;</span><br><span class="line">                if(trian.insert(p, a)) &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 2: &#123;</span><br><span class="line">                trian.output();</span><br><span class="line">                break;</span><br><span class="line">            &#125;  </span><br><span class="line">            case 3:&#123;</span><br><span class="line">                cin &gt;&gt; a;</span><br><span class="line">                if (trian.del(a)) &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 4:&#123;</span><br><span class="line">                cin &gt;&gt; a;</span><br><span class="line">                int inx = trian.query(a);</span><br><span class="line">                if (inx != -1) &#123;</span><br><span class="line">                    cout &lt;&lt; inx &lt;&lt; endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">                trian.reverse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟动态数组</title>
      <link href="/2019/01/30/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2019/01/30/%E6%A8%A1%E6%8B%9F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/30/模拟动态数组/title.jpg" alt="title"></p><a id="more"></a><p>​    大概就是用数组模拟动态数组吧，功能包括插入，查询，删除，遍历。可以进行初始化，动态扩容，以及最后释放掉内存</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OK 1</span><br><span class="line"></span><br><span class="line">typedef struct Vector &#123;</span><br><span class="line">int len, size;</span><br><span class="line">    int *q;</span><br><span class="line">&#125; Vector;</span><br><span class="line"></span><br><span class="line">void init(Vector *a, int size) &#123;</span><br><span class="line">a -&gt; q = (int *)malloc(sizeof(int) * size);</span><br><span class="line">    a -&gt; len = 0;</span><br><span class="line">    a -&gt; size = size;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void expand(Vector *a) &#123;</span><br><span class="line">a -&gt; size *= 2;</span><br><span class="line">    int *old = a -&gt; q;</span><br><span class="line">    a -&gt; q = (int *)malloc(sizeof(int) * a -&gt; size);</span><br><span class="line">    for (int i = 0; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        a -&gt; q[i] = old[i];</span><br><span class="line">    &#125;</span><br><span class="line">    free(old);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int insert(Vector *a, int inx, int val) &#123;</span><br><span class="line">if (inx &lt; 0 || inx &gt; a -&gt; len) return ERROR;</span><br><span class="line">    if (a -&gt; len &gt;= a -&gt; size) &#123;</span><br><span class="line">        expand(a);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = a -&gt; len; i &gt; inx; i--) &#123;</span><br><span class="line">        a -&gt; q[i] = a -&gt; q[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    a -&gt; q[inx] = val;</span><br><span class="line">    a -&gt; len++;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int search(Vector *a, int val) &#123;</span><br><span class="line">for (int i = 0; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        if(a -&gt; q[i] == val) return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete_node(Vector *a, int inx) &#123;</span><br><span class="line">if (inx &lt; 0 || inx &gt;= a -&gt; len) return ERROR;</span><br><span class="line">    for (int i = inx + 1; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        a -&gt; q[i - 1] = a -&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a -&gt; len--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Vector *a) &#123;</span><br><span class="line">for (int i = 0; i &lt; a -&gt; len; i++) &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, a -&gt; q[i], i == a -&gt; len - 1? &apos;\n&apos;: &apos; &apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear(Vector *a) &#123;</span><br><span class="line">free(a -&gt; q);</span><br><span class="line">    free(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Vector *a = (Vector *)malloc(sizeof(Vector));</span><br><span class="line">    init(a, 20);</span><br><span class="line">int m, t, p, q;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">        switch (t) &#123;</span><br><span class="line">            case 1: </span><br><span class="line">                scanf(&quot;%d%d&quot;, &amp;p, &amp;q);</span><br><span class="line">                if (insert(a, p, q)) &#123;</span><br><span class="line">                    printf(&quot;success\n&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    printf(&quot;failed\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">                if(delete_node(a, p)) &#123;</span><br><span class="line">                    printf(&quot;success\n&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    printf(&quot;failed\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">                if(search(a, p)) &#123;</span><br><span class="line">                    printf(&quot;success\n&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    printf(&quot;failed\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                print(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷3994高速公路</title>
      <link href="/2019/01/29/%E6%B4%9B%E8%B0%B73994%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/"/>
      <url>/2019/01/29/%E6%B4%9B%E8%B0%B73994%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/29/洛谷3994高速公路/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>C国拥有一张四通八达的高速公路<del>网</del>树，其中有n个城市，城市之间由一共n-1条高速公路连接。除了首都1号城市，每个城市都有一家本地的客运公司，可以发车前往全国各地，有若干条高速公路连向其他城市，这是一个树型结构，1号城市（首都）为根。假设有一个人要从i号城市坐车出发前往j号城市，那么他要花费Pi*（i城市到j城市的距离）+Qi元。由于距离首都越远，国家的监管就越松，所以距离首都越远，客运公司的Pi（单位距离价格）越大，形式化的说，如果把高速路网看成一棵以首都为根的有根树，i号城市是j号城市的某个祖先，那么一定存在Pi&lt;=Pj。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>大宁成为了国家统计局的调查人员，他需要对现在的高速路网进行一次调查，了解从其他每一个城市到达首都1号城市所花费的金钱(路径必须是简单路径)。</p><p>因为有非常多转车（或不转车）的抵达首都的方法，所以人工计算这个结果是十分复杂的。大宁非常的懒，所以请你编写一个程序解决它。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第 1 行包含1个非负整数 n,表示城市的个数。</p><p>第 2 到 n 行，每行描述一个<strong>除首都之外</strong>的城市。其中第 i 行包含4 个非负整数 Fi,Si,Pi,Qi，分别表示 i号城市的父亲城市，它到父亲城市高速公路的长度，以及乘车价格的两个参数。</p><p>输出格式：</p><p>输出包含 n-1 行，每行包含一个整数。</p><p>其中第 i 行表示从 i+1号城市 出发，到达首都最少的乘车费用。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 9 3 0</span><br><span class="line">1 17 1 9</span><br><span class="line">1 1 1 6</span><br><span class="line">4 13 2 15</span><br><span class="line">4 9 2 4</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27</span><br><span class="line">26</span><br><span class="line">7</span><br><span class="line">43</span><br><span class="line">24</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于前40%的数据1&lt;=n&lt;=1000。</p><p>对于另外20%的数据 满足从第i（i≠1）个城市出发的高速公路连向第i-1个城市。</p><p>对于所有的数据1&lt;=n&lt;=1000000，0&lt;=Pi，Qi&lt;=2^31-1，保证结果不会大于2^63-1。</p><p>思路：</p><p>​    这道题我们可以设<code>S[i]</code>代表首都到i城市的距离， <code>dp[i]</code>代表第i个城市到首都最少乘车费用，那么我们可以得到递推式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + P[i] * (S[i] - S[j]) + Q[i]) (0 &lt;= j &lt; i)</span><br></pre></td></tr></table></figure><p>​    上面这个式子的时间复杂度为O(n ^ 2)，由于n的范围为1e6，因此我们必须优化为O(n)的做法，我们发现，该式符合斜率优化的特征：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j]为变量，P[i] * S[i]和Q[i]为不变量，而P[i]*S[j]为混合量</span><br></pre></td></tr></table></figure><p>​    我们开始将混合量去掉：</p><p>第一步：由于该题所有城市组成一棵树，1号首都为根结点。我们设j 为 k的子节点（不一定是直接子节点）且对于求<code>dp[i]</code>，j比k优，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] + P[i] * (S[i] - S[j]) + Q[i] &lt; dp[k] + P[i] * (S[i] - S[k]) + Q[i]</span><br><span class="line">dp[j] - P[i] * S[j] &lt; dp[k] - P[i] * S[k]</span><br><span class="line">(dp[j] - dp[k]) / (S[j] - S[k]) &lt; P[i]</span><br></pre></td></tr></table></figure><p>​    其中<code>(dp[j] - dp[k]) / (S[j] - S[k])</code>就为求解的斜率</p><p>第二步</p><p>​    设P(p, q)为点p和点q之间的斜率，那么假设j, p, q都是i的祖宗节点且q是j的祖宗节点，p是q的祖宗节点且P(p, q) &gt; P(q, j)。我们讨论所有的情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) P[i] &lt; P(q, j) &lt; P(p, q)</span><br><span class="line">此时，q优于j，p优于q，因此p是最优解</span><br><span class="line">(2) P(q, j) &lt; P[i] &lt; P(p, q)</span><br><span class="line">此时，j优于q，p优于q，因此j,p中的一个是最优解</span><br><span class="line">(3) P(q, j) &lt; P(p, q) &lt; P[i]</span><br><span class="line">此时，j优于q，q优于p，因此j是最优解</span><br></pre></td></tr></table></figure><p> 我们会发现，在满足该种的情况下，无论如何，q都不是最优解，也就是中间的那个永远不是最优，因此，我们可以用单调队列来维护斜率上升的队列来O(1)的求解<code>dp[i]</code></p><p>第三步：</p><p>​    因为这是一个树，在遍历树的时候，遍历完子节点回溯到父节点的时候需要对队列进行还原，我们发现手动模拟的队列数组q虽然tail，head改变，但是存储的内容只有一个位置发生改变，其余改变的只有head和tail，数组中的东西依旧保存。因此我们只需要维护每次的head，tail和改变的那个值即可，详细请看代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int num=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">inline ll readl() &#123;</span><br><span class="line">    ll num=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int inx;</span><br><span class="line">ll val;</span><br><span class="line">void set(int ninx, ll nval) &#123;</span><br><span class="line">inx = ninx;</span><br><span class="line">val = nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll P[1000005] = &#123;0&#125;, Q[1000005] = &#123;0&#125;, dp[1000005] = &#123;0&#125;, s[1000005] = &#123;0&#125;;</span><br><span class="line">vector&lt;node&gt; v[1000005];</span><br><span class="line">int q[1000005];</span><br><span class="line"></span><br><span class="line">void set(int j, int i) &#123;</span><br><span class="line">dp[i] = dp[j] + P[i] * (s[i] - s[j]) + Q[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getp(int j, int i) &#123;</span><br><span class="line">return 1.0 * (dp[i] - dp[j]) / (s[i] - s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int tail, int head) &#123;</span><br><span class="line">while (head + 2 &lt;= tail &amp;&amp; getp(q[head], q[head + 1]) &lt;= P[inx]) head++;</span><br><span class="line">set(q[head], inx);</span><br><span class="line">while (head + 2 &lt;= tail &amp;&amp; getp(q[tail - 1], inx) &lt;= getp(q[tail - 2], q[tail - 1])) tail--;</span><br><span class="line">int flag = q[tail];</span><br><span class="line">q[tail++] = inx;</span><br><span class="line">for (int i = 0; i &lt; v[inx].size(); i++) &#123;</span><br><span class="line">node t = v[inx][i];</span><br><span class="line">s[t.inx] = s[inx] + t.val;</span><br><span class="line">dfs(t.inx, tail, head);</span><br><span class="line">&#125;</span><br><span class="line">q[tail - 1] = flag;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int n, father;</span><br><span class="line">ll x;</span><br><span class="line">node t;</span><br><span class="line">n = read();</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">father = read();</span><br><span class="line">x = readl();</span><br><span class="line">P[i] = readl();</span><br><span class="line">Q[i] = readl();</span><br><span class="line">t.set(i, x);</span><br><span class="line">v[father].push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">q[1] = 1;</span><br><span class="line">dfs(1, 1, 1);</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
            <tag> 斜率优化 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-7</title>
      <link href="/2019/01/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-7/"/>
      <url>/2019/01/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/28/动态规划优化问题-7/title4.jpg" alt="title4"></p><a id="more"></a><p>之前系列讲了动态规划优化的去除冗余状态，重新定义状态，或者单调栈或单调队列优化等关于动态规划的优化问题。</p><p>接下来讲的就比较难了，属于动态规划的斜率优化问题</p><p>具体我们用例题来详细说明</p><p>例题：古老的打印机</p><p>有一台古老的打字机和一篇待打印的文章，文章中有 n 个字符，每个字符会有一个消耗值 Ci, 打字机工作一次会打印若干连续的 k 个字符，同时打字机会有磨损，打字机的单次磨损计算公式为：</p><p>(∑i=1kCi)2+M</p><p>其中 M 是打字机启动一次的固定磨损值，现在给你 n 个字符的消耗值，问你打字机顺序打印出这 n 个字符的最小磨损值为多少？</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行输入两个数字，n,M(1≤n≤106,1≤M≤104) 代表文章中字符数量和打字机单次启动的固定磨损值。</p><p>第二行输入 n 个数字，第 i 个数字代表文章中第 i 个字符的磨损值 Ci(1≤Ci≤100)。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，代表打字机顺序打完 n 个字符的最小磨损值</p><hr><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 40</span><br><span class="line">3 3 6 5 1 2</span><br></pre></td></tr></table></figure><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">256</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    对于这类问题，我们设<code>s[i]</code>为前i个字符的Ci的和， <code>dp[i]</code>代表前i个字符的最小磨损值，那么我们可以得到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (s[i] - s[j])^2 + M) (0 &lt;= j &lt; i)</span><br></pre></td></tr></table></figure><p>​    由上面的递推公式可知，这样的时间复杂度为O(n^2)，而n的范围是1e6，所以肯定1s内跑不完，因此我们需要把它优化为O(n)的时间复杂度</p><p>​    我们展开上面的式子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = min(dp[j] + (s[i] - s[j])^2 + M)</span><br><span class="line">  = min(dp[j] + s[i]^2 + s[j]^2 - 2 * s[i] * s[j] + M)</span><br><span class="line">我们单拿出dp[j] + s[i]^2 + s[j]^2 - 2 * s[i] * s[j] + M来看</span><br><span class="line">其中s[i]^2，M是固定值，dp[j]，s[j]^2是变化值，2 * s[i] * s[j]是两者的混合值</span><br></pre></td></tr></table></figure><p>如果只有固定值和变化值，我们可以通过一个变量维护前i的s[j]^2 + dp[j]的最大值来O(1)的求出dp[i]，可是由于混合值的出现，导致我们无法这样求出</p><p>记住一点：只要看到混合值的出现，就要想办法对其进行斜率优化！！</p><p>具体步骤是</p><p>1.假设j &gt; k且dp[j] + (s[i] - s[j])^2 + M优于dp[k] + (s[i] - s[k])^2 + M，那么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[j] + (s[i] - s[j])^2 + M &lt; dp[k] + (s[i] - s[k])^2 + M</span><br><span class="line">等价于：dp[j] + s[j]^2 - 2 * s[j] * s[i] &lt; dp[k] + s[k]^2 - 2 * s[k] * s[i]</span><br><span class="line">等价于：(dp[j] + s[j]^2) - (dp[k] + s[k]^2) &lt; 2 * s[i] * (s[j] - s[k])</span><br><span class="line">等价于：(dp[j] + s[j]^2) - (dp[k] + s[k]^2) / (s[j] - s[k]) &lt; 2 * s[i]</span><br><span class="line">我们假设f(i) = dp[i] * s[i]^2</span><br><span class="line">那么：f(j) - f(k) / (s[j] - s[k]) &lt; 2 * s[i]</span><br></pre></td></tr></table></figure><p>至于为什么叫斜率优化，当我们把s[i]看作x，f(i)看作y，那么f(j) - f(k) / (s[j] - s[k])就是斜率了</p><p>也就是说，只要满足f(j) - f(k) / (s[j] - s[k]) &lt; 2 * s[i]且j &gt; k，那么j就一定优化k</p><p>2.我们设P(x, y)代表点x，y之间的斜率，对i中的p, q, j进行分析（p &lt; q &lt; j &lt; i且P(p, q) &gt; P(q, j)），那么斜率会有三种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 2 * s[i] &lt; P(q, j) &lt; P(p, q)</span><br><span class="line">此时，q优于j，p优于q，因此p是最优解</span><br><span class="line">(2) P(q, j) &lt; 2 * s[i] &lt; P(p, q)</span><br><span class="line">此时，j优于q，p优于q，因此j,p中的一个是最优解</span><br><span class="line">(3) P(q, j) &lt; P(p, q) &lt; 2 * s[i]</span><br><span class="line">此时，j优于q，q优于p，因此j是最优解</span><br></pre></td></tr></table></figure><p>​    我们会发现，在p(p, q) &gt; p(q, j)且 p &lt; q &lt; j &lt; i的情况下，无论如何，q都不是最优解，也就是中间的那个永远不是最优，因此，我们可以用单调队列来维护斜率上升的队列来O(1)的求解<code>dp[i]</code>，具体做法见代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll sum[1000005] = &#123;0&#125;;</span><br><span class="line">ll dp[1000005] = &#123;0&#125;;</span><br><span class="line">int q[1000005] = &#123;0&#125;;</span><br><span class="line">int n, M, a, tail, head;</span><br><span class="line"></span><br><span class="line">void set(int j, int i) &#123;</span><br><span class="line">dp[i] = dp[j] + (sum[i] - sum[j]) * (sum[i] - sum[j]) + M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getp(int j, int i) &#123;</span><br><span class="line">double p1 = (dp[i] + sum[i] * sum[i]) - (dp[j] + sum[j] * sum[j]);</span><br><span class="line">double p2 = sum[i] - sum[j];</span><br><span class="line">return p1 / p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;M);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">sum[i] = sum[i - 1] + a;</span><br><span class="line">&#125;</span><br><span class="line">head = tail = 1;</span><br><span class="line">set(0, 1);</span><br><span class="line">q[tail++] = 0;</span><br><span class="line">q[tail++] = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">while(head + 2 &lt;= tail &amp;&amp; getp(q[head], q[head + 1]) &lt;= 2 * sum[i]) head++;</span><br><span class="line">set(q[head], i);</span><br><span class="line">while(head + 2 &lt;= tail &amp;&amp; getp(q[tail - 1], i) &lt;= getp(q[tail -2], q[tail - 1])) tail--;</span><br><span class="line">q[tail++] = i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[n]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海贼OJ57有趣的序列</title>
      <link href="/2019/01/27/%E6%B5%B7%E8%B4%BCOJ57%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%8F%E5%88%97/"/>
      <url>/2019/01/27/%E6%B5%B7%E8%B4%BCOJ57%E6%9C%89%E8%B6%A3%E7%9A%84%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/海贼OJ57有趣的序列/title5.jpg" alt="title5"></p><a id="more"></a><h2 id="有趣的序列"><a href="#有趣的序列" class="headerlink" title="有趣的序列"></a>有趣的序列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在生成一个包含所有自然数的序列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123456789101112131415...</span><br></pre></td></tr></table></figure><p>其中 d12 是数字 1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入三个数字 x,y,z(1≤x,y,z≤1,000,000)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出一个整数，代表<code>dx×dy×dz</code> 的结果</p><p>思路：</p><p>​    因为x，y，z范围是1e6，因此我们可以先预处理出<code>sum[i]</code>代表i位数共占多少位置，并预处理出<code>start[i]</code>代表i位数的起始数组</p><p>​    这样，我们传入位置后，若位置&gt;<code>sum[i]</code>，就用位置-=<code>sum[i]</code>并查找下一位，若等于<code>sum[i]</code>，就返回9（因为每位数的最后一个数字的最后一位都是9），若小于<code>sum[i]</code>，就判断是第该位的哪一个数字的哪一位，并把该数返回即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">&gt; File Name: p.cpp</span><br><span class="line">&gt; Author: Zcy</span><br><span class="line">&gt; Mail: 296763002@qq.com</span><br><span class="line">&gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum[7] = &#123;0, 9, 180, 2700, 36000, 450000, 5400000&#125;;</span><br><span class="line">int start[7] = &#123;0, 1, 10, 100, 1000, 10000, 100000&#125;;</span><br><span class="line"></span><br><span class="line">int quick(int a, int b) &#123;</span><br><span class="line">int ans = 1;</span><br><span class="line">while(b) &#123;</span><br><span class="line">if(b &amp; 1) &#123;</span><br><span class="line">ans *= a;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a *= a;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getinx(int inx) &#123;</span><br><span class="line">for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">if (inx &gt; sum[i]) &#123;</span><br><span class="line">inx -= sum[i];</span><br><span class="line">&#125; else if (inx == sum[i]) &#123;</span><br><span class="line">return 9;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int cs = inx / i;</span><br><span class="line">int ys = inx % i;</span><br><span class="line">if (ys == 0) &#123;</span><br><span class="line">cs = cs + start[i] - 1;</span><br><span class="line">cs %= 10;</span><br><span class="line">return cs;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cs = cs + start[i];</span><br><span class="line">int ttt = quick(10, i - ys);</span><br><span class="line">int kkk = cs / ttt;</span><br><span class="line">kkk %= 10;</span><br><span class="line">return kkk;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">// for (int i = 1; i &lt;= 1000; i++) &#123;</span><br><span class="line">// printf(&quot;%d&quot;, getinx(i));</span><br><span class="line">// &#125;</span><br><span class="line">int xx = getinx(x);</span><br><span class="line">int yy = getinx(y);</span><br><span class="line">int zz = getinx(z);</span><br><span class="line">printf(&quot;%d\n&quot;, xx * yy * zz);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1757通天之分组背包</title>
      <link href="/2019/01/27/%E6%B4%9B%E8%B0%B71757%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/"/>
      <url>/2019/01/27/%E6%B4%9B%E8%B0%B71757%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/洛谷1757通天之分组背包/title3.jpg" alt="title3"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>直达通天路·小A历险记第二篇</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>自01背包问世之后，小A对此深感兴趣。一天，小A去远游，却发现他的背包不同于01背包，他的物品大致可分为k组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>两个数m,n，表示一共有n件物品，总重量为m</p><p>接下来n行，每行3个数ai,bi,ci，表示物品的重量，利用价值，所属组数</p><p>输出格式：</p><p>一个数，最大的利用价值</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">45 3</span><br><span class="line">10 10 1</span><br><span class="line">10 5 1</span><br><span class="line">50 400 2</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1&lt;=m&lt;=1000 1&lt;=n&lt;=1000 组数t&lt;=100</p><p>思路：</p><p>​    分组背包入门题，没啥好说的～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;zcy[1005];</span><br><span class="line">int v[1005], w[1005];</span><br><span class="line">int dp[1050] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int m, n, group;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;w[i], &amp;group);</span><br><span class="line">        zcy[group].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (!zcy[i].size()) break;</span><br><span class="line">        for (int k = m; k &gt;= 0; k--) &#123;</span><br><span class="line">            for (int j = 0; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">                int vv = v[zcy[i][j]];</span><br><span class="line">                int ww = w[zcy[i][j]];</span><br><span class="line">                if (k - vv &lt; 0) continue;</span><br><span class="line">                dp[k] = max(dp[k - vv] + ww, dp[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分组背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1064金明的预算方案</title>
      <link href="/2019/01/27/%E6%B4%9B%E8%B0%B71064%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/"/>
      <url>/2019/01/27/%E6%B4%9B%E8%B0%B71064%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/洛谷1064金明的预算方案/title6.jpg" alt="title6"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N<em>N</em>元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>主件 附件</p><p>电脑 打印机，扫描仪</p><p>书柜 图书</p><p>书桌 台灯，文具</p><p>工作椅 无</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有00个、11个或22个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N<em>N</em>元。于是，他把每件物品规定了一个重要度，分为55等：用整数1−51−5表示，第55等最重要。他还从因特网上查到了每件物品的价格（都是1010元的整数倍）。他希望在不超过N<em>N</em>元（可以等于N<em>N</em>元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第j<em>j</em>件物品的价格为v[j]<em>v</em>[<em>j</em>]，重要度为w[j]<em>w</em>[<em>j</em>]，共选中了k<em>k</em>件物品，编号依次为j1,j2,…,jk<em>j</em>1,<em>j</em>2,…,<em>j**k</em>，则所求的总和为：</p><p>v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]<em>v</em>[<em>j</em>1]×<em>w</em>[<em>j</em>1]+<em>v</em>[<em>j</em>2]×<em>w</em>[<em>j</em>2]+…+<em>v</em>[<em>j**k</em>]×<em>w</em>[<em>j**k</em>]。</p><p>请你帮助金明设计一个满足要求的购物单。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第11行，为两个正整数，用一个空格隔开：</p><p>Nm<em>N**m</em> （其中N(&lt;32000)<em>N</em>(&lt;32000)表示总钱数，m(&lt;60)<em>m</em>(&lt;60)为希望购买物品的个数。） 从第22行到第m+1<em>m</em>+1行，第j<em>j</em>行给出了编号为j−1<em>j</em>−1的物品的基本数据，每行有33个非负整数</p><p>vpq<em>v<strong>p</strong>q</em> （其中v<em>v</em>表示该物品的价格（v&lt;10000<em>v</em>&lt;10000），p表示该物品的重要度（1−51−5），q<em>q</em>表示该物品是主件还是附件。如果q=0<em>q</em>=0，表示该物品为主件，如果q&gt;0<em>q</em>&gt;0，表示该物品为附件，q<em>q</em>是所属主件的编号）</p><p>输出格式：</p><p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大（&lt;200000&lt;200000）。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure><p>解析：因为这道题每个主件可以有0， 1， 2个附件，因此有两种解决方案：</p><p>方案一：我们把有从属关系的一个或多个物品当作一类物品，若只有主件，那么共有2种组合方案（0，主件）。若有一个附件，那么有4种组合方案（0，主件，附件，主见附件），若有两个附件，那么有8种组合方案。我们只要把全部组合方案的价格，重要程度列出来，然后用分组背包的思维就可以做了。</p><p>方案二：因为附件数少，因此我们可以用求全部方案数将其转化为分组背包。若附件多怎么办呢？这时，我们可以设置<code>dp[i][j]</code>代表第i类商品总价不超过j元的最大价值（有所属关系的归位一种），然后每次copy<code>dp[i-1]</code>数组，并对主件商品强制购买，附件商品进行01背包。最后和原<code>dp[i - 1]</code>数组每位比较取较大值，即为<code>dp[i]</code>数组，最后<code>dp[商品种类][最大钱数]</code>即为答案</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;zcy[65];</span><br><span class="line">map&lt;int, int&gt;maps;</span><br><span class="line"></span><br><span class="line">int v[65], w[65];</span><br><span class="line">int dp[32050] = &#123;0&#125;, temp[32050] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int V, m, tot = 0, father;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;V, &amp;m);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v[i], &amp;w[i], &amp;father);</span><br><span class="line">        if (father == 0) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            maps[i] = tot;</span><br><span class="line">            zcy[tot].push_back(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            zcy[maps[father]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">        memcpy(temp, dp, sizeof(int) * (V + 5));</span><br><span class="line">        int vv = v[zcy[i][0]];</span><br><span class="line">        int ww = w[zcy[i][0]] * vv;</span><br><span class="line">        for (int j = V; j &gt;= vv; j--) &#123;</span><br><span class="line">            temp[j] = temp[j - vv] + ww;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">            int vvv = v[zcy[i][j]];</span><br><span class="line">            int www = w[zcy[i][j]] * vvv;</span><br><span class="line">            for (int p = V; p &gt;= vv + vvv; p--) &#123;</span><br><span class="line">                temp[p] = max(temp[p - vvv] + www, temp[p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[V]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 特殊背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1858多人背包</title>
      <link href="/2019/01/25/%E6%B4%9B%E8%B0%B71858%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85/"/>
      <url>/2019/01/25/%E6%B4%9B%E8%B0%B71858%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/25/洛谷1858多人背包/title1.jpg" alt="title1"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求01背包前k优解的价值和</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行三个数K、V、N</p><p>接下来每行两个数，表示体积和价值</p><p>输出格式：</p><p>前k优解的价值和</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 10 5</span><br><span class="line">3 12</span><br><span class="line">7 20</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">57</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于100%的数据,K≤50,V≤5000,N≤200</p><p>思路：</p><p>​    这道题本身不算特别难，设置一个二维数组<code>dp[i][j]</code>代表背包容量为i的时候第j优解的价值。V的范围是5000，N的范围是200，如果按照01背包求最优解的话时间复杂度为1e6</p><p>​    可是由于是求第k优，k的范围为1～50，因此我们得在1e6的循环中，用O(k)的复杂度求出前k优，这时候，我们就需要用到归并排序取前50大</p><p>​    这道题太毒瘤了，条件里也没交代说必须正好装满V。。。结果最后答案必须是正好装满V的答案。。。</p><p>​    答案见代码：</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[5005][55] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int K, V, N, v, w;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;K, &amp;V, &amp;N);</span><br><span class="line">    dp[0][0] = 1;//正好装满初始化dp[0][0] = 1, 若是类似01背包可以不必装满的话，就是初始化dp[i][0] = 1 (0 &lt;= i &lt;= V)</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;v, &amp;w);</span><br><span class="line">        for (int j = V; j &gt;= v; j--) &#123;</span><br><span class="line">            int p1 = 1, p2 = 1;</span><br><span class="line">            int c[55] = &#123;0&#125;;</span><br><span class="line">            while(p1 &lt;= dp[j][0] || p2 &lt;= dp[j - v][0]) &#123;</span><br><span class="line">                if (p2 &gt; dp[j - v][0] || (p2 &lt;= dp[j - v][0] &amp;&amp; p1 &lt;= dp[j][0] &amp;&amp; dp[j][p1] &gt;= dp[j - v][p2] + w)) &#123;</span><br><span class="line">                    c[++c[0]] = dp[j][p1];</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c[++c[0]] = dp[j - v][p2] + w;</span><br><span class="line">                    p2++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (c[0] &gt;= K) break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int ppp = 0; ppp &lt;= c[0]; ppp++) &#123;</span><br><span class="line">                dp[j][ppp] = c[ppp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= K; i++) </span><br><span class="line">        ans += dp[V][i];</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包第k优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1541乌龟棋</title>
      <link href="/2019/01/25/%E6%B4%9B%E8%B0%B71541%E4%B9%8C%E9%BE%9F%E6%A3%8B/"/>
      <url>/2019/01/25/%E6%B4%9B%E8%B0%B71541%E4%B9%8C%E9%BE%9F%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/25/洛谷1541乌龟棋/title2.jpg" alt="title2"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>乌龟棋的棋盘是一行N<em>N</em>个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N<em>N</em>格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p><p>乌龟棋中M<em>M</em>张爬行卡片，分成4种不同的类型（M<em>M</em>张卡片中不一定包含所有44种类型的卡片，见样例），每种类型的卡片上分别标有1,2,3,41,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p><p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p><p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p><p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>每行中两个数之间用一个空格隔开。</p><p>第11行22个正整数N,M<em>N</em>,<em>M</em>，分别表示棋盘格子数和爬行卡片数。</p><p>第22行N<em>N</em>个非负整数，a1,a2,…,aN<em>a</em>1,<em>a</em>2,…,<em>a**N</em>，其中ai<em>a**i</em>表示棋盘第i<em>i</em>个格子上的分数。</p><p>第33行M<em>M</em>个整数，b1,b2,…,bM<em>b</em>1,<em>b</em>2,…,<em>b**M</em>，表示M张爬行卡片上的数字。</p><p>输入数据保证到达终点时刚好用光M<em>M</em>张爬行卡片。</p><p>输出格式：</p><p>11个整数，表示小明最多能得到的分数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 5</span><br><span class="line">6 10 14 2 8 8 18 5 17</span><br><span class="line">1 3 1 2 1</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">73</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    刚开始我是设的<code>dp[i][j][p][q][k]</code>代表第一种卡片i个，第二种卡片j个，第三种卡片p个，第四种卡片q个，走到第k个格子的最大得分。后来发现，我既然得到ijpq了，肯定k是固定的。。。然后就灰溜溜的缩减为了四维dp</p><p>​    我们设了<code>dp[i][j][p][q]</code>后，由于题目上说正好把M张卡片用完，因此我们只需要用一个数组c存每种卡片的张数，那么<code>dp[c[1]][c[2]][c[3]][c[4]]</code>极为答案</p><p>​    这个题有个坑点，就是起始位置是1而不是0，自己在这里傻逼了好久～</p><p>​    废话不说，上代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[355];</span><br><span class="line">int c[5] = &#123;0&#125;;</span><br><span class="line">int dp[125][125][125][125] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;b);</span><br><span class="line">        c[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][0][0][0] = a[1];</span><br><span class="line">    for (int i = 0; i &lt;= c[1]; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= c[2]; j++) &#123;</span><br><span class="line">            for (int p = 0; p &lt;= c[3]; p++) &#123;</span><br><span class="line">                for (int q = 0; q &lt;= c[4]; q++) &#123;</span><br><span class="line">                    if (i != 0) dp[i][j][p][q] = max(dp[i - 1][j][p][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                    if (j != 0) dp[i][j][p][q] = max(dp[i][j - 1][p][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                    if (p != 0) dp[i][j][p][q] = max(dp[i][j][p - 1][q] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                    if (q != 0) dp[i][j][p][q] = max(dp[i][j][p][q - 1] + a[i + j * 2 + p * 3 + q * 4 + 1], dp[i][j][p][q]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[c[1]][c[2]][c[3]][c[4]]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1158导弹拦截</title>
      <link href="/2019/01/25/%E6%B4%9B%E8%B0%B7P1158%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/"/>
      <url>/2019/01/25/%E6%B4%9B%E8%B0%B7P1158%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/25/洛谷P1158导弹拦截/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>经过 11年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 0时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。</p><p>某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行包含 4个整数x1、y1、x2、y2，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为(x1,y1)、(x2,y2)。 第二行包含1个整数N，表示有 N颗导弹。接下来N行，每行两个整数 x,y，中间用 一个空格隔开，表示一颗导弹的坐标(x,y)。不同导弹的坐标可能相同。</p><p>输出格式：</p><p>一个整数，即当天的最小使用代价。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 10 0</span><br><span class="line">2</span><br><span class="line">-3 3</span><br><span class="line">10 0</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><p>输入样例#2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 6 0</span><br><span class="line">5</span><br><span class="line">-4 -2</span><br><span class="line">-2 3</span><br><span class="line">4 0</span><br><span class="line">6 -2</span><br><span class="line">9 1</span><br></pre></td></tr></table></figure><p>输出样例#2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p>【数据范围】</p><p>对于10%的数据，N=1</p><p>对于20%的数据，1≤N≤2</p><p>对于40%的数据，1≤N≤100</p><p>对于70%的数据，1≤N≤1000</p><p>对于100%的数据，1≤N≤100000，且所有坐标分量的绝对值都不超过1000。</p><p>题解：</p><p>​    这道题百分之百的数据范围N为1e5，那么说明题目所需的复杂度最大为NlogN，我们可以把所有导弹对第一个拦截系统的距离进行由大到小排序（复杂度为NlogN）</p><p>​    由于已经是按照对第一个拦截系统的距离进行由大到小排序了，我们假设从<code>[i, n]</code>的导弹由第一个拦截，那么第一个拦截系统的最小半径为第i个对于第一个拦截系统 的距离，那么剩下的<code>[1, i - 1]</code>由第二个拦截系统拦截，我们可以在遍历的时候记录一下前i个对于第二个拦截系统的距离的最大值，这样我们只需要求<code>flag + daodan[i].d1</code>的最小值即为正确答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">    &gt; File Name: p.cpp</span><br><span class="line">    &gt; Author: Zcy</span><br><span class="line">    &gt; Mail: 296763002@qq.com</span><br><span class="line">    &gt; Created Time: 三  1/23 18:16:17 2019</span><br><span class="line"> ************************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    int j1, j2;</span><br><span class="line">    void set(int x1, int y1, int x2, int y2) &#123;</span><br><span class="line">        j1 = (x - x1) * (x - x1) + (y - y1) * (y - y1);</span><br><span class="line">        j2 = (x - x2) * (x - x2) + (y - y2) * (y - y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;point[100005];</span><br><span class="line"></span><br><span class="line">bool zcy(node A, node B) &#123;</span><br><span class="line">    return A.j1 &gt; B.j1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int x1, y1, x2, y2, n;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">        point[i].set(x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(point, point + n, zcy);</span><br><span class="line">    int ans = 0x3f3f3f3f;</span><br><span class="line">    int k = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ans = min(ans, point[i].j1 + k);</span><br><span class="line">        k = max(point[i].j2, k);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = min(ans, k);</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1028数的计算</title>
      <link href="/2019/01/23/%E6%B4%9B%E8%B0%B71028%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/01/23/%E6%B4%9B%E8%B0%B71028%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/23/洛谷1028数的计算/title.jpg" alt="title"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们要求找出具有下列性质数的个数(包含输入的自然数n<em>n</em>):</p><p>先输入一个自然数n<em>n</em>(n≤1000<em>n</em>≤1000),然后对此自然数按照如下方法进行处理:</p><ol><li>不作任何处理;</li><li>在它的左边加上一个自然数,但该自然数不能超过原数的一半;</li><li>加上数后,继续按此规则进行处理,直到不能再加自然数为止.</li></ol><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>11个自然数n<em>n</em>(n≤1000<em>n</em>≤1000)</p><p>输出格式：</p><p>11个整数，表示具有该性质数的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>满足条件的数为6，16，26，126，36，136</p><p>思路：</p><p>​    做这个题主要是想用优化的思想来做，这道题我们可以用三层for，两层for，一层for来AC。我把我想到的这三种都说一下，主要是给大家提供更多的思路，毕竟解题的道路是灵活的～</p><p>三层 for：</p><p>​    我们可以设<code>dp[i][j]</code>代表从左边数第i个整数为j的方案数，那么我们就可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化dp[1][j] = 1; (1 &lt;= j &lt;= n)</span><br><span class="line">for (int i = 1; quick(2, i) &lt;= n; i++) &#123;//quick(2, i)为2^i</span><br><span class="line">    int j = quick(2, i);</span><br><span class="line">    for (; j &lt;= n; j++) &#123;</span><br><span class="line">        for (int k = 1; k &lt;= j / 2; k++) &#123;</span><br><span class="line">            dp[i + 1][j] += dp[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这样全部满足条件的dp[i][n]的和即为答案</span><br></pre></td></tr></table></figure><p>两层for：</p><p>​    我们可以设<code>dp[i]</code>代表最右边为数字i有多少种方案，则:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[1] = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">    for (int j = 1; j &lt;= i / 2; j++) &#123;</span><br><span class="line">        dp[i] += dp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//dp[n]即为答案</span><br></pre></td></tr></table></figure><p>一层for：</p><p>​    和上面一样，我们设置<code>dp[i]</code>代表最右边为数字i有多少种方案，并用变量sum来记录和，则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[1] = 1;</span><br><span class="line">sum = 0;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = 1;</span><br><span class="line">    if (!(i &amp; 1)) s += dp[i / 2];</span><br><span class="line">    dp[i] += s;</span><br><span class="line">&#125;</span><br><span class="line">//dp[n]即为答案</span><br></pre></td></tr></table></figure><p>​    大概就是这样，Over</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++简易实现Linux命令-待完善</title>
      <link href="/2019/01/21/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Linux%E5%91%BD%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84/"/>
      <url>/2019/01/21/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Linux%E5%91%BD%E4%BB%A4-%E5%BE%85%E5%AE%8C%E5%96%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/简易实现Linux命令-待完善/title7.jpg" alt="title7"></p><a id="more"></a><p>​    两天前老师布置了一个作业，让用C++简易实现linux的ls（包括ls -l，ls -a等）和cd命令，感觉效果不错，挂到了Github上，有时间再继续完善完善其它功能吧～</p><p>​    Github地址：<a href="https://github.com/ivan-zcy/shell" target="_blank" rel="noopener">跳转</a></p><p>​    当然也可以通过主页 -&gt; 项目进行查看：<a href="http://www.ivan-zcy.top/project/">跳转</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简单用法(一)</title>
      <link href="/2019/01/21/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%80/"/>
      <url>/2019/01/21/Git%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/Git简单用法-一/title9.jpg" alt="title9"></p><a id="more"></a><p>[TOC]</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>​    输入下面命令查看git是否已经安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure><p>​    若没有安装，则输入下面命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git -y</span><br><span class="line"></span><br><span class="line">#如果是Mac用户，则：</span><br><span class="line">$ brew install git</span><br><span class="line"></span><br><span class="line">#brew和apt-get都可以看作软件管理工具，Liunx下用apt-get，Mac下用brew，若没有它就先下它</span><br></pre></td></tr></table></figure><h3 id="2-配置用户名与邮箱"><a href="#2-配置用户名与邮箱" class="headerlink" title="2.配置用户名与邮箱"></a>2.配置用户名与邮箱</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##若想设置为全局生效，就添加--global参数</span><br><span class="line">$ git config --global user.name&quot;用户名&quot;</span><br><span class="line">$ git config --global user.email &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure><h3 id="3-基本流程"><a href="#3-基本流程" class="headerlink" title="3.基本流程"></a>3.基本流程</h3><ol><li>初始化新的仓库或远程Clone仓库</li><li>创建或修改文件</li><li>使用<code>git add</code>命令将修改后的文件添加到本地缓存（索引库）</li><li>使用<code>git commit</code>命令提交改动到本地代码库</li><li>使用<code>git push</code>命令推送到远程仓库</li></ol><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><h4 id="4-1克隆远程仓库到本地或者在本地初始化仓库"><a href="#4-1克隆远程仓库到本地或者在本地初始化仓库" class="headerlink" title="4.1克隆远程仓库到本地或者在本地初始化仓库"></a>4.1克隆远程仓库到本地或者在本地初始化仓库</h4><h5 id="4-1-1克隆远程仓库到本地-前提条件是本地已与远程仓库SSH关联"><a href="#4-1-1克隆远程仓库到本地-前提条件是本地已与远程仓库SSH关联" class="headerlink" title="4.1.1克隆远程仓库到本地(前提条件是本地已与远程仓库SSH关联)"></a>4.1.1克隆远程仓库到本地(前提条件是本地已与远程仓库SSH关联)</h5><p>​    在自己远程仓库中（比如自己的Github仓库）点击clone or download，选择Use SSH，然后复制链接。</p><p>​    然后在本地中输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 存储的路径</span><br><span class="line">$ git clone 之前复制的链接</span><br></pre></td></tr></table></figure><h5 id="4-1-2克隆远程仓库到未关联SSH的主机"><a href="#4-1-2克隆远程仓库到未关联SSH的主机" class="headerlink" title="4.1.2克隆远程仓库到未关联SSH的主机"></a>4.1.2克隆远程仓库到未关联SSH的主机</h5><p>​    在远程仓库中点击clone or download，选择Use HTTPS，然后复制链接。</p><p>​    然后在本地中输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 存储的路径</span><br><span class="line">$ git clone 之前复制的链接</span><br></pre></td></tr></table></figure><h5 id="4-1-3本地初始化新仓库"><a href="#4-1-3本地初始化新仓库" class="headerlink" title="4.1.3本地初始化新仓库"></a>4.1.3本地初始化新仓库</h5><p>​    创建代码目录并初始化， 通过<code>git init</code>命令进行初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 想要放置的位置</span><br><span class="line">$ mkdir project</span><br><span class="line">$ cd project</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>​    对于三者的区别，前两者已经同远程仓库建立连接，第一个从本地向远程仓库push更新的时候不用账号密码，第二个需账号密码。而第三个没有同远程仓库建立连接</p><h4 id="4-2查看"><a href="#4-2查看" class="headerlink" title="4.2查看"></a>4.2查看</h4><h5 id="4-2-1本地git仓库状态"><a href="#4-2-1本地git仓库状态" class="headerlink" title="4.2.1本地git仓库状态"></a>4.2.1本地git仓库状态</h5><p>​    利用<code>git status</code>命令查看当前本地仓库的状态信息</p><h5 id="4-2-2比较改动前后文件的区别"><a href="#4-2-2比较改动前后文件的区别" class="headerlink" title="4.2.2比较改动前后文件的区别"></a>4.2.2比较改动前后文件的区别</h5><p>​    利用<code>git status</code>只能查看本地仓库的状态信息，比如某个文件以被改动，新增或者删除了某个文件等等。但如果想获取修改了某个文件的具体内容，需要通过<code>git diff</code>命令来查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff//会显示当前你所有已做的但没有加入到索引里的修改</span><br><span class="line">git diff --cached //显示缓存区中哪些文件被修改了</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="4-3添加文件到索引库"><a href="#4-3添加文件到索引库" class="headerlink" title="4.3添加文件到索引库"></a>4.3添加文件到索引库</h4><p>以下操作都需要在克隆到本地的仓库目录下进行：</p><h5 id="4-3-1添加-修改"><a href="#4-3-1添加-修改" class="headerlink" title="4.3.1添加/修改"></a>4.3.1添加/修改</h5><p>​    把一个文件添加或更新内容到本地索引，可以使用<code>git add</code>命令</p><p>​    例如创建一个新的txt文件，并往文件内写入“hello world”，并用<code>git add</code>命令添加到本地索引库中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hello world&quot; &gt; newfile.txt</span><br><span class="line">$ git add newfile.txt</span><br></pre></td></tr></table></figure><p>​    可利用<code>$ git add *</code>命令将全部修改过的文件自动添加</p><h5 id="4-3-2删除"><a href="#4-3-2删除" class="headerlink" title="4.3.2删除"></a>4.3.2删除</h5><p>​    把仓库里的文件删掉，可以使用<code>git rm</code>命令</p><p>​    例如删除新创建的newfile.txt文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm newfile.txt</span><br></pre></td></tr></table></figure><p>​    对于删除文件，需要<code>git commit</code>一下，版本库中文件才可以完全被删除</p><h5 id="4-3-3撤销"><a href="#4-3-3撤销" class="headerlink" title="4.3.3撤销"></a>4.3.3撤销</h5><p>​    把仓库里的改动撤销回到刚克隆下来的状态，可以使用<code>git reset</code>命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#git reset命令有三种方式</span><br><span class="line"></span><br><span class="line">$ git reset -mixed  #git reset默认方式，退回到某个版本，只保留源码，回退commit和index信息</span><br><span class="line">$ git reset -soft #回退到某个版本，只回退commit信息。如果还要提交，直接commit即可</span><br><span class="line">$ git reset -hard#彻底退回某个版本，本地的源码也会变为上一个版本的内容</span><br><span class="line"></span><br><span class="line">#用法为：</span><br><span class="line">#回退所有内容到上一个版本 </span><br><span class="line">$ git reset HEAD^</span><br><span class="line">#回退newfile.txt这个文件的版本到上一个版本 </span><br><span class="line">$ git reset HEAD^ a.py</span><br><span class="line">#向前回退所有内容到第3个版本 </span><br><span class="line">$ git reset HEAD~3</span><br><span class="line">#回退到某个版本 </span><br><span class="line">git reset 版本名</span><br></pre></td></tr></table></figure><h4 id="4-4提交仓库的改动"><a href="#4-4提交仓库的改动" class="headerlink" title="4.4提交仓库的改动"></a>4.4提交仓库的改动</h4><p>​    仓库的每次改动操作后，推送同步到远程仓库前，都需要对这一次或这一批次的操作做提交，命令为<code>git commit</code>，只有完成提交，才可以推送改动到远程仓库</p><p>​    例如提交本次改动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;我的注释&quot;</span><br></pre></td></tr></table></figure><p>​    如果加上-a，则无需add便可以直接 commit所有的更新</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a -m &quot;我的注释&quot;</span><br></pre></td></tr></table></figure><h4 id="4-5推送到远程仓库"><a href="#4-5推送到远程仓库" class="headerlink" title="4.5推送到远程仓库"></a>4.5推送到远程仓库</h4><p>​    提交仓库改动后就可以开始推送改动的内容到远程仓库了，命令为<code>git push</code>，用法是<code>git push -u origin 分支名</code>，其中分支名默认为master。第一次推送可以使用-u参数（会绑定此时的仓库分支名，这样下次推送就无需加分支名了）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="4-6当远程仓库被修改，如何同步到本地"><a href="#4-6当远程仓库被修改，如何同步到本地" class="headerlink" title="4.6当远程仓库被修改，如何同步到本地"></a>4.6当远程仓库被修改，如何同步到本地</h4><h5 id="4-6-1查看仓库改动"><a href="#4-6-1查看仓库改动" class="headerlink" title="4.6.1查看仓库改动"></a>4.6.1查看仓库改动</h5><p>通过<code>git fetch</code>命令查看有哪些新改动，用法为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure><h5 id="4-6-2同步到本地"><a href="#4-6-2同步到本地" class="headerlink" title="4.6.2同步到本地"></a>4.6.2同步到本地</h5><p>通过<code>git pull</code>命令实现同步到本地，具体用法是<code>git pull origin 分支名</code>，分支名默认为master</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现SSH免密登陆</title>
      <link href="/2019/01/21/%E5%AE%9E%E7%8E%B0ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/"/>
      <url>/2019/01/21/%E5%AE%9E%E7%8E%B0ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/21/实现ssh免密登陆/title6.jpg" alt="title6"></p><a id="more"></a><p>####SSH是什么？</p><p>​    SSH是建立在应用层基础上的安全协议，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。</p><p>​    当数据到达目的地时，SSH自动对加密数据进行解密。整个过程都是透明的，使用OpenSSH工具将会增进系统的安全性</p><p>​    除此之外，SSH传输的数据是经过压缩的，所以可以加快传输的速度。SSH还有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的通道。</p><p>####SSH连接的原理</p><p>​    假设A主机想要连接到B主机：</p><ol><li>A主机向B主机发送连接请求</li><li>B主机向A主机发送公钥</li><li>A主机用公钥将密码信息加密并发送给B</li><li>B主机用私钥解密并验证密码信息，信息合法就建立连接</li></ol><h4 id="免密登录的原理"><a href="#免密登录的原理" class="headerlink" title="免密登录的原理"></a>免密登录的原理</h4><p>​    由于上面的方式A主机必须得输入密码信息发送进行验证，也就是说我们每次进行连接都得需要输入密码，超级麻烦～</p><p>​    因此，我们就可以通过免密登录来实现无密码进行链接。</p><p>​    至于实现的原理是什么？假设A主机想要免密连接到B主机：</p><ol><li>在A主机上生成公钥私钥</li><li><p>将A中的公钥拷贝给到B主机中的authorized_keys（也就相当于把A加入到B的白名单中）</p></li><li><p>A向B发送连接请求</p></li><li>B得到请求后，在authorized_key中查找是否有对应用户名和IP。如果有则随机生成一个字符串并用A的公钥进行加密并发送给A</li><li>A得到B发来的消息后用私钥进行解密，然后将解密后的字符串发送回B。B进行对比，若一致则允许免密登录</li></ol><p>####如何实现免密登录</p><h5 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h5><p>​    A主机若已经生成了公钥私钥，则跳过此步（因此一个主机在同一时间下只能拥有一对公钥私钥，再次随机生成会覆盖掉之前的公钥私钥，但不建议这么做，因为可能在其它主机上存储了A主机之前的公钥，如果A主机再次生成公钥私钥的话会导致之前做过免密登录的主机失效）</p><p>​    若无公钥私钥，则A主机通过<code>$ ssh-keygen -t rsa -P</code> 就可以在家目录下的.ssh文件夹中生成id_rsa(私钥)和id_rsa.pub(公钥)两个文件</p><h5 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h5><p>​    把A中的id_rsa.pub(也就是公钥)中的内容追加到B主机中家目录下的.ssh/authorized_keys中（若B主机没有该路径和文件则先创建），这样就实现了加入白名单</p><p>​    这样，已有A向B发起连接就可以无需输入密码了～</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是佩奇源码</title>
      <link href="/2019/01/20/%E5%95%A5%E6%98%AF%E4%BD%A9%E5%A5%87%E6%BA%90%E7%A0%81/"/>
      <url>/2019/01/20/%E5%95%A5%E6%98%AF%E4%BD%A9%E5%A5%87%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/啥是佩奇源码/title.jpg" alt="title"></p><a id="more"></a><p>​    感谢GIthub上提供的源码，地址：<a href="https://github.com/Monster12138/-" target="_blank" rel="noopener">跳转</a></p><p>​    大家熟悉了Python内置的turtle后可以随意DIY，超棒的Python内置绘制图形库！！</p><p>源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from turtle import*</span><br><span class="line"></span><br><span class="line">def nose(x,y):#鼻子</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-30)</span><br><span class="line">    begin_fill()</span><br><span class="line">    a=0.4</span><br><span class="line">    for i in range(120):</span><br><span class="line">        if 0&lt;=i&lt;30 or 60&lt;=i&lt;90:</span><br><span class="line">            a=a+0.08</span><br><span class="line">            lt(3) #向左转3度</span><br><span class="line">            fd(a) #向前走a的步长</span><br><span class="line">        else:</span><br><span class="line">            a=a-0.08</span><br><span class="line">            lt(3)</span><br><span class="line">            fd(a)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(25)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(10)</span><br><span class="line">    pd()</span><br><span class="line">    pencolor(255,155,192)</span><br><span class="line">    seth(10)</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(5)</span><br><span class="line">    color(160,82,45)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(20)</span><br><span class="line">    pd()</span><br><span class="line">    pencolor(255,155,192)</span><br><span class="line">    seth(10)</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(5)</span><br><span class="line">    color(160,82,45)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def head(x,y):#头</span><br><span class="line">    color((255,155,192),&quot;pink&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    seth(0)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(180)</span><br><span class="line">    circle(300,-30)</span><br><span class="line">    circle(100,-60)</span><br><span class="line">    circle(80,-100)</span><br><span class="line">    circle(150,-20)</span><br><span class="line">    circle(60,-95)</span><br><span class="line">    seth(161)</span><br><span class="line">    circle(-300,15)</span><br><span class="line">    pu()</span><br><span class="line">    goto(-100,100)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-30)</span><br><span class="line">    a=0.4</span><br><span class="line">    for i in range(60):</span><br><span class="line">        if 0&lt;=i&lt;30 or 60&lt;=i&lt;90:</span><br><span class="line">            a=a+0.08</span><br><span class="line">            lt(3) #向左转3度</span><br><span class="line">            fd(a) #向前走a的步长</span><br><span class="line">        else:</span><br><span class="line">            a=a-0.08</span><br><span class="line">            lt(3)</span><br><span class="line">            fd(a)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ears(x,y): #耳朵</span><br><span class="line">    color((255,155,192),&quot;pink&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(100)</span><br><span class="line">    circle(-50,50)</span><br><span class="line">    circle(-10,120)</span><br><span class="line">    circle(-50,54)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(-12)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(30)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(100)</span><br><span class="line">    circle(-50,50)</span><br><span class="line">    circle(-10,120)</span><br><span class="line">    circle(-50,56)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def eyes(x,y):#眼睛</span><br><span class="line">    color((255,155,192),&quot;white&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(-20)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(-95)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(15)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(12)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(-3)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(3)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    color((255,155,192),&quot;white&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(-25)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(40)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(15)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(12)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(-3)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(3)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def cheek(x,y):#腮</span><br><span class="line">    color((255,155,192))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(0)</span><br><span class="line">    begin_fill()</span><br><span class="line">    circle(30)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def mouth(x,y): #嘴</span><br><span class="line">    color(239,69,19)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-80)</span><br><span class="line">    circle(30,40)</span><br><span class="line">    circle(40,80)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def body(x,y):#身体</span><br><span class="line">    color(&quot;red&quot;,(255,99,71))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    begin_fill()</span><br><span class="line">    seth(-130)</span><br><span class="line">    circle(100,10)</span><br><span class="line">    circle(300,30)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(230)</span><br><span class="line">    seth(90)</span><br><span class="line">    circle(300,30)</span><br><span class="line">    circle(100,3)</span><br><span class="line">    color((255,155,192),(255,100,100))</span><br><span class="line">    seth(-135)</span><br><span class="line">    circle(-80,63)</span><br><span class="line">    circle(-150,24)</span><br><span class="line">    end_fill()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hands(x,y):#手</span><br><span class="line">    color((255,155,192))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-160)</span><br><span class="line">    circle(300,15)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(15)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(0)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-10)</span><br><span class="line">    circle(-20,90)</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(30)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(237)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-20)</span><br><span class="line">    circle(-300,15)</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(20)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(0)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-170)</span><br><span class="line">    circle(20,90)</span><br><span class="line"></span><br><span class="line">def foot(x,y):#脚</span><br><span class="line">    pensize(10)</span><br><span class="line">    color((240,128,128))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-90)</span><br><span class="line">    fd(40)</span><br><span class="line">    seth(-180)</span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pensize(15)</span><br><span class="line">    fd(20)</span><br><span class="line"></span><br><span class="line">    pensize(10)</span><br><span class="line">    color((240,128,128))</span><br><span class="line">    pu()</span><br><span class="line">    seth(90)</span><br><span class="line">    fd(40)</span><br><span class="line">    seth(0)</span><br><span class="line">    fd(90)</span><br><span class="line">    pd()</span><br><span class="line">    seth(-90)</span><br><span class="line">    fd(40)</span><br><span class="line">    seth(-180)</span><br><span class="line">    color(&quot;black&quot;)</span><br><span class="line">    pensize(15)</span><br><span class="line">    fd(20)</span><br><span class="line"></span><br><span class="line">def tail(x,y):#尾巴</span><br><span class="line">    pensize(4)</span><br><span class="line">    color((255,155,192))</span><br><span class="line">    pu()</span><br><span class="line">    goto(x,y)</span><br><span class="line">    pd()</span><br><span class="line">    seth(0)</span><br><span class="line">    circle(70,20)</span><br><span class="line">    circle(10,330)</span><br><span class="line">    circle(70,30)</span><br><span class="line"></span><br><span class="line">def zcy(x, y):</span><br><span class="line">    pu()</span><br><span class="line">    goto(x, y)</span><br><span class="line">    pendown()</span><br><span class="line">    setheading(0)</span><br><span class="line">    forward(20)</span><br><span class="line">    right(135)</span><br><span class="line">    forward(80)</span><br><span class="line">    left(135)</span><br><span class="line">    forward(55)</span><br><span class="line"></span><br><span class="line">    pu()</span><br><span class="line">    goto(x + 65, y - 22)</span><br><span class="line">    pendown()</span><br><span class="line">    seth(120)</span><br><span class="line">    a = 0.5</span><br><span class="line">    for i in range(40):</span><br><span class="line">        a = a + 0.07</span><br><span class="line">        if i &gt;= 37:</span><br><span class="line">            lt(20)</span><br><span class="line">        elif i &gt;= 30:</span><br><span class="line">            lt(7)</span><br><span class="line">        else:</span><br><span class="line">            lt(6)</span><br><span class="line">        fd(a)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x + 90, y - 22)</span><br><span class="line">    pendown()</span><br><span class="line">    seth(-65)</span><br><span class="line">    forward(38)</span><br><span class="line">    pu()</span><br><span class="line">    goto(x + 130, y - 22)</span><br><span class="line">    pendown()</span><br><span class="line">    seth(235)</span><br><span class="line">    forward(100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def setting():          #参数设置</span><br><span class="line">    pensize(4)</span><br><span class="line">    hideturtle()</span><br><span class="line">    colormode(255)</span><br><span class="line">    color((255,155,192),&quot;pink&quot;)</span><br><span class="line">    setup(840,500)</span><br><span class="line">    speed(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    setting()           #画布、画笔设置</span><br><span class="line">    nose(-100,100)      #鼻子</span><br><span class="line">    head(-69,167)       #头</span><br><span class="line">    ears(0,160)         #耳朵</span><br><span class="line">    eyes(0,140)         #眼睛</span><br><span class="line">    cheek(80,10)        #腮</span><br><span class="line">    mouth(-20,30)       #嘴</span><br><span class="line">    body(-32,-8)        #身体</span><br><span class="line">    hands(-56,-45)      #手</span><br><span class="line">    foot(2,-177)        #脚</span><br><span class="line">    tail(148,-155)      #尾巴</span><br><span class="line">    #zcy(206, -148)      #牵着尾巴的署名</span><br><span class="line">    done()              #结束</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-6</title>
      <link href="/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-6/"/>
      <url>/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/动态规划优化问题-6/title1.jpg" alt="title1"></p><a id="more"></a><p>例五：矩形问题</p><p>​    在一个n✖️m的黑白相间的矩形中，问有多少个全白色的子矩形（0代表黑色，1代表白）</p><p>​    最暴力的方法就是挨个子矩形都去判断，这样的时间复杂度为O(n^2✖️m^2)，在这里就不说了。</p><p>​    我们可以优化，设<code>dp[i][j]</code>代表以(i, j)为右下角的子矩形的个数，再通过<code>l[i][j]</code>数组记录第i行j列向上有多少个连续的白矩形。这样就可以把题目优化到O(n✖️m^2)，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">    minn = l[i][j];</span><br><span class="line">        for (int k = j; k &gt;= 1; k--) &#123;</span><br><span class="line">            minn = min(minn, l[i][k]);</span><br><span class="line">            if (!minn) break;</span><br><span class="line">            ans += minn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    但是如果n和m的取值范围都是1e3怎么办？这时，我们就可以通过转移优化中的单调栈优化来进一步进行优化</p><p>​    我们创建一个单调栈数组<code>sta[i]</code>代表第i行的单调栈。保持单调栈递增，那么就可以将题目优化到O(n✖️m)了，详情请看代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int num=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx, val, sum;</span><br><span class="line">    node(int x, int y, int z) &#123;</span><br><span class="line">        inx = x;</span><br><span class="line">        val = y;</span><br><span class="line">        sum = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stack&lt;node&gt;que[1005];</span><br><span class="line">int l[1005][1005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, a;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            if (a) &#123;</span><br><span class="line">                l[i][j] = l[i - 1][j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!que[i].empty()) &#123;</span><br><span class="line">                if (que[i].top().val &gt;= l[i][j]) &#123;</span><br><span class="line">                    que[i].pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node sta(j, l[i][j], 0);</span><br><span class="line">            if (que[i].empty()) &#123;</span><br><span class="line">                sta.sum = j * l[i][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sta.sum = que[i].top().sum + (j - que[i].top().inx) * l[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            que[i].push(sta);</span><br><span class="line">            ans += sta.sum;</span><br><span class="line">            if (ans &gt;= 100007) &#123;</span><br><span class="line">                ans %= 100007;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-5</title>
      <link href="/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-5/"/>
      <url>/2019/01/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/动态规划优化问题-5/title4.jpg" alt="title4"></p><a id="more"></a><p>例四：扔鸡蛋问题</p><p>​    定义鸡蛋的硬度为 k，则代表鸡蛋最高从 k 楼扔下来不会碎掉，现在给你 n 个硬度相同的鸡蛋，楼高为 m，问最坏情况下最少测多少次，可以测出鸡蛋的硬度。</p><p>​    我们假设有2个鸡蛋，100层楼。那么我们应该如何扔在最坏情况下测的次数最少呢？</p><p>1.二分法：刚开始我傻傻的以为是二分法，第一个鸡蛋在第50层扔，但是如果一个鸡蛋在第50层碎了，那么第二个鸡蛋只能从第1层扔直到第49层，才能测出鸡蛋的硬度（在最坏情况为49层时），这样最坏情况下需要测50次</p><p>2.平方根法：我们继续优化，我们每10层测一次，第10层若碎了，第二个鸡蛋就从1层测到9层。若没碎继续测第20层…以此类推，最坏情况是第99层时，这时我们需要测10 + 9 = 19次</p><p>3.假设法：方法二一定是最优解吗？我们可以假设一下，设2个鸡蛋100层楼在最坏情况下最多测x次，那么第一个鸡蛋应该放在第x层最合适（如果第一个鸡蛋放在是x + i层，如果碎了最坏情况下最多测x + i次，比x次多；如果第一个鸡蛋放在x - i层，如果没碎的话，由于x - i比x小，所以它剩余测的次数一定 &gt;= x）</p><p>​    因此，我们第一次放在x层（碎了话最多测x次，没碎的话第二次放在2 <em> x - 1层，碎的话最多测x次，没碎的话第三次放在3 </em> x - 3层，碎的话最多测x次，没碎的话第四次放在4 * x - 6层…依次类推），我们只要保证x + (x - 1) + (x - 2) … + 1 &gt;= 100即可，这样解出最优答案为14</p><p>​    好了，以上是推理，我们可以用dp的方法来求出正确的答案。我们可以假设<code>dp[i][j]</code>代表i个鸡蛋j层楼最少测多少次。这样我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">dp[1][j] = k (1 &lt;= j &lt;= m)//一个鸡蛋j层楼最坏情况下最少需要测j次</span><br><span class="line">dp[i][1] = 1 (1 &lt;= i &lt;= n)  //i个鸡蛋1层楼最坏情况下最少需要测1次</span><br><span class="line"></span><br><span class="line">这样我们可以得到dp转移式：</span><br><span class="line">dp[i][m] = min(max(dp[i - 1][j - 1], dp[i][m - j]))  (1 &lt;= j &lt;= m)</span><br></pre></td></tr></table></figure><p>​    那么，当n范围为1e2，m范围为1e9的时候，我们怎么办呢？</p><p>​    数组肯定开不下那么大，而且上面算法的时间复杂度为O(n(m^2))，会直接爆掉的。这时我们就可以进行重新定义状态信息来优化算法。</p><p>​    我们可以假设<code>dp[i][j]</code>代表i个鸡蛋测j次最多能测多少层楼。这样我们可以得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//初始化：</span><br><span class="line">dp[1][j] = j//一个鸡蛋测j次最多可以测j层楼</span><br><span class="line">dp[i][1] = 1  //i个鸡蛋测1次最多可以测1层楼</span><br><span class="line"></span><br><span class="line">我们假设第i个鸡蛋测k次最多测n层楼，那么在测n层楼的情况下，第一次需要测的位置应该是i-1个鸡蛋测k - 1次最多测的层数+1(只有满足这个条件，在第m层碎了测的次数最坏情况才为k)</span><br><span class="line">若在第m层没碎，那么往上最多能测的层数应该是i个鸡蛋测k - 1次最多的层数</span><br><span class="line">因此，dp[i][k] = dp[i - 1][k - 1] + dp[i][k - 1] + 1</span><br><span class="line"></span><br><span class="line">我们只要找第一个dp[n][j]大于m的j即是正确答案</span><br></pre></td></tr></table></figure><p>​    最后上AC代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll dp[35][100005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;, m);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 100000; i++) &#123;</span><br><span class="line">            dp[1][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 2; j &lt;= 100000; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= 100000; j++) &#123;</span><br><span class="line">            if (dp[n][j] &gt;= m) &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;, j);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-4</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-4/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-4/title8.jpg" alt="title8"></p><a id="more"></a><p>例三：多重背包</p><p>​    多重背包问题我们经常能碰到，就是给出n种物品，每种物品有<code>a[i]</code>个，占用空间为<code>v[i]</code>，价值为<code>w[i]</code>，背包容量为K，问背包所能装下的物品的最大价值</p><p>方法一：</p><p>​    我们一般的求法就是开一个<code>dp[k]</code>数组代表空间容量为i时的最大价值。然后遍历每种物品的每件，通过递推公式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[k] = max(dp[k], dp[k - v[i]] + w[i]);</span><br></pre></td></tr></table></figure><p>​    这时时间复杂度为<code>O(n * m * K)</code>(其中n为种类数，m为每种物品的数量，K为背包容量)</p><p>​    但是，当m特别大时，我们应该怎么办呢？</p><p>方法二：</p><p>​    我们会发现，每种的物品，它们的<code>v[i]和w[i]</code>是相同的。假如某种物品有15种，我们上面那种方法的做法，由于是遍历该种的每一件物品，因此也就是将{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}任意组合。我们会发现组合会有很多重复，因此我们可以这样进行优化：</p><p>​    对于集合{1, 2, 4, 8}，我们也可以通过这四个数组合成1～15个的任意一个。这样我们只需要求每种物品的n件物品优化成logn种物品，这样时间复杂度就可以优化为<code>O(n * log(m) * K)</code> </p><p>​    注意点！！！！如果一种物品有n件，所选的集合必须只能组成<code>[1, n]</code>，比如13:{1, 2, 4, 6}</p><p>​    这种方法的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[10005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, K, v, w, num;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;K, &amp;n);//K代表背包容量，n代表物品种类数</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;num);//v,w,num分别代表每种物品的体积，价值，数量</span><br><span class="line">        int val = 1;//val为集合所有元素的和，初始化为1</span><br><span class="line">        int j = 1;//j为集合为集合中的元素，初始化为1</span><br><span class="line">        while (val &lt;= num) &#123;</span><br><span class="line">            int vv = v * j;  //此时把j个该种物品看作一个物品进行dp，也就是01背包</span><br><span class="line">            int ww = w * j;</span><br><span class="line">            for (int p = K; p &gt;= vv; p--) &#123;</span><br><span class="line">                dp[p] = max(dp[p], dp[p - vv] + ww);</span><br><span class="line">            &#125;</span><br><span class="line">            j = val + 1;</span><br><span class="line">            val += j;</span><br><span class="line">        &#125;</span><br><span class="line">        val -= j;//该操作保证所求集合确保正好组成[1, num]</span><br><span class="line">        j = num - val;</span><br><span class="line">        if (j &gt; 0) &#123;</span><br><span class="line">            int vv = v * j;</span><br><span class="line">            int ww = w * j;</span><br><span class="line">            for (int p = K; p &gt;= vv; p--) &#123;</span><br><span class="line">                dp[p] = max(dp[p], dp[p - vv] + ww);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[K]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    方法二时间复杂度为<code>O(n * logm * K)</code>，还不可以继续优化呢？答案是可以的，我们可以利用单调队列对多重背包问题进行优化到<code>O(n * K)</code>。大家可以先自己考虑一下如何去做再往下看</p><p>方法三：</p><p>​    方法三看了好多好的题解才搞懂。。只能说自己太笨了Orz～以下是我的理解，希望能对大家有些帮助</p><p>​    我们单拿出一种物品来看，比如体积为5，价值为6，数量为3，再假如K为22。那么我们单拿出全部%5 == 2的容量来看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[2] = dp[2];</span><br><span class="line">dp[7] = max(dp[2], dp[7] - 6) + 6;</span><br><span class="line">dp[12] = max(dp[2], dp[7] - 6, dp[12] - 12) + 12;</span><br><span class="line">dp[17] = max(dp[2], dp[7] - 6, dp[12] - 12, dp[17] - 18) + 18;</span><br><span class="line">dp[22] = max(dp[7] - 6, dp[12] - 12, dp[17] - 18, dp[22] - 24) + 24;</span><br><span class="line"></span><br><span class="line">//这一步没看懂的同学看这里！！</span><br><span class="line">比如dp[22] = max(dp[7] - 6, dp[12] - 12, dp[17] - 18, dp[22] - 24) + 24中，</span><br><span class="line">dp[7] - 6若是最大值，dp[7] - 6 + 24等价于dp[22] = dp[7] + 18，也就是用3个该种物品</span><br><span class="line">dp[12] - 12若是最大值，dp[12] - 12 + 24等价于dp[22] = dp[12] + 12，也就是用2个该种商品</span><br><span class="line">dp[17] - 18若是最大值，dp[17] - 18 + 24等价于dp[22] = dp[17] + 6，也就是用1个该种商品</span><br><span class="line">dp[22] - 24若是最大值，dp[22] - 24 + 24等价于dp[22] = dp[22]，也就是不用该种商品</span><br></pre></td></tr></table></figure><p>​    至于最多选用几个的数量s，它等于s = min(s, K / v)。这样，我们就可以将题目转化为下面的代码形式（伪代码）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (循环遍历每种商品) &#123;</span><br><span class="line">    for (循环遍历全部余数d[0, v)) &#123;</span><br><span class="line">        for (循环遍历K以内全部余数为d的容量k*v+d) &#123;</span><br><span class="line">          for (循环遍历s个上一种物品的状态并更新最大值) &#123;</span><br><span class="line">                </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从伪代码可以看出时间复杂度为<code>O(n * K * s)</code> （第二层和第三层for相乘为K），和上一种方法复杂度差不多甚至在某些情况下还要更高。我们可以用单调队列维护最大值且区间差值小于等于s来优化该算法，此时复杂度为<code>O(n * K)</code></p><p>​    比如说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将dp[2] - 0 * 6加入单调队列并维护最大值，然后用队列最大值 + 0 * 6即为新的dp[2]</span><br><span class="line">将dp[7] - 1 * 6加入单调队列并维护最大值，然后用队列最大值 + 1 * 6即为新的dp[7]</span><br><span class="line">将dp[12] - 2 * 6加入单调队列并维护最大值，然后用队列最大值 + 2 * 6即为新的dp[12]</span><br><span class="line">将dp[17] - 3 * 6加入单调队列并维护最大值，然后用队列最大值 + 3 * 6即为新的dp[17]</span><br><span class="line">将dp[22] - 4 * 6加入单调队列并维护最大值，然后用队列最大值 + 4 * 6即为新的dp[22]</span><br><span class="line"></span><br><span class="line">//注意单调队列的维护需要注意的两点(1.若q[tail] &lt;= val则循环tail--直到满足条件为止 2.若q[tail]与q[head]相差数量大于s则循环head++直到满足条件为止)</span><br></pre></td></tr></table></figure><p>​    下面给出这道题单调队列优化的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//dp[i]存储当前状态下容量为i的最大价值</span><br><span class="line">//q[i]用于模拟优先队列</span><br><span class="line">//inv[i]用于存储优先队列中位置为i的使用该种商品的物品数</span><br><span class="line">int dp[10005] = &#123;0&#125;, inv[10005] = &#123;0&#125;, q[10005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int K, n, v, w, s;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;K, &amp;n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;v, &amp;w, &amp;s);</span><br><span class="line">        s = min(K / v, s);    //代表能用的该种物品的最大数量</span><br><span class="line">        for (int mod = 0; mod &lt; v; mod++) &#123;</span><br><span class="line">            int head = 1, tail = 1; //相当于清空队列</span><br><span class="line">            for (int j = 0; j &lt;= (K - mod) / v; j++) &#123;</span><br><span class="line">                int val = dp[j * v + mod] - j * w;</span><br><span class="line">                while (head &lt; tail &amp;&amp; q[tail - 1] &lt;= val) &#123;</span><br><span class="line">                    tail--;         //该操作保证队列单调</span><br><span class="line">                &#125;</span><br><span class="line">                q[tail] = val;</span><br><span class="line">                inv[tail++] = j;</span><br><span class="line">                while (head &lt; tail &amp;&amp; j - inv[head] &gt; s) &#123;</span><br><span class="line">                    head++;         //该操作用于维护数量上限</span><br><span class="line">                &#125;</span><br><span class="line">                //此时队列的头（即最大值）就是我们需要使用该种商品的数量</span><br><span class="line">                dp[j * v + mod] = max(q[head] + j * w, dp[j * v + mod]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[K]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-3</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-3/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-3/title2.jpg" alt="title2"></p><a id="more"></a><p>例2:切割回文串</p><p>​    给出一个字符串s，对字符串最少切几刀，可以使得切完后的每一段字符串都是回文串（单一字符也是回文串）？</p><p>​    这道题我们首先能想到用区间dp来做，设置<code>dp[i][j]</code>代表字符串区间[i, j]最少切多少刀使得每一段字符串都是回文串，这时我们就可以得到递推方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当[i, j]是回文数的时候，dp[i][j] = 0;</span><br><span class="line">//当[i, j]不是回文数的时候，dp[i][j] = min(dp[i][k] + dp[k + 1][j] + 1) //其中i &lt;= k &lt; j</span><br><span class="line">//而对于[i, j]是否为回文数，需要利用bool数组maps[i][j]来记录和预处理</span><br></pre></td></tr></table></figure><p>​    上面方法的空间复杂度是O(n ^ 2)，时间复杂度是O(n ^ 3)，预处理时间复杂度也为O(n^3)，因此当n为1e5左右时直接爆炸。</p><p>​    和上一篇文章一样。大家先在这里停住，考虑一下如何将上面的思路，缩减为空间复杂度为O(n)，时间复杂度为O(nlogn)再继续往下看</p><p>​    对于空间复杂度。我们需要一个数组<code>maps[i][j]</code>用来记录字符串区间[i, j]是否为回文串，对于这个二维数组，我们可以怎么优化呢？对，把它变为一个动态数组<code>maps[i]</code>，用于存储以i结尾的回文串的起始位置。（由于出题人生成的都是随机数据，所以1e5个字符全是相同的那种极限样例根本不可能出现，出现的概率不亚于天天中大乐透～Orz）</p><p>​    这时，maps数组从O(n ^ 2)优化成了O(k)（k为回文串的个数），我们就需要来考虑预处理回文串的时间复杂度优化问题了。由于极限数据根本不可能出现，因此我们可以通过便利中点i，让起点star和终点endd从i向两边扩，若s[star] != s[endd]时即跳出循环，并把全部符合条件的star加入到<code>maps[endd]</code>中，这样预处理的时间复杂度就为O（nlogn）</p><p>​    考虑完预处理，接下来我们开始考虑dp数组的空间优化和状态转移的时间优化～</p><p>​    dp数组上面方法中是二维的，因此我们需要优化成一维数组。用<code>dp[i]</code>来代表前i个字符串最少切的刀数。</p><p>​    优化成一维数组后，我们紧跟着推出递推方程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[j] + 1;//[j + 1, i]必须是回文字符串</span><br></pre></td></tr></table></figure><p>​    由于数据是随机的，因此满足条件的j不会特别多。由于<code>maps[i]</code>中存了全部满足条件的j，因此dp的时间复杂度大概也为O(nlogn)。</p><p>​    因此，第二种方法总的空间复杂度为O(nlogn)，时间复杂度为O(nlogn)。这样数据范围就能从1e2提升到1e5了</p><p>​    以上就是这道题动态规划优化的全部思维，下面附上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[500005];</span><br><span class="line">int dp[500005] = &#123;0&#125;;</span><br><span class="line">vector &lt;int&gt; zcy[500005];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">    int n = strlen(s + 1);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        zcy[i].push_back(i);</span><br><span class="line">        if (i + 1 &lt;= n &amp;&amp; s[i + 1] == s[i])</span><br><span class="line">            zcy[i + 1].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int p, q;</span><br><span class="line">        for (p = i + 1, q = i - 1; p &lt;= n &amp;&amp; q &gt;= 1; p++, q--) &#123;</span><br><span class="line">            if (s[p] == s[q]) &#123;</span><br><span class="line">                zcy[p].push_back(q);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[i] == s[i + 1]) &#123;</span><br><span class="line">            for (p = i + 2, q = i - 1; p &lt;= n &amp;&amp; q &gt;= 1; p++, q--) &#123;</span><br><span class="line">                if (s[p] == s[q]) &#123;</span><br><span class="line">                    zcy[p].push_back(q);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dp, 0x3f, sizeof(dp));</span><br><span class="line">    dp[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int j = 0; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">            if (zcy[i][j] == 1) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            dp[i] = 0;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; zcy[i].size(); j++) &#123;</span><br><span class="line">            dp[i] = min (dp[i], dp[zcy[i][j] - 1] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-2</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-2/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-2/title3.jpg" alt="title3"></p><a id="more"></a><p>例一：墙壁涂色问题：</p><p>​    共有n面墙壁围成一圈，共有k种颜色，相邻墙壁不能涂同一种颜色，问共有多少种涂色方案？</p><p>​    我们可以想到利用<code>dp[i][j]</code>代表第i面墙涂第j种颜色的方案数，初始化<code>dp[1][1] = 1</code>，利用递推公式<code>dp[i][j] += dp[i - 1][k] (其中k != j)</code>，最后<code>ans += dp[n][k] (其中k != 1)</code>，<code>ans *= k</code> 即为答案</p><p>​    按照上面的思路，我们发现它需要开二维数组，空间复杂度为<code>O(n * k)</code>，时间复杂度也为<code>O(n * k)</code></p><p>​    如果题目中<code>n * k</code>的数据范围超过1e7该怎么办呢？</p><p>​    这时，我们就可以通过重新定义状态以去掉那些冗余项来对其进行优化，大家可以先考虑考虑如何进行优化成时间和空间复杂度均为O(n)再接着往下看～</p><p>​    这时，我们可以设<code>dp[i]</code>代表第i面墙与第一面墙成环的方案数，初始化<code>dp[1] = 1, dp[2] = k - 1, dp[3] = (k - 2) * dp[2]</code> 。</p><p>​    我们可以发现，第i面墙与第一面墙成环，那么需要保证第i面墙与第1面颜色不同，也与第i - 1面墙颜色不同。由于<code>dp[i - 1]</code>代表i - 1面墙成环的方案数，因此i - 1面墙与第一面墙颜色不同，所以当第i - 1面墙与第一面墙颜色不同的情况下，<code>dp[i]</code>有<code>dp[i - 1] * (k - 2)</code>种方案。        </p><p>​    除此之外，第i - 1面墙也可以与第一面墙相同。这时假若第i - 1面墙与第一面墙颜色相同，那么前i - 1面墙的方案数为<code>dp[i - 2]</code>，由于第一面和第i - 1面墙颜色相同，因此在该种情况下第i面墙的方案数为<code>dp[i - 2] * (k - 1)</code>。</p><p>​    这两种情况的总和就是<code>dp[i]</code>的方案总数，即当i &gt; 3时：<code>dp[i] = dp[i - 1] * (k - 2) + dp[i - 2] * (k - 1)</code></p><p>​    最终<code>dp[n] *= k</code>即为答案</p><p>​    给出这道题的解题代码（由于数据范围爆longlong因此用大数）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int dp[1005][2005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">    dp[1][0] = dp[2][0] = dp[3][0] = dp[1][1] = 1;</span><br><span class="line">    dp[2][1] = k - 1;</span><br><span class="line">    dp[3][1]= (k - 2) * dp[2][1];</span><br><span class="line">    if (dp[3][1] &gt;= 10) &#123;</span><br><span class="line">        dp[3][0]++;</span><br><span class="line">        dp[3][2] = dp[3][1] / 10;</span><br><span class="line">        dp[3][1] %= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 4; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0];</span><br><span class="line">        for (int j = 1; j &lt;= dp[i][0]; j++) &#123;</span><br><span class="line">            dp[i][j] = (k - 2) * dp[i - 1][j] + (k - 1) * dp[i - 2][j];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= dp[i][0]; j++) &#123;</span><br><span class="line">            if (dp[i][j] &gt;= 10) &#123;</span><br><span class="line">                dp[i][j + 1] += dp[i][j] / 10;</span><br><span class="line">                dp[i][j] %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int j = dp[i][0] + 1;</span><br><span class="line">        while(dp[i][j]) &#123;</span><br><span class="line">            dp[i][0]++;</span><br><span class="line">            if (dp[i][j] &gt;= 10) &#123;</span><br><span class="line">                dp[i][j + 1] = dp[i][j] / 10;</span><br><span class="line">                dp[i][j] %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= dp[n][0]; i++) &#123;</span><br><span class="line">        dp[n][i] *= k;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= dp[n][0]; i++) &#123;</span><br><span class="line">        if(dp[n][i] &gt;= 10) &#123;</span><br><span class="line">            dp[n][i + 1] += dp[n][i] / 10;</span><br><span class="line">            dp[n][i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[n][dp[n][0] + 1]) dp[n][0]++;</span><br><span class="line">    for (int i = dp[n][0]; i &gt; 0; i--) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划优化问题-1</title>
      <link href="/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-1/"/>
      <url>/2019/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/16/动态规划优化问题-1/title5.jpg" alt="title5"></p><a id="more"></a><p>​    动态规划的题目，有时可能你推出了递推式，但是由于时间复杂度过高，或者dp数组过大，而导致TLE或MLE。这时，我们就需要用到动态规划优化</p><p>​    优化有两种，分别是状态优化和转移优化</p><p>​    状态优化用于优化空间，有两种方法，一是去除冗余的状态，二是重新定义状态。去除冗余状态最简单的例子比如滚动数组求解，重定义状态最简单的例子就是01背包，dp{i}{j}代表第i个物品在空间大小为j的背包下能装的最大价值，我们可以状态优化为dp{i}代表空间大小为i的背包能装下的最大价值。</p><p>​    而转移优化是用来优化时间，有以下四类题：一是最长上升子序列O(nlogn)求法，二是单调（队列/栈）优化，三是斜率优化，四是四边形不等式</p><p>​    这时候我们就可以根据不同的题目要求，选择相应的方式进行求解。</p><p>​    具体对应例题将在本博客的后续进行详细解答～</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言碎碎念</title>
      <link href="/2019/01/11/C%E8%AF%AD%E8%A8%80%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2019/01/11/C%E8%AF%AD%E8%A8%80%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/11/C语言碎碎念/title4.jpg" alt="title4"></p><a id="more"></a><ol><li><p>对于if判断句，一些情况下可以进行如下简写：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (falg) &#123;</span><br><span class="line">printf(&quot;ok\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//可简写成以下格式：</span><br><span class="line">flag &amp;&amp; printf(&quot;ok\n&quot;);</span><br></pre></td></tr></table></figure></li><li><p>结构体的比较与复制：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">&#125;</span><br><span class="line">node temp1[4];</span><br><span class="line">node temp2[105][15];</span><br><span class="line"></span><br><span class="line">//结构体数组比较</span><br><span class="line">memcmp(temp1, temp2[0], sizeof(temp1));//代表temp1从temp[0]开始，temp2从temp2[0][0]开始，比较它们的前sizeof(temp1)个字节</span><br><span class="line"></span><br><span class="line">//再比如：</span><br><span class="line">memcmp(temp1 + 1, temp2[2] + 2, sizeof(node)); //代表temp1[1]和temp2[2][2]进行比较</span><br><span class="line"></span><br><span class="line">//结构体复制：</span><br><span class="line">memcpy(temp1, temp2[0], sizeof(temp1));//代表将temp2的前sizeof(temp1)个字节复制给temp1</span><br></pre></td></tr></table></figure></li><li><p>函数数组与函数指针的使用</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f (int n) &#123;</span><br><span class="line">    return n * (n + 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int g (int n) &#123;</span><br><span class="line">    return n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数数组</span><br><span class="line">int (*Func[2])(int) = &#123;</span><br><span class="line">    f, g</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数指针作参</span><br><span class="line">int k (int (*t)(int), val) &#123;</span><br><span class="line">    return t(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数数组指针作参</span><br><span class="line">void k (int (*p[2])(int), int val) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, p[i](val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">k (Func, 3);//即可实现调用</span><br></pre></td></tr></table></figure></li><li><p>函数和数组的关系</p><p> 函数就相当于一个映射，而数组<code>a[i] = t</code>也相当于一个映射</p><p> 因此，函数是压缩的数组，数组是展开的函数。</p><p> 函数比数组更省空间，数组相当于记录式函数</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网--服务器搭建</title>
      <link href="/2019/01/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/科学上网-服务器搭建/title1.jpg" alt="title1"></p><a id="more"></a><p>​    平时用个百度查东西总是出来一堆广告，这时候就无比怀念谷歌。</p><p>​    这里是电脑版搭建服务器实现科学上网的方法，感谢亦泽的教程！！不光电脑版，对于手机安卓，亦泽大佬努力帮助我们科学上网，学习交流请加群972084185</p><p>​    以下为pdf文件，仅支持电脑浏览</p><div class="row">    <embed src="科学上网.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件体系风格</title>
      <link href="/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/软件体系风格/title6.jpg" alt="title6"></p><a id="more"></a><ol><li><p>管道/过滤器体系结构风格：构件被称为过滤器，负责对数据进行加工；连接件被称为管道，是输入数据流和输出数据流之间的通路。每个过滤器是一个独立的个体元素，各个过滤器互不相关；每个过滤器独立完成自己的任务，不同过滤器之间不需要交互。数据输出的最终结果与各个过滤器的执行顺序无关。</p><p>   优点：简单性、支持复用、系统具有可扩展性和可进化性、系统并发性、便于系统分析</p><p>   缺点：系统处理过程时采用批处理方式；不适合用来设计交互式应用系统；因为没有通用的数据传输标准，导致每个过滤器都要花费时间进行添加和去除因解析输入数据和合成数据产生的标记，降低了系统性能，增加了过滤器设计的复杂性；难以进行错误处理</p><p>   使用实例：传统的编译器</p></li></ol><ol start="2"><li><p>面向对象体系结构风格：充分体现了软件工程的模块化、信息隐藏、抽象和重用原则。在这种风格中，对象是一种被称为管理器的构件，负责保持资源的完整性。在对象与对象之间，通过函数调用和过程调用来进行交互。对象抽象可以使构件之间通过黑盒方式进行操作。该结构支持信息隐藏。利用封装技术使对象结构和实现方法对外透明，并将属性和方法包装在一起由对象统一管理</p><p>   优点：对象向外界隐藏自己的详细信息，改变一个对象不影响其他部分；</p><p>  低耦合高内聚使系统更容易分解既相互作用又相互独立的对象集合</p><p> 继承和封装方法为对象复用提供了技术支持</p><p>缺点：一个对象的标识发生改变，必须修改所有显示调用该对象的程序语句；</p></li></ol><p>​         会因为一个对象的标识发生改变而产生连锁反应</p><ol start="3"><li><p>事件驱动体系结构风格：基本思想是系统对外部的行为表现可以通过它对事件的处理来实现。在这种体系结构中构件不再调用过程，而是声明事件。触发一个事件会引起其他构件的过程调用。</p><p>   优点：事件声明者不需要知道哪些构件会响应事件；提高了软件复用能力；</p></li></ol><p>​         便于系统升级</p><p>  缺点：构件放弃了对计算的控制权，完全由系统决定；存在数据传输问题；</p><ol start="4"><li><p>解释器体系结构风格：主要用于构建虚拟机，弥合程序语义和计算机硬件之间的缝隙。适用于系统和用户之间的交互非常复杂的情况。解释器结构包括一个执行引擎和三个储存器。即被解释的程序，执行引擎，被解释程序的当前状态和执行引擎的当前状态四部分组成</p><p> 优点：能够提高应用程序的移植能力和编程语言的跨平台移植能力。</p><p>  实际测试工作可能非常复杂，测试代价高，具有风险性</p><p> 缺点：由于使用了特定语言和自定义操作规则，增加了系统运行的开销</p></li></ol><p>​          难以设计和测试</p><p>​    使用实例：java的编译器；专家系统领域的prolog语言；脚本语言；</p><ol start="5"><li><p>客户机/服务器体系结构风格（C/S）</p><p> 优点：客户机构件和服务器构件分别运行在不同的计算机上，利于分布式数据的组织和处理</p><p> 构件之间的位置相互透明，不必考虑对方的实际存储位置</p><p> 客户机侧重数据的显示和分析,服务器则注重数据的管理</p><p> 构件之间彼此独立且隔离,软硬件环境的配置灵活性高</p><p> 系统功能扩展性强</p><p> 将大规模业务逻辑分布给网络连接的低成本计算机以降低系统开销</p><p> 缺点：开发成本较高。 </p><p> 大部分开发工作都集中在客户机程序的设计,增加了设计的复杂度。 </p><p> 信息内容和形式单一 ；维护费用高</p><p> 两层C/S结构都采用单一服务器,以局域网为中心,数据安全性不高。</p></li><li><p>浏览器/服务器体系结构风格：B/S是C/S的一种实现方式，主要包括浏览器、web服务器和数据库服务器。</p><p> 优点：客户端只需要安装测览器,操作简单,能发布动态信息和静态信息</p><p> 运用HTTP标准协议和统一客户端软件,能够实现跨平台通信。</p><p> 开发成本比较低,只需要维护Web服务器程序和中心数据库。</p><p> 缺点：个性化程度比较低,所有客户端程序的功能都是一样的</p><p> 数据提交一般以页面为单位,动态交互性不强,不利于在线事务处理</p><p> B/S体系结构的可扩展性比较差,系统安全性难以保障。</p><p> B/S结构的应用系统查询中心数据库,其速度要远低于C/S体系结构</p><p> 客户端的数据处理能力差,加重了Web服务器的工作负担,影响系统的整体性能</p></li></ol><ol start="7"><li><p>MVC体系结构（模型-视图-控制器）：被广泛的应用于用户交互程序的设计中用于开发具有人机界面的软件系统。</p><p> 模型：应用程序的核心，封装了问题的核心数据、逻辑关系和计算功能。</p><p> 视图：模型的表示，从模型中获取数据并提供交互界面为用户显示模型信息。</p><p> 控制器：负责处理用户与系统之间的交互，为用户提供操作接口。</p><p> 分离模型、视图和控制器，能够提高设计和使用的灵活性</p></li></ol><p>​    优点：多个视图与一个模型相对应。变化一传播机制确保了所有相关视图都能及时的获取模型变化信息，从而使所有视图和控制器同步，便于为维护。</p><p>​    良好的移植性。模型独立于视图，可以方便的实现不同部分的移植</p><p>​    系统被分割为独立的三部分，功能发生变化时，改变任意一部分就能满足要求。</p><p>​    缺点：增加了系统设计和运行的复杂性；</p><p>​    视图与控制器过于紧密，妨碍了两者的独立重用；</p><p>​    视图访问模型效率比较低；</p><ol start="8"><li><p>分层体系结构风格：将系统划分层次结构，每一层都具有高耦合低内聚的性质。上层通过下层的接口使用下层的功能，下层不能使用上层的功能。利用接口隐藏下层实现细节，有助于抽象设计</p><p>   优点：可以通过将系统分解为一个增量的步骤序列来完成复杂的业务逻辑；</p><p> 每一层的交互和功能影响只存在于上下两层，便于系统功能的扩展；</p></li></ol><p>​         可以通过相邻层的相同接口用不同的方法实现每一层，支持软件资源的复用</p><p>   缺点：并非所有系统都能按照层次进行划分；</p><p>​         很难找到一种合适和正确的层次划分方法；</p><p>​         传输数据时需要经过多个层次导致系统性能下降</p><p>​         多层结构难以调试，往往需要通过一系列的跨层次调用来实现</p><p>  使用实例：分层通信协议、计算机网络协议TCP/IP、操作系统和数据库系统</p><ol start="9"><li><p>C2体系结构风格：基于构件和消息的体系结构风格，包括构件和连接件两种元素，构件之间只能通过连接件相连。核心思想是有限可视化，即构件只能使用上层构件提供的服务而不能感知下层构件的存在。消息只能单项传递，这样有利于系统的维护和发展</p><p>   优点：可以使用任何编程语言来开发构件；具有一定的扩展能力；</p></li></ol><p>​         构件不需要共享地址空间，避免了共享全局变量造成的复杂关系；           具有良好的适应性；能够动态的更新系统的框架设计 </p><ol start="10"><li><p>基于层次消息总线的体系结构风格（HMB）：构件之间通过消息总线进行通信，支持构建的分布式存储和并发运行。包括构建件和消息总线两种软件元素。消息总线包括消息登记、消息分派和传递及消息过滤。</p><p>HMB体系风格结构支持运行时的系统演化，体现在动态删除和删除构件；动态改变构件所响应的消息；消息过滤</p></li><li><p>正交体系结构风格：以垂直线索构件为基础的层次化结构，包括组织和线索。基本思想：按照功能的正交相关性，将系统垂直划分为若干个子系统，每个子系统用一条线索表示，每条线索由多个具有不同层次功能和抽象级别的构件组成。</p><p>优点：结构清晰、便于修改与维护、易于重用</p><p>实例：汽修服务管理的设计方案</p></li></ol><ol start="12"><li><p>公共对象请求代理体系结构风格(CORBA)：由对象管理组织提出，是一套完整的对象技术规范，其核心包括标准语言、接口和协议。在异构分布式环境下，可以实现应用程序之间的交互操作</p><p>优点：实现了客户端程序与服务器程序的分离；</p><p>将分布式计算模式与面向对象技术结合起来，提高软件复用率；</p><p>提供了软件总线机制；</p><p>支持各种编程语言和操作系统，在开发时能更好利用已有的开发成果</p></li></ol><ol start="13"><li><p>数据共享体系结构风格(仓库风格):有两种软件元素：一种是中央数据单元(<br> 资源库)，用于表示系统的当前状态；另一种是相互依赖的构建组，用于对中央数据单元实施操作。两者可以进行信息交互。</p><p> 数据共享体系结构可以分为传统的数据库和黑板。</p></li></ol><p>​    黑板是数据共享体系结构的一个特例，用以解决状态冲突并处理可能存在的不确定性知识源，经常被用于信号处理（语音和模式识别），在自然语言处理领域也有广泛应用（机器翻译和句法分析）</p><p>​    一个典型的黑板系统包括三个部分：</p><p>​    知识源：系统设计的关键，主要的信息来源</p><p>​    中央数据单元：黑板系统的运行完全依赖与中央数据单元的状态变化。</p><p>​    控制单元：控制单元是由中央数据单元的状态驱动的</p><p>​    优点：便于多客户共享大量数据</p><p>​    便于将构建作为知识源添加到系统中来</p><p>​    缺点：对共享数据结构，不同知识源要达成一致</p><p>​        需要同步机制和枷锁机制来保证数据的完整性和统一性，增大了系统设计的复杂度。</p><ol start="14"><li><p>反馈控制环体系结构风格：反馈控制环是一种特定的数据流结构，包括过程，数据元素，控制器。过程控制是连续的，可以利用各种构件和相关规则来设计反馈控制系统，实现各种功能</p><p>典型实例：机器学习</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件体系结构复习</title>
      <link href="/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/10/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/软件体系结构复习/title5.jpg" alt="title5"></p><a id="more"></a><ol><li>软件复用技术的出发点是在开发应用系统时不再采用一切从零开始的模式，而是以已有工作为基础，充分利用过去应用开发过程中所积累的经验与知识，将开发的重点集中于当前应用的特有部分</li></ol><ol start="2"><li>软件复用根据复用对象的类型不同，分为代码复用、设计复用、分析复用和测试复用 </li></ol><ol start="3"><li>代码复用：分为目标代码复用和源代码复用。<ol><li>目标代码复用级别最低，历史也最久。目前大多数编程语言的运行支持环境都提供了链接和绑定功能来支持这种复用。</li><li>源代码复用的级别略高于目标代码复用，程序员在编程时可以将一些想要复用的代码段复制到自己的程序中，但这样做往往会产生一种新老代码不匹配的现象。因此，大规模的实现源程序复用只能依靠构件库。构件库包含了大量的可复用构件。例如对象链接及嵌入技术(OLE)，OLE既能在源程序级别上定义构件构造新系统，又能使这些构件在目标代码级别上仍然时一些独立的可复用构件，能够在运行时被灵活的组合到不同的应用系统中。</li></ol></li></ol><ol start="4"><li><p>设计复用比源程序复用的级别更高。设计复用受实现环境的影响较小，因此被复用的机会更多，所需的修改也更少。设计复用的途径有三种：</p><p> (1)从现有系统的设计结果中提取一些可复用的设计元素用于新系统的设计过程中</p><p> (2)把现有系统的全部设计文档在新的软、硬件平台上重新实现，即一个设计用于多个具体实现</p><p> (3)独立于任何具体应用，有计划的开发一些可复用的设计元素</p></li></ol><ol start="5"><li><p>分析复用比设计复用的级别更高，可复用的分析成分是针对问题域的某些事物或某些问题所给出的具有普遍意义的解法。分析复用的途径有三种：</p><p> (1)从现有系统的分析结果中提取可复用的分析成分用于分析新系统</p><p> (2)根据完整的分析文档来产生针对不同软硬件平台和其他实现条件的多项设计结果</p><p> (3)独立于具体应用问题，开发专门用于复用的分析成分</p></li></ol><ol start="6"><li>测试复用分为测试用例复用和测试过程复用。测试复用无法和代码复用、设计复用、分析复用进行级别上的比较，但从信息的形态上来看，大体与代码复用的级别相当</li></ol><ol start="7"><li><p>软件复用根据信息复用的方式不同，可以分为黑盒复用和白盒复用。</p><p> 黑盒复用是指对已有软件结构不做任何修改，直接进行复用，是最理想的复用方式</p><p> 白盒复用是指已有软件结构不能完全满足用户要求，需要进行适应性修改后才能使用。是最常用的复用方式</p></li><li><p>软件复用的实现技术一般包括组装和生成两种类型</p><p> 在组装技术中，软件构件是复用的基石。构件在软件开发过程中类似于硬件中的芯片，通过组装可以形成更大的构件。构件是对某一函数、过程、子程序、数据类型及算法等可复用软件成分的抽象。对构件进行描述时应选择即不依赖具体硬件平台也不依赖具体编程语言的抽象描述语言，这样可以避免开发的构件因机器和语言的限制导致复用性降低</p><p> 在生成技术中，由程序生成器完成对软件结构模式的复用。生成器导出的模式相当于种子，从中可生长出新的专用软件构件。生成技术利用可复用模式，通过生成程序产生一个新的程序或程序段，产生的程序即是模式的实例。可复用的模式分为代码模式和规则模式。</p></li></ol><ol start="9"><li><p>基于构件的软件开发</p><p> 基本思想：将用户需求分解为一系列的子功能构建，在开发过程中不必重新设计这些基本功能模块，只需要从现有构件库中寻找合适的构件来组装应用系统</p><p> 优点：(1)大大提高软件的可复用性和开发效率</p><p> (2)使产品在客户需求吻合度、上线时间和质量上领先于同类产品</p><p> (3)使产品的开发与维护变得简单</p><p> (4)客户可以随时应对商业环境和IT技术的变化，以实现快速定制</p><p> 基本目标：以组装的方式生成新应用系统，组装以形式上独立的构件服务为基础进行</p><p> 具备要素：构件组装的应用程序、独立服务、公共构件基础设施和通用服务</p></li></ol><ol start="10"><li><p>软件构件技术的发展历程</p><p>20世纪60年代初：提出了结构化分析与设计方法。意为通过工程化方法，规范开发过程，使软件系统具有良好的结构，即产生可拼装和裁剪的模块化结构。</p><p>20世纪80年代末：出现了面向对象编程技术。其基本思想使使用对象来描述客观事物，对象封装了属性和操作方法。</p><p>20世纪90年代：软件构件技术得到迅速发展。强调开发过程应融入构件化技术和体系结构技术，要求开发的系统具备易理解，自适应，互操作，可扩展和可复用的特点。</p></li></ol><ol start="11"><li>为什么要建立软件体系结构：建立软件体系结构是整个开发过程的关键性步骤，设计一个完整的框架结构和一套构造规则是项目开发成功的关键。软件体系结构的设计对于大型项目开发的成败起着举足轻重的作用。</li></ol><ol start="12"><li><p>软件体系结构研究在整个开发过程中占有重要地位的原因是/为什么要研究软件体系结构</p><p>(1)软件体系结构可以作为项目开发的指导方针</p><p>(2)软件体系结构是设计过程的开端，体现了系统最早期的设计决策，对软件生命周期的影响很大</p><p>(3)软件体系结构具有可复用性</p><p>(4)促进系统的理解</p><p>(5)软件体系结构描述除了提供清晰精确的文档之外，还对文档进行了一致性分析和依赖性分析，暴露其中隐藏的各种问题</p><p>(6)构件复用是建立体系结构良好的软件系统的出发点</p><p>(7)软件体系结构规定了系统演化的方向，提供了系统管理的有效手段</p><p>(8)软件体系结构对系统演化具有重要的意义</p><p>(9)软件体系结构影响着开发组织和维护组织的结构</p></li></ol><ol start="13"><li><p>领域设计</p><p>步骤：(1)将依赖关系从现实中分离，使之容易辨认和修改，以适应新的需求</p></li></ol><p>​         (2)分层框架，使软件资源可以按照特定应用、操作系统及硬件平台的</p><p> 要求分层</p><p>​         (3)在每一层寻找适合领域设计框架的通用软件资源，并以此为基础寻</p><p>​           找其他基础性资源</p><p>   复用元素的选择原则：</p><p>(1)在软件开发和维护过程中，使用最频繁的元素</p><p>​        (2)提供最大利益的元素</p><p>​       (3)用于创建和维护对本公司具有重要意义的策略性软件元素</p><p>​       (4)复用消费者所需要的软件元素</p><ol start="14"><li>软件产品线包括核心资源开发，软件项目开发和技术协调组织管理</li></ol><p>核心资源开发被称为领域工程，利用核心资源的软件项目开发被称为应用工程。核心资源开发的目的是创建软件项目批量生产和大粒度复用的基础设施。核心资源开发的输出包括三点：产品线范围、核心资源、开发计划</p><p>软件项目开发活动依赖于核心资源开发活动的输出结果(产品线范围、核心资源和开发计划)以及各个项目的实际需求。软件项目开发活动的输入包括四点：项目实际需求、产品线范围、用于创建该项目的核心资源、开发计划。</p><p>技术协调和组织管理对于软件产品线的成功至关重要。技术协调负责监视核心资源开发活动和软件项目开发活动。组织管理必须建立合适的组织机构，确保各组织单位得到充足的资源。此外还需要建立一个实时性的调整计划，并对开发活动中涉及的档案进行有效的管理。尤其是开发进度和预算计划</p><p>三者的关系：核心资源开发与软件项目开发之间存在反馈循环，核心资源促进了应用系统的创建，新应用系统的开发又更新了核心资源，从应用系统个性中总结出的共性知识又将丰富产品线的核心资源。核心资源开发和软件项目开发都需要人力财力物理的投入，因此需要持久、强力有远见的组织管理。在产品线开发过程中，三大活动不断进行迭代循环，促进产品线的基础设施不断完善，开发的应用系统的质量不断提高，提高了领域开发的效率。</p><ol start="15"><li>场景：是对于风险承担者与系统进行交互的简短描述。在评估过程中，使用场景可以将那些模糊的、不适用于分析的质量属性需求描述转换为具体的、易于理解的表达形式</li></ol><p>场景分为直接场景和间接场景。直接场景在设计体系结构到系统构造的过程中使用，代表系统的外部视角和观点。间接场景在对现有体系结构进行改变和演化的过程中使用</p><p>​    场景的作用：</p><p>(1)场景可以覆盖系统的若干需求，并使抽象的需求可操作化</p><p>​        (2)在系统开发的早期，场景可以用来构造软件体系结构的雏形</p><p>​        (3)场景可以指导从软件体系结构到系统实际建造的过渡过程</p><p>​        (4)场景提供了对需求更深刻的理解，帮助用户认识软件产品并做出采</p><p>购决策。还可以帮助用户完善软件文档，在软件体系结构层面实现软</p><p>件的可跟踪性</p><p>​        (5)场景在系统建造过程中，可用来控制系统风险并对质量目标具体化</p><p>​        (6)软件体系结构在一个系统的软件生命周期中可能需要变动，场景成为分析变动的必要性及评估体系结构在更新后的合理性等方面的基础</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件质量与保证复习</title>
      <link href="/2019/01/10/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/10/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/10/软件质量与保证复习/title3.jpg" alt="title3"></p><a id="more"></a><p>第一章</p><p>1、软件质量保证(SQA)是一种应用于整个软件过程的保护性活动，它包括、</p><p>   (1)一种质量管理方法</p><p>   (2)有效的软件工程技术</p><p>   (3)在整个软件过程中采用的正式技术复审</p><p>   (4)一种多层次的测试策略</p><p>   (5)对软件文档及其修改的控制</p><p>   (6)保证软件遵从软件开发标准的流程</p><p>   (7)度量和报告机制</p><p>2、我们应该从哪几个方面考虑软件质量</p><p>   (1)软件结构方面   (2)功能与性能方面   (3)开发标准与文档方面</p><p>3、IEEE对软件质量的定义</p><p>   (1)系统、部件或过程满足规定需求的程度</p><p>   (2)系统、部件或过程满足顾客或客户需要或期望的程度</p><p>   该定义相对客观，强调了产品（或服务）和客户/社会需求的一致性</p><p>4、ANSI关于软件质量的定义</p><p>   与软件产品满足规定的和隐含的需求的能力有关的特征和特性的全体</p><p>   (1)软件产品中能满足用户给定需求的全部特性的集合</p><p>   (2)软件具有所期望的各种属性组合的程度</p><p>   (3)用户主观得出的软件是否满足其综合期望的程度</p><p>   (4)决定所用软件在使用中将满足其综合期望程度的软件合成特性</p><p>5、软件质量保证的目的：</p><p>   (1)通过对软件产品和活动进行评审和审计来验证软件是否符合标准</p><p>   (2)软件质量保证组在项目一开始时就一起建立计划、标准和过程，这些使软件项目满足机构方针的需求</p><p>6、软件测试是使用人工或自动手段来运行或测定某个系统的过程，检验他是否满足规定的需求或者弄清预期结果与实际结果之间的差别。</p><p>第二章</p><p>7、软件质量控制是一组由开发组织使用的程序和方法，使用他可在规定的资金投入和时间限制的条件下，提供满足客户质量要求的软件产品并持续不断地改善开发过程和开发组织自身，以提高将来生产高质量软件产品的能力。</p><p>8、软件质量控制的基本方法：目标问题度量法、风险管理法</p><p>第三章</p><p>9、软件过程度量中的常见问题：度量太多太频繁、度量太少太迟、度量了不正确的事物和属性、度量的定义不精确、收集了数据却没有利用、错误的解释度量数据、自动化工具欠缺</p><p>10、软件配置管理是一种标识、组织和控制修改的技术。作为CMM2级的一个关键域，在整个软件的开发活动中占有重要位置，是贯穿于整个软件过程中的保护性活动。用于标识变化、控制变化、保证变化被适当的实现、向其他可能有兴趣的人员报告变化</p><p>11、一个软件研发项目可以划分为三阶段：计划阶段、开发阶段和维护阶段</p><p>第四章</p><p>12.软件可靠性评价准则</p><p>   (1)模型拟合性</p><p>   (2)模型预计程度</p><p>   (3)模型偏差</p><p>   (4)模型偏差趋势</p><p>   (5)模型噪声</p><p>   注：345指标值越小，模型的适应性越好</p><p>13、提高软件可靠性的方法和技术</p><p>   (1)建立以可靠性为核心的质量标准。软件质量分为产品质量(软件质量、文档质量)和过程质量。确定划分的个开发过程的质量度量</p><p>   (2)选择开发方法</p><p>   (3)软件重用，包括开发过程重用、软件构件重用、知识重用</p><p>   (4)使用开发管理工具</p><p>   (5)加强测试，测试方法包括走查、机器测试、程序证明或交替程序显示、模拟测试、设计审查</p><p>   (6)容错设计：容错设计可以避免故障，不让差错和缺陷潜入软件</p><p>第五章</p><p>14、能力成熟度模型CMM为软件过程改进提供了一个框架，将整个软件改进过程分为5个成熟度等级，用于定义一个有序的尺度，用于衡量组织软件过程成熟度评价其软件过程能力</p><table><thead><tr><th>等级</th><th>特征</th><th>关键域</th></tr></thead><tbody><tr><td>初始级</td><td>软件过程混乱无序、对过程几乎没有定义、依靠个人才能成功、反应式管理方式</td><td></td></tr><tr><td>可重复级</td><td>建立基本的项目管理、制定必要的项目管理、能利用以前的类似项目取得成功</td><td>需求管理、项目计划、项目跟踪和监控、软件子合同管理、软件配置管理、软件质量保证</td></tr><tr><td>已定义级</td><td>将软件管理和过程文档化标准化、综合成标准软件过程并用于所有的软件开发</td><td>组织过程定义、组织过程焦点、培训大纲、软件集成管理、软件产品工程、组织协调、专家评审</td></tr><tr><td>已管理级</td><td>通过收集软件过程、产品质量的详细度量对两者进行理解和控制</td><td>定量的软件过程管理   定量的产品质量管理</td></tr><tr><td>优化级</td><td>软件过程的量化反馈和新的思想和技术促进过程的不断改进</td><td>缺陷预防、过程变更、   技术变更管理</td></tr></tbody></table><p> 15、CMM/CMMI在质量保证中的四个目标，质量保证实现的具体实施方法</p><p>目标：(1)软件质量保证活动是有计划的‘</p><p>​          (2)软件产品和活动与适用的标准、规程和需求的符合性要得到客观验证      (3)相关的小组和个人要被告知软件质量保证的活动和结果</p><p>(4)高级管理者处理在软件项目内部不能解决的不符合问题</p><p>具体实施方法：(1)定义项目类型和软件周期</p><p>​                  (2)建立SQA计划，确定项目审计内容</p><p>(3)生成SQA报告</p><p>(4)审计SQA报告     (5)独立汇报</p><p>第六章</p><p>16、为什么需要软件评审</p><p>   (1)提高项目的生产率，早期发现错误，减少返工时间，减少测试时间</p><p>   (2)改善软件的质量</p><p>   (3)在评审过程中，使开发团队的其他人员更熟悉产品和开发过程</p><p>   (4)通过评审，标志着软件开发一个阶段的完成</p><p>   (5)生产出更加容易维护的软件，增加对所开发软件的理解</p><p>17、评审的方法：特别检查、轮查、走查、团队评审、检视</p><p>18、评审的内容：管理评审、技术评审、文档评审、过程评审</p><p>19、文档评审的内容和检查列表、</p><p>内容：需求评审、设计评审、代码评审、质量验证评审</p><p>检查列表：正确性、完整性、一致性、有效性、易测性、模块化、清晰性、可行性、可靠性、可追溯性</p><p>20、评审会议流程</p><p>   (1)准备评审会议，提前发送通知让成员对会议内容有所准备，确保会议召开</p><p>   (2)召开评审会议，流程为评审预备、评审开始、评审决议、评审结束</p><p>   (3)跟踪和分析评审结果，验证作者是否恰当的解决了会议上列出的问题，修改的过程中有没有注入新的缺陷，测量评审的效果</p><p>第七章</p><p>21、全面质量管理和ISO 9000的异同</p><p>   相同之处</p><p>   (1)两者的管理理论和统计理论一致，即产品质量形成于产品全过程，质量体系贯穿于质量形成的全过程</p><p>   (2)实现方法相同，都是PDCA质量环运行模式</p><p>   (3)两者都要求对质量实施系统化的管理，都强调一把手对质量的管理</p><p>   (4)两者的最终目的一致，都是为了提高产品质量，满足顾客的需求，都强调任何一个过程都是可以不断改进和改善的</p><p>   不同之处</p><p>   (1)两者的期间目标不一致：全面质量管理的目标是改变现状，其作业只限一次。ISO9000的目标是维持标准现状，目的是尽量减少实际结果与标准值的偏差。    </p><p>   (2)二者的工作中心不同。全面质量管理以人为中心，ISO9000以标准为中心。</p><p>   (3)两者执行标准和检查方式不同。实施全面质量管理的企业所制定的标准是企业结合滋生特点制定的自我约束的管理体制，其检查方主要是企业内部人员，检查方法是考核和评估。ISO9000系列标准是国际公认的质量管理体系标准，它是世界各国共同遵守的准则。</p><p>22、质量屋结构图</p><p><img src="/2019/01/10/软件质量与保证复习/1.png" alt="1"></p><p>23、6σ是寻求同时增加顾客满意和企业经济增长的经营战略途径，一种全新的管</p><p>理企业。核心是追求零缺陷生产，防范产品责任风险、降低成本、提高生产率和市场占有率、提高顾客满意度和忠诚度</p><p>24、6σ管理的优点</p><p>   (1)提升企业管理的能力：降低管理流程浪费，简化管理流程，降低材料成本</p><p>   (2)节约企业运营的成本</p><p>   (3)增加顾客价值</p><p>   (4)改进服务水平</p><p>   (5)形成积极向上的企业文化</p><p>25.DMAIC模式的5步循坏改进法</p><p>   (1)定义：明确问题、目标和流程</p><p>   (2)评估：找到导致问题产生的关键原因，明确问题的核心所在</p><p>   (3)分析：对原因进行进一步分析，确认他们之间是否存在因果关系</p><p>   (4)改进：挑选最理想的改进方案付诸实施</p><p> (5)控制：根据控制标准，及时解决各种问题，使改进过程不偏离预定的轨道</p><p>第九章</p><p>26、软件测试的原则</p><p>   (1)在整个软件开发过程中尽早地和不断地进行软件测试</p><p>   (2)在开始测试时，不应默认程序中不存在错误</p><p>   (3)设计测试用例，要给出测试的预期结果</p><p>   (4)测试工作应避免由系统开发人员或开发机构本身来测试</p><p>   (5)对合理和不合理的输入都要进行测试</p><p>   (6)重点测试错误群集的程序区段</p><p>   (7)除检查系统是否完备外，还要检查程序功能是否有多余</p><p>   (8)用穷举测试是不可能的</p><p>   (9)长期完整保留测试用例和测试文件，直至该软件产品被废弃为止</p><p>27、软件测试过程：单元测试-集成测试-系统测试-验收测试-回归测试贯穿整个测试过程</p><p>第十二章</p><p>28、软件缺陷是存在于软件之中的那些不希望或不可接受的偏差</p><p>29、软件缺陷的产生原因：程序编写错误、未按照规定编写代码、软件越来越复杂、开发人员的态度、沟通问题、需求变更过于频繁、进度压力、管理失误</p><p>30、软件缺陷特征：缺陷的发生都是有原因的、缺陷的重现性、缺陷的积累性放大性、缺陷的修复可能引进新的缺陷</p><p>31、软件缺陷属性：缺陷标识、缺陷类型、缺陷严重程度、缺陷优先级、缺陷状态、缺陷起源、缺陷来源、缺陷根源</p><p>32、报告软件缺陷的基本原则：软件缺陷的尽快报告、有效的描述软件缺陷</p><p>第十三章</p><p>33、集成测试与单元测试和系统测试的区别</p><p>   (1)范围不同</p><p>单元测试主要关注模块的内部</p><p>集成测试主要关注穿越接口的数据、信息是否正确，是否会丢失</p><p>集成测试仅针对软件系统展开测试</p><p>系统测试包括软件系统以及与软件系统交互的所有硬件和软件平台</p><p>   (2)依据不同</p><p>单元测试针对详细设计做测试，依据是详细设计说明书</p><p>集成测试针对概要设计做测试，依据是概要设计说明书</p><p>系统测试针对需求做测试，依据是需求规格说明书及行业标准</p><p>34、几种集成测试实施方案的比较</p><p>   (1)非增量式集成测试：先分散测试，然后集中起来再一次完成集成测试。</p><p>缺点：如果模块的接口处存在错误，会在集成测试时一下子暴露出来；</p><p>难以判断出错的原因和位置，改正错误时容易引入新的错误。</p><p>   (2)自顶向下的优点：逐步求精，一开始便能让测试者看到系统的框架。</p><p>缺点:被调用的模拟子模块可能不能反映真实情况，导致测试行不充分。</p><p>   (3)自底向上的优点：即使数据流没有完全形成，测试数据也很容易生成。</p><p>缺点：只有模块全部被装进去，才能看到整个系统的框架。</p><p>   (4)三明治集成测试：自底向上和自顶向下相结合，有助于尽早发现缺陷和提高工作效率。</p><p>   (5)核心系统先行集成测试：能保证一些重要功能和服务的实现，对于快速软件开发很有效果。但要求系统明确区分核心部件和外围软件部件。</p><p>   (6)高频集成测试：特点是集成次数频繁，必须借助自动化工具来实现。</p><p>35、集成测试的过程分为三个阶段</p><p>   (1)计划阶段：完成集成测试计划，制订集成测试策略</p><p>   (2)计划实现阶段：建立继承测试环境，完成测试计划和开发</p><p>   (3)执行评估阶段：执行集成测试用例，记录和评估测试结果</p><p>第十四章</p><p>36、系统测试主要方法：性能测试、强度测试、安全性测试、兼容性测试、恢复测试、用户图形界面测试、安装测试、可靠性测试、配置测试、可用性测试、文档资料测试、网站测试</p><p>37、性能测试就是对软件的运行性能指标进行测试，判断系统集成之后在实际的使用环境下能否稳定可靠的运行。</p><p>性能测试中主要考虑时间性能和空间性能两方面</p><p>目标：判断被测系统是否满足预期的性能需求；判断系统的性能表现</p><p>第十五章</p><p>38、测试文档的撰写</p><p>   (1)测试计划：分为作为产品的测试计划和作为工具的测试计划</p><p>​      测试计划包括：概要、目标和标准、测试的领域、测试方法描述、</p><p>测试进度表、测试资源、配置范围、测试工具</p><p>   (2)测试规范：包括背景信息、测试特性、功能考虑、测试考虑</p><p>   (3)测试案例和测试报告</p><p>   (4)软件缺陷报告：包括软件缺陷名称、待测软件版本、优先级与严重性、</p><p>详细测试步骤、缺陷造成的后果、预计结果、其他信息</p><p>39、一个好的文档具有以下三点：提高可用性、提高可靠性、降低支持费用</p><p>40、调试方法：蛮力法、回溯法、原因排除法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件质量保证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究rand()随机数</title>
      <link href="/2019/01/01/%E6%8E%A2%E7%A9%B6rand-%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2019/01/01/%E6%8E%A2%E7%A9%B6rand-%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/探究rand-随机数/title2.jpg" alt="title2"></p><a id="more"></a><p>####关于srand()函数</p><p>​    srand（）函数用于设置随机种子，一般参数为time（0）作为随机种子</p><h4 id="关于time-函数"><a href="#关于time-函数" class="headerlink" title="关于time()函数"></a>关于time()函数</h4><p>​    time（0）函数返回当前时间戳（以秒为单位，从1900.01.01开始，时间戳是32位整数，所以2036年就会失效）</p><p>####关于rand()函数</p><p>​    rand（）会随机生成一个整型(实质是一套算法，若种子相同，一套算法算出来的东西也相同)</p><h4 id="关于rand-函数的随机性"><a href="#关于rand-函数的随机性" class="headerlink" title="关于rand()函数的随机性"></a>关于rand()函数的随机性</h4><p>​    由于rand()函数也是一种算法，传入相同的随机种子，生成的数也是相同的，所以广义上来说，随机数并不是真正的随机，是一种伪随机。</p><p>​    一个随机算法，需要保证在规定的范围内的每一个数都有可能出现且出现的概率是相同的，根据传入的随机种子不同，随机数也不同。</p><p>####rand()函数算法如何实现0～2^32 - 1均匀随机的出现？</p><p>​    利用费马定理：如果p是一个素数，a^(φ(p)) % p = 1(当a与p互素时)</p><p>​    具体见代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 100000</span><br><span class="line"></span><br><span class="line">//100000以内的素数数组</span><br><span class="line">int prime[MAX_N + 5] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">//my_seed是一个随机种子，rand()算法核心的两个参数a_num, b_num,</span><br><span class="line">//利用my_seed = my_seed * a_num % b_num能够保证my_seed在1～b_num - 1均匀的出现</span><br><span class="line">static int my_seed = 37, a_num, b_num;</span><br><span class="line"></span><br><span class="line">//自定义rand()函数</span><br><span class="line">int my_rand() &#123;</span><br><span class="line">#define i my_seed</span><br><span class="line">    do &#123;</span><br><span class="line">        //rand()算法的核心，该算式能够保证i在1～9999均匀的出现</span><br><span class="line">        i = i * a_num % b_num;</span><br><span class="line">    &#125; while (i &gt; 10000);</span><br><span class="line">    return i;</span><br><span class="line">#undef i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//至于a_num和b_num如何得到，下面是求解过程</span><br><span class="line"></span><br><span class="line">//预处理全部素数</span><br><span class="line">void init_prime() &#123;</span><br><span class="line">    for (int i = 2; 2 * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        if (!prime[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0]; j++) &#123;</span><br><span class="line">            if (i * prime[j] &gt; MAX_N) break;</span><br><span class="line">            prime[i * prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速幂函a^b % c</span><br><span class="line">int quick_mod(int a, int b, int c) &#123;</span><br><span class="line">    int ans = 1, temp = a % c;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans *= temp;</span><br><span class="line">        temp *= temp;</span><br><span class="line">        temp %= c;</span><br><span class="line">        ans %= c;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//由于b为质数且a,b互质，根据费马定理小定理a^(φ(p)) % p = 1，也就是a^(p - 1) % p = 1</span><br><span class="line">//因此我们只需要确定p - 1的全部约数不为1，即确定a^i是循环节为p - 1的算式</span><br><span class="line">int get_len(int a, int b) &#123;</span><br><span class="line">    for (int i = 1; i &lt; b - 1; i++) &#123;</span><br><span class="line">        if ((b - 1) % i) continue;</span><br><span class="line">        if (quick_mod(a, i, b) == 1) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return b - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_a_and_b(int *a, int *b) &#123;</span><br><span class="line">    //找到一个大于13000的素数b_num</span><br><span class="line">    for (int i = 1; i &lt;= prime[0]; i++) &#123;</span><br><span class="line">        *b = prime[i];</span><br><span class="line">        if (prime[i] &gt; 13000) break;    </span><br><span class="line">    &#125;</span><br><span class="line">    //根据b_num找到符合条件的a_num</span><br><span class="line">    for (int i = 2; i &lt; *b; i++) &#123;      </span><br><span class="line">        if (get_len(i, *b) != *b - 1) continue;</span><br><span class="line">        *a = i;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对a（也就是a_num），b(也就是b_num)进行验证</span><br><span class="line">void check(int a, int b) &#123;</span><br><span class="line">    a_num = a, b_num = b;</span><br><span class="line">    int vis[10001] = &#123;0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        int temp = my_rand();</span><br><span class="line">        if (vis[temp]) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[temp] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; OK&quot; &lt;&lt; endl;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init_prime();</span><br><span class="line">    int a, b;</span><br><span class="line">    get_a_and_b(&amp;a, &amp;b);</span><br><span class="line">    check(a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler56</title>
      <link href="/2019/01/01/Euler56/"/>
      <url>/2019/01/01/Euler56/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler56/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><p>一古戈尔（10100）是一个巨大的数字：一后面跟着一百个零。100100则更是无法想像地巨大：一后面跟着两百个零。然而，尽管这两个数如此巨大，各位数字和却都只有1。</p><p>若a, b &lt; 100，所有能表示为ab的自然数中，最大的各位数字和是多少？</p><p>思路：</p><p>​    一道考验基操的题——大数乘法。打一遍当热热手～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void mul (int *num, int val) &#123;</span><br><span class="line">    for (int i = 1; i &lt;= num[0]; i++) &#123;</span><br><span class="line">        num[i] *= val;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= num[0]; i++) &#123;</span><br><span class="line">        if (num[i] &gt;= 10) &#123;</span><br><span class="line">            num[i + 1] += num[i] / 10;</span><br><span class="line">            num[i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(num[num[0] + 1]) &#123;</span><br><span class="line">        num[0] ++;</span><br><span class="line">        num[num[0] + 1] = num[num[0]] / 10;</span><br><span class="line">        num[num[0]] %= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int mx = 0;</span><br><span class="line">    for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">        int num[205] = &#123;1, 1&#125;;</span><br><span class="line">        for (int j = 1; j &lt;= 100; j++) &#123;</span><br><span class="line">            int k = 0;</span><br><span class="line">            mul(num, i);</span><br><span class="line">            for (int p = 1; p &lt;= num[0]; p++) &#123;</span><br><span class="line">                k += num[p];</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &gt; mx) &#123;</span><br><span class="line">                mx = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, mx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模版 </tag>
            
            <tag> 大数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler53</title>
      <link href="/2019/01/01/Euler53/"/>
      <url>/2019/01/01/Euler53/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler53/title6.jpg" alt="title6"></p><a id="more"></a><p>题意：</p><p>从五个数12345中选择三个恰好有十种方式，分别是：</p><p>123、124、125、134、135、145、234、235、245和345</p><p>在组合数学中，我们记作：5C3 = 10。</p><p>一般来说，</p><p>nCr=n!r!(n−r)!n!r!(n−r)!，其中r ≤ n，n! = n×(n−1)×…×3×2×1，且0! = 1。</p><p>直到n = 23时，才出现了超出一百万的组合数：23C10 = 1144066。</p><p>若数值相等形式不同也视为不同，对于1 ≤ n ≤ 100，有多少个组合数nCr超过一百万？</p><p>思路：</p><p>​    由于当n的取值范围小于等于100，因此可以利用杨辉三角来做～，开两个二维数组，当值小于1000000时，用dp【n】【m】来存储C（n，m）的值，当值大于1000000时，直接用book【n】【m】=1标记一下，推导方程见代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll dp[105][105] = &#123;0&#125;;</span><br><span class="line">bool book[105][105] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            if (j == 0 || j == i) dp[i][j] = 1;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (book[i - 1][j - 1] || book[i - 1][j]) &#123;</span><br><span class="line">                    sum ++;</span><br><span class="line">                    book[i][j] = 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span><br><span class="line">                    if (dp[i][j] &gt; 1000000) &#123;</span><br><span class="line">                        book[i][j] = 1;</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler93</title>
      <link href="/2019/01/01/Euler93/"/>
      <url>/2019/01/01/Euler93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler93/title8.jpg" alt="title8"></p><a id="more"></a><p>题意：</p><p>使用集合{1, 2, 3, 4}中每个数字恰好一次以及(+, −, *, /)四则运算和括号，可以得到不同的正整数。</p><p>例如，</p><p>8 = (4 <em> (1 + 3)) / 2<br>14 = 4 </em> (3 + 1 / 2)<br>19 = 4 <em> (2 + 3) − 1<br>36 = 3 </em> 4 * (2 + 1)</p><p>注意不允许直接把数字连起来，如12 + 34。</p><p>使用集合{1, 2, 3, 4}，可以得到31个不同的数，其中最大值是36，以及1到28之间所有的数。</p><p>若使用包含有四个不同数字a &lt; b &lt; c &lt; d的集合可以得到从1到n之间所有的数，求其中使得n最大的集合，并将你的答案写成字符串：abcd。</p><p>思路：</p><p>​    由于有（）所以不知道如何插空，因为后缀表达式不含括号，这时候我们可以将算式转化为后缀表达式。只要满足前i位运算符 &lt; 数字个数这一条件，把全部组合计算一遍即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int vis[10005] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">double calc (char * result, int n) &#123;</span><br><span class="line">    stack&lt;double&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (result[i] &lt;= &apos;9&apos; &amp;&amp; result[i] &gt;= &apos;0&apos;)&#123;</span><br><span class="line">            s.push(result[i] - &apos;0&apos;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        double a = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        double b = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        switch(result[i]) &#123;</span><br><span class="line">            case &apos;+&apos;: &#123;</span><br><span class="line">                s.push (a + b);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &apos;-&apos;: &#123;</span><br><span class="line">                s.push (b - a);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &apos;*&apos;: &#123;</span><br><span class="line">                s.push (a * b);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &apos;/&apos;: &#123;</span><br><span class="line">                s.push (b / a);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define EPS 1e-7</span><br><span class="line"></span><br><span class="line">void dfs(char * result, int k, int a, int b, int *num) &#123;</span><br><span class="line">    if (k == 7) &#123;</span><br><span class="line">        double ret = calc (result, 7);</span><br><span class="line">        if (ret &gt; 0 &amp;&amp; fabs(ret - floor(ret)) &lt;= EPS) &#123;</span><br><span class="line">            vis[(int)ret] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (b + 1 &lt; a) &#123;</span><br><span class="line">        result[k] = &apos;+&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">        result[k] = &apos;-&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">        result[k] = &apos;*&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">        result[k] = &apos;/&apos;;</span><br><span class="line">        dfs(result, k + 1, a, b + 1, num);</span><br><span class="line">    &#125;</span><br><span class="line">    if (a &lt; 4) &#123;</span><br><span class="line">        result[k] = num[a] + &apos;0&apos;;</span><br><span class="line">        dfs(result, k + 1, a + 1, b, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int mx = 0;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt;10; j++) &#123;</span><br><span class="line">            for (int p = j + 1; p &lt; 10; p++) &#123;</span><br><span class="line">                for (int q = p + 1; q &lt; 10; q++) &#123;</span><br><span class="line">                    memset(vis, 0, sizeof(vis));</span><br><span class="line">                    int num[4] = &#123;i, j, p, q&#125;;</span><br><span class="line">                    char result[7] = &#123;0&#125;;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        dfs(result, 0, 0, 0, num);</span><br><span class="line">                    &#125;while(next_permutation(num, num + 4));</span><br><span class="line">                    int tt = 1;</span><br><span class="line">                    for (; vis[tt]; tt++);</span><br><span class="line">                    if (mx &lt; tt) &#123;</span><br><span class="line">                        mx = tt;</span><br><span class="line">                        flag = i * 1000 + j * 100 + p * 10 + q;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, flag);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler72</title>
      <link href="/2019/01/01/Euler72/"/>
      <url>/2019/01/01/Euler72/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler72/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>考虑形如n/d的分数，其中n和d均为正整数。如果n &lt; d且其最大公约数为1，则该分数称为最简真分数。</p><p>如果我们将d ≤ 8的最简真分数构成的集合按大小升序列出，我们得到：</p><p>1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8</p><p>可以看出该集合中共有21个元素。</p><p>d ≤ 1,000,000的最简真分数构成的集合中共有多少个元素？</p><p>思路：</p><p>​    就是求前1000000项的欧拉函数和，套用线性筛模版求欧拉函数即可。记住三个原理：1.当n为素数，φ(n) = n - 1</p><p>​    2.当p为素数且p，q互素，φ(p✖️q） = φ(p)✖️φ(q)</p><p>​    3.当p为素数且p，q不互素，φ(p✖️q） = p✖️φ(q)</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 1000000</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">int prime[N + 5] = &#123;0&#125;;</span><br><span class="line">int book[N + 5] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            book[i] = i - 1;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt;= N; j++) &#123;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                book[i * prime[j]] = book[i] * prime[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                book[i * prime[j]] = book[i] * book[prime[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ll sum = 0;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        sum += book[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    答案为303963552391</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler61</title>
      <link href="/2019/01/01/Euler61/"/>
      <url>/2019/01/01/Euler61/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/Euler61/title12.jpg" alt="title12"></p><a id="more"></a><p>三角形数、正方形数、五边形数、六边形数、七边形数和八边形数统称为多边形数。它们分别由如下的公式给出：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>三角形数</td><td>P3,n=n(n+1)/2</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>正方形数</td><td>P4,n=n2</td><td>1, 4, 9, 16, 25, …</td></tr><tr><td>五边形数</td><td>P5,n=n(3n−1)/2</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>六边形数</td><td>P6,n=n(2n−1)</td><td>1, 6, 15, 28, 45, …</td></tr><tr><td>七边形数</td><td>P7,n=n(5n−3)/2</td><td>1, 7, 18, 34, 55, …</td></tr><tr><td>八边形数</td><td>P8,n=n(3n−2)</td><td>1, 8, 21, 40, 65, …</td></tr></tbody></table><p>由三个4位数8128、2882、8281构成的有序集有如下三个有趣的性质。</p><ol><li>这个集合是循环的，每个数的后两位是后一个数的前两位（最后一个数的后两位也是第一个数的前两位）。</li><li>每种多边形数——三角形数（P3,127=8128）、正方形数（P4,91=8281）和五边形数（P5,44=2882）——在其中各有一个代表。</li><li>这是唯一一个满足上述性质的4位数有序集。</li></ol><p>存在唯一一个包含六个4位数的有序循环集，每种多边形数——三角形数、正方形数、五边形数、六边形数、七边形数和八边形数——在其中各有一个代表。求这个集合的元素和</p><p>思路：</p><p>​    模块1：找出全部1000～9999的x边形数n，并把n存到g【x】【n / 100】动态数组中</p><p>​    模块2：对数组{3, 4, 5, 6, 7, 8}进行全排列，并进行dfs</p><p>​    详细见代码</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Triangle (int n) &#123;</span><br><span class="line">    return n * (n + 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Square(int n ) &#123;</span><br><span class="line">    return n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Pentagonal (int n ) &#123;</span><br><span class="line">    return n * (3 * n - 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Hexagonal (int n )&#123;</span><br><span class="line">    return n * (2 * n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Heptagonal (int n) &#123;</span><br><span class="line">    return n * (5 * n - 3) / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Octagonal (int n) &#123;</span><br><span class="line">    return n * (3 * n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int (*FuncList[6])(int) = &#123;</span><br><span class="line">        Triangle , Square, Pentagonal, Hexagonal,Heptagonal, Octagonal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;g[10][105];</span><br><span class="line">vector&lt;int&gt;gg[10];</span><br><span class="line"></span><br><span class="line">void model1 () &#123;</span><br><span class="line">    for (int i = 1; ; i++) &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            int t = FuncList[j](i);</span><br><span class="line">            if (1000 &lt;= t &amp;&amp; t &lt; 10000) &#123;</span><br><span class="line">                g[j][t / 100].push_back(t);</span><br><span class="line">                gg[j].push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt;= 10000) &#123;</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag == 6) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int *num, int t, int now, int k, int sum) &#123;</span><br><span class="line">    if (k == 6) &#123;</span><br><span class="line">        if (now % 100 == t / 100) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, sum);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int m = now % 100;</span><br><span class="line">    for (int i = 0; i &lt; g[num[k]][m].size(); i++) &#123;</span><br><span class="line">        int tt = g[num[k]][m][i];</span><br><span class="line">        bool flag = dfs(num, t, tt, k + 1, sum + tt);</span><br><span class="line">        if(flag) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void model2() &#123;</span><br><span class="line">    int num[6] = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">    bool flag = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        for (int i = 0; i &lt; gg[num[0]].size(); i++) &#123;</span><br><span class="line">            int t = gg[num[0]][i];</span><br><span class="line">            flag = dfs(num, t, t, 1, t);</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while(next_permutation(num, num + 6) &amp;&amp; !flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    model1();</span><br><span class="line">    model2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷2719搞笑世界杯</title>
      <link href="/2019/01/01/%E6%B4%9B%E8%B0%B72719%E6%90%9E%E7%AC%91%E4%B8%96%E7%95%8C%E6%9D%AF/"/>
      <url>/2019/01/01/%E6%B4%9B%E8%B0%B72719%E6%90%9E%E7%AC%91%E4%B8%96%E7%95%8C%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/洛谷2719搞笑世界杯/title3.jpg" alt="title3"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>随着世界杯小组赛的结束,法国,阿根廷等世界强队都纷纷被淘汰,让人心痛不已. 于是有人组织了一场搞笑世界杯,将这些被淘汰的强队重新组织起来和世界杯一同比赛.你和你的朋友欣然去购买球票.不过搞笑世界杯的球票出售方式也很特别,它们只准备了两种球票.A 类票——免费球票 B 类票——-双倍价钱球票.购买时由工作人员通过掷硬币决定,投到正面，的买A类票, 反面的买B类票.并且由于是市场经济,主办方不可能倒贴钱,所以他们总是准备了同样多的A类票和B类票.你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置.</p><p>这时工作人员开始通过硬币售票.不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了,因为剩下的这两张票全是免费票。</p><p>你和你的朋友在欣喜之余,想计算一下排在队尾的两个人同时拿到一种票的概率是多少(包括同时拿A 类票或B类票) 假设工作人员准备了2n 张球票,其中n 张A类票,n 张B类票,并且排在队伍中的人每人必须且只能买一张球票(不管掷到的是该买A 还是该买B).</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>输入文件仅一行,包含球票数2n . 其中,0&lt;n&lt;=1250 ，n 为整数。</p><p>输出格式：</p><p>输出文件只包含一个数,为拿到同一种票的概率,精确到小数点后4 位。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">256</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.9500</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    概率dp的入门题，我们设dp【i】【j】代表A类票有i张，B类票有j张最后两张相同的概率。我们初始化dp【i】【0】= 1（2 &lt;= i &lt;= n），dp【0】【i】 = 1（2 &lt;= i &lt;= n），其余为0.然后利用dp【i】【j】= dp【i - 1】【j】✖️0.5 + dp【i】【j-1】✖️0.5，最后dp【n】【n】即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">double dp[1300][1300] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 2; i &lt;= n / 2; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n / 2; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n / 2; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] * 0.5 + dp[i][j - 1] * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.4f\n&quot;, dp[n / 2][n / 2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 概率dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1140相似基因</title>
      <link href="/2019/01/01/%E6%B4%9B%E8%B0%B71140%E7%9B%B8%E4%BC%BC%E5%9F%BA%E5%9B%A0/"/>
      <url>/2019/01/01/%E6%B4%9B%E8%B0%B71140%E7%9B%B8%E4%BC%BC%E5%9F%BA%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/01/洛谷1140相似基因/title1.jpg" alt="title1"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>两个基因的相似度的计算方法如下：</p><p>对于两个已知基因，例如AGTGATG和GTTAG，将它们的碱基互相对应。当然，中间可以加入一些空碱基-，例如：</p><p><img src="/2019/01/01/洛谷1140相似基因/1.jpg" alt="1"></p><p>这样,两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：</p><p><img src="/2019/01/01/洛谷1140相似基因/2.jpg" alt="2"></p><p>那么相似度就是：(−3)+5+5+(−2)+(−3)+5+(−3)+5=9。因为两个基因的对应方法不唯一，例如又有：</p><p><img src="/2019/01/01/洛谷1140相似基因/3.jpg" alt="3"></p><p>相似度为：(−3)+5+5+(−2)+5+(−1)+5=14。规定两个基因的相似度为所有对应方法中，相似度最大的那个。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>共两行。每行首先是一个整数，表示基因的长度；隔一个空格后是一个基因序列，序列中只含A,C,G,T四个字母。1≤1≤序列的长度≤100。</p><p>输出格式：</p><p>仅一行，即输入基因的相似度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 AGTGATG</span><br><span class="line">5 GTTAG</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    我们设dp【i】【j】为第一个基因的1～i位和第二个基因的1～j位的最大相似值，那么可以得到递推公式dp【i】【j】=max（dp【i-1】【j】+ maps【i】【-】，dp【i】【j-1】 + maps【-】【j】，dp【i - 1】【j - 1】+ maps【i】【j】）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int maps[5][5] = &#123;</span><br><span class="line">        5, -1, -2, -1, -3,</span><br><span class="line">        -1, 5, -3, -2, -4,</span><br><span class="line">        -2, -3, 5, -2, -2,</span><br><span class="line">        -1, -2, -2, 5, -1,</span><br><span class="line">        -3, -4, -2, -1, 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char s1[105], s2[105];</span><br><span class="line">int dp[105][105] = &#123;0&#125;;</span><br><span class="line">map&lt;char, int&gt;zcy;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    zcy[&apos;A&apos;] = 0;</span><br><span class="line">    zcy[&apos;C&apos;] = 1;</span><br><span class="line">    zcy[&apos;G&apos;] = 2;</span><br><span class="line">    zcy[&apos;T&apos;] = 3;</span><br><span class="line">    scanf(&quot;%d%s&quot;, &amp;n, s1 + 1);</span><br><span class="line">    scanf(&quot;%d%s&quot;, &amp;m, s2 + 1);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0] + maps[zcy[s1[i]]][4];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[0][i] = dp[0][i - 1] + maps[4][zcy[s2[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = max(max(dp[i - 1][j] + maps[zcy[s1[i]]][4],</span><br><span class="line">                               dp[i][j - 1] + maps[4][zcy[s2[j]]]),</span><br><span class="line">                           dp[i - 1][j - 1] + maps[zcy[s1[i]]][zcy[s2[j]]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[n][m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1436棋盘分割</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71436%E6%A3%8B%E7%9B%98%E5%88%86%E5%89%B2/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71436%E6%A3%8B%E7%9B%98%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1436棋盘分割/title7.jpg" alt="title7"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的两部分中的任意一块继续如此分割，这样割了(n-1)次后，连同最后剩下的矩形棋盘共有n块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)</p><p><img src="/2018/12/31/洛谷1436棋盘分割/1.jpg" alt="1"></p><p>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成n块矩形棋盘，并使各矩形棋盘总分的平方和最小。</p><p>请编程对给出的棋盘及n，求出平方和的最小值。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行为一个整数n(1 &lt; n &lt; 15)。</p><p>第2行至第9行每行为8个小于100的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。</p><p>输出格式：</p><p>仅一个数，为平方和。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 1 1 1 1 3</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br><span class="line">1 1 1 1 1 1 1 0</span><br><span class="line">1 1 1 1 1 1 0 3</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1460</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    主要是考验思维吧，只要想到用五维dp就可以很快的推出dp推导式。dp【i】【j】【p】【q】【m】代表左上角坐标（i，j），右下角坐标（p，j）的矩形切m刀的最大值。</p><p>然后dp推导式在代码中</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int maps[10][10];</span><br><span class="line">int sum[10][10] = &#123;0&#125;;</span><br><span class="line">int dp[10][10][10][10][15] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    memset(dp, 0x3f3f3f3f, sizeof(dp));</span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= 8; j++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;maps[i][j]);</span><br><span class="line">            sum[i][j] = sum[i][j - 1] + maps[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= 8; j++) &#123;</span><br><span class="line">            for (int p = i; p &lt;= 8; p++) &#123;</span><br><span class="line">                for (int q = j; q &lt;= 8; q++) &#123;</span><br><span class="line">                    int suu = 0;</span><br><span class="line">                    for (int o = i; o &lt;= p; o++) &#123;</span><br><span class="line">                        suu += sum[o][q] - sum[o][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][p][q][0] = suu * suu;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int o = 1; o &lt; n; o++) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= 8; j++) &#123;</span><br><span class="line">                for (int p = i; p &lt;= 8; p++) &#123;</span><br><span class="line">                    for (int q = j; q &lt;= 8; q++) &#123;</span><br><span class="line">                        for (int k = i; k &lt; p; k++) &#123;</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][k][q][o - 1] + dp[k + 1][j][p][q][0]);</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][k][q][0] + dp[k + 1][j][p][q][o - 1]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (int k = j; k &lt; q; k++) &#123;</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][p][k][o - 1] + dp[i][k + 1][p][q][0]);</span><br><span class="line">                            dp[i][j][p][q][o] = min(dp[i][j][p][q][o], dp[i][j][p][k][0] + dp[i][k + 1][p][q][o - 1]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[1][1][8][8][n - 1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1481魔族密码</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71481%E9%AD%94%E6%97%8F%E5%AF%86%E7%A0%81/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71481%E9%AD%94%E6%97%8F%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1481魔族密码/title10.jpg" alt="title10"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>风之子刚走进他的考场，就……</p><p>花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花）</p><p>风之子：我呕……（杀死人的眼神）快说题目！否则……-_-###</p><p>花花：……咦<del>好冷</del>我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉<em>^_^</em>）。魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含1个字母，至多75个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链：</p><p>i int integer</p><p>但下面的单词不组成词链：</p><p>integer</p><p>intern 现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。</p><p>风之子：密码就是最长词链所包括的单词数阿……</p><p>花花：活活活，还有，看你长得还不错，给你一个样例吧：</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>这些文件的格式是，第一行为单词表中的单词数N（1&lt;=N&lt;=2000），下面每一行有一个单词，按字典顺序排列，中间也没有重复的单词咧！！</p><p>输出格式：</p><p>你要提交的文件中只要在第一行输出密码就行啦^^</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">i</span><br><span class="line">int</span><br><span class="line">integer</span><br><span class="line">intern</span><br><span class="line">internet</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    依次将每个单词加入字典树中，并计算建树过程中（路径上）节点的最大值，该节点即为【节点】.num=max（【节点】.num，【最大节点】.num+1），最后num最大的节点即位所求</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    node *son[26];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct tree &#123;</span><br><span class="line">    node *head;</span><br><span class="line">&#125;head;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">char s[105];</span><br><span class="line">int ans = 0;</span><br><span class="line"></span><br><span class="line">void add(node *point, int ceng, int maxx, int len) &#123;</span><br><span class="line">    if (ceng == len) &#123;</span><br><span class="line">        maxx = max(maxx, point -&gt; num);</span><br><span class="line">        point -&gt; num = maxx + 1;</span><br><span class="line">        if (ans &lt; point -&gt; num) ans = point -&gt; num;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int k = s[ceng] - &apos;a&apos;;</span><br><span class="line">    maxx = max(maxx, point -&gt; num);</span><br><span class="line">    if (point -&gt; son[k] == NULL) &#123;</span><br><span class="line">        point -&gt; son[k] = (node *) malloc(sizeof(node));</span><br><span class="line">        add(point -&gt; son[k], ceng + 1, maxx, len);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        add(point -&gt; son[k], ceng + 1, maxx, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(node *point) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">        if (point -&gt; son[i] == NULL) continue;</span><br><span class="line">        Delete(point -&gt; son[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    head.head = (node *)malloc(sizeof(node));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, s);</span><br><span class="line">        int len = strlen(s);</span><br><span class="line">        add(head.head, 0, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    Delete(head.head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1507NASA的食物计划</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71507NASA%E7%9A%84%E9%A3%9F%E7%89%A9%E8%AE%A1%E5%88%92/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71507NASA%E7%9A%84%E9%A3%9F%E7%89%A9%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1507NASA的食物计划/title11.jpg" alt="title11"></p><a id="more"></a><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NASA(美国航空航天局)因为航天飞机的隔热瓦等其他安全技术问题一直大伤脑筋,因此在各方压力下终止了航天飞机的历史,但是此类事情会不会在以后发生，谁也无法保证,在遇到这类航天问题时,解决方法也许只能让航天员出仓维修,但是多次的维修会消耗航天员大量的能量,因此NASA便想设计一种食品方案,让体积和承重有限的条件下多装载一些高卡路里的食物.</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>航天飞机的体积有限,当然如果载过重的物品,燃料会浪费很多钱,每件食品都有各自的体积、质量以及所含卡路里,在告诉你体积和质量的最大值的情况下,请输出能达到的食品方案所含卡路里的最大值,当然每个食品只能使用一次.</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行 两个数 体积最大值(&lt;400)和质量最大值(&lt;400)</p><p>第二行 一个数 食品总数N(&lt;50).</p><p>第三行－第3+N行</p><p>每行三个数 体积(&lt;400) 质量(&lt;400) 所含卡路里(&lt;500)</p><p>输出格式：</p><p>一个数 所能达到的最大卡路里(int范围内)</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">320 350</span><br><span class="line">4</span><br><span class="line">160 40 120</span><br><span class="line">80 110 240</span><br><span class="line">220 70 310</span><br><span class="line">40 400 220</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">550</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    01背包的变形题，题目有三个量v（体积），w（重量），val（价值），因此我们可以开一个二维dp数组dp【i】【j】代表最大体积是i，最大重量是j条件下的最大价值，最后dp【V】【W】即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int v[55], w[55], val[55];</span><br><span class="line">int dp[405][405] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int V, W, n;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;V, &amp;W);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;, &amp;v[i], &amp;w[i], &amp;val[i]);</span><br><span class="line">        for (int p = V; p &gt;= v[i]; p--) &#123;</span><br><span class="line">            for (int q = W; q &gt;= w[i]; q--) &#123;</span><br><span class="line">                dp[p][q] = max(dp[p - v[i]][q - w[i]] + val[i], dp[p][q]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[V][W]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1137旅行计划</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71137%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71137%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1137旅行计划/title9.jpg" alt="title9"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明要去一个国家旅游。这个国家有N个城市，编号为1至N，并且有M条道路连接着，小明准备从其中一个城市出发，并只往东走到城市i停止。</p><p>所以他就需要选择最先到达的城市，并制定一条路线以城市i为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。</p><p>现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的i，都需要你为小明制定一条路线，并求出以城市i为终点最多能够游览多少个城市。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行为两个正整数N,M。</p><p>接下来M行，每行两个正整数x,y，表示了有一条连接城市x与城市y的道路，保证了城市x在城市y西面。</p><p>输出格式：</p><p>N行，第i行包含一个正整数，表示以第i个城市为终点最多能游览多少个城市。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>均选择从城市1出发可以得到以上答案。</p><p>对于20%的数据，N≤100；</p><p>对于60%的数据，N≤1000；</p><p>对于100%的数据，N≤100000,M≤200000</p><p>思路：</p><p>​    这道题利用拓扑排序找到所有能够从i节点到达的节点j，令dp【j】 = dp【i】+ 1，最后dp数组就是所求</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int ru[100005] = &#123;0&#125;;</span><br><span class="line">int dp[100005] = &#123;0&#125;;</span><br><span class="line">vector&lt;int&gt;zcy[100005];</span><br><span class="line">queue&lt;int&gt;que;</span><br><span class="line"></span><br><span class="line">void tupo() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        if (!ru[i]) &#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!que.empty()) &#123;</span><br><span class="line">        int t = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for (int i = 0; i &lt; zcy[t].size(); i++) &#123;</span><br><span class="line">            int k = zcy[t][i];</span><br><span class="line">            dp[k] = max(dp[k], dp[t] + 1);</span><br><span class="line">            ru[k] --;</span><br><span class="line">            if (!ru[k]) que.push(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        zcy[a].push_back(b);</span><br><span class="line">        ru[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    tupo();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷1108低价购买</title>
      <link href="/2018/12/31/%E6%B4%9B%E8%B0%B71108%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0/"/>
      <url>/2018/12/31/%E6%B4%9B%E8%B0%B71108%E4%BD%8E%E4%BB%B7%E8%B4%AD%E4%B9%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/31/洛谷1108低价购买/title5.jpg" alt="title5"></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价(216216范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。</p><p>这里是某支股票的价格清单：</p><p>日期 1,2,3,4,5,6,7,8,9,10,11,121,2,3,4,5,6,7,8,9,10,11,12</p><p>价格68,69,54,64,68,64,70,67,78,62,98,8768,69,54,64,68,64,70,67,78,62,98,87</p><p>最优秀的投资者可以购买最多44次股票，可行方案中的一种是：</p><p>日期 2,5,6,102,5,6,10</p><p>价格 69,68,64,6269,68,64,62</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第1行: N(1≤N≤5000)N(1≤N≤5000)，股票发行天数</p><p>第2行: NN个数，是每天的股票价格。</p><p>输出格式：</p><p>两个数:最大购买次数和拥有最大购买次数的方案数(≤231≤231)当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">68 69 54 64 68 64 70 67 78 62 98 87</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题有两问，一问是求最长下降子序列，一个是求最长下降子序列的个数。我们可以先举个例子来看一下：设置f数组为最长下降子序列的长度，g数组为最长下降子序列的个数，对于样例：</p><p>val数组：3 7 6 4 5 5 3</p><p>f数组：1 1 2 3 3 3 4</p><p>g数组：1 1 1 1 0 1 2    </p><p>​    也就是说，g数组有三个规则：</p><pre><code>1. 当f【i】为1的时候，g【1】 = 12. 当f【i】==f【j】+1&amp;&amp;val【i】&lt; val【j】时，g【i】+= g【j】3. 当f【i】== f【j】&amp;&amp;val【i】==val【j】时，g【i】= 0</code></pre><p>最后max（f【i】）即是最长长度，所有f【i】==最长长度的g【i】的和即为个数</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using std::cin;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line"></span><br><span class="line">int val[5005] = &#123;0&#125;;</span><br><span class="line">int dp[5005][2] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">            if (val[j] &gt; val[i]) &#123;</span><br><span class="line">                dp[i][0] = std::max(dp[i][0], dp[j][0] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (dp[i][0] == 1) &#123;</span><br><span class="line">            dp[i][1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">            if (dp[i][0] == dp[j][0] + 1 &amp;&amp; val[j] &gt; val[i]) &#123;</span><br><span class="line">                dp[i][1] += dp[j][1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i][0] == dp[j][0] &amp;&amp; val[j] == val[i]) &#123;</span><br><span class="line">                dp[i][1] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxx = 1, sum = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        maxx = std::max(dp[i][0], maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (dp[i][0] == maxx) &#123;</span><br><span class="line">            sum += dp[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxx &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces1096DEasy Problem</title>
      <link href="/2018/12/29/CodeForces1096DEasy-Problem/"/>
      <url>/2018/12/29/CodeForces1096DEasy-Problem/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/29/CodeForces1096DEasy-Problem/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Vasya is preparing a contest, and now he has written a statement for an easy problem. The statement is a string of length 𝑛n consisting of lowercase Latin latters. Vasya thinks that the statement can be considered hard if it contains a subsequence hard; otherwise the statement is easy. For example, hard, hzazrzd, haaaaard can be considered hard statements, while har, hart and drah are easy statements. </p><p>Vasya doesn’t want the statement to be hard. He may remove some characters from the statement in order to make it easy. But, of course, some parts of the statement can be crucial to understanding. Initially the ambiguity of the statement is 00, and removing 𝑖i-th character increases the ambiguity by 𝑎𝑖ai (the index of each character is considered as it was in the original statement, so, for example, if you delete character r from hard, and then character d, the index of d is still 44 even though you delete it from the string had).</p><p>Vasya wants to calculate the minimum ambiguity of the statement, if he removes some characters (possibly zero) so that the statement is easy. Help him to do it!</p><p>Recall that subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.</p><p>Input</p><p>The first line contains one integer 𝑛n (1≤𝑛≤1051≤n≤105) — the length of the statement.</p><p>The second line contains one string 𝑠s of length 𝑛n, consisting of lowercase Latin letters — the statement written by Vasya.</p><p>The third line contains 𝑛n integers 𝑎1,𝑎2,…,𝑎𝑛a1,a2,…,an (1≤𝑎𝑖≤9982443531≤ai≤998244353).</p><p>Output</p><p>Print minimum possible ambiguity of the statement after Vasya deletes some (possibly zero) characters so the resulting statement is easy.</p><p>Examples</p><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">hhardh</span><br><span class="line">3 2 9 11 7 1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">hhzarwde</span><br><span class="line">3 2 6 9 4 8 7 1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">hhaarr</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给你一个n个字符的字符串，每个字符都有一个权制，问你删除最小的权值，使得剩下的字符串里不包含子序列hard。问最小删除的字符的权值和是多少？</p><p>思路：</p><p>​    求最小删除的字符权值和，我们可以转化为求剩余不包含子序列hard的字符串的最大权值。我们可以设dp{i}{j}代表第i个字符为第j种状态的最大权值（状态共有5种，0代表0～i全部子序列都不包含h，1代表0～i全部子序列最多包含h，2代表0～i全部子序列最多包含ha，3代表0～i全部子序列最多包含har，4代表0～i全部子序列最多包含hard，最后dp{n}{0～3}的最大值即为答案）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char s[100005];</span><br><span class="line">long long dp[100005][5];</span><br><span class="line">long long val[100005];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">    long long sum = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;val[i]), sum += val[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (s[i] == &apos;h&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0];</span><br><span class="line">            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]) + val[i];</span><br><span class="line">            for (int j = 2; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (s[i] == &apos;a&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + val[i];</span><br><span class="line">            dp[i][1] = dp[i - 1][1];</span><br><span class="line">            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + val[i];</span><br><span class="line">            for (int j = 3; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (s[i] == &apos;r&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + val[i];</span><br><span class="line">            dp[i][1] = dp[i - 1][1] + val[i];</span><br><span class="line">            dp[i][2] = dp[i - 1][2];</span><br><span class="line">            dp[i][3] = max(dp[i - 1][2], dp[i - 1][3]) + val[i];</span><br><span class="line">            for (int j = 4; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (s[i] == &apos;d&apos;) &#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + val[i];</span><br><span class="line">            dp[i][1] = dp[i - 1][1] + val[i];</span><br><span class="line">            dp[i][2] = dp[i - 1][2] + val[i];</span><br><span class="line">            dp[i][3] = dp[i - 1][3];</span><br><span class="line">            dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]) + val[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long long mx = 0;</span><br><span class="line">    for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">        mx = max(mx, dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, sum - mx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb复习(三)</title>
      <link href="/2018/12/26/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%89/"/>
      <url>/2018/12/26/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/26/JavaWeb复习三/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="三-创建和部署MVC-Web应用"><a href="#三-创建和部署MVC-Web应用" class="headerlink" title="三 创建和部署MVC Web应用"></a>三 创建和部署MVC Web应用</h1><h2 id="3-1-一个简单应用的组成"><a href="#3-1-一个简单应用的组成" class="headerlink" title="3.1 一个简单应用的组成"></a>3.1 一个简单应用的组成</h2><p>​    一个简单Web应用包括html表单、servlet控制器、一个模型（普通Java类）、一个xml部署描述文件、一个jsp视图</p><h2 id="3-2-步骤"><a href="#3-2-步骤" class="headerlink" title="3.2 步骤"></a>3.2 步骤</h2><h3 id="3-2-1-分析用户视图以及高层体系结构"><a href="#3-2-1-分析用户视图以及高层体系结构" class="headerlink" title="3.2.1 分析用户视图以及高层体系结构"></a>3.2.1 分析用户视图以及高层体系结构</h3><p><img src="/2018/12/26/JavaWeb复习三/1.png" alt="1"></p><h4 id="3-2-1-1对于访问链接："><a href="#3-2-1-1对于访问链接：" class="headerlink" title="3.2.1.1对于访问链接："></a>3.2.1.1对于访问链接：</h4><p>根据上图：</p><p>​    1:客户请求访问页面    </p><p>​    2.容器找到html页面</p><p>​    3.容器把页面返还给浏览器</p><h4 id="3-2-1-2-对于访问servlet："><a href="#3-2-1-2-对于访问servlet：" class="headerlink" title="3.2.1.2 对于访问servlet："></a>3.2.1.2 对于访问servlet：</h4><p>根据上图：</p><p>​    4:客户把请求数据发送给容器</p><p>​    5.容器根据url找到对应的servlet，并把请求传递给这个servlet</p><p>​    6.servlet调用模型（普通java类）</p><p>​    7.类返回一个结果，servelet把回答增加到请求对象</p><p>​    8.servlet把请求转给jsp</p><p>​    9.jsp从请求对象得到答案</p><p>​    10.jsp为生成容器生成页面</p><p>​    11.容器把页面返回给用户</p><h3 id="3-3-2-创建项目的开发环境"><a href="#3-3-2-创建项目的开发环境" class="headerlink" title="3.3.2 创建项目的开发环境"></a>3.3.2 创建项目的开发环境</h3><p>​    MVC项目的标准层级结构</p><p><img src="/2018/12/26/JavaWeb复习三/2.png" alt="2"></p><h3 id="3-3-3-创建项目的部署环境"><a href="#3-3-3-创建项目的部署环境" class="headerlink" title="3.3.3 创建项目的部署环境"></a>3.3.3 创建项目的部署环境</h3><p>​    Tomcat的层级结构：</p><p><img src="/2018/12/26/JavaWeb复习三/3.png" alt="3">    </p><h3 id="3-3-4-对Web应用各组件进行迭代开发和测试"><a href="#3-3-4-对Web应用各组件进行迭代开发和测试" class="headerlink" title="3.3.4 对Web应用各组件进行迭代开发和测试"></a>3.3.4 对Web应用各组件进行迭代开发和测试</h3><h4 id="3-3-4-1-构建和测试html表单"><a href="#3-3-4-1-构建和测试html表单" class="headerlink" title="3.3.4.1 构建和测试html表单"></a>3.3.4.1 构建和测试html表单</h4><h5 id="3-3-4-1-1-构建："><a href="#3-3-4-1-1-构建：" class="headerlink" title="3.3.4.1.1 构建："></a>3.3.4.1.1 构建：</h5><p>​    举个例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>填写表单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--html认为/login就是要调用的servlet(客户知道的url名)，在项目目录结构中并不存在--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"haha"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/login"</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"men"</span>&gt;</span>男</span><br><span class="line">             <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"women"</span>&gt;</span>女</span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"SUBMIT"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-3-4-1-2-部署和测试"><a href="#3-3-4-1-2-部署和测试" class="headerlink" title="3.3.4.1.2:部署和测试"></a>3.3.4.1.2:部署和测试</h5><p>​    1.在开发环境中创建html，然后保持在项目名/web下</p><p>​    2.把html文件的副本放在tomcat/webapps/项目名中</p><p>​    3.创建web.xml文档，保存在开发环境项目名/etc下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--该部署文件的主要目的是定义逻辑名与实际类文件之间的映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>部署名<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>类文件的完全限定名<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>部署名<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--.do只是一个约定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/用户可知的url名.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    4.把web.xml文件的副本放在/tomcat/webapps/项目名/WEB-INF目录下</p><p>​    5.启动tomcat（cd到tomcat主目录，然后运行/bin/startup.sh）</p><p>​    6.测试页面（输入<a href="http://localhost:8080/项目名）" target="_blank" rel="noopener">http://localhost:8080/项目名）</a></p><h4 id="3-3-4-2-构建控制器servlet第一个版本"><a href="#3-3-4-2-构建控制器servlet第一个版本" class="headerlink" title="3.3.4.2 构建控制器servlet第一个版本"></a>3.3.4.2 构建控制器servlet第一个版本</h4><h5 id="3-3-4-2-1-编写servlet"><a href="#3-3-4-2-1-编写servlet" class="headerlink" title="3.3.4.2.1 编写servlet"></a>3.3.4.2.1 编写servlet</h5><p>​    利用html表单测试这个控制器（确保html页面能适当调用servlet，且servlet能正确接收html参数）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写doPost方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"haha&lt;br&gt;"</span>);</span><br><span class="line">        <span class="comment">//获取表单中的name信息（根据html标记中的name属性匹配）</span></span><br><span class="line">        String s = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        out.println(<span class="string">"he is "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-4-2-2-编译servlet"><a href="#3-3-4-2-2-编译servlet" class="headerlink" title="3.3.4.2.2 编译servlet"></a>3.3.4.2.2 编译servlet</h5><p>​    命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//切到项目目录下</span><br><span class="line">cd project</span><br><span class="line">//路径根据不同的存放目录是不同的，tomcat之后是相同的</span><br><span class="line">//-d用来告诉编译器，.class文件放在适当包结构中的clases目录下</span><br><span class="line">javac -classpath /路径/tomcat/common/lib/servlet-api.jar:classes:. -d classes src/com/web/testServlet.java</span><br></pre></td></tr></table></figure><h5 id="3-3-4-2-3-部署servlet"><a href="#3-3-4-2-3-部署servlet" class="headerlink" title="3.3.4.2.3 部署servlet"></a>3.3.4.2.3 部署servlet</h5><p>​    创建.class文件副本，把它移到tomcat/项目/WEB-INF/classes/com/web下</p><h5 id="3-3-4-2-4-测试servlet"><a href="#3-3-4-2-4-测试servlet" class="headerlink" title="3.3.4.2.4 测试servlet"></a>3.3.4.2.4 测试servlet</h5><p>​    重启tomcat然后访问网页即可</p><h4 id="3-3-4-3-为模型类构建测试类，构建并测试模型类"><a href="#3-3-4-3-为模型类构建测试类，构建并测试模型类" class="headerlink" title="3.3.4.3 为模型类构建测试类，构建并测试模型类"></a>3.3.4.3 为模型类构建测试类，构建并测试模型类</h4><p>​    例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.model;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public String getName(String name) &#123;</span><br><span class="line">        String s = &quot;hello, &quot;;</span><br><span class="line">        s = s + name;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-4-servlet升级到第二版"><a href="#3-3-4-4-servlet升级到第二版" class="headerlink" title="3.3.4.4 servlet升级到第二版"></a>3.3.4.4 servlet升级到第二版</h4><h5 id="3-3-4-4-1-改写"><a href="#3-3-4-4-1-改写" class="headerlink" title="3.3.4.4.1 改写"></a>3.3.4.4.1 改写</h5><p>​    可以调用模型类,如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.web</span><br><span class="line"></span><br><span class="line">import com.model.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">pulbic class TestServlet extends HttpServlet &#123;</span><br><span class="line">    //重写doPost方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;</span><br><span class="line">        //新补充的内容：</span><br><span class="line">        String s = request.getParameter(&quot;name&quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        String s1 = t.getName(s);</span><br><span class="line">        </span><br><span class="line">        response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(&quot;haha&lt;br&gt;&quot;);</span><br><span class="line">        //获取表单中的name信息（根据html标记中的name属性匹配）</span><br><span class="line">        out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-4-4-2-部署"><a href="#3-3-4-4-2-部署" class="headerlink" title="3.3.4.4.2 部署"></a>3.3.4.4.2 部署</h5><p>​    1.编译servlet</p><p>​    2.将servlet文件的副本替换到之前的/tomcat/wabapps/项目/WEB-INF/classes/com/web下</p><p>​    3.把模型的class文件移动到/tomcat/wabapps/项目/WEB-INF/classes/com/model下</p><p>​    4.重启tomcat</p><p>​    5.打开浏览器浏览</p><h4 id="3-3-4-5-构建jsp，servlet升级到第三版"><a href="#3-3-4-5-构建jsp，servlet升级到第三版" class="headerlink" title="3.3.4.5 构建jsp，servlet升级到第三版"></a>3.3.4.5 构建jsp，servlet升级到第三版</h4><p>​    可以把表示分派到jsp完成</p><p>​    jsp代码如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.*"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;这是一个标题&lt;/h1&gt;</span><br><span class="line">        &lt;!-- &lt;% %&gt;标记里有一些标准Java代码--&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">        &lt;!--从这里从请求对象得到一个styles属性--&gt;</span><br><span class="line">        String s = (String)resquest.getAttribute(<span class="string">"styles"</span>);</span><br><span class="line">        out.print(<span class="string">"&lt;br&gt;"</span> + s);</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>​    然后将jsp文件保存在项目目录/web下</p><p>​    将它的副本移动到tomcat/项目名下</p><p>​    servlet代码修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.web</span><br><span class="line"></span><br><span class="line">import com.model.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">pulbic class TestServlet extends HttpServlet &#123;</span><br><span class="line">    //重写doPost方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;</span><br><span class="line">        //新补充的内容：</span><br><span class="line">        String s = request.getParameter(&quot;name&quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        String s1 = t.getName(s);</span><br><span class="line">        </span><br><span class="line">        //response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        //PrintWriter out = response.getWriter();</span><br><span class="line">        //out.println(&quot;haha&lt;br&gt;&quot;);</span><br><span class="line">        //获取表单中的name信息（根据html标记中的name属性匹配）</span><br><span class="line">        //out.println(s1);</span><br><span class="line">        </span><br><span class="line">        //为请求对象增加styles属性，供jsp使用</span><br><span class="line">        request.setAttribute(&quot;styles&quot;, s1);</span><br><span class="line">        //为jsp实例化一个请求分派器</span><br><span class="line">        RequestDispatcher view = request.getRequestDispatcher(&quot;test.jsp&quot;);</span><br><span class="line">        //使用请求分派器要求容器准备好jsp，并向jsp发送请求和响应</span><br><span class="line">        view.forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    重新部署servlet即可，重启tomcat查看</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb复习(二)</title>
      <link href="/2018/12/25/JavaWeb%E5%A4%8D%E4%B9%A0%E4%BA%8C/"/>
      <url>/2018/12/25/JavaWeb%E5%A4%8D%E4%B9%A0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/25/JavaWeb复习二/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="二-web应用体系结构"><a href="#二-web应用体系结构" class="headerlink" title="二.web应用体系结构"></a>二.web应用体系结构</h1><h2 id="2-1-web容器"><a href="#2-1-web容器" class="headerlink" title="2.1 web容器"></a>2.1 web容器</h2><p>​    Servlet没有main()方法，它受控于另一个Java应用，这个Java应用被称为Web容器，Tomcat就是这样一个容器。</p><p>​    对于每个请求，Web容器可以实例化servlet（或至少建一个新线程），可以调用servlet的doPost()或doGet()方法，把方法的重要参数(http请求和http响应对象)交给servlet，可以管理servlet的生死以及servlet的资源</p><h3 id="2-1-1-指向某servlet请求的流程"><a href="#2-1-1-指向某servlet请求的流程" class="headerlink" title="2.1.1 指向某servlet请求的流程"></a>2.1.1 指向某servlet请求的流程</h3><p>​    Web服务器应用得到指向某servlet请求后，此时服务器将请求交给部署该servlet的容器，由容器向servlet提供http请求和响应，并且由容器调用servlet的方法（如doPost()、doGet()）</p><p><img src="/2018/12/25/JavaWeb复习二/1.png" alt="1"></p><p>​    最后线程结束，容器把响应对象转换为一个http响应，并把它返回浏览器，然后删除请求和响应对象</p><h3 id="2-1-2-容器的作用"><a href="#2-1-2-容器的作用" class="headerlink" title="2.1.2 容器的作用"></a>2.1.2 容器的作用</h3><p>​    1.通信支持：利用容器提供的方法，可以让servlet和Web服务器对话，无需自己建立ServerSocket、监听端口、创建流等</p><p>​    2.生命周期管理：它能负责加载类、实例化和初始化Servlet、调用servlet方法以及垃圾回收。有了容器的控制，就不用太多考虑资源管理</p><p>​    3.多线程支持：容器会自动为它接受的每个servlet请求创建一个新的线程。servlet已经运行完相应的http方法，线程就会自动结束</p><p>​    4.声明方式实现安全：利用容器，可以使用xml部署描述文件来配置安全性，而不必将其硬编码写到servlet类代码中</p><p>​    5.JSP支持：容器可以将JSP代码翻译成真正的Java</p><p>​    因此说，有了容器我们可以更专注自己的业务逻辑，而不用过多考虑线程管理、安全性和网络通信等底层服务</p><h2 id="2-2-关于Servlet名称"><a href="#2-2-关于Servlet名称" class="headerlink" title="2.2 关于Servlet名称"></a>2.2 关于Servlet名称</h2><h3 id="2-2-1-Servlet的三个名字"><a href="#2-2-1-Servlet的三个名字" class="headerlink" title="2.2.1 Servlet的三个名字"></a>2.2.1 Servlet的三个名字</h3><p>​    1.客户知道的URL名（虚拟的名字，完全为客户提供）</p><p>​    2.部署servlet人员定义的部署名（虚拟的内部名，只用于部署Servlet）</p><p>​    3.实际的文件名（开发人员的Servlet类拥有一个完全限定名，包括类名和包名）</p><h3 id="2-2-2-Servlet多个名字的好处"><a href="#2-2-2-Servlet多个名字的好处" class="headerlink" title="2.2.2 Servlet多个名字的好处"></a>2.2.2 Servlet多个名字的好处</h3><p>​    1.灵活性高，移动文件而不必担心后期维护</p><p>​    2.安全性高，对客户隐藏了服务器的目录结构</p><h2 id="2-3-关于部署文件"><a href="#2-3-关于部署文件" class="headerlink" title="2.3 关于部署文件"></a>2.3 关于部署文件</h2><p>​    部署文件会告诉容器如何运行servlet和jsp：</p><p>​    1.可以使用两个xml元素把url映射到servlet</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         version=&quot;2.4&quot;&gt;</span><br><span class="line">    &lt;!--一个部署描述文件可以声明多个servlet--&gt;</span><br><span class="line">    &lt;!--servlet-name把servlet和servlet-mapping元素绑定在一起--&gt;</span><br><span class="line">    &lt;!--servlet元素告诉容器哪个类文件属于一个特定Web应用--&gt;</span><br><span class="line">    &lt;1--servlet-name是部署名--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;!--servlet-class是java类,也就是类的完全限定名--&gt;</span><br><span class="line">        &lt;servlet-class&gt;testServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;test Servlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;!--url-pattern是客户所用的请求名，也就是用户知道的url名--&gt;</span><br><span class="line">        &lt;url-pattern&gt;/Serv1&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>​    2.对Web应用的安全角色、错误页面、标记库、初始配置信息等方面进行定制</p><p>​    也就是说，利用部署描述文件，可以利用一种声明方式修改应用，而无需修改源代码</p><h2 id="2-4-MVC设计模式"><a href="#2-4-MVC设计模式" class="headerlink" title="2.4 MVC设计模式"></a>2.4 MVC设计模式</h2><p>​    若不使用mvc设计模式，那么流程图servlet请求的流程图如下：</p><p><img src="/2018/12/25/JavaWeb复习二/2.png" alt="2"></p><p>​    我们发现业务逻辑与表示之间有很强的联系，因为我们需要在两者之间放别的东西，使得业务逻辑本身就能作为一个可重用的Java类。</p><p>​    因此，我们引入模型-视图-控制器（MVC）设计模式，它的核心就是把业务逻辑从servlet中抽出来，放到一个模型中（模型就是可重用的普通java类，它是业务数据和处理该数据的方法组合）</p><h2 id="2-5-J2EE"><a href="#2-5-J2EE" class="headerlink" title="2.5 J2EE"></a>2.5 J2EE</h2><p>​    J2EE是一种超级规范，它结合了sevlets、jsp、ejb规范。一个完全兼容j2EE应用服务器必须有一个web容器和一个ejb容器。</p><p>​    tomcat是一个web容器，而不是一个完整的j2EE应用服务器</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb复习(一)</title>
      <link href="/2018/12/24/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%80/"/>
      <url>/2018/12/24/JavaWeb%E5%A4%8D%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>​                          <img src="/2018/12/24/JavaWeb复习一/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><h2 id="1-1-web应用"><a href="#1-1-web应用" class="headerlink" title="1.1 web应用"></a>1.1 web应用</h2><p>​    一个JavaWeb应用：java+servlet+jsp</p><h2 id="1-2-流程"><a href="#1-2-流程" class="headerlink" title="1.2 流程"></a>1.2 流程</h2><p>​    web服务器用于接受客户需求，然后向客户返回一些结果</p><p>​    浏览器就是一个软件，它可以与服务器通信，能够解释html代码，并将web页面呈现给用户</p><p>​    流程如下：</p><p><img src="/2018/12/24/JavaWeb复习一/1.png" alt="1"></p><p>​    web上浏览器和服务器的大多数通信都是使用http协议完成，http协议支持简单的请求和响应会话，浏览器（客户）发送一个http请求，服务器会用一个http响应做应答。</p><p>​    总结就是：1.html告诉浏览器如何向用户显示内容</p><p>​                2.http是web上客户和服务器进行通信用的协议</p><p>​                3.服务器使用http向客户（浏览器）发送html</p><h2 id="1-3-HTTP协议"><a href="#1-3-HTTP协议" class="headerlink" title="1.3 HTTP协议"></a>1.3 HTTP协议</h2><p>​    http协议是TCP/IP的上层协议（TCP用于保证从一个网络节点向另一个网络节点发送的文件能完整到达，IP是一个底层协议，负责把数据块沿路移动/路由到目的地），需要依赖TCP/IP从一处向另一处完整地传送请求和响应</p><p>​    http会话的结构是一个简单的请求/响应序列：浏览器发出请求，服务器做出响应</p><h2 id="1-4-请求流-响应流要素"><a href="#1-4-请求流-响应流要素" class="headerlink" title="1.4 请求流/响应流要素"></a>1.4 请求流/响应流要素</h2><h3 id="1-4-1请求流关键要素："><a href="#1-4-1请求流关键要素：" class="headerlink" title="1.4.1请求流关键要素："></a>1.4.1请求流关键要素：</h3><p>​    1.http方法</p><p>​    2.要访问的页面(URL)    </p><p>​    3.表单参数（如方法参）</p><h3 id="1-4-2响应流关键要素："><a href="#1-4-2响应流关键要素：" class="headerlink" title="1.4.2响应流关键要素："></a>1.4.2响应流关键要素：</h3><p>​    1.状态码（表明请求是否成功）</p><p>​    2.内容类型（包括文本、图片、html等）</p><p>​    3.内容（具体的html、图片等）</p><h2 id="1-5-http请求"><a href="#1-5-http请求" class="headerlink" title="1.5 http请求"></a>1.5 http请求</h2><p>​    http协议有很多请求方法，常用的有get方法和post方法</p><h3 id="1-5-1-get请求"><a href="#1-5-1-get请求" class="headerlink" title="1.5.1 get请求"></a>1.5.1 get请求</h3><p>​    get是最简单的http方法，用于要求服务器获取一个资源并把资源发过来</p><p>特点：</p><p>​    1.get发送数据是有限的（取决于服务器）</p><p>​    2.get发送的数据会追加到url后，所以发送的数据完全暴露（通过?符隔开，两部分加在一起，整个串组成完整的请求url）</p><h4 id="1-5-1-1get请求解析"><a href="#1-5-1-1get请求解析" class="headerlink" title="1.5.1.1get请求解析"></a>1.5.1.1get请求解析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//GET代表http方法， /books/test.jsp 为web服务器上资源的路径</span><br><span class="line">//sex=man&amp;name=Professional为参数</span><br><span class="line">//HTTP/1.1 为协议的版本</span><br><span class="line">GET /books/test.jsp?sex=man&amp;name=Professional HTTP/1.1//请求行</span><br><span class="line">//以下是请求首部</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept: text/xml,application/xml,text/html;q=0.9,text/plain</span><br></pre></td></tr></table></figure><h3 id="1-5-2-post请求"><a href="#1-5-2-post请求" class="headerlink" title="1.5.2 post请求"></a>1.5.2 post请求</h3><p>​    post方法可以请求某个东西，与此同时可以向服务器发送一些表单数据</p><h4 id="1-5-2-1post请求解析"><a href="#1-5-2-1post请求解析" class="headerlink" title="1.5.2.1post请求解析"></a>1.5.2.1post请求解析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//POST代表http方法， /advisor/test.do 为web服务器上资源的路径</span><br><span class="line">//HTTP/1.1 为协议的版本</span><br><span class="line">POST /advisor/test.do HTTP/1.1//请求行</span><br><span class="line">//以下到空行为请求首部</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept: text/xml,application/xml,text/html;q=0.9,text/plain</span><br><span class="line">（----此处空一行----）</span><br><span class="line">//以下为消息体</span><br><span class="line">color=dark&amp;taste=malty</span><br></pre></td></tr></table></figure><h3 id="1-5-3其他方法"><a href="#1-5-3其他方法" class="headerlink" title="1.5.3其他方法"></a>1.5.3其他方法</h3><p>​    比如head、trace、put、delete、options、connect等方法</p><h2 id="1-6-http响应"><a href="#1-6-http响应" class="headerlink" title="1.6 http响应"></a>1.6 http响应</h2><p>​    http响应可以包含html，http还会在响应内容前增加首部信息，而浏览器使用首部信息来帮助处理html页面</p><h3 id="1-6-1响应解析"><a href="#1-6-1响应解析" class="headerlink" title="1.6.1响应解析"></a>1.6.1响应解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//以下为http响应首部</span><br><span class="line">//HTTP/1.1为http协议版本 200为http状态码 OK为状态码的相应文本</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate</span><br><span class="line">Date: Tue, 26 Jul 2016 09:32:11 GMT</span><br><span class="line">Expires: Tue, 26 Jul 2016 09:32:12 GMT</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 3892</span><br><span class="line">//Content-Type响应首部的值称为MIME类型，用于告诉浏览器要接收的数据是什么类型,它的值域请求首部的Accept值相关</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Last-Modified: Tue, 26 Jul 2016 09:32:12 GMT</span><br></pre></td></tr></table></figure><h2 id="1-7-端口"><a href="#1-7-端口" class="headerlink" title="1.7 端口"></a>1.7 端口</h2><p>​    端口是一个16位的数(范围0～2^16 - 1)，用于标识服务器硬件上一个特定的软件程序</p><p>。它并不是一个可以插入物理设备的位置，只表示服务器应用的“逻辑“数。从0～1023的端口号已经保留，由一些众所周知的服务使用</p><h3 id="1-7-1-常用端口"><a href="#1-7-1-常用端口" class="headerlink" title="1.7.1 常用端口"></a>1.7.1 常用端口</h3><p>​    21：FTP</p><p>​    23：Telnet</p><p>​    25：SMTP</p><p>​    37：Time</p><p>​    80：HTTP</p><p>​    443：HTTPS</p><p>​    110：POP3</p><h2 id="1-8-Web服务器"><a href="#1-8-Web服务器" class="headerlink" title="1.8 Web服务器"></a>1.8 Web服务器</h2><p>​    两个常用的Web服务器，一个是Apache，另一个是Tomcat</p><h2 id="1-9-静态-动态Web页面"><a href="#1-9-静态-动态Web页面" class="headerlink" title="1.9 静态/动态Web页面"></a>1.9 静态/动态Web页面</h2><p>​    静态页面只是原封不动的在目录中，服务器找到静态页面，并把它原样传给客户</p><p>​    对于动态页面而言，Web服务器上有一个辅助应用可以生成非静态的即时页面且能与web服务器通信。每当请求到来时，辅助应用具体写出html，web服务器再把这个html响应到浏览器。辅助应用是一个CGI程序（CGI代表公共网关接口）</p><h3 id="1-9-1-动态页面生成流程"><a href="#1-9-1-动态页面生成流程" class="headerlink" title="1.9.1 动态页面生成流程"></a>1.9.1 动态页面生成流程</h3><p>​    举个动态页面显示当前日期的例子：</p><p><img src="/2018/12/24/JavaWeb复习一/2.png" alt="2"></p><h2 id="1-10-Servlet"><a href="#1-10-Servlet" class="headerlink" title="1.10 Servlet"></a>1.10 Servlet</h2><p>​    Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用于交互式地浏览和修改数据，生成动态Web内容</p><h3 id="1-10-1-Servlet编写、部署、运行"><a href="#1-10-1-Servlet编写、部署、运行" class="headerlink" title="1.10.1 Servlet编写、部署、运行"></a>1.10.1 Servlet编写、部署、运行</h3><p>​    1.项目目录树和tomcat目录树如下：</p><p><img src="/2018/12/24/JavaWeb复习一/3.png" alt="3"></p><p>​    2.在src目录下编写testServlet.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是一个标准的Servlet声明</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testservlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest reque, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        java.util.Date today = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">        out.println(<span class="string">"&lt;html&gt; &lt;body&gt; &lt;h1&gt; time is &lt;/h1&gt; &lt;br&gt; today &lt;/body&gt; &lt;/html&gt;"</span> );</span><br><span class="line">        <span class="comment">//Java嵌套html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3.在etc创建一个部署描述文件web.xml（每个web应用都有一个部署描述文件）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个部署描述文件可以声明多个servlet--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet-name把servlet和servlet-mapping元素绑定在一起--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-class是java类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--url-pattern是客户所用的请求名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Serv1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    4.在project目录下编译servlet，生成的testServelet.class文件将会在classes目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath /yourpath/tomcat/common/lib/Servlet-api.jar -d classes src/testServlet.java</span><br></pre></td></tr></table></figure><p>​    5.将testServelet.class复制到WEB-INF/classes目录下，再把web.xml复制到WEB-INF目录下</p><p>​    6.从tomcat目录下启动tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure><p>​    7.打开浏览器，输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/test/Serv1//test为项目名，Servl为servlet名</span><br></pre></td></tr></table></figure><h2 id="1-11-JSP"><a href="#1-11-JSP" class="headerlink" title="1.11 JSP"></a>1.11 JSP</h2><p>​    在html中引入Java，就是jsp。</p><h3 id="1-11-1-示例"><a href="#1-11-1-示例" class="headerlink" title="1.11.1 示例"></a>1.11.1 示例</h3><p>举个当前日期的例子：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        The time is</span><br><span class="line">        &lt;%= <span class="keyword">new</span> java.util.Date() %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="1-11-2-好处"><a href="#1-11-2-好处" class="headerlink" title="1.11.2 好处"></a>1.11.2 好处</h3><p>​    1.使得Java开发人员处理Java，html开发人员开一专心处理Web（仅仅需要学如何调用具体Java方法）</p><p>​    2.避免html以某种格式放入一个String中导致错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim复制代码到终端外</title>
      <link href="/2018/12/22/vim%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BB%88%E7%AB%AF%E5%A4%96/"/>
      <url>/2018/12/22/vim%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BB%88%E7%AB%AF%E5%A4%96/</url>
      
        <content type="html"><![CDATA[<p>​                            <img src="/2018/12/22/vim复制代码到终端外/title5.jpg" alt="title5"></p><a id="more"></a><p>​    1) 打开 iTerm2 的偏好设置，找到General -&gt; Selection，取消 Copy to pasteboard on selection。</p><p>​    2)在 ~/.vimrc 里添加 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure><p>上面的步骤完成了以后，如果要复制整段代码，就按下面的步骤做：</p><p>​    1.vim打开某一文件，按 ESC 进入 normal 模式<br>​    2.v 进入 visual 模式。</p><p>​    3.shift+g 选中光标后的所有内容</p><p>​    4. y复制选中内容</p><p>​    5. cmd+v 粘贴代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下mysql无法启动的解决办法</title>
      <link href="/2018/12/19/Mac%E4%B8%8Bmysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/12/19/Mac%E4%B8%8Bmysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/19/Mac下mysql无法启动的解决办法/title4.jpg" alt="title4"></p><a id="more"></a><p>​    又到了做课设的日子～然后发现电脑里的mysql服务怎么都打不开，上网百度了一下，原因是某种情况下导致”/usr/local/MySQL/data”的拥有者发生了改变，所以只需要将其拥有者修改为“mysql“就可以了。（个人觉得是更改了管理员导致的吧）</p><p>​    这时候，我们只需要在终端中运行，mysql服务就能运行了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R mysql /usr/local/mysql/data1</span><br></pre></td></tr></table></figure><p>​    Over～</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据找前1000大</title>
      <link href="/2018/12/18/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%89%BE%E5%89%8D1000%E5%A4%A7/"/>
      <url>/2018/12/18/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%89%BE%E5%89%8D1000%E5%A4%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/海量数找前1000大/title3.jpg" alt="title3"></p><a id="more"></a><p>​    打个比方，在100亿个亿中，找前1000大的数，我们应该怎么办？</p><p>​    一般人上来可能会想，可以先排序（比如快排，分治等等），然后取前1000个，这样时间复杂度是O(nlogn)（n为100亿），这样肯定是不可以的​    </p><p>​    我们会发现，我们只需要对前1000个进行处理，而不是每个数都排序确定位置，因此我们可以对排序进行优化。打个比方对快排进行优化：取第一个数做基准，然后利用快排原理把比这个数小的移到左边，比这个数大的移到右边。若左边的数大于1000，直接把右边舍弃，对左边继续进行快排。若左边的数小于1000，记录左边数的个数m，然后对右边继续继续进行快排。此时找的是n - m - 1个数。循环执行直到找到1000，这种时间复杂度是O(n)，大概是2n左右吧。。</p><p>​    利用上边这种方法确实可以解决时间复杂度问题，可是要一次性读取全部的数据，100亿的int型大概需要占用40G内存，普通个人电脑是无法做到的。有的人会想，我可以把数据存在文件中，每次左边的数存1.txt里，右边的数存2.txt，根据上面的判断条件选择读取哪个文件即可。这样的想法不错，可是多次的读写操作，效率会变得很低很低。。。</p><p>​    这时候，我们可以考虑一下分布式，每个计算机负责一部分数据，并行计算前1000大并把数据传送到一个计算机汇总求总的前1000大</p><p>​    上述方法非常好，可是却需要受到硬件条件的限制。我们可以利用最小堆来实现求前1000大，首先取前1000个数构建最小堆，然后每读取一个数，若小于堆顶直接舍弃，若大于则扔掉堆顶，把该数加入到堆中。这样暂用内存不大，不受制于硬件条件，且时间复杂度为O(n)</p><p>​    以上墨迹这么多，就是给大家提供一种思考问题的思路，要考虑到方方面面，而不是单纯的时间复杂度那么简单。</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 探究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux一切皆文件</title>
      <link href="/2018/12/18/%E4%BA%86%E8%A7%A3Linux/"/>
      <url>/2018/12/18/%E4%BA%86%E8%A7%A3Linux/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/了解Linux/title2.jpg" alt="title2"></p><a id="more"></a><h4 id="1-一切皆文件"><a href="#1-一切皆文件" class="headerlink" title="1.一切皆文件"></a>1.一切皆文件</h4><p>​    Linux 一切皆文件，不仅是狭义上的文件，像键盘、打印机、虚拟终端，进程间通信和网络通信等输入/输出资源都是定义在文件系统空间下的字节流</p><p>​    好处：对于输入/输出资源，可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源    （注：api是应用程序编程接口）</p><p>​    操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用</p><p>​    在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式</p><p>​    注意点：Linux 文件是没有所谓的扩展名的，一个 Linux文件能否被执行与它是否可执行的属性有关，只要权限中有x就可以执行（不一定执行成功）虽然如此，但期望通过扩展名来了解该文件是什么东西，所以一般还会以适当的扩展名来表示该文件是什么</p><h4 id="2-物理存储机制："><a href="#2-物理存储机制：" class="headerlink" title="2.物理存储机制："></a>2.物理存储机制：</h4><p>​    磁性存储介质磁化后会保留被磁化状态，且状态能被读取和修改，磁化有两个方向可表示0和1，所以用磁性存储介质来存储信息<br>​    而硬盘就是把磁性存储介质做成多个盘片（包含数以亿计的磁性存储单位），并使用磁性读写头对盘片进行读写</p><p>​    由于硬盘中磁性存储单元众多，所以需要一套规则来规划信息如何存取，于是就有了物理、逻辑概念：</p><ol><li>一个硬盘有多张盘片叠成</li><li>每张盘片上的存储颗粒（一存储颗粒为1bit）成环形一圈圈地排布，每一圈称为磁道</li><li>每条磁道上都有一圈存储颗粒，每512*8（512byte，0.5KB）个存储颗粒作为一个扇区</li><li>扇区是硬盘最小的物理存储单位</li><li>N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置</li><li>簇是文件系统的最小存储单位</li><li>所有盘面上的同一磁道构成一个圆柱，称为柱面</li><li>柱面是系统分区的最小单位</li></ol><p>​        磁头读写文件时先分区读写，由inode编号（区内唯一的编号）找到对应磁道和扇区，然后一个柱面一个柱面地进行读写</p><p><img src="/2018/12/18/了解Linux/1.jpg" alt="1"></p><h4 id="3-Linux文件体系："><a href="#3-Linux文件体系：" class="headerlink" title="3.Linux文件体系："></a>3.Linux文件体系：</h4><p>​    Linux以文件的形式对计算机中的数据和硬件资源进行管理，反映在Linux的文件类型上就是：普通文件、目录文件（也就是文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信的接口）等等。而这些种类繁多的文件被Linux使用目录树进行管理（就是以根目录（/）为根，向下呈现分支状的一种树形结构）</p><h5 id="3-1-普通文件"><a href="#3-1-普通文件" class="headerlink" title="3.1. 普通文件"></a>3.1. 普通文件</h5><p>​    类似mp4、pdf这样应用层面上的文件类型都属于普通文件，Linux用户可以根据访问权限对普通文件进行查看、更改和删除</p><h5 id="3-2-目录文件"><a href="#3-2-目录文件" class="headerlink" title="3.2. 目录文件"></a>3.2. 目录文件</h5><p>​    目录文件包含了目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件</p><h5 id="3-3-链接文件"><a href="#3-3-链接文件" class="headerlink" title="3.3. 链接文件"></a>3.3. 链接文件</h5><p>​    类似快捷方式，是指向另一个文件的间接指针</p><h5 id="3-4-块设备文件和字符设备文件"><a href="#3-4-块设备文件和字符设备文件" class="headerlink" title="3.4. 块设备文件和字符设备文件"></a>3.4. 块设备文件和字符设备文件</h5><p>​    这些文件一般隐藏在/dev目录下，在进行设备读取和外设交互时会被使用到。比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</p><h5 id="3-5-管道文件"><a href="#3-5-管道文件" class="headerlink" title="3.5. 管道文件"></a>3.5. 管道文件</h5><p>​    主要用于进程间通讯</p><h5 id="6-套接字文件"><a href="#6-套接字文件" class="headerlink" title=".6. 套接字文件"></a>.6. 套接字文件</h5><p>​    用于进程间的网络通信，也可以用于本机之间的非网络通信，这些文件一般隐藏在/var/run目录下，证明着相关进程的存在</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2018/12/18/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/12/18/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/markdown语法/title1.jpg" alt="title1"></p><a id="more"></a><p>[TOC]</p><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><h4 id="2-目录"><a href="#2-目录" class="headerlink" title="2.目录"></a>2.目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TOC]//一般放在文章开头</span><br></pre></td></tr></table></figure><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure><h4 id="4-行内标记"><a href="#4-行内标记" class="headerlink" title="4.行内标记"></a>4.行内标记</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前面内容`行内标记内容`后面内容</span><br></pre></td></tr></table></figure><h4 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5.代码块"></a>5.代码块</h4><p><img src="/2018/12/18/markdown语法/1.png" alt="1"></p><h4 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[个人博客](wwww.ivan-zcy.top)</span><br></pre></td></tr></table></figure><h4 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片上传失败的备注](图片地址)</span><br></pre></td></tr></table></figure><h4 id="8-序表"><a href="#8-序表" class="headerlink" title="8.序表"></a>8.序表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//有序</span><br><span class="line">1. 内容</span><br><span class="line">2. 内容</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">//无序</span><br><span class="line">* 内容</span><br><span class="line">* 内容</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">//嵌套</span><br><span class="line">1. 内容</span><br><span class="line">1. 内容</span><br><span class="line">2. 内容</span><br><span class="line">2. 内容</span><br></pre></td></tr></table></figure><h4 id="9-选项"><a href="#9-选项" class="headerlink" title="9.选项"></a>9.选项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [] 选项名</span><br></pre></td></tr></table></figure><h4 id="10-分隔线"><a href="#10-分隔线" class="headerlink" title="10.分隔线"></a>10.分隔线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法一</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="11-跳转邮箱"><a href="#11-跳转邮箱" class="headerlink" title="11.跳转邮箱"></a>11.跳转邮箱</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;296763002@qq.com&gt;</span><br></pre></td></tr></table></figure><h4 id="12-字体倾斜"><a href="#12-字体倾斜" class="headerlink" title="12.字体倾斜"></a>12.字体倾斜</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法一：</span><br><span class="line">*内容*</span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">_内容_</span><br></pre></td></tr></table></figure><h4 id="13-字体加粗"><a href="#13-字体加粗" class="headerlink" title="13.字体加粗"></a>13.字体加粗</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//方法一：</span><br><span class="line">**内容**</span><br><span class="line"></span><br><span class="line">//方法二：</span><br><span class="line">__内容__</span><br></pre></td></tr></table></figure><h4 id="14-删除线"><a href="#14-删除线" class="headerlink" title="14.删除线"></a>14.删除线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~内容~~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github使用</title>
      <link href="/2018/12/18/Github%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/18/Github%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/18/Github使用总结/title.jpg" alt="title"></p><a id="more"></a><p>1.Github是什么？</p><p>​    gitHub是一个面向开源及私有软件项目的托管平台，上面托管了众多优秀的项目</p><p>2.Github常用术语：</p><p>——Repository<br>​    仓库，用于存储你的开源项目</p><p>——Issue<br>​    问题，用于对项目提出意见或建议，以及发现的Bug，修复了就可以Close掉</p><p>——Star<br>​    点赞，想拥有程序员这种完美主义者的赞很难。。。拥有几千赞感觉就逆天了，上万赞的或许只有那些顶级开源项目了。。</p><p>——Watch<br>​    观察，如果对某个项目设置了 Watch，那么该项目有任何更新都可以在第一时间收到通知</p><p>——Fork<br>​    分叉，如果你看到别人一个好的开源项目，你想要做些改进，就可以Fork对方的项目（本质上相当于新建了一个分支）</p><p>——clone</p><p>​    克隆，用于将代码克隆到本地</p><p>——Pull Request<br>​    发起请求，如果你Fork了别人的项目并做了改进，想要把自己的改进合并到对方的项目中，就可以发起合并请求。原作者如果同意，你的改进就加到了原项目中</p><p>——Gist<br>​    用于分享代码片段</p><p>——Organizations</p><p>​    组织，用于组织和团队</p><p>3创建自己的项目：</p><p>​    1) 点击右上角下三角号-&gt;New repository</p><p><img src="/2018/12/18/Github使用总结/1.png" alt="1"></p><p>​    2) 会出现如下界面：<img src="/2018/12/18/Github使用总结/2.png" alt="2"></p><p>​    这样一个项目就创建成功啦～</p><p>4.如何对其他开源项目进行贡献？</p><p>​    <img src="/2018/12/18/Github使用总结/3.png" alt="3"></p><p>1)fork</p><p>​    在想要修改的他人项目页面，点击右上角【fork】</p><p><img src="/2018/12/18/Github使用总结/4.jpg" alt="4"></p><p>​    这时候就会将该项目克隆到你的github仓库中</p><p>2)clone</p><p>​    在本地利用git clone命令，将项目克隆到自己电脑上</p><p><img src="/2018/12/18/Github使用总结/6.png" alt="6"></p><p><img src="/2018/12/18/Github使用总结/7.png" alt="7"></p><p>3)update</p><p>​    接下来就可以在本地对项目进行修改（建议在master上切出一个新分支进行修改，修改完后再将分支merge到master）</p><p>4)push</p><p>​    使用git push命令将改动同步到自己的gitHub项目仓库里</p><p><img src="/2018/12/18/Github使用总结/5.png" alt="5"></p><p>5)pull request</p><p>​    向原作者提交代码,点击文件列表上的【New pull request】</p><p><img src="/2018/12/18/Github使用总结/8.png" alt="8"></p><p>​    系统检查无误显示Able to merge后，就可以点击【Create pull request】进行提交</p><p><img src="/2018/12/18/Github使用总结/9.jpg" alt="9"></p><p>​    之后系统会让写一段注释，用于向原作者阐述你做了哪些修改和优化。若原作者同意将你的代码合并到原项目中，就可以点击【merge pull request】</p><p><img src="/2018/12/18/Github使用总结/10.jpg" alt="10"></p><p>5.修改其他开源项目时原项目发生改变时 如何保持同步？</p><p>1)fetch</p><p>​    先把原项目fetch到自己电脑本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch git@github.com:原作者/原作者项目 master:latest</span><br></pre></td></tr></table></figure><p>​    master是原项目分支，latest是自己项目分支。若latest分支不存在的话，将自动创建。其实也可以将代码fetch到自己的master分支，但不建议这么做</p><p>2)merge</p><p>​    代码fetch到latest分支之后，再切到master分支使用git merge命令将最新代码合并到master分支</p><p>3)push</p><p>​    再使用git push命令，就可以将最新代码推到自己的github项目中</p><p>参考：</p><p>​    <a href="https://www.itcodemonkey.com/article/10049.html" target="_blank" rel="noopener">如何在GitHub上大显身手？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛I乘胜追击</title>
      <link href="/2018/12/11/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BI%E4%B9%98%E8%83%9C%E8%BF%BD%E5%87%BB/"/>
      <url>/2018/12/11/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BI%E4%B9%98%E8%83%9C%E8%BF%BD%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/11/哈理工第八届校团队赛I乘胜追击/title2.jpg" alt="title2"></p><a id="more"></a><p>Description</p><p> 三国时期，群雄割据，战乱频繁。公元228年，孙权派番阳太守周鲂诱骗曹休派兵前来，曹休果然中计。待孙权任陆逊为大都督，朱桓、全琮为左、右督，各领兵三万人迎击曹休时，曹方知被欺。但其仗恃兵力占优，仍决定与吴国交战。彼时陆逊所率大军与与曹休所率大军于石亭展开激战。陆逊探得曹休于长江边共驻扎n座军营，相互以粮道连接，其中第1座军营为大本营。当第i(i&gt;=2)座军营被攻陷时，营中残兵败将将沿粮道向第f[i]座军营逃窜。陆逊极善用兵，常人用a[i]的兵力方能攻下第i座军营，而陆逊仅需a[i]-d[i]的兵力即可攻下。倘给陆以a[i]的兵力，则陆不仅能攻下第i座军营，还可乘胜追击，沿着军士逃跑方向攻下第f[i]座军营。陆逊善用兵如此，故而仅用了最少的兵力便大破曹休，攻下所有军营，生擒一万余人，缴获牛马驴骡车辆上万。试问陆逊于石亭之战中共用兵力几何？（以上史料来自百度百科且有删改，不保证真实准确性）  </p><p>Input  </p><p>第一行一个整数T(T&lt;=50)，代表数据组数在每组数据中：第一行一个整数n(2&lt;=n&lt;=50000)表示军营数目第二行有n-1个整数f【2】~f【n】(f【i】&lt;i)第三行有n个整数a【1】~a【n】(2&lt;=a【i】&lt;=1e9)第四行有n个整数d【1】~d【n】(1&lt;=d【i】&lt;a【i】)  </p><p>Output  </p><p>对于每组数据，输出一行一个整数，表示陆逊攻下所有军营所需使用的最少兵力  </p><p>Sample Input  </p><p>1</p><p>4</p><p>1 1 3</p><p>100 50 2 5</p><p>2 49 1 1  </p><p>Sample Output  </p><p>7  </p><p>Hint  </p><p>输入数据量较大，请合理控制输入效率。</p><p>样例解释：</p><p>首先使用2兵力攻击军营3，并追击至大本营1。然后使用5-1=4兵力攻击军营4。最后使用50-49=1兵力攻击军营2。共使用兵力2+4+1=7。</p><p>思路：</p><p>​    一道树形dp的题，比较难。二维数组dp【50005】【3】，其中dp【i】【0】代表以i本营为根节点的子树(攻打i本营无花费)的最小花费，dp【i】【1】代表以i本营为根节点的子树(攻打i本营花费a【i】- d【i】)的最小花费，dp【i】【2】代表以i本营为根节点的子树(攻打i本营花费a【i】)的最小花费。然后找到dp的递推式即可求出</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector &lt;int&gt; zcy[50005];</span><br><span class="line">int two[50005], one[50005];</span><br><span class="line">ll dp[50005][3];    //dp[i][0]代表无花费，dp[i][1]代表仅攻克自己，dp[i][2]代表连带攻克父节点</span><br><span class="line">ll minn[50005];</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    dp[inx][2] = two[inx];</span><br><span class="line">    dp[inx][1] = one[inx];</span><br><span class="line">    dp[inx][0] = 0;</span><br><span class="line">    for (int i = 0; i &lt; zcy[inx].size(); i++) &#123;</span><br><span class="line">        int ii = zcy[inx][i];</span><br><span class="line">        if (ii == father) continue;</span><br><span class="line">        dfs(ii, inx);</span><br><span class="line">        if (dp[ii][0]) &#123;</span><br><span class="line">            minn[i] = min(dp[ii][0], dp[ii][1]);</span><br><span class="line">            dp[inx][1] += minn[i];</span><br><span class="line">            dp[inx][2] += minn[i];</span><br><span class="line">            dp[inx][0] += minn[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn[i] = dp[ii][1];</span><br><span class="line">            dp[inx][1] += minn[i];</span><br><span class="line">            dp[inx][2] += minn[i];</span><br><span class="line">            dp[inx][0] += minn[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k = dp[inx][0];</span><br><span class="line">    if (k == 0) return;</span><br><span class="line">    int suu = 0;</span><br><span class="line">    for (int i = 0; i &lt; zcy[inx].size(); i++) &#123;</span><br><span class="line">        int ii = zcy[inx][i];</span><br><span class="line">        if (ii == father) continue;</span><br><span class="line">        if (!suu) &#123;</span><br><span class="line">            dp[inx][0] = k - minn[i] + dp[ii][2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[inx][0] = min(dp[inx][0], k - minn[i] + dp[ii][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        suu++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, a;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            zcy[i].push_back(a);</span><br><span class="line">            zcy[a].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;two[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;one[i]);</span><br><span class="line">            one[i] = two[i] - one[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, 0);</span><br><span class="line">        ll ans;</span><br><span class="line">        if(dp[1][0]) &#123;</span><br><span class="line">            ans = min(dp[1][0], dp[1][1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = dp[1][1];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018院个人赛、校团队赛总结</title>
      <link href="/2018/12/10/2018%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E4%B8%AA%E4%BA%BA%E8%B5%9B%E3%80%81%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/10/2018%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E4%B8%AA%E4%BA%BA%E8%B5%9B%E3%80%81%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/2018哈理工院个人赛、校团队赛总结/title.jpg" alt="title"></p><a id="more"></a><p>​    院个人赛拿了亚军，校团队赛185支队伍拿了第五名。还算满意，今天打算总结总结～</p><p>​    哈理工院个人赛12月2号举行，10道题4个小时。题目比较简单～</p><p>​    两道水题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐玩木桶/">跳转到小乐乐玩木桶</a> 和 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐玩木桶-1/">跳转到小乐乐玩木桶+</a>  刚上来没理解题意，之后就过了～</p><p>​    一道最长公共子序列裸题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐匹配字符串/">跳转到小乐乐匹配字符串</a> 随后就A了</p><p>​    一道简单的思维题没过多久也A了，有一个小小的坑点 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐的组合数/">跳转到小乐乐的组合数</a></p><p>​    一道博弈题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐学博弈/">跳转到小乐乐学博弈</a>     写了很多样例，抱着试试看的态度交了一发过了，没在深思原因</p><p>​    一道模拟题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐和25/">跳转到小乐乐和25</a> 我是用模拟写的，考验的是细心吧</p><p>​    一道状压dp题 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐搭积木/">跳转到小乐乐搭积木</a> 正好主攻dp和数论，这道题就笑纳啦</p><p>​    一道bfs题变形，调bug调到哭 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐打游戏/">跳转到小乐乐打游戏</a> 现场赛没做出来，可恨的是我之前做过也做出来了。。快哭了</p><p>​    一道dp题  <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐下象棋/">跳转到小乐乐下象棋</a> 哎当时脑子笨了没想到，赛后重做发现还是蛮简单的</p><p>​    还有一道防Ak题好像是一道主席树变形，自己不主攻线段树也做不出来了</p><p>​    最后拿了院赛的亚军还行吧，冠军被增林老哥拿去了。膜拜膜拜！Orz～</p><p>​    </p><p>​    哈理工校团队赛12月9号举行，哈工大出题，题目中等偏难～</p><p>​    刚上来热身赛三道题：第一道大模拟被队友A了，自己懒得再补～ 第二道是一个01背包的变形题，秒A  <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛热身B信小呆/">跳转到信小呆</a>  第三道是一个线性筛的变形题，也A了 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛热身C孪生素数猜想/">跳转到孪生素数猜想</a>  第一次AK，虽然是热身赛，也值得纪念一下，苦笑～</p><p>​    之后正式赛12道题5小时，最终做出来7个～</p><p>​    上来快速A掉一个暴力的水题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛B咕咕咕/">跳转到咕咕咕</a> </p><p>​    然后过了一道抽屉原理的题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛D所以我也想玩这个序列游戏/">跳转到所以我也想玩这个序列游戏</a> </p><p>​    队友过掉了一道二分题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛K汪汪汪/">跳转到汪汪汪</a> 赛后自己补了一下</p><p>​    随后过了一道01分数规划 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛H刘禅的课程/">跳转到刘禅的课程</a> </p><p>​    一道树形dp的题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛C树上路径计数/">跳转到树上路径计数</a> </p><p>​    随后队友过了一道几何题，队友用算式推出了12维空间求解点关于直线的对称点的公式，膜拜Orz～自己不会就不补了</p><p>​    然后过了一道篇难的数论题 <a href="http://www.ivan-zcy.top/2018/12/10/哈理工第八届校团队赛E格子染色计数/">跳转到格子染色计数</a> </p><p>​    赛后听题解I题也是一道树形dp，一直没往上靠，脑子好笨呀～赛后补了 <a href="http://www.ivan-zcy.top/2018/12/11/哈理工第八届校团队赛I乘胜追击/">跳转到乘胜追击</a></p><p>​    校赛第一不愧是亚洲区预赛金牌爷，10题膜拜膜拜Orz～ </p><p>​    现在西区计院和东区软件学院差距越来越大了，前四名全是西区，前十名8个西区。。。无力。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛E格子染色计数</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BE%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E8%AE%A1%E6%95%B0/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BE%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛E格子染色计数/title5.jpg" alt="title5"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>有排成一行的n个格子，你需要在 m 种颜色中选取 k 种颜色对这 n 个格子染色，要求k 种颜色都要使用，且相邻格子的颜色不同，求方案数（答案对 10^9 + 7取模）。  </p><p>Input  </p><p>第一行为测试数据组数T( 1 &lt;= T &lt;= 10).每组测试数据：第一行有两个个整数n, m, k. (1 &lt;= n, m &lt;= 1e9, k &lt;= 1e6)。  </p><p>Output  </p><p>一个整数, 为染色方案数, 输出答案对 1e9 + 7 取模.  </p><p>Sample Input  </p><p>3</p><p>3 4 2</p><p>3 4 3</p><p>3 4 4  </p><p>Sample Output  </p><p>12</p><p>24</p><p>0</p><p>思路：</p><p>​    这道题难度不小，需要利用卢卡斯定理+容斥定理+线性求阶乘逆元来求解～，答案为C(m,k)✖️(k✖️(k-1)^(n-1) - C(k,k-1)✖️(k-1)✖️(k-2)^(n-1) + C(k,k-2)✖️(k-2)✖️(k-3)^(n-1)…C(k,1)✖️1✖️0^(n-1))</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define N 1000000</span><br><span class="line">#define mod 1000000007</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line">ll fact[N + 5], inv[N + 5];</span><br><span class="line"></span><br><span class="line">ll extend(ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if(a == 0 &amp;&amp; b == 0) return -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = extend(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll reverse(ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = extend(a, n, x, y);</span><br><span class="line">    if (d == 1) return (x % n + n) % n;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    fact[0] = fact[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        fact[i] = fact[i - 1] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N] = reverse(fact[N], mod);</span><br><span class="line">    for (int i = N - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + 1] * (i + 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll C(ll n, ll m) &#123;</span><br><span class="line">    if (n &lt; m || m &lt; 0) return 0;</span><br><span class="line">    if (n &lt; mod) return fact[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">    return C(n / mod, m / mod) * C(n % mod, m % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ls(ll n, ll m) &#123;</span><br><span class="line">    if (n &lt; m || m &lt; 0) return 0;</span><br><span class="line">    ll mm = n - m;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    for (int i = mm + 1; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = i * ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans * inv[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while(b) &#123;</span><br><span class="line">        if (b &amp; 1) &#123;</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= 2;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        ll ans = ls(m, k);</span><br><span class="line">        ll t = k * quick(k - 1, n - 1) % mod;</span><br><span class="line">        int tot = -1;</span><br><span class="line">        for (int i = k - 1; i &gt;= 1; i --) &#123;</span><br><span class="line">            t = (t + tot * (C(k, i) * i % mod * quick(i - 1, n - 1) % mod) + mod) % mod;</span><br><span class="line">            tot = -tot;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * t % mod;</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛C树上路径计数</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BC%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BC%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛C树上路径计数/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>给定一棵有n个顶点的树，你需要统计出树上所有长度为奇数的路径数量。路径长度为经过边的条数。s 到 t 和 t 到 s视作相同。  </p><p>Input  </p><p>第一行为测试数据组数T( 1 &lt;= T &lt;= 5).每组测试数据：第一行有一个整数n（1 &lt;= n &lt;= 1e5），表示顶点数。接下来n - 1 行 每行两个整数u, v，表示u, v之间存在一条边。  </p><p>Output </p><p> 一个整数, 路径长度为奇数的数量。  </p><p>Sample Input  </p><p>2</p><p>2</p><p>1 2</p><p>4 </p><p>1 2</p><p>2 3</p><p>1 4  </p><p>Sample Output  </p><p>1</p><p>4</p><p>思路：</p><p>​    这道题典型的树形dp题，规定1节点为root，dp【i】【0】代表以i为根节点的子树的奇数子节点个数，dp【i】【1】代表以i为根节点的子树的偶数子节点个数，dp【1】【0】+dp【1】【0】✖️dp【1】【1】即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector &lt;int&gt;zcy[100005];</span><br><span class="line">int dp[100005][2];</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    for (int i = 0; i &lt; zcy[inx].size(); i++) &#123;</span><br><span class="line">        int ii = zcy[inx][i];</span><br><span class="line">        if(ii ==father) continue;</span><br><span class="line">        dfs(ii, inx);</span><br><span class="line">        dp[inx][0] += dp[ii][1] + 1;</span><br><span class="line">        dp[inx][1] += dp[ii][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, a, b;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            zcy[a].push_back(b);</span><br><span class="line">            zcy[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, 0);</span><br><span class="line">        ll ans = (ll)dp[1][0] * (dp[1][1] + 1);</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛H刘禅的课程</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BH%E5%88%98%E7%A6%85%E7%9A%84%E8%AF%BE%E7%A8%8B/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BH%E5%88%98%E7%A6%85%E7%9A%84%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛H刘禅的课程/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>刘禅对学习的态度让太傅操碎了心。刘禅有n种课程要学习（礼、乐、射、御、书、数等等），每个课程有对应的重要程度s[i]，刘禅估计了一下，机智的他算出了每个课程他最后能得到的分数c[i]， 太傅给出了他最终成绩的计算公式:</p><p><img src="/2018/12/10/哈理工第八届校团队赛H刘禅的课程/1.png" alt="1"></p><p> 现在他可以推迟k门课程，使得他剩下的n-k门课程的最终成绩尽量高，因为这样父皇才会让他出宫玩耍。机智的刘禅已经算出了答案，不过他想考考你。输出最高的不少于n-k门课程的最终成绩。    </p><p>Input  </p><p>多组数据，请读入到文件末尾（数据组数不超过10）第一行两个非负整数n, k(1≤ n≤ 1e5 , 0≤ k &lt; n) 第二行n个正整数s[i] 第三行n个正整数c[i]1&lt;=s[i],c[i]&lt;=1000  </p><p>Output  </p><p>一个实数，四舍五入保留6位小数  </p><p>Sample Input  </p><p>3 1 </p><p>1 2 3 </p><p>3 2 1  </p><p>Sample Output  </p><p>2.333333  </p><p>Hint  </p><p>去掉最后一门课程即可。</p><p>(2<em>2+3</em>1)/(2+1)=7/3</p><p>思路：</p><p>​    01分数规划的裸题，利用二分找结果ans，会得到si✖️ci/ si = ans ,只要贪心求的前n - k大的si✖️ci - ans✖️si的和，大于等于0返回1，否则返回0</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[100005], b[100005];</span><br><span class="line">int n, k;</span><br><span class="line">double t[100005];</span><br><span class="line"></span><br><span class="line">bool whd(double A, double B) &#123;</span><br><span class="line">    return A &gt; B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool zcy(double val) &#123;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        t[i] = a[i] - val * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(t, t + n, whd);</span><br><span class="line">    for (int i = 0; i &lt; n - k; i++) &#123;</span><br><span class="line">        sum += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &gt;= 0) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) &#123;</span><br><span class="line">        double minn = 0, maxx= 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            a[i] = a[i] * b[i];</span><br><span class="line">            if (maxx &lt; a[i]) &#123;</span><br><span class="line">                maxx = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double mid;</span><br><span class="line">        for (int i = 0; i &lt; 80; i++) &#123;</span><br><span class="line">            mid = (minn + maxx) / 2;</span><br><span class="line">            if (zcy(mid)) minn = mid;</span><br><span class="line">            else maxx = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.6f\n&quot;, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 二分 </tag>
            
            <tag> 01分数规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛K汪汪汪</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BK%E6%B1%AA%E6%B1%AA%E6%B1%AA/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BK%E6%B1%AA%E6%B1%AA%E6%B1%AA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛K汪汪汪/title7.jpg" alt="title7"></p><a id="more"></a><p>题意：</p><p>Description</p><p> 给n个区间[l, r]，判断是否存在区间交叉。即是否存在1 &lt;= i &lt; j &lt;= n，使得li &lt; lj &lt; ri &lt; rj。  </p><p>Input  </p><p>多组数据每组数据第一行一个整数n，第二行到第n + 1行每行两个数分别代表该区间的左右端点。  </p><p>Output  </p><p>如果存在交叉，输出“YES”；否则输出“NO”  </p><p>Sample Input  </p><p>2</p><p>1 3</p><p>2 4</p><p>3</p><p>1 7</p><p>2 4</p><p>5 6  </p><p>Sample Output  </p><p>YES</p><p>NO  </p><p>Hint  </p><p>1 &lt;= n &lt;= 1e5, 1 &lt;= li &lt; ri &lt;= 2e5, 每组数据中所有的l，r互不相同。所有组数据n的和不超过1e6.读入数据较大，请使用高效的读入方式。</p><p>思路：</p><p>​    利用sort按照l从小到大排序，若l相同则按照r从小到大排序，然后遍历，二分查找即可。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace IO &#123;</span><br><span class="line">    const int MX = 4e7;</span><br><span class="line">    char buf[MX];</span><br><span class="line">    int c, sz;</span><br><span class="line"></span><br><span class="line">    void begin() &#123;</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline bool read(int &amp;t) &#123;</span><br><span class="line">        while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++;</span><br><span class="line">        if (c &gt;= sz) return false;</span><br><span class="line">        bool flag = 0; if(buf[c] == &apos;-&apos;) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++)</span><br><span class="line">            t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        if(flag) t = -t;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int l, r;</span><br><span class="line">&#125;stu[100005];</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">bool zcy(node A, node B) &#123;</span><br><span class="line">    if (A.l == B.l) &#123;</span><br><span class="line">        return A.r &lt; B.r;</span><br><span class="line">    &#125;</span><br><span class="line">    return A.l &lt; B.l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int erfen(int val) &#123;</span><br><span class="line">    int star = 0, endd = n - 1;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    while(star &lt;= endd) &#123;</span><br><span class="line">        int mid = (star + endd) / 2;</span><br><span class="line">        if (stu[mid].l &lt;= val) &#123;</span><br><span class="line">            star = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            endd = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    IO::begin();</span><br><span class="line">    while (IO::read(n)) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            IO::read(stu[i].l);</span><br><span class="line">            IO::read(stu[i].r);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(stu, stu + n, zcy);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            int inx = erfen(stu[i].l);</span><br><span class="line">            if (inx == -1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = inx; j &lt; n &amp;&amp; stu[j].l &lt; stu[i].r; j++) &#123;</span><br><span class="line">                if(stu[j].r &gt; stu[i].r) &#123;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛D所以我也想玩这个序列游戏</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BD%E6%89%80%E4%BB%A5%E6%88%91%E4%B9%9F%E6%83%B3%E7%8E%A9%E8%BF%99%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BD%E6%89%80%E4%BB%A5%E6%88%91%E4%B9%9F%E6%83%B3%E7%8E%A9%E8%BF%99%E4%B8%AA%E5%BA%8F%E5%88%97%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛D所以我也想玩这个序列游戏/title6.jpg" alt="title6"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>今天dxy休息，他想出了一个序列游戏，具体描述如下：你有一个长度为n的正整数序列和一个正整数m，问其中是否存在一个非空子区间使得这个子区间的区间和是m的倍数。</p><p>Input  </p><p>多组数据，读入到文件结尾对于每一组数据第一行：两个数n,m第二行：n个正整数，表示题目中的序列n&lt;=10^6，m&lt;=2000，0&lt;a[i]&lt;=10^9  </p><p>Output  </p><p>对于每组数据输出一行：若存在所描述的区间，则输出YES，否则输出NO  </p><p>Sample Input  </p><p>5 3</p><p>1 2 3 4 5</p><p>5 100</p><p>1 2 3 4 5  </p><p>Sample Output  </p><p>YES</p><p>NO</p><p>思路：</p><p>​    这道题主要利用了抽屉原理，长度为n的一个数组，若n大于等于m，则一定存在一个子区间的和是m的倍数。当n &lt; m时，由于m小于2000，直接暴力求解即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">int a[1000005];</span><br><span class="line">ll sum[1000005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            sum[i] = sum[i - 1] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &gt;= m) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int len = 1; len &lt;= n; len++) &#123;</span><br><span class="line">            for (int i = 1; i + len - 1 &lt;= n; i++) &#123;</span><br><span class="line">                if ((sum[i + len - 1] - sum[i - 1]) % m == 0) &#123;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 抽屉原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛B咕咕咕</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BB%E5%92%95%E5%92%95%E5%92%95/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9BB%E5%92%95%E5%92%95%E5%92%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛B咕咕咕/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>给你一个字符串，请数出有多少个连续字符串<strong>”CCPC”，</strong>不区分大小写。  </p><p>Input  </p><p>输入第一行是数据组数T（T&lt;=10）接下来T行每行有一个字符串。（字符串仅由大小写英文字母构成，长度&lt;=100000）  </p><p>Output  </p><p>输出T行，每行输出对应字符串中”CCPC”的个数  </p><p>Sample Input  </p><p>2</p><p>CCpc</p><p>aCCpcCpcecpC  </p><p>Sample Output  </p><p>1</p><p>2</p><p>思路：</p><p>​    大水题，暴力就完了～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char s[100005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        scanf(&quot;%s&quot;, s);</span><br><span class="line">        int n = strlen(s);</span><br><span class="line">        for (int i = 0; i &lt; n - 3;i++) &#123;</span><br><span class="line">            if ((s[i] == &apos;C&apos; || s[i] == &apos;c&apos;) &amp;&amp; (s[i + 1] == &apos;C&apos; || s[i + 1] == &apos;c&apos; ) &amp;&amp; (s[i + 2] == &apos;P&apos; || s[i + 2] == &apos;p&apos;) &amp;&amp; (s[i + 3] == &apos;C&apos; || s[i + 3] == &apos;c&apos;)) &#123;</span><br><span class="line">                sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛热身B信小呆</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABB%E4%BF%A1%E5%B0%8F%E5%91%86/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABB%E4%BF%A1%E5%B0%8F%E5%91%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛热身B信小呆/title1.jpg" alt="title1"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>​    小g得到一张满x减x的购物劵，他想在自己购物车中选择一部分物品来买，购物车里没种物品只能买一件，并且他想尽量少花钱。由于小g很穷很笨，如果它购物车里所有物品价值总和比x小，那么他只能选择放弃这张优惠劵</p><p>​    也就是说他会在n个物品中选若干，使得花费总和大于等于x且最小</p><p>​    问花费最少的钱能拿到货物的最大价值是多少？</p><p>Input  </p><p>​    输入第一行是t(t &lt;= 100)，表示t组样例。接下来输入n和x (0 &lt; n &lt; 100, 0 &lt; x &lt; 10000)，代表小g购物车有n件物品，优惠劵满x减x，接下来一行有n个数(0 &lt; ai &lt; 100)代表n个物品的价格</p><p>Output  </p><p>​    对于每组样例，请输出“Case x: y”, x是输入样例组数，y是小g在花最少的钱能拿到货物的最大价值</p><p>Sample Input  </p><p>2</p><p>3 10</p><p>1 2 3</p><p>3 10</p><p>5 6 3</p><p>Sample Output  </p><p>Case 1: 0</p><p>Case 2: 11</p><p>思路：</p><p>​    01背包的变形题,dp【i】代表总价值为i的货物搭配是否存在(1存在，0不存在)，然后从x开始遍历，若存在dp【i】则直接输出并跳出，不存在输出0</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">bool dp[10005];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, tot = 0, a, n, x;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;x);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            for (int j = i * 100; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (dp[j]) &#123;</span><br><span class="line">                    dp[j + a] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int i = x; i &lt;= n * 100; i++) &#123;</span><br><span class="line">            if(dp[i]) &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;, ++tot, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届校团队赛热身C孪生素数猜想</title>
      <link href="/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABC%E5%AD%AA%E7%94%9F%E7%B4%A0%E6%95%B0%E7%8C%9C%E6%83%B3/"/>
      <url>/2018/12/10/%E5%93%88%E7%90%86%E5%B7%A5%E7%AC%AC%E5%85%AB%E5%B1%8A%E6%A0%A1%E5%9B%A2%E9%98%9F%E8%B5%9B%E7%83%AD%E8%BA%ABC%E5%AD%AA%E7%94%9F%E7%B4%A0%E6%95%B0%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/10/哈理工第八届校团队赛热身C孪生素数猜想/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>Description  </p><p>​    素数只能被1和自身整除，孪生素数猜想为：存在无穷多个素数对形如（p, p + 2），如3和5， 11和13等</p><p>​    先给定一个数k，判断k是否为孪生素数</p><p>Input  </p><p>​    输入第一行是t(t &lt;= 100)，代表数据组数，接下来每组数据输入一个k(2 &lt; k &lt; 100000)</p><p>Output  </p><p>​    对于每组样例，请输出“Case x: y”, x是输入样例组数，如果是孪生数输出Yes，否则输出No</p><p>Sample Input  </p><p>3</p><p>5</p><p>23</p><p>30</p><p>Sample Output  </p><p>Case 1: Yes</p><p>Case 2: No</p><p>Case 3: No</p><p>思路：</p><p>​    直接线性筛出1e5 + 2以内的全部素数，然后从素数中再筛选出全部的孪生素数并标记为1.直接判断book[k]是否为1，1Yes，0No</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 100002</span><br><span class="line"></span><br><span class="line">bool book[N + 5];</span><br><span class="line">int prime[N + 5];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    prime[0] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            book[prime[j] * i] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    for (int i = 2; i &lt; prime[0]; i++) &#123;</span><br><span class="line">        if ((prime[i] - 2 == prime[i - 1]) || (prime[i] + 2 == prime[i + 1])) &#123;</span><br><span class="line">            book[prime[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(prime[prime[0]] - 2 == prime[prime[0] - 1]) &#123;</span><br><span class="line">        book[prime[0]] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    int T, k, tot = 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">        if(book[k]) &#123;</span><br><span class="line">            printf(&quot;Case %d: Yes\n&quot;, ++tot);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;Case %d: No\n&quot;, ++tot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术-第三章</title>
      <link href="/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/08/C语言核心技术-第三章/title1.jpg" alt="title1"></p><a id="more"></a><p>第三章 字面量</p><p>3.1 整数常量</p><p>​    十进制常量起始数字不可为0</p><p>​    以0开始的数字会被解释成八进制</p><p>​    十六进制以0x或0X作前缀</p><p>​    解析下面两行代码：</p><p>3.2浮点常量</p><p>​    默认类型为double，也可用后缀f或F来说明该常量是float型</p><p>3.3字符串常量</p><p>​    字符串常量可以初始一个char数组，也可以初始化一个指向char的指针，例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p = &quot;hello, zcy!&quot;;//p指向字符&apos;h&apos;</span><br></pre></td></tr></table></figure><p>​    虽然C语言没有严格禁止修改指针指向的字符串字面量，但也不能试图这么做，以下做法是不好的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p = &quot;hello, zcy!&quot;;</span><br><span class="line">*p = &quot;hi, acm!&quot;;//这样做很不好</span><br></pre></td></tr></table></figure><p>​    这样做导致语句不具备可移植性，在某些系统下会产生运行错误。原因有两个：</p><p>​    （1）一些编译器将字符串字面量视为常量，可能将其存在只读存储器中，对其进行写操作将会产生错误</p><p>​    （2）程序中有两个或更多完全相同的字符串字面量，编译器可能会将它们存储在相同的位置，因此修改一个字符串会对其他字符串造成影响。</p><p>​    而使用字符串字面量初始的数组变量不会产生这种影响</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术-第二章下</title>
      <link href="/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8B/"/>
      <url>/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/08/C语言核心技术-第二章下/title4.jpg" alt="title4"></p><a id="more"></a><p>第二章 数据类型</p><p>2.3 对象在内存中的对齐方式</p><p>​    类型都对其对象限定了对应的对齐方式，也就是说类型指定了该类型对象的内存地址形式。形式诸如所有地址都可存储，偶数地址开始存储，被4整除地址开始存储等等。一个类型的对齐用该类型两个连续对象在内存中相距的字节数表示</p><p>2.3.1  _Alignof操作符</p><p>​    _Alignof用于判断一个类型的对齐，使用格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_Alignof(int)  //此时返回4</span><br></pre></td></tr></table></figure><p>2.3.2 _Alignas修饰符</p><p>​    _Alignas用于规定对齐值，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_Alignof(4) short a; //定义一个拥有4字节对齐值的short类型变量a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术-第二章上</title>
      <link href="/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A/"/>
      <url>/2018/12/08/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/08/C语言核心技术-第二章上/title3.jpg" alt="title3"></p><a id="more"></a><p>第二章 数据类型</p><p>​    C语言中，对象引用到内存中的一个位置，该位置内容可表示为该对象的值。一个对象的数据类型决定了这个对象在内存中所占用的空间大小，以及所采用的编码方式</p><p>2.1 整数类型</p><p>​    char类型也是一个标准的整数类型</p><p>​    C语言只定义了标准类型最小的存储空间，char类型只占用一个字节，short类型至少占用2字节，long类型至少占用4字节，long long类型至少占用8字节(1字节 == 8位)</p><p>2.1.1stdint.h头文件</p><p>​    stdint.h头文件定义了整数类型以满足对于已知位长的定义：</p><p>​    intN_t / uintN_t    位长为N的整数/无符号整数</p><p>​    int_leastN_t / uint_leastN_t    位长至少为N的整数/无符号整数</p><p>​    int_fastN_t / uint_fastN_t    位长至少为N的最快速的整数/无符号整数</p><p>​    intmax_t / uintmax_t    位长最大的整数/无符号整数</p><p>​    intptr_t / uintptr_t    位长足以存储指针值的整数/无符号整数</p><p>​    关于intptr_t的足以存储指针值的整数如何理解，我百度了一下它的宏定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Types for `void *&apos; pointers.  */</span><br><span class="line"></span><br><span class="line">#if __WORDSIZE == 64  </span><br><span class="line"># ifndef __intptr_t_defined  </span><br><span class="line">typedef long int  intptr_t;  </span><br><span class="line">#  define __intptr_t_defined  </span><br><span class="line"># endif  </span><br><span class="line">typedef unsigned long int  uintptr_t;</span><br><span class="line"></span><br><span class="line">#else  </span><br><span class="line"># ifndef __intptr_t_defined  </span><br><span class="line">typedef int   intptr_t;  </span><br><span class="line">#  define __intptr_t_defined  </span><br><span class="line"># endif  </span><br><span class="line">typedef unsigned int    uintptr_t;  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    显然，intptr_t不是指针类型，而是long int型。至于为什么解释成void *指针，尽管概念上地址是指针, 但内存管理常常使用一个无符号整型更好地完成。因为内核对待物理内存如同一个大数组，并且内存地址只是一个数组索引。而一个指针容易解引用，当直接处理内存存取时, 使用一个整数类型能避免这种解引用，因此避免了 bug。所以内核中内存地址常常是unsigned long型。（关于解引用，可以解释为返回内存地址中保存的值，关于它的解释找到一篇特别好的博文 <a href="https://www.cnblogs.com/Mayfly-nymph/p/8213837.html" target="_blank" rel="noopener">跳转</a> ）</p><p>2.1.2limits.h头文件</p><p>​    该头文件有很多宏定义，用于获得整数类型的范围，例如：INT_MIN,UINT_MAX,INT_LEAST64_MIN 等等</p><p>2.2浮点类型</p><p>​    关于浮点类型精度丢失的原因：</p><p>​    是因为我们在程序里写的是十进制小数，而计算机内部只能用二进制的小数表示, 所以导致无法精确的表达</p><p>​    对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n），所以十进制小数都是由这些小数一点点拼凑出来的一个近似值, 所以才会不准确</p><p>​    例如用二进制来表示十进制的1.2:<br>​    1.01 = 1 + 1/4 = 1.25 , 偏大<br>​    1.001 = 1 + 1/8 = 1.125 , 偏小<br>​    1.0011 = 1 + 1/8 + 1/16 = 1.1875，偏小<br>​    1.001101 = 1 + 1/8+ 1/16 + 1/64 = 1.203125 , 偏大<br>​    1.0011001 = 1 + 1/8 + 1/16 + 1/128 = 1.1953125 ,偏小<br>​    1.00110011 = 1 + 1/8+1/16+1/128+1/256 = 0.19921875 , 偏小<br>​    直到越来越接近…这就是精度缺失的根本原因</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术—第一章下</title>
      <link href="/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8B/"/>
      <url>/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/07/C语言核心技术—第一章下/title1.jpg" alt="title1"></p><a id="more"></a><p>第一章：C语言基础</p><p>1.6编译器运行原理</p><p>​    用文本编辑器写完源码，编译器对翻译单元进行处理，若没有发现错误，则会生成包含对应机器码的目标文件（扩展名为.o或.obj）</p><p>​    目标文件也成为模块，一个链接库包含多个编译好可以快速获取的模块</p><p>​    然后编译器调用链接器将所有目标文件和所用到的链接库函数结合起来，成为一个可执行文件</p><p><img src="/2018/12/07/C语言核心技术—第一章下/1.jpg" alt="1"></p><p>1.6.1编译的8个逻辑步骤</p><p>​    (1)从源码读取并转换字符，如有必要将字符转换成源代码字符集的字符</p><p>​    (2)无论何时，只要反斜线后紧跟换行符，预处理器都会将两者删除，因为行尾字符视为预处理器命令的终止，反斜线可让预处理命令（如宏定义）可以在下一行继续</p><p>​    (3)将源码文件分解为若干预处理器标记和空格符序列，每个注释被看作一个空格</p><p>​    (4)执行预处理命令，展开宏调用</p><p>​    //1～4不仅作用于源码文件，也作用于#include命令插入的文件。</p><p>​    (5)字符常量和字符串字面量中的字符和转义序列被转换成运行字符集中对应的字符</p><p>​    (6)相邻字符串字面量被连接为一个字符串</p><p>​    (7)编译器分析标记序列，生成对应机器码</p><p>​    (8)链接器解析对外部函数和对象的引用，并生成可执行文件</p><p>1.6.2标记</p><p>​    标记可以是关键字、标识符、常量、字符串字面量、符号</p><p>​    将源码解析成标记过程中，采用原则如下：</p><p>​    为避免歧义，每个连续的非空格符必须附加到正在读取的标记后面，直到出现附加后使得有效标记变为无效为止</p><p>​    例如：a+++b。第一个+无法当作标识符的一部分，也不能当作以a开头的关键字的一部分，所以+是一个新标记的开始。第二个+附加到第一个+后面形成一个有效标记++，第三个+附加上来+++不是有效标记，因此表达式被分解成a++ + b</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言核心技术—第一章上</title>
      <link href="/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8A/"/>
      <url>/2018/12/07/C%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/07/C语言核心技术—第一章上/title.jpg" alt="title"></p><a id="more"></a><p>第一章：C语言基础</p><p>1.1C语言程序结构</p><p>​    函数定义，全局声明和预处理命令组成了C语言程序</p><p>1.1.1 关于链接库：</p><p>​    C语言链接库除标准库外，还有许多特殊链接库可以使用，例如图形函数链接库。</p><p>​    如果使用非标准库，会限制所开发程序的可移植性。这些程序只能移植到已经加载了这些非标准库的系统上</p><p>1.1.2关于预处理命令</p><p>​    函数中调用的每个函数需要在该函数前声明，预处理命令#include&lt;.h&gt;指示编译器的预处理器将该头文件内容插入到源代码中，以达到声明头文件中函数的目的。</p><p>​    预处理命令每条需独占一行，且#前只能有空格符或制表符，不可有其它字符（若想换行可在前一行最后加反斜线）</p><p>1.1.3关于函数</p><p>​    C语言由函数组成，一个函数可以调用其他函数。函数的定义不能嵌套在另一个函数内（也就是说函数内可以定义局部变量，但是不能定义局部函数）</p><p>1.2源代码文件</p><p>1.2.1模块化</p><p>​    C语言支持模块化，也就是将一个程序组织成多个源代码文件和头文件，然后分别编译他们</p><p>​    对于一个包含多个源文件的程序，可利用头文件来存储函数的声明、全局变量、宏与常量。并通过引用头文件来间接声明它们。</p><p>1.2.2编译单元与标记</p><p>​    每个C源代码文件连同被包含在其中的头文件，构成一个翻译单元。</p><p>​    编译器按次序处理编译单元的内容，把源代码转换成标记。标记是最小的语义单元，如变量名称与运算符</p><p>1.3注释</p><p>​    预处理器仅通过检查注释的结束符来判定注释结束，因此不能嵌套块注释。若想注释包含块注释的代码，可使用条件预处理命令，例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if 0/*如果true则执行之间的代码，false直接跳过 0代表false)</span><br><span class="line">int a = 5; /*定义a*/</span><br><span class="line">    printf(&quot;%d\n&quot;, a); /*输出a*/</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    预处理会把每个注释都替换成一个空格</p><p>1.4环境</p><p>​    编译器转换程序源代码时，所处环境称为编译环境</p><p>​    编译后程序执行，所处环境称为运行环境</p><p>1.5字符集</p><p>​    C语言定义了两个字符集：源代码字符集和运行字符集。源代码字符集用于组成源码，运行字符集是可以被执行程序解释的字符集</p><p>​    在许多C语言实现版本中，两个字符集相同。若不同，则编译器会把源代码中的字符常量和字符串字面量转换成运行字符集中对应的元素</p><p>1.5.1宽字符和多字节字符</p><p>​    为兼容全球的所有语言，有些字符需要超过一个字节来编码。因此出现了两种表示大型字符集的标准化方法：</p><p>​    宽字符：该字符集内，每个字符使用相同的位长</p><p>​    多字节字符：每个字符可以采用一个或多个字节表示，通过它所在字符串或流的上下文，来确定字符值</p><p>1.5.2双字符组和三字符组</p><p>​    有些符号在键盘无法输入，可采用一些等效方法实现。例如双字符组和三字符组。</p><p>​    例如：&lt;: 等价为 [     </p><p>​           %&gt; 等价为 }  </p><p>​            ??&lt; 等价为{    等等</p><p>1.5.3通用符和标识符</p><p>​    通用符即Unicode值，格式为\uXXXX或\UXXXXXXXX （X为16进制数），可用于标识符、字符常量、字符串字面量。</p><p>​    标识符用于引用变量、函数、宏、结构以及其他定义的对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> C核心技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-12-04博客搭建进度</title>
      <link href="/2018/12/04/18-12-04%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/12/04/18-12-04%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/04/18-12-04博客搭建进度/titile.jpg" alt="titile"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页 (11.30更新)</p><p>​    ——调整底部布局 (12.02更新)</p><p>​    ——新增小游戏——见缝插针 (12.02更新)</p><p>​    ——修复音乐弹出、小火箭移动端错误问题</p><p>​    ——更新“关于我”页面特效</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-12-02博客搭建进度</title>
      <link href="/2018/12/02/18-12-02%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/12/02/18-12-02%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/18-12-02博客搭建进度/title9.jpg" alt="title9"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页 (11.30更新)</p><p>​    ——调整底部布局</p><p>​    ——新增小游戏——见缝插针</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐搭积木</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%90%AD%E7%A7%AF%E6%9C%A8/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%90%AD%E7%A7%AF%E6%9C%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐搭积木/title.jpg" alt="title"></p><a id="more"></a><p>题目描述</p><p>小乐乐想要给自己搭建一个积木城堡。 </p><p>积木城堡我们假设为n*m的平面矩形。 </p><p>小乐乐现在手里有1<em>2，2</em>1两种地砖。 </p><p>小乐乐想知道自己有多少种组合方案。 </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入整数n,m。(1&lt;=n,m&lt;=10)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出组合方案数。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>示例2</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>示例3</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    状压dp的入门题，把每一行的状态压缩成一个二进制数（竖为1横为0），然后转化为十进制。依次遍历第一行的所有状态方案数都初始化为1，然后依据dp递推式推出其余行。最后累加最后一行的所有可行性方案的和即可。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define Maxn 2048</span><br><span class="line">using namespace std;</span><br><span class="line">int chg[Maxn*Maxn][2];</span><br><span class="line">ll dp[1&lt;&lt;13][13];</span><br><span class="line">int n,m,tot;</span><br><span class="line"> </span><br><span class="line">void dfs(int c,int s,int scur)&#123;</span><br><span class="line">    if(c&gt;m) return;</span><br><span class="line">    if(c==m)&#123;</span><br><span class="line">        chg[tot][0]=s;</span><br><span class="line">        chg[tot++][1]=scur;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(c+1,s&lt;&lt;1,scur&lt;&lt;1|1);</span><br><span class="line">    dfs(c+1,s&lt;&lt;1|1,scur&lt;&lt;1);</span><br><span class="line">    dfs(c+2,s&lt;&lt;2|3,scur&lt;&lt;2|3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    if(m&gt;n) &#123;</span><br><span class="line">        int kk = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = kk;</span><br><span class="line">    &#125;</span><br><span class="line">    tot=0;</span><br><span class="line">    dfs(0,0,0);</span><br><span class="line">    memset(dp,0,sizeof dp);</span><br><span class="line">    dp[(1&lt;&lt;m)-1][0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;tot;j++)</span><br><span class="line">            dp[chg[j][1]][i]+=dp[chg[j][0]][i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,dp[(1&lt;&lt;m)-1][n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐打游戏</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%89%93%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E6%89%93%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐打游戏/title8.jpg" alt="title8"></p><a id="more"></a><p>题目描述</p><p>​        小乐乐觉得学习太简单了，剩下那么多的时间好无聊，于是便想打游戏。<br>​        最近新出了一个特别火的游戏，叫吃猪，小乐乐准备玩一玩。<br>​        吃猪游戏很简单，给定一个地图，大小为n*m，在地图中会随机出现一个火山口，只要小乐乐能逃离这个地图，他便能吃猪！<br>​        但吃鸡远没有那么简单：<br>​        1.小乐乐每走一次只能上下左右四个方向中走一步。<br>​        2.小乐乐每走一步，火山喷发的岩浆就会向四周蔓延一个格子，所有岩浆走过的地方都视为被岩浆覆盖。<br>​        3.小乐乐碰到岩浆就会死。<br>​        4.地图中还有很多障碍，使得小乐乐不能到达，但是岩浆却可以把障碍融化。<br>​        5.小乐乐只有走到题目给定的终点才算游戏胜利，才能吃猪。<br>​        小乐乐哪见过这场面，当场就蒙了，就想请帮帮他，告诉他是否能吃猪。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组样例输入</span><br><span class="line"></span><br><span class="line">第一行给定n,m,(1 &lt;= n, m &lt;= 1000)代表地图的大小。</span><br><span class="line"></span><br><span class="line">接下来n行，每一行m个字符，代表地图，对于每一个字符，如果是&apos;.&apos;，代表是平地，&apos;S&apos;代表小乐乐起始的位置，</span><br><span class="line">&apos;E&apos;代表终点，&apos;#&apos;代表障碍物，&apos;F&apos;代表火山口。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出只有一行。如果小乐乐能吃猪，输出&quot;PIG PIG PIG!&quot;。否则输出&quot;A! WO SI LA!&quot;。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">F..</span><br><span class="line">#S#</span><br><span class="line">#.E</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PIG PIG PIG!</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    两个BFS，注意下细节即可。。。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,foot;</span><br><span class="line">&#125;;</span><br><span class="line">int dx[5]=&#123;0,1,-1,0&#125;,n,m;</span><br><span class="line">int dy[5]=&#123;1,0,0,-1&#125;;</span><br><span class="line">char a[1001][1001];</span><br><span class="line">int vis[1001][1001];</span><br><span class="line">int footstep[1001][1001];</span><br><span class="line">int bfs(int startx,int starty)&#123;</span><br><span class="line">    deque&lt;node&gt;Q;</span><br><span class="line">    node start;</span><br><span class="line">    start.x = startx;</span><br><span class="line">    start.y = starty;</span><br><span class="line">    start.foot = 0;</span><br><span class="line">    vis[startx][starty] = 1;</span><br><span class="line">    Q.push_back(start);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        node now = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        // printf(&quot;x=%d y=%d foot = %d\n&quot;,now.x,now.y,now.foot);</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = now.x+dx[i];</span><br><span class="line">            int y = now.y+dy[i];</span><br><span class="line"> </span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;n &amp;&amp;y&gt;=0&amp;&amp;y&lt;m &amp;&amp; a[x][y] != &apos;#&apos; &amp;&amp; a[x][y] != &apos;F&apos;&amp;&amp; !vis[x][y] &amp;&amp; now.foot+1&lt;=footstep[x][y])&#123;</span><br><span class="line">                if(a[x][y] == &apos;E&apos;)&#123;</span><br><span class="line">                    return now.foot+1;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                node then;</span><br><span class="line">                then.x = x;</span><br><span class="line">                then.y = y;</span><br><span class="line">                then.foot = now.foot+1;</span><br><span class="line">                Q.push_back(then);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.clear();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void bfs1(int startx,int starty)&#123;</span><br><span class="line">    deque&lt;node&gt;Q;</span><br><span class="line">    node start;</span><br><span class="line">    start.x = startx;</span><br><span class="line">    start.y = starty;</span><br><span class="line">    start.foot = 0;</span><br><span class="line">    footstep[startx][starty] = 0;</span><br><span class="line">    vis[startx][starty] = 1;</span><br><span class="line">   Q.push_back(start);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        node now = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)&#123;</span><br><span class="line">            int x = now.x+dx[i];</span><br><span class="line">            int y = now.y+dy[i];</span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;n &amp;&amp;y&gt;=0&amp;&amp;y&lt;m &amp;&amp;!vis[x][y])&#123;</span><br><span class="line">                footstep[x][y] = now.foot+1;</span><br><span class="line">                vis[x][y] = 1;</span><br><span class="line">                node then;</span><br><span class="line">                then.x = x;</span><br><span class="line">                then.y = y;</span><br><span class="line">                then.foot = now.foot+1;</span><br><span class="line">                Q.push_back(then);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.clear();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        int Sx,Sy,Ex,Ey;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,a[i]);</span><br><span class="line">            for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">                if(a[i][j] == &apos;S&apos;)&#123;</span><br><span class="line">                    Sx = i,Sy = j;</span><br><span class="line">                &#125;else if(a[i][j] == &apos;F&apos;)&#123;</span><br><span class="line">                    Ex = i,Ey = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(footstep,0,sizeof(footstep));</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        bfs1(Ex,Ey);</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        int ans1 = bfs(Sx,Sy);</span><br><span class="line">        if(ans1)&#123;</span><br><span class="line">            printf(&quot;PIG PIG PIG!\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;A! WO SI LA!\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> BFS </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐下象棋</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E4%B8%8B%E8%B1%A1%E6%A3%8B/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E4%B8%8B%E8%B1%A1%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐下象棋/title7.jpg" alt="title7"></p><a id="more"></a><p>题目描述</p><p>小乐乐一天天就知道玩，这一天又想玩象棋。<br>我们都知道马走日。<br>现在给定一个棋盘，大小是n*m,把棋盘放在第一象限，棋盘的左下角是(0,0),右上角是(n - 1, m - 1);<br>小乐乐想知道，一个马从左下角(0, 0)开始，走了k步之后，刚好走到右上角(n - 1, m - 1)的方案数。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：多组样例输入，每组一行，三个整数n, m, k(1 &lt;= n, m, k &lt;= 200),如题目所示。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：输出答案 mod 1000000007</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    设置dp【i】【j】【k】代表第k步到达坐标为(i,j)的方案数，然后三层for循环找8个方向即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define mod 1000000007</span><br><span class="line">long long dp[205][205][205];</span><br><span class="line">int fx[8][2] = &#123;1, 2, 2, 1, -1, 2, -2, 1, -1, -2, -2, -1, 1, -2, 2, -1&#125;;</span><br><span class="line">int main () &#123;</span><br><span class="line">int n, m, k;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) &#123;</span><br><span class="line">memset(dp, 0, sizeof(dp));</span><br><span class="line">dp[0][0][0] = 1;</span><br><span class="line">for (int p = 1; p &lt;= k; p++) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">for (int q = 0; q &lt; 8; q++) &#123;</span><br><span class="line">int ii = i + fx[q][0];</span><br><span class="line">int jj = j + fx[q][1];</span><br><span class="line">if (ii &gt;= 0 &amp;&amp; ii &lt; n &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; m) &#123;</span><br><span class="line">dp[i][j][p] = (dp[i][j][p] + dp[ii][jj][p - 1]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[n - 1][m - 1][k]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐和25</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%92%8C25/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%92%8C25/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐和25/title6.jpg" alt="title6"></p><a id="more"></a><p>题目描述</p><p>小乐乐特别喜欢25这个数字，他想把所有的数字都变成25的倍数。<br>现在小乐乐得到一个数字，想问问你最少用几次操作才可以把这个数字改造成25的倍数。<br>对于一次操作我们可以把相邻的两位做交换，比如123经过一次操作之后就可以变成213或者132。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组数据输入</span><br><span class="line"></span><br><span class="line">对于每组数据，只有一行输入一个整数n(1 &lt;= n &lt;= 1000000000)。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果经过最少x次操作后，这个数就变成了25的倍数，那么输出x；</span><br><span class="line"></span><br><span class="line">如果这个数无论怎么变化都变不成25的倍数，输出-1.</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>示例2</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">经过一次之后变成2200</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    要想是25的倍数，只要保证最后最后两位是00或者25或者50或者75即可。然后对这四种情况进行模拟即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[15];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        int num0 = 0, num2 = 0, num5 = 0, num7 = 0;</span><br><span class="line">        int tot = 0, flag = 0;</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        while(n) &#123;</span><br><span class="line">            a[++tot] = n % 10;</span><br><span class="line">            n /= 10;</span><br><span class="line">            if (a[tot] == 0) &#123;</span><br><span class="line">                num0++;</span><br><span class="line">            &#125; else if(a[tot] == 2) &#123;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125; else if(a[tot] == 5) &#123;</span><br><span class="line">                num5++;</span><br><span class="line">            &#125; else if(a[tot] == 7) &#123;</span><br><span class="line">                num7++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num0 &gt;= 2) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 0) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 0) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line">        &#125;</span><br><span class="line">        if (num2 &gt;= 1 &amp;&amp; num5 &gt;= 1) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 5) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 2) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        if(num5 &gt;= 1 &amp;&amp; num0 &gt;= 1) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 0) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 5) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line">        &#125;</span><br><span class="line">        if(num7 &gt;= 1 &amp;&amp; num5 &gt;= 1) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            int aa[15];</span><br><span class="line">            int ls = 0;</span><br><span class="line">            for (int i = 1; i&lt;= tot; i++) &#123;</span><br><span class="line">                aa[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 5) &#123;</span><br><span class="line">                    ls += abs(i - 1);</span><br><span class="line">                    for (int j = i; j &gt; 1; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= tot; i++) &#123;</span><br><span class="line">                if(aa[i] == 7) &#123;</span><br><span class="line">                    ls += abs(i - 2);</span><br><span class="line">                    for (int j = i; j &gt; 2; j--) &#123;</span><br><span class="line">                        aa[j] = aa[j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, ls);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, minn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐学博弈</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%AD%A6%E5%8D%9A%E5%BC%88/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%AD%A6%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐学博弈/title4.jpg" alt="title4"></p><a id="more"></a><p>题目描述</p><p>小乐乐和小皮蛋开始学习关于博弈的知识。<br>给定两堆石子，第一堆有n个石子，第二堆有m个石子。<br>每次操作可以从一堆石子中拿走一些石子，拿走石子的数量可以是1 - k个，小乐乐先手拿石子，然后依次轮流。<br>假如到小乐乐的轮次，小乐乐拿不了了(也就是所有的石子都被拿光了)，那么小皮蛋就获胜，反之亦然。<br>假设小乐乐和小皮蛋都绝顶聪明，都会采用最佳的策略，请问最后谁会赢。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多组数据输入，对于每一组数据，只有一行由空格分开的三个整数n, m, k(0 &lt;= n, m &lt;= 1000000000, k &gt;= |n - m|).</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果小乐乐会赢，输出&quot;HAI YOU SEI!&quot;,否则输出&quot;LAOZI CHUI SI NI!&quot;。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">130 135 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HAI YOU SEI!</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小乐乐会赢</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题有个输入限制k &gt;= |n - m|，自己看着n,m,k的数很大都是1e9，觉得应该是很简单的一个题，规律不可能太复杂。然后自己写了n多的样例，发现只有在n == m的时候小乐乐才会输。莽了一发过了</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m, k;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) &#123;</span><br><span class="line">        if (n == m) &#123;</span><br><span class="line">            printf(&quot;LAOZI CHUI SI NI!\n&quot;);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            printf(&quot;HAI YOU SEI!\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐匹配字符串</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐匹配字符串/title3.jpg" alt="title3"></p><a id="more"></a><p>题目描述</p><p>小乐乐有字符串str1,str2。 </p><p>小乐乐想要给他们找朋友。 </p><p>小乐乐想知道在这两个字符串中最多能匹配出多长的相同子串（可非连续）。 </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入字符串str1;</span><br><span class="line"></span><br><span class="line">第二行输入字符串str2;</span><br><span class="line"></span><br><span class="line">数据保证字符串长度小于1000，且非空，字符串仅由小写字母组成。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出最长相同子串的长度。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asd</span><br><span class="line">ad</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    动态规划入门题，两层 for循环分别遍历两个字符串的字符，若s1【i】 == s2【j】，则dp【i】【j】= dp【i - 1】【j - 1】+ 1，否则dp【i】【j】= max(dp【i - 1】【j】,dp【i】【j - 1】)即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s1[1005], s2[1005];</span><br><span class="line">int dp[1005][1005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    scanf(&quot;%s&quot;, s1 + 1);</span><br><span class="line">    scanf(&quot;%s&quot;, s2 + 1);</span><br><span class="line">    int n1 = strlen(s1 + 1);</span><br><span class="line">    int n2 = strlen(s2 + 1);</span><br><span class="line">    for (int i = 1; i &lt;= n1; i++) &#123;</span><br><span class="line">        for (int j = 1; j&lt;= n2; j++) &#123;</span><br><span class="line">            if(s1[i] != s2[j]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[n1][n2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐玩木桶+</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6-1/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐玩木桶-1/title2.jpg" alt="title2"></p><a id="more"></a><p>题目描述</p><p>小乐乐用散落在森林里的木板做了一个木桶。 </p><p>已知底面积为S(㎡)。 </p><p>小乐乐经过各种仪器的精密测量知道了，所有木板的近似长度h[i]。 </p><p>小乐乐只能选用三块木板去拼木桶，小乐乐拼凑成的木桶的最大装水体积是(㎡)？ </p><p>（容量测量，底面积乘高，木桶不倾斜） </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入整数n，S。(3&lt;=n&lt;=1000，1&lt;=s&lt;=1000，n表示拼凑木桶所需木板)</span><br><span class="line"></span><br><span class="line">第二行输入n个整数h[i](1&lt;=h[i]&lt;=1000,h[i]表示i号木板的长度)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出木桶最大装水体积。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 3 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    这道题是上一道题的变形 <a href="http://www.ivan-zcy.top/2018/12/02/哈理工院赛-小乐乐玩木桶/">上题链接</a>  只要sort一下，用s✖️第三大的数即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        printf(&quot;%d\n&quot;, a[n - 3] * m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐玩木桶</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%8E%A9%E6%9C%A8%E6%A1%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐玩木桶/titile1.jpg" alt="titile1"></p><a id="more"></a><p>题目描述</p><p>小乐乐用散落在森林里的木板做了一个木桶。 </p><p>已知底面积为S(㎡)。 </p><p>小乐乐经过各种仪器的精密测量知道了，所有木板的近似长度h[i]。 </p><p>小乐乐想知道自己拼凑出的木桶的最大装水体积为？ </p><p>（容量测量，底面积乘高，木桶不倾斜） </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行输入整数n，S。(1&lt;=n,s&lt;=1000，n表示拼凑木桶所需木板)</span><br><span class="line"></span><br><span class="line">第二行输入n个整数h[i](1&lt;=h[i]&lt;=1000,h[i]表示i号木板的长度)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出木桶最大装水体积。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    就是找出最小值，然后用s ✖️最小值即可。。。大水题</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        int a;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            if (minn &gt; a) &#123;</span><br><span class="line">                minn = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, minn * m);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>院赛-小乐乐的组合数+</title>
      <link href="/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/2018/12/02/%E5%93%88%E7%90%86%E5%B7%A5%E9%99%A2%E8%B5%9B-%E5%B0%8F%E4%B9%90%E4%B9%90%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/12/02/哈理工院赛-小乐乐的组合数/title7.jpg" alt="title7"></p><a id="more"></a><p>题目描述</p><p>小乐乐得知一周有7天之后就对7产生了兴趣。 </p><p>小乐乐得到了两堆数字数字时连续的。 </p><p>第一堆包含[1,n]n个数字，第二堆包含[1,m]m个数字。</p><p>小乐乐想要从两堆中各挑选出一个整数x,y，使得x,y的和为7的倍数。</p><p>请问小乐乐有多少种组合的方式。 </p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入整数n,m。(1&lt;=n,m&lt;=1e6)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出满足的对数。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 7</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)</span><br></pre></td></tr></table></figure><p>思路：</p><p>​    从n,m中找一个较小值，用i遍历这个较小值，然后累加（(i + 较大值)  / 7）- (i / 7)即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    long long n, m;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    if (n &gt; m) &#123;</span><br><span class="line">        long long flag = n;</span><br><span class="line">        n = m;</span><br><span class="line">        m = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        long long k = i + m;</span><br><span class="line">        ans += k / 7 - i / 7;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-30博客搭建进度</title>
      <link href="/2018/11/30/18-11-30%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/30/18-11-30%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/30/18-11-30博客搭建进度/title5.jpg" alt="title5"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明（11.29更新）</p><p>​    ——实现博文字数统计（11.29更新）</p><p>​    ——添加顶部加载条（11.29更新）</p><p>​    ——添加简历页</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-29博客搭建进度</title>
      <link href="/2018/11/29/18-11-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/29/18-11-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/29/18-11-29博客搭建进度/title1.jpg" alt="title1"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景(11.28更新)</p><p>​    ——修改网站图片外链至本地（11.28更新）</p><p>​    ——博文尾部自动添加声明</p><p>​    ——实现博文字数统计</p><p>​    ——添加顶部加载条</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近几天</title>
      <link href="/2018/11/28/%E6%9C%80%E8%BF%91%E5%87%A0%E5%A4%A9/"/>
      <url>/2018/11/28/%E6%9C%80%E8%BF%91%E5%87%A0%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/28/最近几天/title4.jpg" alt="title4"></p><a id="more"></a><p>​    比完赛歇了两天后发现，三个星期外出打比赛落下的作业，课程设计，过程性考核扒拉扒拉之类的东西像冰冷的雨点在我脸上胡乱的拍，简直要哭了，直到今天所有的作业算是告一段落</p><p>​    补习班11月17号也开课了，前期课还挺简单（呸呸呸！不奶了不奶了），每次要坐40多分钟公交去补课的地方。哎～睡懒觉的机会没了</p><p>​    12月份院赛，校赛也要开始了。打打就好，过了那个兴奋的年纪</p><p>​    也该准备找工作滚粗了，简历几乎要完稿了，还差最最最重要的照骗，预约了明天的海马体，但愿能拍成照骗而不是照片吧哈哈哈哈</p><p>​    寒假是继续留在哈尔滨补课还是能pass过简历去公司实习，纠结～ 每一步都不想走错，自己继续纠结吧</p><p>​    哈尔滨的冬天 屋里暖气烘烘的 一天到晚好疲乏呀总是睡觉 想出去踢球 想着外边哈哈气都起雾 算了吧 哎 苦涩～</p><p>​                                        ——2018.11.28夜</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-28博客搭建进度</title>
      <link href="/2018/11/28/18-11-28%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/28/18-11-28%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/28/18-11-28博客搭建进度/titile6.jpg" alt="titile6"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间（11.13更新）</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览)（11.13更新）</p><p>​    ——新增动态背景</p><p>​    ——修改网站图片外链至本地</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十八)getcwd(),getline(),chdir()函数</title>
      <link href="/2018/11/16/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-18/"/>
      <url>/2018/11/16/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-18/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/16/C语言查缺补漏-18/title.jpg" alt="title"></p><a id="more"></a><p>关于getcwd()与getline()与chdir()函数使用：</p><p>一.getcwd()函数定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">char *getcwd(char *buf,size_t size);</span><br><span class="line">//getcwd()会将当前工作目录的绝对路径并复制到参数buf所指的内存空间,参数size为buf的空间大小。</span><br></pre></td></tr></table></figure><p>二.getcwd()函数用法:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> path[<span class="number">105</span>];</span><br><span class="line">getcwd(path,<span class="keyword">sizeof</span>(path));</span><br><span class="line"><span class="built_in">puts</span>(path);</span><br></pre></td></tr></table></figure><p>三.getline()函数定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istream&amp; getline(istream &amp;is, string &amp;str, char delim);</span><br><span class="line">istream&amp; getline(istream &amp;is, string &amp;str);</span><br><span class="line">is是进行读入操作的输入流，str是用来存储读入的内容，delim是终结符，遇到该字符停止读取操作，不写默认为回车</span><br></pre></td></tr></table></figure><p>四.getline()函数用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行输入回车结束时：</span><br><span class="line">string str;</span><br><span class="line">getline(cin, str);</span><br><span class="line"></span><br><span class="line">循环输入到ctrl + z结束时：</span><br><span class="line">while (getline(cin, str)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五.chdir函数定义：</p><p>​    chdir 是C语言中的一个系统调用函数（同cd），用于改变当前工作目录。其参数为Path 目标目录，可以是绝对目录或相对目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; </span><br><span class="line">int chdir（const char * path）; </span><br><span class="line">chdir（）用户将当前的工作目录改变成以参数路径所指的目录。</span><br><span class="line">返回值执行成功则返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>六.chdir函数用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chdir(&quot;/tmp&quot;);</span><br><span class="line">//当前目录更改为/tmp</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京站总结</title>
      <link href="/2018/11/15/2018icpc%E5%8C%97%E4%BA%AC%E7%AB%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/15/2018icpc%E5%8C%97%E4%BA%AC%E7%AB%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc北京站总结/title.jpg" alt="title"></p><a id="more"></a><p>​    亚洲区预赛北京站应该是国内最难打的一站吧。。刚开始就没抱什么期待。比赛前一星期做了青岛的重现赛，5题银牌水平，突然就对北京有了一丝期待，但愿能获个奖，希望今年不白玩。</p><p>​    现场赛开始后刚开始，队友告诉我I题可以用数位dp做，连忙看起了i，另两个队友看起了A题。没过10分钟清华大学A题一血。增林老哥紧随其后没多久A题Accept。赛后问队友A题好像是传递闭包，然后自己今天补了一下这道题：<a href="http://www.ivan-zcy.top/2018/11/15/2018icpc北京Jin-Yong-Wukong-Ranking-List传递闭包/">链接</a></p><p>​       I题修修改改，找其中关系解决了n取1e5范围的所有可能。结果WA了，再读题才发现，它喵的这道题n的长度是1e5，而不是数字。。。那肯定规律题没跑了，让志愿者打印了之前处理前9位数的表。找到了规律。在第2个小时Accpet掉：<a href="http://www.ivan-zcy.top/2018/11/15/2018icpc-Palindromes推规律/">链接</a></p><p>​    D题现场赛被我刨除相邻建传送门的可能。。从那之后思路再也没往那上面靠过。很遗憾没出，今天补了补20多分钟就出了，满心悔恨～还是自己脑子太笨了。。 <a href="http://www.ivan-zcy.top/2018/11/15/2018icpc北京Frog-and-Portal转换二进制/">链接</a></p><p>​    B题至今很迷，不知道问题出到哪儿了。我把WA的代码贴出来，希望大佬们能出一组样例Hack一下我的代码。。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int num[205];</span><br><span class="line">int ans[205];</span><br><span class="line">int add[205];</span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    str.clear();</span><br><span class="line">    memset(ans, 0, sizeof(ans));</span><br><span class="line">    memset(add, 0, sizeof(add));</span><br><span class="line">    int tot = 0;</span><br><span class="line">    int flggg = 0;</span><br><span class="line">    int numm = 0;</span><br><span class="line">    while((c = getchar()) != EOF) &#123;</span><br><span class="line">        if (c == &apos;#&apos;) break;</span><br><span class="line">        if (c == &apos;\n&apos;) &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            num[tot] = numm;</span><br><span class="line">            numm = 0;</span><br><span class="line">            if (str[str.length() - 1] &gt;= &apos;0&apos; &amp;&amp; str[str.length() - 1] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                flggg = 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flggg = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            numm++;</span><br><span class="line">            if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; &amp;&amp; flggg == 1) &#123;</span><br><span class="line">                str += c;</span><br><span class="line">                flggg = 0;</span><br><span class="line">            &#125; else if (flggg) &#123;</span><br><span class="line">                numm++;</span><br><span class="line">                str += &quot; &quot;;</span><br><span class="line">                str += c;</span><br><span class="line">                flggg = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                str += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str += &quot; &quot;;</span><br><span class="line">    num[tot]++;</span><br><span class="line">    for (int i = 1; i &lt;= tot; i ++) &#123;</span><br><span class="line">        add[i] = add[i - 1] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int flag = 0, start = -1, flaa = 0, num = 0;</span><br><span class="line">    for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) &#123;</span><br><span class="line">                flag = 2;</span><br><span class="line">            &#125; else if (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos; &amp;&amp; flaa == 1)&#123;</span><br><span class="line">                flag = 2;</span><br><span class="line">            &#125; else if (str[i] == &apos; &apos;)&#123;</span><br><span class="line">                if (start != -1) &#123;</span><br><span class="line">                    if (num != 0) printf(&quot; &quot;);</span><br><span class="line">                    for (int j = start; j &lt; i; j++) &#123;</span><br><span class="line">                        printf(&quot;%c&quot;, str[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                    for (int j = 1; j &lt;= tot; j++) &#123;</span><br><span class="line">                        if (add[j] &gt; start) &#123;</span><br><span class="line">                            ans[j] ++;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = -1;</span><br><span class="line">                flag = 0;</span><br><span class="line">                flaa = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (flag == 2)&#123;</span><br><span class="line">            if (str[i] == &apos; &apos;) &#123;</span><br><span class="line">                start = -1;</span><br><span class="line">                flag = 0;</span><br><span class="line">                flaa = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                start = i;</span><br><span class="line">                if (str[i] == &apos;0&apos;) flaa = 1;</span><br><span class="line">            &#125; else if (str[i] &gt;= &apos;a&apos; &amp;&amp; str[i] &lt;= &apos;z&apos;) &#123;</span><br><span class="line">                flag = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num != 0) &#123;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= tot; i ++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后很惊险的拿了亚洲区预赛北京站的铜牌。。虽然今年很遗憾，但也算满足了。哪里跌倒哪里爬起，以后的日子继续加油吧～</p><p><img src="/2018/11/15/2018icpc北京站总结/1.jpg" alt="1"></p><p><img src="/2018/11/15/2018icpc北京站总结/2.jpg" alt="2"></p><p><img src="/2018/11/15/2018icpc北京站总结/3.jpg" alt="3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京Frog and Portal转换二进制</title>
      <link href="/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACFrog-and-Portal%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
      <url>/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACFrog-and-Portal%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc北京Frog-and-Portal转换二进制/titile2.jpg" alt="titile2"></p><a id="more"></a><p>题意：</p><p>时间限制:1000ms</p><p>单点时限:1000ms</p><p>内存限制:512MB</p><p>描述</p><p>A small frog wants to get to the other side of a river. The frog is initially located at one bank of the river (position 0) and wants to get to the other bank (position 200). Luckily, there are 199 leaves (from position 1 to position 199) on the river, and the frog can jump between the leaves. When at position p, the frog can jump to position p+1 or position p+2.How many different ways can the small frog get to the bank at position 200? This is a classical problem. The solution is the 201st number of Fibonacci sequence. The Fibonacci sequence is constructed as follows: F1=F2=1;Fn=Fn-1+Fn-2.Now you can build some portals on the leaves. For each leaf, you can choose whether to build a portal on it. And you should set a destination for each portal. When the frog gets to a leaf with a portal, it will be teleported to the corresponding destination immediately. If there is a portal at the destination, the frog will be teleported again immediately. If some portal destinations form a cycle, the frog will be permanently trapped inside. Note that You cannot build two portals on the same leaf.Can you build the portals such that the number of different ways that the small frog gets to position 200 from position 0 is M?</p><p>输入</p><p>There are no more than 100 test cases.Each test case consists of an integer M, indicating the number of ways that the small frog gets to position 200 from position 0. (0 ≤ M &lt; 232)</p><p>输出</p><p>For each test case:The first line contains a number K, indicating the number of portals.Then K lines follow. Each line has two numbers ai and bi, indicating that you place a portal at position ai and it teleports the frog to position bi.You should guarantee that 1 ≤ K, ai, bi ≤ 199, and ai ≠ aj if i ≠ j. If there are multiple solutions, any one of them is acceptable.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">2</span><br><span class="line">1 199</span><br><span class="line">2 2</span><br><span class="line">2</span><br><span class="line">4 199</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><p>​    这道题意思就是一共有200层楼梯，可以一次上一层，也可以一次上两层。我们可以建造若干个传送门，可以直接从a传送到b（强制传送）。给你一个n，问到第200层有n种方案数，需要建多少个传送门，如何建？（多种建造方案任选一种即可）</p><p>思路：</p><p>​    这道题应该深思如何建造传送门。有3种合理的建造：</p><ol><li><p>由k层传送到199层，这样总方案数会加上第k层的方案数</p></li><li><p>由k层传送到k层。死循环，总方案数不会记入该层方案数</p></li><li><p>由k层传送到k+1层。会使k层的方案数累计到k+1层中。</p><p>由这三种构造，我们可以转化为二进制来求解。</p><p>比如当n为7时，它的二进制为111，也就是1 + 2 + 4</p><p>那么传送门就应该建6个。</p><p>分别是1传送到199（总方案数+1）</p><p>（这样2，3分别有1，1种方案数）</p><p>3传送到4</p><p>（这样4，5分别有2，2种方案数）</p><p>5传送到199 （总方案数+2）</p><p>（这样6，7分别有2，2种方案数）</p><p>7传送到8</p><p>（这样8，9分别有4，4种方案数）</p><p>9传送到199 （总方案数+4）</p><p>10传送到10 （封死）</p><p>（10以后无法到达200，方案数为0）</p><p>这样总方案数为7，符合条件</p></li></ol><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int flag[205];</span><br><span class="line">long long dp[205];</span><br><span class="line">int main () &#123;</span><br><span class="line">    long long n;</span><br><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        memset(flag, 0, sizeof(flag));</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            printf(&quot;2\n1 1\n2 1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n % 2) &#123;</span><br><span class="line">            flag[1] = 1;</span><br><span class="line">            ans ++;</span><br><span class="line">            n /= 2;</span><br><span class="line">            int inx = 3;</span><br><span class="line">            while(n) &#123;</span><br><span class="line">                flag[inx] = 2;</span><br><span class="line">                ans++;</span><br><span class="line">                inx += 2;</span><br><span class="line">                if (n % 2) &#123;</span><br><span class="line">                    flag[inx] = 1;</span><br><span class="line">                    ans++;</span><br><span class="line">                    inx += 2;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            flag[inx - 1] = 3;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            n /= 2;</span><br><span class="line">            int inx = 1;</span><br><span class="line">            while(n) &#123;</span><br><span class="line">                flag[inx] = 2;</span><br><span class="line">                ans++;</span><br><span class="line">                inx += 2;</span><br><span class="line">                if (n % 2) &#123;</span><br><span class="line">                    flag[inx] = 1;</span><br><span class="line">                    ans++;</span><br><span class="line">                    inx += 2;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            flag[inx - 1] = 3;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">        for (int i = 1; i &lt;= 198; i++) &#123;</span><br><span class="line">            if (flag[i] == 1) &#123;</span><br><span class="line">                printf(&quot;%d 199\n&quot;, i);</span><br><span class="line">            &#125; else if (flag[i] == 2) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;, i, i + 1);</span><br><span class="line">            &#125; else if (flag[i] == 3)&#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京Palindromes推规律</title>
      <link href="/2018/11/15/2018icpc-Palindromes%E6%8E%A8%E8%A7%84%E5%BE%8B/"/>
      <url>/2018/11/15/2018icpc-Palindromes%E6%8E%A8%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc-Palindromes推规律/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>时间限制:1000ms</p><p>单点时限:1000ms</p><p>内存限制:512MB</p><p>描述</p><p>Recently, Nvoenewr learnt palindromes in his class.A palindrome is a nonnegative integer that is the same when read from left to right and when read from right to left. For example, 0, 1, 2, 11, 99, 232, 666, 998244353353442899 are palindromes, while 10, 23, 233, 1314 are not palindromes.Now, given a number, Nvoenewr can determine whether it’s a palindrome or not by using loops which his teacher has told him on the class. But he is now interested in another question: What’s the K-th palindrome? It seems that this question is too difficult for him, so now he asks you for help.Nvoenewr counts the number from small to big, like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101 and so on. So the first palindrome is 0 and the eleventh palindrome is 11 itself.<br>Nvoenewr may ask you several questions, and the K may be very big.</p><p>输入</p><p>The first line contains one integer T(T &lt;= 20) —— the number of questions that Nvoenewr will ask you.Each of the next T lines contains one integer K. You should find the K-th palindrome for Nvoenewr.Let’s say K is a n-digit number. It’s guaranteed that K &gt;= 1, 1 &lt;= n &lt;= 100000 and the sum of n in all T questions is not greater than 1000000.</p><p>输出</p><p>Print T lines. The i-th line contains your answer of Nvoenewr’s i-th question.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">101</span><br></pre></td></tr></table></figure><p>​    翻译成汉语就是问第n个回文数是多少？n的长度范围是1e5</p><p>思路：</p><p>​    队友当时告诉我用数位dp做，然后我想了一手觉得还是找联系吧。然后发现只要处理前九位就能填满1e5的数据范围。。直到错了两发才发现，他喵的n的数据范围不是1e5，而是n的数字长度为1e5。好吧，即然这样肯定是有规律了，然后就利用之前处理的前1e9个打表找到其中的规律然后Accept（规律见代码）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 100000</span><br><span class="line"></span><br><span class="line">char s[N + 5];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T --) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, s);</span><br><span class="line">        int len = strlen(s);</span><br><span class="line">        if (len == 1) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, s[0] - &apos;0&apos; - 1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len == 2 &amp;&amp; s[0] == &apos;1&apos; &amp;&amp; s[1] == &apos;0&apos;) &#123;</span><br><span class="line">            printf(&quot;9\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[0] == &apos;1&apos;) &#123;</span><br><span class="line">            if (s[1] == &apos;0&apos;) &#123;</span><br><span class="line">                printf(&quot;9&quot;);</span><br><span class="line">                for (int i = 2; i &lt; len; i++) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int i = len - 2; i &gt; 1; i--) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;9\n&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">                    printf(&quot;%c&quot;, s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%d&quot;, s[0] - &apos;0&apos; - 1);</span><br><span class="line">            for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">                printf(&quot;%c&quot;, s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = len - 2; i &gt; 0; i--) &#123;</span><br><span class="line">                printf(&quot;%c&quot;, s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d\n&quot;, s[0] - &apos;0&apos; - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc北京Jin Yong’s Wukong Ranking List传递闭包</title>
      <link href="/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACJin-Yong-Wukong-Ranking-List%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/"/>
      <url>/2018/11/15/2018icpc%E5%8C%97%E4%BA%ACJin-Yong-Wukong-Ranking-List%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/15/2018icpc北京Jin-Yong-Wukong-Ranking-List传递闭包/title2.jpg" alt="title"></p><a id="more"></a><p>时间限制:1000ms</p><p>单点时限:1000ms</p><p>内存限制:512MB</p><p>描述</p><p>Jin Yong was the most famous and popular Chinese wuxia (The one who fight bad people by his Wukong i.e. Wushu and Kongfu) novelist who lived in Hong Kong. Between 1955 and 1972, he wrote 14 novels which earned him a reputation as one of the greatest and most popular Chinese writers. Over 100 million copies of his works have been sold worldwide，not including a countless number of pirated copies. Jin Yong’s works seem to have magic. Once you begin to read a novel of his, you just can’t stop until you finish it.Last month, Jin Yong passed away at the age of 94. Many Jin Yong’s fans in PKU held a meeting to memorize him. Jin Yong’s fans always like to discuss or argue or even quarrel about whose Wukong are better among the wuxia characters of his novel. During the meeting, this happened again:Every fans said some words like “Qiao Feng’s Wukong is better than Guo Jing’s”. Obviously, those words may contradict each other and then cause quarrels. As a boring and girlfriendless male programmer of EECS school, you always want to make some things. So you are eager to point out the contradictions as soon as possible. That means, you want to find out the first one whose words contradict the words said by others before him.Please note that if A is better than B, and B is better than C, then of course A must be better than C.</p><p>输入</p><p>There are no more than 15 test cases.For each test case:The first line is an integer n( 1 &lt;= n &lt;=20), meaning that there are n sentences.The following n lines are those n sentences which is in the format below:s1 s2This means someone said that s1’s Wukong was better than s2’s. Both s1 and s2 are names of Jin Yong’s characters which consists of only English letters. It’s guaranteed that s1 and s2 are different, and their length is no more than 30. Names are case sensitive.</p><p>输出</p><p>For each test case, print the first sentence which cause a contradiction. If there are no contradiction, print 0 instead.</p><p>提示</p><p>DON’T try to figure out who are those names in the sample and waste your time.</p><ul><li><p>样例输入</p><p><code>2</code></p><p> <code>BrokenReputation ExtinctNun</code></p><p> <code>HelloLaught EnvelopeNotFlat</code></p><p><code>6</code></p><p><code>LandOverWind LonelyLight</code></p><p><code>FireMonk CutTheForest</code></p><p><code>CutTheForest LookCrazy</code></p><p><code>MakeFoxRush LetMeGo</code></p><p><code>HeroAunt UniqueLand</code></p><p><code>LookCrazy FireMonk</code></p></li><li><p>样例输出</p><p><code>0</code></p><p><code>LookCrazy FireMonk</code></p></li></ul><p>​    题意就是给出一个n代表有n行，每行两个a，b，代表a的武功高于b，问最早从第几行开始导致前后矛盾，若不矛盾输出0</p><p>思路：</p><p>​    比赛时队友用传递闭包做的，今天自己做了一下。这个题可以转化为有向图判定是否成环（利用map&lt;string, int&gt;映射一下名字），可以用bool型的book{i}{j}来代表从i到j是否连通。每一行都更新一下，若book{i}{j}和book{j}{i}都为1就代表前后矛盾</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s1[25], s2[25];</span><br><span class="line">map&lt;string, int&gt;zcy;</span><br><span class="line">bool book[50][50];</span><br><span class="line">int res1[50], res2[50];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        zcy.clear();</span><br><span class="line">        memset(book, 0, sizeof(book));</span><br><span class="line">        int tot = 0;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; s1[i];</span><br><span class="line">            cin &gt;&gt; s2[i];</span><br><span class="line">            if (!zcy[s1[i]]) &#123;</span><br><span class="line">                zcy[s1[i]] = ++tot;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!zcy[s2[i]]) &#123;</span><br><span class="line">                zcy[s2[i]] = ++tot;</span><br><span class="line">            &#125;</span><br><span class="line">            if (book[zcy[s2[i]]][zcy[s1[i]]] || flag) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res1[0] = zcy[s2[i]];</span><br><span class="line">            res2[0] = zcy[s1[i]];</span><br><span class="line">            int tot1 = 0, tot2 = 0;</span><br><span class="line">            for (int j = 1; j &lt;= tot; j++) &#123;</span><br><span class="line">                if(book[j][zcy[s2[i]]] == 1) &#123;</span><br><span class="line">                    res1[++tot1] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 1; j &lt;= tot; j++) &#123;</span><br><span class="line">                if(book[zcy[s1[i]]][j] == 1) &#123;</span><br><span class="line">                    res2[++tot2] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int p = 0; p &lt;= tot1; p++) &#123;</span><br><span class="line">                for (int q = 0; q &lt;= tot2; q++) &#123;</span><br><span class="line">                    if(book[res2[q]][res1[p]] == 0) &#123;</span><br><span class="line">                        book[res1[p]][res2[q]] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        cout &lt;&lt; s1[i] &lt;&lt; &quot; &quot; &lt;&lt; s2[i] &lt;&lt; endl;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 传递闭包 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc徐州站总结</title>
      <link href="/2018/11/14/2018icpc%E5%BE%90%E5%B7%9E%E7%AB%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/14/2018icpc%E5%BE%90%E5%B7%9E%E7%AB%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>​    <img src="/2018/11/14/2018icpc徐州站总结/title3.jpg" alt="title3"></p><a id="more"></a><p>​    这场比赛有很多没想到吧，努力了那么久，没想到以打铁草草收场。赛后听题解说c题和i题是水题，直到最后一个小时才有人开始做这两个题。我们队也根本没有想过这两个题会是水题。直到比赛半个多小时过去，清华大学才Accept掉第一个A题。所有队伍都开始尝试做这道，我们队也不例外。</p><p>​    关于A题，题意跳转连接：<a href="http://www.ivan-zcy.top/2018/11/14/icpc2018徐州Rikka-with-Minimum-Spanning/">跳转</a> 这道题题干特别特别长，大概就是给出一个随机函数自动生成n个点m条边的无向图，让你求它的最小生成树个数✖️最小生成树权值的值。关于求最小生成树权值很简单，直接可以用Kruskal求解，而最小生成树个数我们队想了好久，刚开始试图Matrix_Tree算法来求，结果发现由于N为1e5，二维数组根本没有办法放开。后来改用dfs，修修改改直到4小时40分钟才Accept掉。</p><p>​    毫无疑问，打铁了。。。距离铜牌只差了12分钟罚时。。。而且给出的正解，竟然说随机函数不可能生成两个及以上的最小生成树。。。。自己辛辛苦苦用最小生成树个数✖️最小生成树权值求出来的，一些队只用简单的最小生成树权值就求出来。。。欲哭无泪，只能说自己还是太菜。。。</p><p>​    来时抱着争银保铜的信心，结果遗憾草草收场…</p><p>​    抛去比赛，中国矿业大学的校园很大很美，校园里大到可以举办半程马拉松，Orz，又是别人家的大学系列。除此之外徐州的地锅鸡也非常非常好吃。一切都过去了，就这样吧～</p><p><img src="/2018/11/14/2018icpc徐州站总结/2.jpg" alt="2"></p><p><img src="/2018/11/14/2018icpc徐州站总结/3.jpg" alt="3"></p><p><img src="/2018/11/14/2018icpc徐州站总结/1.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc徐州Rikka with Minimum Spanning</title>
      <link href="/2018/11/14/icpc2018%E5%BE%90%E5%B7%9ERikka-with-Minimum-Spanning/"/>
      <url>/2018/11/14/icpc2018%E5%BE%90%E5%B7%9ERikka-with-Minimum-Spanning/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/14/icpc2018徐州Rikka-with-Minimum-Spanning/title1.jpg" alt="title1"></p><a id="more"></a><p>给你一个随机函数，其中n为点的数量，m为边的数量，该函数会自动初始化出一张无向无环图，函数如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef unsigned long long ll;</span><br><span class="line">ll k1,k2;</span><br><span class="line">ll xorShift128Plus()</span><br><span class="line">&#123;</span><br><span class="line">    ll k3=k1,k4=k2;</span><br><span class="line">    k1=k4;</span><br><span class="line">    k3^=k3&lt;&lt;23;</span><br><span class="line">    k2=k3^k4^(k3&gt;&gt;17)^(k4&gt;&gt;26);</span><br><span class="line">    return k2+k4;</span><br><span class="line">&#125;</span><br><span class="line">void gen()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d%llu%llu&quot;,&amp;n,&amp;m,&amp;k1,&amp;k2);for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[i].u=xorShift128Plus()%n+1;</span><br><span class="line">        e[i].v=xorShift128Plus()%n+1;</span><br><span class="line">        e[i].w=xorShift128Plus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用如上所示随机函数求出该图所形成的最小生成树个数与该最小生成树总权值的乘积</p><p>题解：</p><p>​    这道题题意其实非常非常长，有很多很多干扰项（比如介绍了一种计算最小生成树数目的算法），翻译成汉语简化一下就是上面那个意思。</p><p>​    嗯嗯，我们队就是被这道题给KO了，辛辛苦苦写了4个多小时的最小生成树计数✖️最小生成树权值才过的题，最后给出的正解居然是直接构造最小生成树就行了。。。。由于随机数生成器过于给力，根本就不会出来两种以上的最小生成树，只需要特判0就行了。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define MAX 100000</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define ll unsigned long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m, p[MAX+5];</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[MAX + 5];</span><br><span class="line"></span><br><span class="line">int find(int r) &#123;</span><br><span class="line">    if(p[r] != r)  p[r] = find(p[r]);</span><br><span class="line">    return p[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp (node a, node b) &#123;</span><br><span class="line">    return a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll k1,k2;</span><br><span class="line"></span><br><span class="line">ll xorShift128Plus() &#123;</span><br><span class="line">    ll k3 = k1,k4 = k2;</span><br><span class="line">    k1 = k4;</span><br><span class="line">    k3 ^= k3 &lt;&lt; 23;</span><br><span class="line">    k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26);</span><br><span class="line">    return k2 + k4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void gen() &#123;</span><br><span class="line">    scanf(&quot;%d%d%llu%llu&quot;,&amp;n, &amp;m, &amp;k1, &amp;k2);</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[i].u = xorShift128Plus() % n + 1;</span><br><span class="line">        e[i].v = xorShift128Plus() % n + 1;</span><br><span class="line">        e[i].w = xorShift128Plus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void kurskal() &#123;</span><br><span class="line">    gen();</span><br><span class="line">    sort(e + 1, e + m + 1, cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    ll sum = 0;</span><br><span class="line">    for(int i = 1;i &lt;= m;i++) &#123;</span><br><span class="line">        int fu = find(e[i].u);</span><br><span class="line">        int fv = find(e[i].v);</span><br><span class="line">        if(fu != fv) &#123;</span><br><span class="line">            p[fu] = fv;</span><br><span class="line">            sum += e[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum = sum % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt == n-1) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt == n-1) printf(&quot;%llu\n&quot;, sum%mod);</span><br><span class="line">    else printf(&quot;0\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">        kurskal();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    没错，就是这么简单～估计这是这一生最令我伤心的一题了吧。。。</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-11-13博客搭建进度</title>
      <link href="/2018/11/13/18-11-13%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/11/13/18-11-13%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/13/18-11-13博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计(10.23更新)</p><p>​    ——新增博文数量统计(10.23更新)</p><p>​        ——新增网站运行时间</p><p>​        ——新增pdf在线浏览（仅支持电脑浏览）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM常用数学公式</title>
      <link href="/2018/11/13/ACM%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/11/13/ACM%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/13/ACM常用数学公式/title.jpg" alt="title"></p><a id="more"></a><p><strong>注意：仅支持电脑查看</strong></p><div class="row">    <embed src="数学公式.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Tournament 规律+思维</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BTournament-%E8%A7%84%E5%BE%8B-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BTournament-%E8%A7%84%E5%BE%8B-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Tournament-规律-思维/titile4.jpg" alt="titile4"></p><a id="more"></a><p>题意：</p><p><img src="/2018/11/09/2018icpc青岛Tournament-规律-思维/1.png" alt="1"></p><p><img src="/2018/11/09/2018icpc青岛Tournament-规律-思维/2.png" alt="2"></p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible</span><br><span class="line">2 1 4 3</span><br><span class="line">3 4 1 2</span><br><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure><p>​    这道题大概就是给T组样例，每组样例n个骑士，m轮比赛。每个骑士每轮比赛都得参加，且每轮比赛对手都不能相同，输出一个矩阵a【i】【j】代表第i轮和j骑士进行对决的是a【i】【j】骑士。若有多种情况，答案输出字典序最小的那个。</p><p>思路：</p><p>​    通过打暴力码得到当n为2的次幂时，最多可以有n - 1次对决。否则当n为256的倍数时（由于n的范围只有1000且n不为2的次幂，所以从256算就可以了），最多可以有(1 + 2 + 4 + 8 + … + 128)轮比赛, 当n为128的倍数时，最多可以有(1 + 2 + 4 + … +64 )轮比赛 ……当n为2的倍数时，最多有1轮比赛。</p><p>​    因此只要超过这些轮比赛，直接Impossible即可。</p><p>​    对于满足条件的，我们找出矩阵的规律即可（对于&lt;=2的，与第i - 1轮对每2个一组的数平分两半相互交换，对于&lt;=4的，与第i - 2轮对每4个一组的数平分两半相互交换，对于&lt;= 8的，与第i - 4轮对每8个一组的数平分两半相互交换…依此递推）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int a[1005][1005];</span><br><span class="line">int ttt[15] = &#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;;</span><br><span class="line"></span><br><span class="line">int quick(int a, int b) &#123;</span><br><span class="line">    int ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if(b &amp; 1) ans *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n, m;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int sum = 0, tot = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        int nn = n;</span><br><span class="line">        while(nn % 2 == 0) &#123;</span><br><span class="line">            nn /= 2;</span><br><span class="line">            sum += quick(2, tot);</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; m) &#123;</span><br><span class="line">            printf(&quot;Impossible\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                a[1][i] = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 2; i &lt;= m + 1; i++) &#123;</span><br><span class="line">                int flaa;</span><br><span class="line">                for (int j = 0; j &lt; 15; j++) &#123;</span><br><span class="line">                    if (ttt[j] &lt; i) &#123;</span><br><span class="line">                        flaa = ttt[j + 1];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flaa /= 2;</span><br><span class="line">                //printf(&quot;%d\n&quot;, flaa);</span><br><span class="line">                for (int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">                    if (j % (flaa * 2) &lt; flaa) &#123;</span><br><span class="line">                        a[i][j] = a[i - flaa][j + flaa];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        a[i][j] = a[i - flaa][j - flaa];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (j == n - 1) &#123;</span><br><span class="line">                        printf(&quot;%d\n&quot;, a[i][j]);</span><br><span class="line">                    &#125; else&#123;</span><br><span class="line">                        printf(&quot;%d &quot;, a[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3162Walking Race 树形dp+单调队列+模拟vector</title>
      <link href="/2018/11/09/POJ3162Walking-Race-%E6%A0%91%E5%BD%A2dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%A8%A1%E6%8B%9Fvector/"/>
      <url>/2018/11/09/POJ3162Walking-Race-%E6%A0%91%E5%BD%A2dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%A8%A1%E6%8B%9Fvector/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/POJ3162Walking-Race-树形dp-单调队列-模拟vector/titile2.jpg" alt="titile2"></p><a id="more"></a><p>题意：</p><p>Description</p><p>flymouse’s sister wc is very capable at sports and her favorite event is walking race. Chasing after the championship in an important competition, she comes to a training center to attend a training course. The center has <em>N</em> check-points numbered 1 through <em>N</em>. Some pairs of check-points are directly connected by two-way paths. The check-points and the paths form exactly a tree-like structure. The course lasts <em>N</em> days. On the <em>i</em>-th day, wc picks check-point <em>i</em> as the starting point and chooses another check-point as the finishing point and walks along the only simple path between the two points for the day’s training. Her choice of finishing point will make it that the resulting path will be the longest among those of all possible choices.</p><p>After every day’s training, flymouse will do a physical examination from which data will obtained and analyzed to help wc’s future training be better instructed. In order to make the results reliable, flymouse is not using data all from <em>N</em> days for analysis. flymouse’s model for analysis requires data from a series of consecutive days during which the difference between the longest and the shortest distances wc walks cannot exceed a bound <em>M</em>. The longer the series is, the more accurate the results are. flymouse wants to know the number of days in such a longest series. Can you do the job for him?</p><p>Input</p><p>The input contains a single test case. The test case starts with a line containing the integers <em>N</em> (<em>N</em> ≤ 106) and <em>M</em> (<em>M</em> &lt; 109). Then follow <em>N</em> − 1 lines, each containing two integers <em>fi</em> and <em>di</em> (i = 1, 2, …, <em>N</em> − 1), meaning the check-points <em>i</em> + 1 and <em>fi</em> are connected by a path of length <em>di</em>.</p><p>Output</p><p>Output one line with only the desired number of days in the longest series.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>Hint</p><p>Explanation for the sample:</p><p>There are three check-points. Two paths of lengths 1 and 3 connect check-points 2 and 3 to check-point 1. The three paths along with wc walks are 1-3, 2-1-3 and 3-1-2. And their lengths are 3, 4 and 4. Therefore data from all three days can be used for analysis.</p><p>​    翻译成汉语，每个样例输入一个n,m,然后再给出n - 1个边的点权。n个点组成一颗树，求出每个点的离它最远的距离记为a【i】,问连续的区间中差值全部小于等于m的最长区间的长度。</p><p>思路：</p><p>​    对于求出每个点离它最远的距离a【i】，我们可以通过树形dp来求解（注意需要用链式前向星或者模拟vector来求解，否则TLE），然后再通过尺取+单调队列来求最长长度（当然用线段树也可以求解）。单调队列需要开两个，一个存最大值队列，一个存最小值队列。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#define N 1000005</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;;</span><br><span class="line">int n, m;</span><br><span class="line">node point[N * 2];</span><br><span class="line">node dp[N][3];</span><br><span class="line">int last[N * 2], fin[N];</span><br><span class="line">deque&lt;int&gt;maxn, minn;</span><br><span class="line"></span><br><span class="line">inline int read() &#123;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    int x = 0;</span><br><span class="line">    while(ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while(&apos;0&apos; &lt;= ch &amp;&amp; ch &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        x = x * 10 + ch - &apos;0&apos;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    node c;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        a = read();</span><br><span class="line">        b = read();</span><br><span class="line">        c.inx = a;</span><br><span class="line">        c.val = b;</span><br><span class="line">        point[++tot] = c;</span><br><span class="line">        last[tot] = fin[i];</span><br><span class="line">        fin[i] = tot;</span><br><span class="line">        c.inx = i;</span><br><span class="line">        point[++tot] = c;</span><br><span class="line">        last[tot] = fin[a];</span><br><span class="line">        fin[a] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs (int inx, int father) &#123;</span><br><span class="line">    for (int i = fin[inx]; i != 0; i = last[i]) &#123;</span><br><span class="line">        node son = point[i];</span><br><span class="line">        if (son.inx == father) continue;</span><br><span class="line">        dfs(son.inx, inx);</span><br><span class="line">        if (dp[inx][0].inx == 0) &#123;</span><br><span class="line">            dp[inx][0].val = dp[son.inx][0].val + son.val;</span><br><span class="line">            dp[inx][0].inx = son.inx;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (dp[inx][0].val &lt; dp[son.inx][0].val + son.val) &#123;</span><br><span class="line">                dp[inx][1].val = dp[inx][0].val;</span><br><span class="line">                dp[inx][1].inx = dp[inx][0].inx;</span><br><span class="line">                dp[inx][0].val = dp[son.inx][0].val + son.val;</span><br><span class="line">                dp[inx][0].inx = son.inx;</span><br><span class="line">            &#125; else if (dp[inx][1].val &lt; dp[son.inx][0].val + son.val) &#123;</span><br><span class="line">                dp[inx][1].val = dp[son.inx][0].val + son.val;</span><br><span class="line">                dp[inx][1].inx = son.inx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs1 (int inx, int father) &#123;</span><br><span class="line">    for (int i = fin[inx]; i != 0; i = last[i]) &#123;</span><br><span class="line">        node son = point[i];</span><br><span class="line">        if (son.inx == father) continue;</span><br><span class="line">        if (dp[inx][0].inx == son.inx) &#123;</span><br><span class="line">            dp[son.inx][2].val = son.val + max(dp[inx][1].val, dp[inx][2].val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[son.inx][2].val = son.val + max(dp[inx][0].val, dp[inx][2].val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(son.inx, inx);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    init();</span><br><span class="line">    dfs(1, -1);</span><br><span class="line">    dp[1][2].val = 0;</span><br><span class="line">    dfs1(1, -1);</span><br><span class="line">    int start = 1;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][0].val = max(dp[i][0].val, dp[i][2].val);</span><br><span class="line">        while(!maxn.empty() &amp;&amp; dp[maxn.back()][0].val &lt; dp[i][0].val) &#123;</span><br><span class="line">            maxn.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        maxn.push_back(i);</span><br><span class="line">        while(!minn.empty() &amp;&amp; dp[minn.back()][0].val &gt; dp[i][0].val) &#123;</span><br><span class="line">            minn.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        minn.push_back(i);</span><br><span class="line">        while(dp[maxn.front()][0].val - dp[minn.front()][0].val &gt; m) &#123;</span><br><span class="line">            if (maxn.front() &lt; minn.front()) &#123;</span><br><span class="line">                start = maxn.front() + 1;</span><br><span class="line">                maxn.pop_front();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start = minn.front() + 1;</span><br><span class="line">                minn.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(i - start + 1, res);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Flippy Sequence 思维</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFlippy-Sequence-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFlippy-Sequence-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Flippy-Sequence-思维/titile3.jpg" alt="titile3"></p><a id="more"></a><p>题意：</p><p><img src="/2018/11/09/2018icpc青岛Flippy-Sequence-思维/1.png" alt="1"></p><p><img src="/2018/11/09/2018icpc青岛Flippy-Sequence-思维/2.png" alt="2"></p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">00</span><br><span class="line">11</span><br><span class="line">5</span><br><span class="line">01010</span><br><span class="line">00111</span><br></pre></td></tr></table></figure><p>#### </p><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>#### </p><p>Hint</p><p>For the second sample test case, there are two valid operation pairs: (1, 1, 2, 2) and (2, 2, 1, 1).</p><p>For the third sample test case, there are six valid operation pairs: (2, 3, 5, 5), (5, 5, 2, 3), (2, 5, 4, 4), (4, 4, 2, 5), (2, 4, 4, 5) and (4, 5, 2, 4).</p><p>​    题意就是给你T组样例，每组样例给你两个长度为n的字符串s1,s2，每个字符串必须且只能反转一个连续的区间（0变1，1变0），问两个字符串反转完毕变成相同字符串的方案数？</p><p>思路：</p><p>​    我们把两个字符串每一位相同的设为0，不同的设为1.若出现了3个及3个以上连续的1，那么永远无法通过反转一次得到相同字符串，此时输出0；若出现了2个连续的1，那么一定是6种方案；若出现了1个连续的1，方案数= (连续1的个数 - 1) ✖️ 2 + （n - 连续1的个数) ✖️2；若没有出现连续的1，方案数=（1 + n）✖️ n / 2。</p><p>​    一定要细心细心再细心！！因为细节没处理好WA了4发当时心态都崩了。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define N 1000005</span><br><span class="line">char s1[N], s2[N];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n, c;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        scanf(&quot;%s%s&quot;, s1, s2);</span><br><span class="line">        int num = 0;</span><br><span class="line">        int flag = 0, flaa = 0;</span><br><span class="line">        int start, endd;</span><br><span class="line">        int num1 = 0, num2 = 0, num3 = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (s1[i] == s2[i]) c = 0;</span><br><span class="line">            else c = 1;</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    if (num == 1) &#123;</span><br><span class="line">                        endd = i - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if (num == 1) &#123;</span><br><span class="line">                    num2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (num == 0) &#123;</span><br><span class="line">                    if (flag == 0) &#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num1++;</span><br><span class="line">                &#125; else if(num == 1) &#123;</span><br><span class="line">                    num3++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    flaa = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i == n - 1) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    if (num == 1) &#123;</span><br><span class="line">                        endd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flaa) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (num == 0) &#123;</span><br><span class="line">            long long sum = (long long)(1 + n) * n / 2;</span><br><span class="line">            printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (num == 1) &#123;</span><br><span class="line">            long long sum = (long long)(num1 - 1) * 2;</span><br><span class="line">            sum += (n - (endd - start + 1)) * 2;</span><br><span class="line">            printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">        &#125; else if (num == 2) &#123;</span><br><span class="line">            printf(&quot;6\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Books 思维</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BBooks-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BBooks-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Books-思维/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>DreamGrid went to the bookshop yesterday. There are  books in the bookshop in total. Because DreamGrid is very rich, he bought the books according to the strategy below: </p><ul><li>Check the  books from the 1st one to the -th one <strong>in order</strong>.</li><li>For each book being checked now, if DreamGrid has enough money (not less than the book price), he’ll buy the book and his money will be reduced by the price of the book.</li><li>In case that his money is less than the price of the book being checked now, he will skip that book.</li></ul><p>BaoBao is curious about how rich DreamGrid is. You are asked to tell him the maximum possible amount of money DreamGrid took before buying the books, which is a non-negative integer. All he knows are the prices of the  books and the number of books DreamGrid bought in total, indicated by . </p><p>Input</p><p>There are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case:</p><p>The first line contains two integers  and  (, ), indicating the number of books in the bookshop and the number of books DreamGrid bought in total.</p><p>The second line contains  non-negative integers  (), where  indicates the price of the -th book checked by DreamGrid.</p><p>It’s guaranteed that the sum of  in all test cases will not exceed .</p><p>#### </p><p>Output</p><p>For each test case output one line.</p><p>If it’s impossible to buy  books for any initial number of money, output “Impossible” (without quotes).</p><p>If DreamGrid may take an infinite amount of money, output “Richman” (without quotes).</p><p>In other cases, output a non-negative integer, indicating the maximum number of money he may take.</p><p>#### </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 2</span><br><span class="line">1 2 4 8</span><br><span class="line">4 0</span><br><span class="line">100 99 98 97</span><br><span class="line">2 2</span><br><span class="line">10000 10000</span><br><span class="line">5 3</span><br><span class="line">0 0 0 0 1</span><br></pre></td></tr></table></figure><p>#### </p><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">96</span><br><span class="line">Richman</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure><p>​    大概意思就是给T组样例，每组一个n，m代表n本书，买了其中m本。然后再给出n本书的价格。购买规则是从前往后遍历书，只要书的价格小于自己剩余的钱数，就购买，否则就跳过。问恰好能买m本拥有的钱最多是多少？若过能全买输出Richman，如果不能恰好买m本输出Impossible；</p><p>思路：</p><p>​    若n == m就Richman，否则第一遍遍历价格为0的书的数量。如果大于m就Impossible。否则就遍历剩下的不为0的图书，小于&lt;= m - 价格为0的数量时，累加钱数，当&gt; m - 价格为0的数量时，比较出其中的最小值。最后答案为累加的钱数+ 最小值 -1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100005];</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n, m;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        long long sum = 0;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        if (n == m) flag = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            if (a[i] == 0) num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num &gt; m) flag = 2;</span><br><span class="line">        else m -= num;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            int tot = 0;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                if (flag) break;</span><br><span class="line">                if (a[i] == 0) continue;</span><br><span class="line">                tot++;</span><br><span class="line">                if (tot &lt;= m) &#123;</span><br><span class="line">                    sum += a[i];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    minn = min(minn, a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (minn == 0) &#123;</span><br><span class="line">            flag = 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sum += minn - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag == 1) printf(&quot;Richman\n&quot;);</span><br><span class="line">        else if(flag == 2) printf(&quot;Impossible\n&quot;);</span><br><span class="line">        else printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018icpc青岛Function and Function 规律</title>
      <link href="/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFunction-and-Function-%E8%A7%84%E5%BE%8B/"/>
      <url>/2018/11/09/2018icpc%E9%9D%92%E5%B2%9BFunction-and-Function-%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/09/2018icpc青岛Function-and-Function-规律/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p><img src="/2018/11/09/2018icpc青岛Function-and-Function-规律/1.png" alt="1"></p><p><img src="/2018/11/09/2018icpc青岛Function-and-Function-规律/2.png" alt="2"></p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">123456789 1</span><br><span class="line">888888888 1</span><br><span class="line">888888888 2</span><br><span class="line">888888888 999999999</span><br><span class="line">98640 12345</span><br><span class="line">1000000000 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">18</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1000000000</span><br></pre></td></tr></table></figure><p>​    大概意思就是给出f(n)和g^k(n)的通项公式，让你求g^k(n)。</p><p>思路：</p><p>​    由于n的范围是1e9，每一位累加和肯定不会超过100，只需要几次递归就可以得到10以内的f(n)，至于10以内的递归，我们可以一眼看出它们的循环结和规律</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int a[10] = &#123;1, 0, 0, 0, 1, 0, 1, 0, 2, 1&#125;;</span><br><span class="line"></span><br><span class="line">int dfs (int x, int k) &#123;</span><br><span class="line">    if (k == 0) return x;</span><br><span class="line">    if (x &lt; 10) &#123;</span><br><span class="line">        if (x == 8) &#123;</span><br><span class="line">            if (k == 1) return a[8];</span><br><span class="line">            else if(k == 2) return a[2];</span><br><span class="line">            if(k % 2 == 1) return a[0];</span><br><span class="line">            else return a[1];</span><br><span class="line">        &#125; else if(x == 0) &#123;</span><br><span class="line">            if(k % 2 == 1) return a[0];</span><br><span class="line">            else return a[1];</span><br><span class="line">        &#125; else if(x == 1) &#123;</span><br><span class="line">            if(k % 2 == 1) return a[1];</span><br><span class="line">            else return a[0];</span><br><span class="line">        &#125; else if(x == 2 || x == 3 || x== 5 || x == 7) &#123;</span><br><span class="line">            if (k == 1) return a[x];</span><br><span class="line">            else if (k % 2 == 0) &#123;</span><br><span class="line">                return a[0];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (x == 4 || x == 6 || x == 9) &#123;</span><br><span class="line">            if (k == 1) return a[x];</span><br><span class="line">            else if (k % 2 == 0) &#123;</span><br><span class="line">                return a[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (x) &#123;</span><br><span class="line">        sum += a[x % 10];</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return dfs(sum, k - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, x, k;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T --) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;x, &amp;k);</span><br><span class="line">        int ans =dfs (x, k);</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU3586Information Disturbing 二分+树形dp</title>
      <link href="/2018/11/08/HDU3586Information-Disturbing-%E4%BA%8C%E5%88%86-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/08/HDU3586Information-Disturbing-%E4%BA%8C%E5%88%86-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/08/HDU3586Information-Disturbing-二分-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Problem Description</p><p>In the battlefield , an effective way to defeat enemies is to break their communication system.<br>The information department told you that there are n enemy soldiers and their network which have n-1 communication routes can cover all of their soldiers. Information can exchange between any two soldiers by the communication routes. The number 1 soldier is the total commander and other soldiers who have only one neighbour is the frontline soldier.<br>Your boss zzn ordered you to cut off some routes to make any frontline soldiers in the network cannot reflect the information they collect from the battlefield to the total commander( number 1 soldier).<br>There is a kind of device who can choose some routes to cut off . But the cost (w) of any route you choose to cut off can’t be more than the device’s upper limit power. And the sum of the cost can’t be more than the device’s life m.<br>Now please minimize the upper limit power of your device to finish your task.</p><p>Input</p><p>The input consists of several test cases.<br>The first line of each test case contains 2 integers: n(n&lt;=1000）m(m&lt;=1000000).<br>Each of the following N-1 lines is of the form:<br>ai bi wi<br>It means there’s one route from ai to bi(undirected) and it takes wi cost to cut off the route with the device.<br>(1&lt;=ai,bi&lt;=n,1&lt;=wi&lt;=1000)<br>The input ends with n=m=0.</p><p>Output</p><p>Each case should output one integer, the minimal possible upper limit power of your device to finish your task.<br>If there is no way to finish the task, output -1.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">3 5 5</span><br><span class="line">4 2 6</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​    这道题就是说给出n，m分别代表节点数和权值，再给出n-1条边ai,bi,wi，代表ai与bi之间有一条无向路，道路权值为wi。问在截断的道路总权值不超过m的前提下使得所有的叶节点都不能与跟节点相连，截断的道路中最大的权值尽可能的小，问最小值是多少？</p><p>思路：</p><p>​    一道较难的树形dp题，我们一般看到在什么什么的前提下，使得某个值最小或者最大。就应该想到用二分来求解。我们通过二分最小值，然后满足所截道路的权值都小于等于二分值进行dfs。最后找到最小满足条件的即是答案。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 1005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt;point[N];</span><br><span class="line">int n, m;</span><br><span class="line">int dp [N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    node t;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        t.val = c;</span><br><span class="line">        t.inx = b;</span><br><span class="line">        point[a].push_back(t);</span><br><span class="line">        t.inx = a;</span><br><span class="line">        point[b].push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int inx, int father, int w) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        if (son.inx == father) continue;</span><br><span class="line">        dfs(son.inx, inx, w);</span><br><span class="line">        if (dp[son.inx] == 0) &#123;     //当儿子节点没有成立的截断</span><br><span class="line">            if (son.val &lt;= w) &#123;</span><br><span class="line">                sum += son.val;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;                    //当儿子节点有成立的截断</span><br><span class="line">            if (son.val &lt;= w) &#123;</span><br><span class="line">                sum += min(dp[son.inx], son.val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sum += dp[son.inx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[inx] = sum;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int erfen() &#123;</span><br><span class="line">    int star = 1, endd = m;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    while (star &lt;= endd) &#123;</span><br><span class="line">        int mid = (star + endd) &gt;&gt; 1;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        bool flag = dfs(1, -1, mid);</span><br><span class="line">        if (flag == true &amp;&amp; dp[1] &lt;= m) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            endd = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            star = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while ((scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &amp;&amp; (n || m)) &#123;</span><br><span class="line">        init();</span><br><span class="line">        int ans = erfen();</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3140Contestants Division 树形dp</title>
      <link href="/2018/11/08/POJ3140Contestants-Division-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/08/POJ3140Contestants-Division-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/08/POJ3140Contestants-Division-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Description</p><p>In the new ACM-ICPC Regional Contest, a special monitoring and submitting system will be set up, and students will be able to compete at their own universities. However there’s one problem. Due to the high cost of the new judging system, the organizing committee can only afford to set the system up such that there will be only one way to transfer information from one university to another without passing the same university twice. The contestants will be divided into two connected regions, and the difference between the total numbers of students from two regions should be minimized. Can you help the juries to find the minimum difference?</p><p>Input</p><p>There are multiple test cases in the input file. Each test case starts with two integers <em>N</em> and <em>M</em>, (1 ≤ <em>N</em> ≤ 100000, 1 ≤ <em>M</em> ≤ 1000000), the number of universities and the number of direct communication line set up by the committee, respectively. Universities are numbered from 1 to <em>N</em>. The next line has <em>N</em> integers, the <em>K</em>th integer is equal to the number of students in university numbered <em>K</em>. The number of students in any university does not exceed 100000000. Each of the following <em>M</em> lines has two integers <em>s</em>, <em>t</em>, and describes a communication line connecting university <em>s</em> and university <em>t</em>. All communication lines of this new system are bidirectional.</p><p><em>N</em> = 0, <em>M</em> = 0 indicates the end of input and should not be processed by your program.</p><p>Output</p><p>For every test case, output one integer, the minimum absolute difference of students between two regions in the format as indicated in the sample output.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 6</span><br><span class="line">1 1 1 1 1 1 1</span><br><span class="line">1 2</span><br><span class="line">2 7</span><br><span class="line">3 7</span><br><span class="line">4 6</span><br><span class="line">6 2</span><br><span class="line">5 7</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br></pre></td></tr></table></figure><p>​    这道题翻译成汉语就是给出n个点，m条边，每个点都有一个权值，问去掉哪条边剩余两部分的权值差最小并输出最小值</p><p>思路：</p><p>​    这道题有一个巨大的坑点，就是点的数据范围是1e5，边的数据范围是1e6，虽然如此，但是题里说了这么一句：“以便只有一种方式将信息从一所大学转移到另一所大学，而不会两次通过同一所大学”，因此这一定是无向无环图，边一定是点的数量-1，也就说一定是一颗树。因此这道题就可以通过树形dp来求解了</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 100005</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">ll val[N];</span><br><span class="line">ll dp[N];</span><br><span class="line">ll sum;</span><br><span class="line">vector&lt;int&gt;point[N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    sum = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;val[i]);</span><br><span class="line">        sum += val[i];</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        point[a].push_back(b);</span><br><span class="line">        point[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    dp[inx] = val[inx];</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        int son = point[inx][i];</span><br><span class="line">        if(son == father) continue;</span><br><span class="line">        dfs(son, inx);</span><br><span class="line">        dp[inx] += dp[son];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) &#123;</span><br><span class="line">        if (n == m &amp;&amp; n == 0) break;</span><br><span class="line">        init();</span><br><span class="line">        dfs(1, -1);</span><br><span class="line">        ll minn = sum;</span><br><span class="line">        ll t;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            if (sum - dp[i] &gt; dp[i]) &#123;</span><br><span class="line">                t = sum - dp[i] - dp[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                t = dp[i] - sum + dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            minn = min(minn, t);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;, ++tot, minn);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3107 Godfather 树形dp+模拟vector</title>
      <link href="/2018/11/07/POJ3107-Godfather-%E6%A0%91%E5%BD%A2dp-%E6%A8%A1%E6%8B%9Fvector/"/>
      <url>/2018/11/07/POJ3107-Godfather-%E6%A0%91%E5%BD%A2dp-%E6%A8%A1%E6%8B%9Fvector/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/07/POJ3107-Godfather-树形dp-模拟vector/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>Description</p><p>Last years Chicago was full of gangster fights and strange murders. The chief of the police got really tired of all these crimes, and decided to arrest the mafia leaders.</p><p>Unfortunately, the structure of Chicago mafia is rather complicated. There are <em>n</em> persons known to be related to mafia. The police have traced their activity for some time, and know that some of them are communicating with each other. Based on the data collected, the chief of the police suggests that the mafia hierarchy can be represented as a tree. The head of the mafia, Godfather, is the root of the tree, and if some person is represented by a node in the tree, its direct subordinates are represented by the children of that node. For the purpose of conspiracy the gangsters only communicate with their direct subordinates and their direct master.</p><p>Unfortunately, though the police know gangsters’ communications, they do not know who is a master in any pair of communicating persons. Thus they only have an undirected tree of communications, and do not know who Godfather is.</p><p>Based on the idea that Godfather wants to have the most possible control over mafia, the chief of the police has made a suggestion that Godfather is such a person that after deleting it from the communications tree the size of the largest remaining connected component is as small as possible. Help the police to find all potential Godfathers and they will arrest them.</p><p>Input</p><p>The first line of the input file contains <em>n</em> — the number of persons suspected to belong to mafia (2 ≤ <em>n</em> ≤ 50 000). Let them be numbered from 1 to <em>n</em>.</p><p>The following <em>n</em> − 1 lines contain two integer numbers each. The pair <em>ai</em>, <em>bi</em> means that the gangster <em>ai</em> has communicated with the gangster <em>bi</em>. It is guaranteed that the gangsters’ communications form a tree.</p><p>Output</p><p>Print the numbers of all persons that are suspected to be Godfather. The numbers must be printed in the increasing order, separated by spaces.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p>​    题目大体意思就是给出一个无向无环图，从中去掉一个结点使其分为一个或多个无向无环图，问去掉哪个结点分成的最大树的结点数最小，把所有符合条件的结点按从小到大的顺序输出出来</p><p>思路：</p><p>​    我们可以把无向无环图看作是一棵树，网上说就是求树的所有重心（也就是结点到其它结点的距离和最小）。我的思路也和网上查不多。我们可以强制以1作为根节点，然后由叶到根求每个节点作为根节点的子树的结点和。利用dp【i】存储去掉i结点分成的k颗树的最大结点数，那么dp【i】为i的全部儿子结点为根的子树的最大值与n - (i为根节点的子树结点数)，取两者的较大值即为dp【i】</p><p>​    因为是一遍遍历嘛～复杂度大概为O(n)，用vector存储邻接表2s竟然TLE我的天！！！换成数组模拟vector只有400多ms，再加上快速读模版只耗费了110ms，就酱紫～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 50005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace IO &#123;</span><br><span class="line">    const int MX = 8e5;</span><br><span class="line">    char buf[MX];</span><br><span class="line">    int c, sz;</span><br><span class="line">    void begin() &#123;</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool read(int &amp;t) &#123;</span><br><span class="line">        while (c &lt; sz &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) &#123;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (c &gt;= sz) return false;</span><br><span class="line">        for (t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) &#123;</span><br><span class="line">            t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int point[2 * N];</span><br><span class="line">int last[2 * N];</span><br><span class="line">int flag[N];</span><br><span class="line">int num[N];</span><br><span class="line">int dp[N];</span><br><span class="line">int ans[N];</span><br><span class="line"></span><br><span class="line">int read() &#123;</span><br><span class="line">    char c = getchar();</span><br><span class="line">    int x = 0;</span><br><span class="line">    while (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123;</span><br><span class="line">        x = x * 10 + c - &apos;0&apos;;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b, tot = 0;;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">        IO::read(a);</span><br><span class="line">        IO::read(b);</span><br><span class="line">        point[++tot] = b;</span><br><span class="line">        last[tot] = flag[a];</span><br><span class="line">        flag[a] = tot;</span><br><span class="line">        point[++tot] = a;</span><br><span class="line">        last[tot] = flag[b];</span><br><span class="line">        flag[b] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx, int father) &#123;</span><br><span class="line">    num[inx] = 1;</span><br><span class="line">    for (int i = flag[inx]; i != 0; i = last[i]) &#123;</span><br><span class="line">        int son = point[i];</span><br><span class="line">        if(son == father) continue;</span><br><span class="line">        dfs(son, inx);</span><br><span class="line">        num[inx] += num[son];</span><br><span class="line">        dp[inx] = max(dp[inx], num[son]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[inx] = max(dp[inx], n - num[inx]);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    IO::begin();</span><br><span class="line">    IO::read(n);</span><br><span class="line">    init();</span><br><span class="line">    dfs(1, -1);</span><br><span class="line">    int minn = 0x3f3f3f3f;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if(minn &gt; dp[i]) &#123;</span><br><span class="line">            tot = 0;</span><br><span class="line">            ans[tot++] = i;</span><br><span class="line">            minn = dp[i];</span><br><span class="line">        &#125; else if(minn == dp[i]) &#123;</span><br><span class="line">            ans[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; tot; i++) &#123;</span><br><span class="line">        if (i == tot - 1) printf(&quot;%d\n&quot;, ans[i]);</span><br><span class="line">        else printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces219D 树形dp</title>
      <link href="/2018/11/07/CodeForces219D-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/07/CodeForces219D-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/07/CodeForces219D-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>The country Treeland consists of <em>n</em> cities, some pairs of them are connected with unidirectional roads. Overall there are <em>n</em> - 1 roads in the country. We know that if we don’t take the direction of the roads into consideration, we can get from any city to any other one.</p><p>The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city <em>a</em> is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city <em>a</em> to any other city. For that some roads may have to be inversed.</p><p>Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country.</p><p>Input</p><p>The first input line contains integer <em>n</em> (2 ≤ <em>n</em> ≤ 2·105) — the number of cities in Treeland. Next <em>n</em> - 1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si, ti (1 ≤ si, ti ≤ <em>n</em>; <em>si</em> ≠ ti) — the numbers of cities, connected by that road. The <em>i</em>-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to <em>n</em>.</p><p>Output</p><p>In the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order.</p><p>Examples：</p><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>​    这道题翻译成汉语，大概意思就是给出一个有向无环图，问选择哪个节点道路方向反转次数最少且可以到达任意节点。输出最小反转次数和满足条件的全部节点</p><p>思路：</p><p>​    由于是有向无环图，我们可以将其转化为树（强制节点1为根节点），我们设正常方向权值为1，反方向权值为0.然后我们第一遍dfs从叶到根遍历每个每个节点作为根节点的子树从根节点到每个节点权值和dp【i】。然后根节点1到所有节点的反转次数为num【1】= n - 1 - dp【i】,第二遍dfs从根到叶求每个节点到全部节点的反转次数即可,利用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当从父到子为正向时</span><br><span class="line">num[son.inx] = num[father] + 1;</span><br><span class="line">//当从父到子为反向时</span><br><span class="line">num[son.inx] = num[father] - 1;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#define N 200005</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int inx, val;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;point[N];</span><br><span class="line">vector&lt;int&gt;ans;</span><br><span class="line">int dp[N];//</span><br><span class="line">int num[N];</span><br><span class="line"></span><br><span class="line">void dfs (int inx, int father) &#123;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        if(son.inx == father) continue;</span><br><span class="line">        dfs(son.inx, inx);</span><br><span class="line">        dp[inx] += son.val + dp[son.inx];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs1 (int inx, int father) &#123;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        if(son.inx == father) continue;</span><br><span class="line">        if(son.val == 1) &#123;</span><br><span class="line">            num[son.inx] = num[inx] + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            num[son.inx] = num[inx] - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(son.inx, inx);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n, a, b;</span><br><span class="line">    node c;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        memset(num, 0, sizeof(num));</span><br><span class="line">        ans.clear();</span><br><span class="line">        int minn = 0x3f3f3f3f;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            point[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            c.inx = b;</span><br><span class="line">            c.val = 1;</span><br><span class="line">            point[a].push_back(c);</span><br><span class="line">            c.inx = a;</span><br><span class="line">            c.val = 0;</span><br><span class="line">            point[b].push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, -1);</span><br><span class="line">        num[1] = n - 1 - dp[1];</span><br><span class="line">        dfs1(1, -1);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if(minn &gt; num[i]) &#123;</span><br><span class="line">                ans.clear();</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                minn = num[i];</span><br><span class="line">            &#125; else if(minn == num[i]) &#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, minn);</span><br><span class="line">        for (int i = 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            printf(&quot;%d%c&quot;, ans[i], i == ans.size() - 1? &apos;\n&apos;: &apos; &apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU2196 Computer树形dp</title>
      <link href="/2018/11/07/HDU2196-Computer%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/07/HDU2196-Computer%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/07/HDU2196-Computer树形dp/title1.jpg" alt="title1"></p><a id="more"></a><p>Problem Description</p><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.<br><img src="http://acm.hdu.edu.cn/data/images/C128-1005-1.JPG" alt="img"></p><p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p><p>Input</p><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. </p><p>Output</p><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给你n个点，再给n - 1行每行两个整数a, b，代表第i个电脑和a相连距离为b。最后输出每台电脑距离最远电脑的距离</p><p>思路：</p><p>​    这题我们可以把图转化为树，可以说是树形dp吧。我们通过第一遍dfs由叶到根递归计算每个节点作为根节点的子树中，与该节点距离最远和次远的距离与儿子节点。再通过第二遍dfs由根到叶递归计算每个节点往上走（非该子树）节点的最长距离。最后我们遍历每个节点，只需要比较该节点作为根节点的子树中的最长距离与往上走的最大值，取较大值即为答案。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 10005</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int son, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct gold &#123;</span><br><span class="line">    int maxx, son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;node&gt;point[N];</span><br><span class="line">gold maxn[N][3];  //0最大值 1次大值 2父最大值</span><br><span class="line">int pre[N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    node c;</span><br><span class="line">    mem(maxn);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        pre[i] = a;</span><br><span class="line">        c.son = i;</span><br><span class="line">        c.val = b;</span><br><span class="line">        point[a].push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx) &#123;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i ++) &#123;</span><br><span class="line">        node son = point[inx][i];</span><br><span class="line">        dfs(son.son);</span><br><span class="line">        if(maxn[inx][0].maxx &lt; son.val + maxn[son.son][0].maxx) &#123;</span><br><span class="line">            maxn[inx][1].maxx = maxn[inx][0].maxx;</span><br><span class="line">            maxn[inx][1].son = maxn[inx][0].son;</span><br><span class="line">            maxn[inx][0].maxx = son.val + maxn[son.son][0].maxx;</span><br><span class="line">            maxn[inx][0].son = son.son;</span><br><span class="line">        &#125; else if(maxn[inx][1].maxx &lt; son.val + maxn[son.son][0].maxx) &#123;</span><br><span class="line">            maxn[inx][1].maxx = son.val + maxn[son.son][0].maxx;</span><br><span class="line">            maxn[inx][1].son = son.son;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs1(int inx) &#123;</span><br><span class="line">    int father = pre[inx];</span><br><span class="line">    if(inx != 1) &#123;</span><br><span class="line">        int t;</span><br><span class="line">        for(int i = 0; i &lt; point[father].size(); i++) &#123;</span><br><span class="line">            if(point[father][i].son == inx) &#123;</span><br><span class="line">                t = point[father][i].val;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(maxn[father][0].son == inx) &#123;</span><br><span class="line">            maxn[inx][2].son = father;</span><br><span class="line">            maxn[inx][2].maxx = t + max(maxn[father][1].maxx, maxn[father][2].maxx);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn[inx][2].son = father;</span><br><span class="line">            maxn[inx][2].maxx = t + max(maxn[father][0].maxx, maxn[father][2].maxx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        dfs1(point[inx][i].son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        int ans;</span><br><span class="line">        init();</span><br><span class="line">        dfs(1);</span><br><span class="line">        dfs1(1);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = max(maxn[i][0].maxx, maxn[i][2].maxx);</span><br><span class="line">            printf(&quot;%d\n&quot;, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1520Anniversary party树形dp</title>
      <link href="/2018/11/06/HDU1520Anniversary-party-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2018/11/06/HDU1520Anniversary-party-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/06/HDU1520Anniversary-party-树形dp/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Problem Description</p><p>There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings.</p><p>Input</p><p>Employees are numbered from 1 to N. A first line of input contains a number N. 1 &lt;= N &lt;= 6 000. Each of the subsequent N lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from -128 to 127. After that go T lines that describe a supervisor relation tree. Each line of the tree specification has the form:<br>L K<br>It means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line<br>0 0 </p><p>Output</p><p>Output should contain the maximal sum of guests’ ratings.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>​    翻译成汉语再翻译成直男的视野，大概意思就是给出一个树，树上n个点，每个点都有一个权值，不能同时选取相邻的两个节点，问满足上述条件选取节点的最大权值和</p><p>思路：</p><p>​    这道题是一道典型的树形dp，我们利用邻接表记录节点之间的关系，由根到叶进行dp。</p><p>​    对于dp【i】【0】代表以该节点为根节点的子树且根节点不被选取的最大权值和</p><p>​    dp【i】【1】代表以该节点为根节点的子树且根节点被选取的最大权值和</p><p>​    我们可以得到父子之间的递推关系式子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当父节点不被选取时，它的dp[inx][0]等于每个儿子节点被选取和不被选取的最大值的和</span><br><span class="line">dp[inx][0] += max(dp[son][1], dp[son][0]);</span><br><span class="line"></span><br><span class="line">//当父节点被选取时，它的dp[inx][1]等于每个儿子节不被选取的和 + 父亲节点的权值</span><br><span class="line">dp[inx][1] = val[inx];</span><br><span class="line">dp[inx][1] += dp[son][0];</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 6005</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int val[N];</span><br><span class="line">int pre[N];</span><br><span class="line">vector&lt;int&gt;point[N];</span><br><span class="line">ll dp[N][2];        //1参加 0不参加</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">        point[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) == 2) &#123;</span><br><span class="line">        if (a == 0 &amp;&amp; b == 0) break;</span><br><span class="line">        point[b].push_back(a);</span><br><span class="line">        pre[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int inx) &#123;</span><br><span class="line">    dp[inx][1] = val[inx];</span><br><span class="line">    for (int i = 0; i &lt; point[inx].size(); i++) &#123;</span><br><span class="line">        int son = point[inx][i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        dp[inx][0] += max(dp[son][1], dp[son][0]);</span><br><span class="line">        dp[inx][1] += dp[son][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        init();</span><br><span class="line">        int root;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if(pre[i] == i) &#123;</span><br><span class="line">                root = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        printf(&quot;%d\n&quot;, max(dp[root][1], dp[root][0]));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSOI307加分二叉树 区间dp</title>
      <link href="/2018/11/06/SSOI307%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8C%BA%E9%97%B4dp/"/>
      <url>/2018/11/06/SSOI307%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8C%BA%E9%97%B4dp/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/06/SSOI307加分二叉树-区间dp/titile2.jpg" alt="titile2"></p><a id="more"></a><p>【问题描述】</p><p>  设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：<br>subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数<br> 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br> 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；<br> （1）tree的最高加分<br> （2）tree最高得分的前序遍历<br>【输入格式】</p><p>第1行：一个整数n（n＜30），为节点个数。<br>第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。<br>【输出格式】</p><p>第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。<br>第2行：n个用空格隔开的整数，为该树的前序遍历。<br>【输入样例1】</p><p>5<br>5 7 1 2 10<br>【输出样例1】</p><p>145<br>3 1 2 4 5</p><p>思路:</p><p>​    虽然这是一个在树上的动态规划题，但实际还是一道区间DP，dp【i】【j】代表区间[i, j]的最高得分，dp【1】【n】即为答案，利用数组query【i】【j】记录该区间的根节点，通过dfs就可以得到最高得分的前序遍历。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">ll dp[35][35];</span><br><span class="line">int query[35][35];</span><br><span class="line">int tot, n;</span><br><span class="line"></span><br><span class="line">void dfs(int left, int right) &#123;</span><br><span class="line">    if (left &gt; right) return;</span><br><span class="line">    int k = query[left][right];</span><br><span class="line">    if (tot != n - 1) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, k);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    dfs(left, k - 1);</span><br><span class="line">    dfs(k + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        tot = 0;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        memset(query, 0, sizeof(query));</span><br><span class="line">        for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;dp[i][i]);</span><br><span class="line">            query[i][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int len = 1; len &lt;= n - 1; len++) &#123;</span><br><span class="line">            for (int i = 1; i + len &lt;= n; i++) &#123;</span><br><span class="line">                for (int k = i; k &lt;= i + len; k++) &#123;</span><br><span class="line">                    ll left, right;</span><br><span class="line">                    if(k == i) &#123;</span><br><span class="line">                        right = dp[i + 1][i + len];</span><br><span class="line">                        left = 1;</span><br><span class="line">                    &#125; else if (k == i + len) &#123;</span><br><span class="line">                        right = 1;</span><br><span class="line">                        left = dp[i][i + len - 1];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        right = dp[k + 1][i + len];</span><br><span class="line">                        left = dp[i][k - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (dp[k][k] + right * left &gt; dp[i][i + len]) &#123;</span><br><span class="line">                        dp[i][i + len] = dp[k][k] + right * left;</span><br><span class="line">                        query[i][i + len] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;, dp[1][n]);</span><br><span class="line">        dfs(1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Not a subsequence动态规划</title>
      <link href="/2018/11/06/%E8%AE%A1%E8%92%9C%E5%AE%A2Not-a-subsequence%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2018/11/06/%E8%AE%A1%E8%92%9C%E5%AE%A2Not-a-subsequence%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/06/计蒜客Not-a-subsequence动态规划/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>In this problem we consider strings over a fixed finite alphabet of size k. The alphabet contains the first k characters from the list</p><p>a,b,c,…,z,A,B,C,…,Z,0,1,…,9.</p><p>For every test case, we are given the value of k(notice that it cannot exceed 62), and consider only strings consisting of the first k characters from the list.</p><p>Given a string s[1..n], we are interested in strings which are not its subsequences. Formally, a string t[1..m] is a subsequence of a string s[1..n] when one can choose not necessarily contiguous‾not necessarily contiguous indices 1≤i1&lt;i2&lt;…im≤n such that t[1]=s[i1],t[2]=s[i2],…,t[m]=t[im]</p><p>For example, acb is a subsequence of babcaabbabcaab. Now, given a string s[1..n], we would like to compute the smallest mm such that there is a string t[1..m], which is not a subsequence of s[1..n]. Additionally, we would like to count the number of such shortest strings t[1..m].</p><p>As the latter number can be quite large, output it modulo 10^9+7.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with the number of test cases T≤100.</p><p>Then the descriptions of TT test cases follow. A single test case consists of a single line containing the size of the alphabet k(k∈[1,62]) and the string s【1..n】(n∈[1,10^6])]. The string consists of the first k characters from a−zA−Z0−9.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For every test case output one line containing two numbers.</p><p>The first number is the smallest mm such that there is a string t[1..m] consisting of the first kkcharacters from a−zA−Z0−9, which is not a subsequence of s[1..n].</p><p>The second number is the total count of such shortest strings t[1..m] modulo 10^9+7.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 abba</span><br><span class="line">62 0123456789</span><br><span class="line">3 aabbcbbcbabcbab</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 52</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概意思就是给你T组样例，每组样例有一个n，代表有n种字符，然后再给出一个字符串。问字符串中不存在的子串的最小长度是多少？有多少种（答案取余1e9+7）？例如 abba，对于字符a,b来说，它不存在的最小子串长度为3，分别为aaa,bbb,aab,baa,bbb</p><p>思路：</p><p>​    一道特别难的dp题，关键是思路吧~</p><p>​    我们首先考虑字符串中不存在的子串的最小长度，我们从前往后遍历，每当出现一个没有标记过的字符就标记一次，当n个字符都标记过时，此时子串长度为1的都有了，因此最小长度只能是2，此时我们需要清空标记，继续往后遍历，每当出现一个没有标记过的字符就标记一次，当n个字符都标记过时，此时子串长度为2的都有了（因为每种字符前面一定每种字符至少存在一次），因此最小长度只能是3</p><p>​    我们再来考虑不存在的最小长度子串有多少种，若最小长度子串为1，那么种类为n-字符串中字符的种类数。若最小长度子串大于1时呢？这时候就需要DP推导式了..</p><p>​    给大家举个例子吧：对于3 abbcbabc来说：</p><p>​    从前往后遍历，第一个字符为a，没有标记过，然后标记该字符，此时字符计数num = 1。那么长度为2的以a结尾的子串没有出现的种类数为3（分别是aa,ba,ca），总计数sum[2] = 3。并设置字符a上一次出现的位置为1</p><p>​    第二个字符b，没有标记过，然后标记该字符，此时字符计数num = 2。那么长度为2的以b结尾没有出现的子串种类数为2（分别是bb,cb），总计数sum[2] = 3 + 2 = 5。并设置字符b上一次出现的位置为2</p><p>​    第三个字符b，标记过，此时字符计数num = 2。长度为2的以b结尾没有出现的子串种类数为1（cb），总计数sum[2] = 3 + 2 + 1 - 2 = 4(也就是sum[2] + 1 - 上次b出现加的2)。并设置字符b上一次出现的位置为3</p><p>​    第四个字符c，没有标记过，然后标记该字符，此时字符计数num = 3。那么长度为2的以c结尾没有出现的子串种类数为1（分别是cc），总计数sum[2] = 3 + 2 + 1 - 2 + 1 = 5。并设置字符c上一次出现的位置为4,此时num==字符种类数，因此没出现的最小子串长度至少为2，清空标记与字符计数num</p><p>​    第五个字符b，没有标记过，然后标记该字符，此时字符计数num = 1。那么长度为3的以b结尾没有出现的子串种类数为5（分别是aab,bab,cab,cbb,ccb），总计数sum[3] = sum[2] = 5,由于上一次出现过b且上次出现b是求长度为2的，因此sum[2] = sum[2] - 1 = 4(也就是sum[2]- 上一次b出现增加的1)，并设置字符b上一次出现的位置为5</p><p>​    第六个字符a，没有标记过，然后标记该字符，此时字符计数num = 2。那么长度为3的以a结尾没有出现的子串种类数为4（分别是aaa,baa,caa,cca），总计数sum[3] = 5 + 4 = 9,由于上一次出现过a且上次出现a是求长度为2的，因此sum[2] = sum[2] - 3 = 1(也就是sum[2]- 上一次a出现增加的3)，并设置字符a上一次出现的位置为6</p><p>​    第七个字符b，标记过，此时字符计数num = 2。那么长度为3的以b结尾没有出现的子串种类数为1（ccb），总计数sum[3] = 5 + 4 + 1   = 10,由于上一次出现过b且上次出现b是求长度为3的，因此sum[3] = sum[3] - 5 = 5(也就是sum[3]- 上一次b出现增加的5)，并设置字符b上一次出现的位置为7</p><p>​    第八个字符c，没有标记过，然后标记该字符，此时字符计数num = 3。那么长度为3的以c结尾没有出现的子串种类数为1（ccc），总计数sum[3] = 5 + 1 = 6,由于上一次出现过c且上次出现c是求长度为2的，因此sum[2] = sum[2] - 1 = 0(也就是sum[2]- 上一次c出现增加的1)，并设置字符c上一次出现的位置为8,由于num == 字符种类数，因此没出现的最小子串长度至少为3</p><p>​    因此最小子串长度为3，没出现的种类数为sum[3] = 6</p><p>​    原理就是这个原理～只需要线性就能求解</p><p>​    </p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 1000000</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define ll long long</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">char s[N + 5];//存储字符串</span><br><span class="line">int map[300];//存储字符映射</span><br><span class="line">bool book[70];//标记数组</span><br><span class="line">ll add[70];//存储该字符上一次增加的值</span><br><span class="line">int flag[70];//记录该字符上一次是为了长度为几的子串贡献的add</span><br><span class="line">ll dp[N + 5];//dp[i]存储长度为i的子串没有出现的种类数</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for (int i = &apos;a&apos;; i &lt;= &apos;z&apos;; i++) &#123;</span><br><span class="line">        map[i] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = &apos;A&apos;; i &lt;= &apos;Z&apos;; i++) &#123;</span><br><span class="line">        map[i] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = &apos;0&apos;; i &lt;= &apos;9&apos;; i++) &#123;</span><br><span class="line">        map[i] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d%s&quot;, &amp;n, s);</span><br><span class="line">        int len = strlen(s);</span><br><span class="line">        mem(book);</span><br><span class="line">        mem(dp);</span><br><span class="line">        mem(flag);</span><br><span class="line">        mem(add);</span><br><span class="line">        dp[1] = n;</span><br><span class="line">        int chang = 1, num = 0;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int t = map[s[i]];</span><br><span class="line">            if(chang == 1) &#123;</span><br><span class="line">                dp[2] = (dp[2] + n - num + mod) % mod;</span><br><span class="line">                if (book[t]) &#123;</span><br><span class="line">                    dp[2] = (dp[2] - add[t] + mod) % mod;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[1]--;</span><br><span class="line">                &#125;</span><br><span class="line">                add[t] = n - num;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[chang + 1] = (dp[chang + 1] + dp[chang]) % mod;</span><br><span class="line">                ll zj = dp[chang];</span><br><span class="line">                if(book[t]) &#123;</span><br><span class="line">                    dp[chang + 1] = (dp[chang + 1] - add[t] + mod) % mod;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (flag[t] == chang - 1) &#123;</span><br><span class="line">                        dp[chang] = (dp[chang] - add[t] + mod) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                add[t] = zj;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[t] = chang;</span><br><span class="line">            if(!book[t]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                book[t] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (num == n) &#123;</span><br><span class="line">                chang++;</span><br><span class="line">                mem(book);</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %lld\n&quot;, chang, dp[chang]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Gold Rush水题</title>
      <link href="/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Gold-Rush%E6%B0%B4%E9%A2%98/"/>
      <url>/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Gold-Rush%E6%B0%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/05/计蒜客Gold-Rush水题/title1.jpg" alt="title1"></p><a id="more"></a><p>题意：</p><p>Alice and Bob are on an adventure trip. Deep in the woods they discover a mysterious deep cave which they enter flutteringly. They find an old console with a giant bar of gold in it. On the bar, there is a number n. Both tried to carry the gold out the cave, but it was still to heavy for one of them.</p><p>Suddenly a little fairy appears in the corner of the cave and approaches Alice and Bob: “This gold is heavy. It weights 2^n femto-grams (10^−15) and nncan reach 62.”</p><p>Bob answered: “What luck! Alice’s knapsack can carry up to aa femto-grams and mine bb femto-grams with a+b=2^n.” Alice interjected: “But how can we divide the gold?”</p><p>Fairy: “I can help you with a spell that can burst one piece of gold into two equally weighted ones. But for each single spell, the cave will be locked one additional day.”</p><p>Alice consults with Bob to use the help of the fairy and take all of the gold. How long will they be trapped if they are clever?</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with the number t≤1000 of test cases.</p><p>Then tt lines follow, each describing a single test case consisting of three numbers n,an,a and bb with a,b≥1,a+b=2^n, and 1≤n≤62.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output one line for every test case with the minimal number of days that Alice and Bob are locked in the cave.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 2 2</span><br><span class="line">2 1 3</span><br><span class="line">10 1000 24</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概意思就是有T组样例，每组样例有一个数是2^n，把它分成a，b，每次只能把一个数分成两个该数的一半，问最少分多少次能够分成a，b巴拉巴拉～</p><p>​    </p><p>思路：</p><p>​    我们只需要得到a，b的最小值t，然后循环把2^n累除2，若比t小就用t-该数，直到t为0为止</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n;</span><br><span class="line">long long quick(long long a, long long b) &#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    while(b) &#123;</span><br><span class="line">        if(b&amp;1) ans *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    long long n, a, b;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        long long res = quick(2, n);</span><br><span class="line">        long long minn = min(a, b);</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(minn) &#123;</span><br><span class="line">            res /= 2;</span><br><span class="line">            num++;</span><br><span class="line">            if(res &lt;= minn) &#123;</span><br><span class="line">                minn -= res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Algebraic Teamwork思维</title>
      <link href="/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Algebraic-Teamwork%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Algebraic-Teamwork%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/05/计蒜客Algebraic-Teamwork思维/titile.jpg" alt="titile"></p><a id="more"></a><p>题意：</p><p>The great pioneers of group theory and linear algebra want to cooperate and join their theories. In group theory, permutations – also known as bijective functions – play an important role. For a finite set A, a function σσ: A → A is called a permutation of A if and only if there is some function ρ : A →  A with</p><p>σ(ρ(a))=a and ρ(σ(a))=afor all a∈A.</p><p>The other half of the new team – the experts on linear algebra – deal a lot with idempotent functions. They appear as projections when computing shadows in 3D games or as closure operators like the transitive closure, just to name a few examples. A function pp : A → A is called idempotent if and only if</p><p>p(p(a))=p(a)for all a∈A.</p><p>To continue with their joined research, they need your help. The team is interested in non-idempotent permutations of a given finite set AA. As a first step, they discovered that the result only depends on the set’s size. For a concrete size 1≤n≤10^5, they want you to compute the number of permutations on a set of cardinality nnthat are <strong>not</strong> idempotent.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with the number t≤100 of test cases.</p><p>Then tt lines follow, each containing the set’s size 1≤n≤10^5.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output one line for every test case containing the number modulo 1000000007=(109+7) of <strong>non</strong>-idempotent permutations on a set of cardinality nn.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2171</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">6425</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给出T组数据，每组数据给出一个集合A的范围n，问有多少对映射σ和ρ，使得σ(ρ(a))=a and ρ(σ(a))=afor all a∈A.但不满足p(p(a))=p(a)for all a∈A.</p><p>思路：</p><p>​    对于第一个条件，我们只要满足a经过ρ，σ映射后还为a且映射关系都为一一映射，这道题刚开始以为是错排的种类数，结果不对后仔细一想，不满足p(p(a))=p(a)for all a∈A.，只要有一个a不满足即可，所以只要不是完全不变的映射即可（种类数为1），答案也就是全排列-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">const long long mod = 1e9+7;</span><br><span class="line">long long jc[100005];</span><br><span class="line">void init() &#123;</span><br><span class="line">    jc[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= 100000; i++) &#123;</span><br><span class="line">        jc[i] = i * jc[i - 1] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;, jc[n] - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Bounty Hunter多路dp</title>
      <link href="/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Bounty-Hunter/"/>
      <url>/2018/11/05/%E8%AE%A1%E8%92%9C%E5%AE%A2Bounty-Hunter/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/05/计蒜客Bounty-Hunter/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Spike is a bounty hunter and he is currently tracking a criminal! To investigate he uses his spaceship, the Swordfish II, and travels to Ndifferent places on 2D Euclidean space before returning to his crew at the starting location with all the information he has gathered. The starting location is the leftmost place (with the lowest x-coordinate) and Spike wants to travel to everyeveryother place before returning. However space fuel costs a lot of Woolongs and Spike would rather spend his money on special beef with bell peppers. Therefore he wants to travel the minimum possible distance.</p><p>On top of that he is being chased by the Red Dragon crime syndicate. To make sure they don’t catch him he can only visit places in increasing order of their xx-coordinate until he reaches the rightmost place (with the largest x-coordinate), then he can turn around and visit places in decreasing order of their x-coordinate until he reaches his starting location again.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input starts with an integer T(1≤T≤100) specifying the number of test cases that follow.</p><p>Each test case consists of an integer N(2≤N≤512) specifying the number of places in the tour.</p><p>The coordinates of these places are given as integers in the next NN lines, xx-coordinate first, yy-coordinate second (0≤x,y≤5000).</p><p>The places are given in ascending order of the x-coordinate.</p><p>Every place has a unique x-coordinate.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, output on a single line the minimum travel distance needed to complete the tour.</p><p>Your output should have an absolute or relative error of at most 10^-2</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 0</span><br><span class="line">3 2</span><br><span class="line">4 1</span><br><span class="line">3</span><br><span class="line">100 1</span><br><span class="line">200 1</span><br><span class="line">300 1</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9.300563079746</span><br><span class="line">400</span><br></pre></td></tr></table></figure><p>大概意思就是给T组样例，每组样例有n个地方，从最左边开始，从左往右走到最右边，再从最右边返回到最左边，每个点有且经过一次，求最短路径</p><p>思路：</p><p>​    我们找一个人从起点开始绕一圈的最短路，其实就是找两个人从起点到达终点（两个人除了终点和起点，不能经过相同的点）路径和的最小值。这是一个旅行商问题。由于505数值太大，因此可以用多路dp来求解</p><p>​    我们设dp【i】【j】保证第一个人到达i点，第二个人到达j点，i &lt; j且j之前的所有点都经过的最小花费，有关递推式在代码中有标注</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    double x, y;</span><br><span class="line">&#125;point[550];</span><br><span class="line"></span><br><span class="line">bool zfq (node A, node B) &#123;</span><br><span class="line">    return A.x &lt; B.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double sq(node A, node B) &#123;</span><br><span class="line">    return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dp[550][550];      //dp[i][j]保证第一个到达i点，第二个人到达j点，i &lt; j且j之前的所有点都经过的最小花费</span><br><span class="line">double d[550][550];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        double ans = inf;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(point, point + n, zfq);</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = inf;</span><br><span class="line">                d[i][j] = sq(point[i], point[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][1] = d[0][1];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j][j + 1] = min (dp[j][j + 1], dp[i][j] + d[i][j + 1]);//可能是i走到j+1</span><br><span class="line">                dp[i][j + 1] = min (dp[i][j + 1], dp[i][j] + d[j][j + 1]);//也可能是j走到j+1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i ++) &#123;</span><br><span class="line">            ans = min(ans, dp[i][n - 1] + d[i][n - 1]);//由于i&lt;j，所以需额外加一个for循环求dp[n-1][n-1]的最小值</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%f\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 多路dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计蒜客Equator尺取法</title>
      <link href="/2018/11/04/%E8%AE%A1%E8%92%9C%E5%AE%A2Equator/"/>
      <url>/2018/11/04/%E8%AE%A1%E8%92%9C%E5%AE%A2Equator/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/04/计蒜客Equator/title1.jpg" alt="title1"></p><a id="more"></a><p>题意：</p><p>In a galaxy far away, the planet Equator is under attack! The evil gang Galatic Criminal People Cooperation is planning robberies in Equator’s cities. Your help is needed! In order to complete your training for becoming a lord of the dark side you should help them deciding which cities to rob.</p><p>As the name says, the desert planet Equator only can be inhabited on its equator. So the gang lands there at some point and travels into some direction robbing all cities on their way until leaving the planet again.</p><p><img src="/2018/11/04/计蒜客Equator/1.jpg" alt="1"></p><p>But what is still open for them is to decide where to land, which direction to take, and when toleave. Maybe they shouldn’t even enter the planet at all? They do not consider costs for travelingor for running their ship, those are peanuts compared to the money made by robbery!</p><p>The cities diﬀer in value: some are richer, some are poorer, some have better safety functions. So the gang assigned expected proﬁts or losses to the cities. Help them deciding where to begin and where to end their robbery to maximize the money in total when robbing every city in between.<br>输入</p><p>The input starts with the number of test cases T ≤ 30. Each test case starts a new line containingthe number of cities 1 ≤ n ≤ 1 000 000. In the same line n integers c i follow. Each c i (0 ≤ i &lt; n,−1000 ≤ c i ≤ +1000) describes the money obtained when robbing city i, a negative c i describes the amount of money they would lose.<br>输出</p><p>For each test case print one integer describing the maximum money they can make in total.<br>样例输入</p><p>3<br>3 1 2 3<br>8 4 5 -1 -1 1 -1 -1 5<br>2 -1 -1<br>样例输出</p><p>6<br>14</p><p>0</p><p>​    这道题翻译成中文的意思大概就是给出一个n个数围成一圈，问最大连续子序列的和是多少？</p><p>思路：</p><p>这道题解法有很多，自己习惯用尺取来求解。对于一个循环的序列，它的最大连续自序列要么是在这个数组中连续，要么是在这个数组中首尾相连。对于在这个数组中连续，我们可以通过尺取法求出来。对于收尾相连，我们可以换位思考，求出数组中连续的最小连续子序列，那么用数组的权值和减去最小连续子序列，剩下的两段连接起来就是收尾相连的最大连续子序列，我们只需要比较数组中连续的和数组首尾相连，取最大值即是正确答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">ll a[1000005];</span><br><span class="line">int main () &#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T --) &#123;</span><br><span class="line">        ll sum = 0;</span><br><span class="line">        ll maxx = 0;</span><br><span class="line">        ll minn = 0x3f3f3f3f;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int endd = 0;</span><br><span class="line">        ll num = 0;</span><br><span class="line">        while(endd &lt; n) &#123;</span><br><span class="line">            if (num + a[endd] &lt; 0) &#123;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num += a[endd];</span><br><span class="line">                maxx = max(num, maxx);</span><br><span class="line">            &#125;</span><br><span class="line">            endd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        num = 0; endd = 0;</span><br><span class="line">        while(endd &lt; n) &#123;</span><br><span class="line">            if (num + a[endd] &gt; 0) &#123;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num += a[endd];</span><br><span class="line">                minn = min(num, minn);</span><br><span class="line">            &#125;</span><br><span class="line">            endd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = max(maxx, sum - minn);</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 尺取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯消元</title>
      <link href="/2018/10/26/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
      <url>/2018/10/26/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/26/高斯消元/title.jpg" alt="title"></p><a id="more"></a><p>待补～</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十四)莫比乌斯反演</title>
      <link href="/2018/10/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/10/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/莫比乌斯反演/title.jpg" alt="title"></p><a id="more"></a><p>​    上一篇将了二项式反演，这一篇讲一下莫比乌斯反演</p><p>学习莫比乌斯反演前，我们先要学习一下莫比乌斯函数</p><p>一.莫比乌斯函数定义：</p><p>​    定义如下：</p><p>​        μ(1) = 1    当x = 1时</p><p>​        μ(x) = (-1)^k    当x由k个不同的质数相乘得到时（保证每个质数都不同且只有质数）</p><p>​        μ(x) = 0    其余情况</p><p>​    </p><p>二.莫比乌斯函数性质：</p><p>​    性质1:当n = 1时，∑ μ(d) = 1   （其中d为n的全部因子）</p><p>​            当n&gt;1时，∑ μ(d) = 0   （其中d为n的全部因子）</p><p>​    性质2：∑ μ(d) / d = φ(n) / n     φ(n)为欧拉函数</p><p>三.线性处理莫比乌斯函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mu[N + 5], vis[N + 5], prime[N + 5];//mu数组用来存储莫比乌斯函数值，vis数组用于标记，prime用于存素数</span><br><span class="line">void init()&#123;</span><br><span class="line">    mu[1] = 1;</span><br><span class="line">    for(int i = 2; i &lt;= N; i ++)&#123;</span><br><span class="line">        if(!vis[i])&#123;//如果是素数</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            mu[i] = -1;//莫比乌斯函数为1</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt;= N; j ++)&#123;</span><br><span class="line">            vis[i * prime[j]] = 1;</span><br><span class="line">            if(i % prime[j]) mu[i * prime[j]] = -mu[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                mu[i * prime[j]] = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四.莫比乌斯反演公式：</p><p><img src="/2018/10/24/莫比乌斯反演/1.jpg" alt="1"></p><p>或者：</p><p><img src="/2018/10/24/莫比乌斯反演/2.jpg" alt="2"></p><pre><code>其中d|n表示能被n整除的所有因子d</code></pre><p>五.例题</p><p>​    给出x, y的范围(x &lt;= a, y &lt;= b),问满足gcd(x, y) == k的对数？</p><p>​    当然啦，有其它巧妙的思路，比如利用欧拉函数+容斥原理，下面来说一下莫比乌斯反演的做法：</p><p>​    设g(d)为满足gcd(x, y) == d的x,y对数，f(d)为满足gcd(x, y) == d的倍数 的x，y的对数</p><p>​    则：f(1) = g(1) + g(2) + g(3) + …</p><p>​        f(2) = g(2) + g(4) + g(6) + …</p><p>​    我们由题意可得f(n) = (a / n)✖️(b / n)</p><p>​    再根据莫比乌斯反演求解g(1) = μ(1)✖️f(1) + μ(2)✖️f(2) + μ(3)✖️f(3) +… + μ(a)✖️f(a)  (当a &lt; b时)即可</p><p>​    若是对数(1, 2)和(2, 1)算作一个则需要去重！！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十三)二项式反演</title>
      <link href="/2018/10/24/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/10/24/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/二项式反演/title1.jpg" alt="title1"></p><a id="more"></a><p>一.引出反演</p><p>​    对于公式f(n) = g(1) + g(2) + … + g(n)，我们只要已知g(x)的函数方程，就可以得到任意的f(n)。但是已知f(x)的函数方程，我们能得到任意的g(n)吗？</p><p>​    这时候，我们就需要用到反演定理了。利用反演定理，我们就可以通过f(x)求任意的g(n)了</p><p>二.反演定理:</p><p><img src="/2018/10/24/二项式反演/1.png" alt="1"></p><p>​    对于不同的的用法，c，d是不同的，至于推导。。。我是不会，Orz～ 关于常用的反演，数学家们已经推倒出来c函数和d函数，我们直接记住用就可以了。</p><p>​    我们常见的反演有二项式反演，斯特林反演，莫比乌斯反演和最值反演，接下来说一下二项式反演。</p><p>三.二项式反演：</p><p>​        <img src="/2018/10/24/二项式反演/2.png" alt="2"></p><p>​    其中（上:n 下:i）代表C(n, i)</p><p>​    </p><p>四.例题：</p><p>​    比如，n封信全部装错的方案数？</p><p>​    当然啦，有个错排公式能O(n)的的推出来，我们还是先看一下二项式反演的做法：</p><p>​    我们设g(i)代表i封信全部装错的方案数</p><p>​    那么∑ C(n, i)✖️g(i)正好是全部的装信情况，也就是n!</p><p>​    因此,f(n) = n! = ∑ C(n, i)✖️g(i)</p><p>​    我们根据二项式反演公式得g(n) = ∑ (-1)^(n - i)✖️C(n, i)✖️f(i)</p><p>​    因此我们只需要累加i从0～n的 (-1)^(n - i)✖️C(n, i)✖️(i)!的和，即为正确答案～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十二)母函数</title>
      <link href="/2018/10/24/%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2018/10/24/%E6%AF%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/母函数/title2.jpg" alt="title2"></p><a id="more"></a><p>一.引出母函数</p><p>​    母函数，也就是生成函数，在ACM中常常用于求解组合数学的计数问题。</p><p>​    一般的，能用母函数做的题，也能用其它方法（诸如推规律啦，DP啦）等等来做，母函数的复杂度为O(n^3),可以说是非常高了，所以只有在数据特别小且实在想不到其他方法求解的时候才可以尝试一下用母函数来做</p><p>​    那么，什么是母函数呢？</p><p>二.母函数的内容与例子</p><p>​    把一个已知的序列和x的多项式{x^0, x^1, x^2, … , x^n}合并起来，产生的新的多项式就叫做原来序列的母函数。</p><p>​    例如：序列{1, 0, 2, 4, 3, 1, 2}的母函数为f(x) = 1✖️x^0 + 0✖️x^1+ 2✖️x^2 + 4✖️x^3 + 3✖️x^4 + 1✖️x^5 + 2✖️x^6;</p><p>​    下面就讲解两道例题，来说明母函数的用法：</p><p>​    1.例如有1g, 2g, 3g, 4g砝码各一枚，问能称几种重量，每种重量的方案数？</p><p>​        1g砝码就是x^0 + x^1，2g砝码就是 x^0 + x^2，3g砝码就是x^0 + x^3，4g砝码就是x^0 + x^4</p><p>​        把他们累乘并化简，得到：1 + x + x^2 + 2✖️x^3 + 2✖️x^4 + 2✖️x^5 + 2✖️x^6 + 2✖️x^7 + x^8 + x^9 + x^10</p><p>​    我们从方程式可知，可以称0～10种重量，其中3～7有两种称法，其余一种</p><p>​    </p><p>​    2.有1分，2分，3分邮票无限，问贴出不同数值的方案数 （数值小于等于100）？</p><p>​        一分邮票可表示为(x^0 + x^1 + x^2 + x^3 + ….+ x^100)</p><p>​        二分邮票可表示为(x^0 + x^2 + x^4 + x^6 + ….+ x^100)</p><p>​        三分邮票可表示为(x^0 + x^3 + x^6 + x^9 + ….+ x^99)        </p><p>​        将三者累乘即可得到如例1中的方程式，即可一眼得到答案（可利用剪枝省略数值&gt;100的部分）</p><p>三.母函数的代码实现</p><p>​    我们拿第2个例子来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll N = 100;//设置上界</span><br><span class="line">ll c1[N + 5];   //c1[i]为最终多项式幂为i的系数</span><br><span class="line">ll c2[N + 5];   //c2为临时合并的多项式</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    c1[0] = 1;  //初始化0的情况算1种</span><br><span class="line">    for (int i = 1; i &lt;= 3; i++) &#123;          //遍历每种邮票</span><br><span class="line">        for (int j = 0; j &lt;= N; j += i) &#123;    //该种邮票存在的次幂j</span><br><span class="line">            for (int k = 0; j + k &lt;= N; k++) &#123;</span><br><span class="line">                c2[j + k] += c1[k] * 1;     //因为每种邮票的不同次幂系数都为1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt;= N; j++) &#123;     //将中间状态c2转移到c1并清空c2</span><br><span class="line">            c1[j] = c2[j];</span><br><span class="line">            c2[j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//c1[i]即为组成i分钱的方案数</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1430 康托展开</title>
      <link href="/2018/10/24/HDU1430-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2018/10/24/HDU1430-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/HDU1430-康托展开/title.jpg" alt="title"></p><a id="more"></a><p>这道题需要用到上一篇讲的康托展开与逆展开原理 <a href="http://www.ivan-zcy.top/2018/10/24/康托展开/">跳转</a></p><p>题意：</p><p>Problem Description</p><p>在魔方风靡全球之后不久，Rubik先生发明了它的简化版——魔板。魔板由8个同样大小的方块组成，每个方块颜色均不相同，可用数字1-8分别表示。任一时刻魔板的状态可用方块的颜色序列表示：从魔板的左上角开始，按顺时针方向依次写下各方块的颜色代号，所得到的数字序列即可表示此时魔板的状态。例如，序列(1,2,3,4,5,6,7,8)表示魔板状态为：</p><p>1 2 3 4<br>8 7 6 5</p><p>对于魔板，可施加三种不同的操作，具体操作方法如下：</p><p>A: 上下两行互换,如上图可变换为状态87654321<br>B: 每行同时循环右移一格,如上图可变换为41236785<br>C: 中间4个方块顺时针旋转一格,如上图可变换为17245368</p><p>给你魔板的初始状态与目标状态，请给出由初态到目态变换数最少的变换步骤，若有多种变换方案则取字典序最小的那种。</p><p>Input</p><p>每组测试数据包括两行，分别代表魔板的初态与目态。</p><p>Output</p><p>对每组测试数据输出满足题意的变换步骤。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345678</span><br><span class="line">17245368</span><br><span class="line">12345678</span><br><span class="line">82754631</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line">AC</span><br></pre></td></tr></table></figure><p>思路：</p><p>  上一篇举的例子就是这道题。在上一篇中我们说过，这道题无论把序列作为10进制或利用状压转成二进制都无法进行存储。因此需要利用康托展开的方式进行存储。</p><p>​    因此，我们只需要利用BFS预处理出初状态为1,2,3,4,5,6,7,8到每种状态的最小步骤即可，然后利用map将1,2,3,4,5,6,7,8映射到真正的初始状态，然后利用该映射关系得到目标状态相对于1,2,3,4,5,6,7,8的状态目标状态值t，ans[t]即为结果，因此只需要预处理，其它查询都是O(1)操作</p><p>​    </p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 100000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s1[10], s2[10];</span><br><span class="line">ll fact[10];</span><br><span class="line">queue&lt;ll&gt; q;</span><br><span class="line">bool book[N + 5];</span><br><span class="line">bool flag[10];</span><br><span class="line">string ans[N + 5];</span><br><span class="line">map&lt;d, d&gt; zcy;</span><br><span class="line"></span><br><span class="line">//逆康托展开</span><br><span class="line">string inv_cantor (ll num) &#123;</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    mem(flag);</span><br><span class="line">    For(i, 0, 7) &#123;</span><br><span class="line">        ll t = num / fact[7 - i];</span><br><span class="line">        num %= fact[7 - i];</span><br><span class="line">        ll tot = -1;</span><br><span class="line">        For(j, 1, 8) &#123;</span><br><span class="line">            if (!flag[j]) tot++;</span><br><span class="line">            if (tot == t) &#123;</span><br><span class="line">                flag[j] = 1;</span><br><span class="line">                s += (&apos;0&apos; + j);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//康托展开</span><br><span class="line">ll cantor (string s) &#123;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    For(i, 0, 7) &#123;</span><br><span class="line">        d tot = 0;</span><br><span class="line">        For (j, i + 1, 7) &#123;</span><br><span class="line">            if (s[i] &gt; s[j]) tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += tot * fact[7 - i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//三种操作</span><br><span class="line">string chooes (string s, d inv) &#123;</span><br><span class="line">    if (inv == 0) &#123;</span><br><span class="line">        For(i, 0, 3) &#123;</span><br><span class="line">            swap(s[i], s[7 - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (inv == 1)&#123;</span><br><span class="line">        Forr(i, 3, 1) &#123;</span><br><span class="line">            swap(s[i], s[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 4, 6) &#123;</span><br><span class="line">            swap(s[i], s[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        swap(s[1], s[2]);</span><br><span class="line">        swap(s[1], s[5]);</span><br><span class="line">        swap(s[1], s[6]);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//预处理开始为1,2,3,4,5,6,7,8到各个状态的最小步数</span><br><span class="line">void init () &#123;</span><br><span class="line">    mem(fact);</span><br><span class="line">    mem(book);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    fact[0] = fact [1] = 1;</span><br><span class="line">    For(i, 2, 7) &#123;//预处理阶乘</span><br><span class="line">        fact[i] = fact[i - 1] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    book[0] = 1;</span><br><span class="line">    q.push(0);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        ll num = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        string s = inv_cantor (num);</span><br><span class="line">        For(i, 0, 3) &#123;//保证字典序最小</span><br><span class="line">            string ss = chooes (s, i);</span><br><span class="line">            ll num1 = cantor(ss);</span><br><span class="line">            if (!book[num1]) &#123;</span><br><span class="line">                q.push(num1);</span><br><span class="line">                book[num1] = 1;</span><br><span class="line">                ans[num1] = ans[num] + (char)(&apos;A&apos; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init ();</span><br><span class="line">    while (scanf(&quot;%s&quot;, s1 + 1) == 1) &#123;</span><br><span class="line">        scanf(&quot;%s&quot;, s2 + 1);</span><br><span class="line">        zcy.clear();</span><br><span class="line">        string s = &quot;&quot;;</span><br><span class="line">        For(i, 1, 8) &#123;//利用映射关系把初始转化为12345678的序列,目标序列随之改变</span><br><span class="line">            zcy[s1[i] - &apos;0&apos;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 1, 8) &#123;</span><br><span class="line">            s += (&apos;0&apos; + zcy[s2[i] - &apos;0&apos;]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll num = cantor(s);</span><br><span class="line">        printf(&quot;%s\n&quot;, ans[num].data());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十一)康托展开与逆康托展开</title>
      <link href="/2018/10/24/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2018/10/24/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/24/康托展开/title5.jpg" alt="title5"></p><a id="more"></a><p>一.引出康托展开</p><p>​    动态规划题有一类分支叫状压DP，意思就是把状态压缩为一个二进制数组，然后转为十进制数存储。一般n的大小不会超过20，因为20个状态的组合就有2^20,也就是1e6种可能。</p><p>​    对于一些题目，紧紧利用状态压缩，会发现状态的组合数远远超过1e6的范围，那时候我们没有办法在1s内遍历出来，或者大到根本连数组都开不出来的时候，一般情况下就需要用到康托展开</p><p>​    例如：对于一个组合 1 2 3 4 5 6 7 8，A操作可以让其转变为8 7 6 5 4 3 2 1，B操作可以让其转变为4 1 2 3 6 7 8 5，C操作可以让其转变为1 7 2 4 5 3 6 8</p><p>​    给出一个初始组合和目标组合，问由初始到目标最少的变换步骤，若多种则选字典树最小的那种？</p><p>​    对于这种题，如果我们把1～8看作0～7，拿这8个数的当作一个状态来存储，需76543210种状态（且里边有些状态根本就不可能出现，如11111111），这样肯定是不可行的。</p><p>​    如果我们利用状态压缩把它转为2进制，0为000，1为001，2为010….7为111,那么8个数连在一起共有24位，也就是需要2^24 = 16777216个状态进行存储，然后缩小了7倍，但是数组依旧太大了</p><p>​    这时候，我们需要考虑康托展开对状态进行定义</p><p>二.关于康托展开</p><p>​    和状压数组不同，康托展开数组a[i]代表的是该序列从第i位开始到最后一位，第i位的数排第几(排名和i都是从0开始)</p><p>​    举个例子：3，5，4，1，2中：a[0] = 2,a[1] = 3, a[2] = 2,a[3] = 0, a[4] = 0</p><p>​    那么3 5 4 1 2的状态值 = a[0]✖️4! + a[1]✖️3! + a[2]✖️2! + a[3]✖️1! + a[4]✖️0! = 70</p><p>​    也就是说，康托展开能够把状态压缩到极致（即像上边那种没有用过的诸如11111111等都被抛弃掉，只剩有用的状态存在），即节省了空间也节省了时间。</p><p>三.关于康托逆展开</p><p>​    我们在二中得到的70可以通过康托逆展开重新得到3，5，4，1，2，方法如下：</p><p>​    70 / 4! = 2余22，因此a[0] = 2;</p><p>​    22 / 3! = 3余4，因此a[1] = 3;             </p><p>​    4 / 2! = 2余0，因此a[2] = 2;</p><p>​    0 / 1! = 0余0，因此a[3] = 0;</p><p>​        0 / 0! = 0余0，因此a[4] = 0;</p><p>​    在1, 2 , 3,  4,  5中，第2大（从0开始算）的数是3</p><p>​    在1, 2 ,  4,  5中，第3大（从0开始算）的数是5</p><p>​    在1, 2 ,  4中，第2大（从0开始算）的数是4    </p><p>​    在1, 2中，第0大（从0开始算）的数是1，最后一个数就是2</p><p>​    因此就能得到序列3，5，4，1，2</p><p>​    以上就是康托逆展开</p><p>四.代码实现：</p><p>​    (1)康托展开实现代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fact[10];//fact[i]存储i的阶乘的值</span><br><span class="line">//把数组s合并为一个状态num, k代表数组长度</span><br><span class="line">void cantor (int s[], ll &amp;num, int k) &#123;</span><br><span class="line">    num = 0;</span><br><span class="line">    for (int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for (int j = i + 1; j &lt; k; j++) &#123;</span><br><span class="line">            if (s[i] &gt; s[j]) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        num += fact[k - i - 1] * cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （2）康托逆展开代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fact[10];//fact[i]存储i的阶乘的值</span><br><span class="line">//把状态值num转回数组s</span><br><span class="line">bool book[10];//判断序列中下角标为i的数是否已经标记</span><br><span class="line">void inv_cantor (int s[], ll num, int k) &#123;</span><br><span class="line">    memset (book, 0, sizeof(book));</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        int p = num / fact[k - i - 1];</span><br><span class="line">        num %= fact[k - i - 1];</span><br><span class="line">        int tot = 0;</span><br><span class="line">        for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">            if (!book[j]) tot ++;</span><br><span class="line">            if (tot == p) &#123;</span><br><span class="line">                book[j] = 1;</span><br><span class="line">                s[i] = j + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    理论就是这些～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论十)卢卡斯定理与扩展卢卡斯</title>
      <link href="/2018/10/23/%E5%85%B3%E4%BA%8E%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
      <url>/2018/10/23/%E5%85%B3%E4%BA%8E%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/关于卢卡斯定理/title.jpg" alt="title"></p><a id="more"></a><p>​    在数论中我们经常遇到求组合数的问题，比如有n个球放入m个箱子里(m &gt; n)，每个箱子只能放一个球，问有多少种方案？类似这种题目就需要用到组合数来求解</p><p>​    学习该内容需学会之前讲的逆元和中国剩余定理。跳转链接：<a href="http://www.ivan-zcy.top/2018/10/22/关于逆元/">逆元</a>  <a href="http://www.ivan-zcy.top/2018/10/23/中国剩余定理/">中国剩余定理</a></p><p>​    那么求组合数都有什么方法呢？</p><p>一.其实早在古代，伟大的先人就解决了求解组合数的问题，那就是伟大的杨辉三角</p><p>​    我们发现        </p><p>​    1</p><p>​    1，1</p><p>​    1，2，1</p><p>​    1，3，3，1</p><p>​    1，4，6，4，1</p><p>​    1，5，10，10，5，1</p><p>​    有没有发现，C（n,m）的值就是第n行m列的值（下标从0开始）</p><p>​    虽然这样可以求组合数，但是它的复杂度是O(n^2)太大了，只能求解1e3以内的组合数</p><p>二.我们可以进一步优化</p><p>​    由于已知C（n,m）= n！/ (n - m)! ✖️m！</p><p>​    我们只需要预处理出前n的阶乘与前n阶乘的逆元，每次就可以O（1）的时间求出组合数的值</p><p>​    因此，我们只需要耗费O(n)的复杂度预处理就可以了</p><p>​    因此它可以求1e6以内的组合数</p><p>三.卢卡斯定理</p><p>​    卢卡斯定理：C（n,m）% p = C（n / p ,m / p)✖️C（n % p ,m % p) % p</p><p>​    当n和m特别大时题目中必须有取余操作，要不会爆longlong，若p小于1e7时卢卡斯定理就派上了用场。</p><p>​    附上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll fact[N + 5];</span><br><span class="line">ll inv[N + 5];</span><br><span class="line"></span><br><span class="line">//省略中间的扩展欧几里得求逆元</span><br><span class="line"></span><br><span class="line">void init () &#123;</span><br><span class="line">    fact[0] = fact[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i ++) &#123;</span><br><span class="line">        fact[i] = fact[i - 1] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N] = mod_reverse(fact[N], mod);     //调用扩展欧几里得求逆元</span><br><span class="line">    for (int i = N -1; i &gt;= 0; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + 1] * (i + 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll C (ll n, ll m) &#123;</span><br><span class="line">    if (n &lt; m || m &lt; 0) return 0;</span><br><span class="line">    if (n &lt; mod) return fact[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">    return C (n / mod, m / mod) * C (n % mod, m % mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码只适用于p&lt;1e7且p为素数的情况，若p为合数呢？</p><p>​    此时就需要用到扩展卢卡斯定理了（此前需学会中国剩余定理）</p><p>四.扩展卢卡斯定理：</p><p>​    由于p为合数，因此我们可以将p分解为p1^a1✖️p2^a2✖️…pk^ak的形式</p><p>​    因此我们可以利用卢卡斯定理求得：</p><p>​    ans ≡ x1 (mod p1^a1)</p><p>​    ans ≡ x2 (mod p2^a2)</p><p>​    ……</p><p>​     ans ≡ xk (mod pk^ak)    </p><p>​    不同质数的幂次方之间肯定两两互质，通过求得每组的解xi，再利用中国剩余定理就可以合并得到最终答案</p><p>​    每组解xi的求法：C（n，m）% (pi^ai)</p><p>​    因此我们需要获得剔除pi因子后的乘积n！,m！的逆元,（n - m）！的逆元的乘积去取模（pi^ai）并加入被剔除的pi的贡献即可</p><p>​    那么我们如何求n！剔除pi因子的乘积呢？</p><p>​    例如19! % (3^2) = （1✖️2✖️4✖️5✖️7✖️8）✖️(10✖️11✖️13✖️14✖️16✖️17)✖️(19)✖️(1✖️2✖️3✖️4✖️5✖️6)</p><p>​    （）内的代表一个分组，每个分组在取余pi^ai后结果相同，因此只需暴力一个分组，利用快速幂求解即可，对于(19)这种不足一个分组的，可以暴力单度计算。对于(1✖️2✖️3✖️4✖️5✖️6)，可提前预处理出来</p><p>​    最后xi = (n)! % (pi^ai)✖️inv((m)! % (pi^ai), pi^ai)✖️inv((m)! % (pi^ai), pi^ai)✖️pi^k即可（其中k为pi在C(n, m )中出现的次数）</p><p>​    最后利用中国剩余定理将xi合并即可</p><p>​    附上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll ksm(ll a, ll b, ll mod) &#123;&#125;  //省略快速幂</span><br><span class="line">ll extend_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123;&#125; //省略扩展欧几里得</span><br><span class="line">ll mod_reverse (ll a, ll n) &#123;&#125; //省略逆元</span><br><span class="line"></span><br><span class="line">//用于求n!%(pi^ai) 其中pk =（pi^ai）</span><br><span class="line">ll mul(ll n,ll pi,ll pk) &#123;</span><br><span class="line">    if(!n) return 1;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    if(n / pk) &#123;</span><br><span class="line">        for(ll i = 2;i &lt; pk; i++)</span><br><span class="line">            if(i % pi) ans = ans * i % pk;</span><br><span class="line">        ans = ksm(ans, n / pk, pk);</span><br><span class="line">    &#125;</span><br><span class="line">    for(ll i = 2;i &lt;= n % pk; i++)</span><br><span class="line">        if(i % pi) ans = ans * i % pk;</span><br><span class="line">    return ans * mul(n / pi, pi, pk) % pk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求xi</span><br><span class="line">ll C(ll n, ll m, ll mod, ll pi, ll pk) &#123;</span><br><span class="line">    if(m &gt; n) return 0;</span><br><span class="line">    ll a = mul(n, pi, pk),b = mul(m, pi, pk),c = mul(n-m, pi, pk);</span><br><span class="line">    ll k=0, ans;</span><br><span class="line">    for(ll i = n; i; i /= pi) k += i / pi;</span><br><span class="line">    for(ll i = m; i; i /= pi) k -= i / pi;</span><br><span class="line">    for(ll i = n - m; i; i /= pi) k -= i / pi;</span><br><span class="line">    ans = a * mod_reverse(b, pk) % pk * mod_reverse(c, pk) % pk * ksm(pi, k, pk) % pk;</span><br><span class="line">    return ans * (mod / pk) % mod * mod_reverse(mod / pk, pk) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展卢卡斯</span><br><span class="line">ll exLucas(ll n, ll m, ll mod) &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(ll x = mod, i = 2; i &lt;= mod; i++)</span><br><span class="line">        if(x % i == 0) &#123;</span><br><span class="line">            ll pk = 1;</span><br><span class="line">            while(x % i == 0) &#123;</span><br><span class="line">                pk *= i;</span><br><span class="line">                x /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + C(n, m, mod, i, pk)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    完工～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论九)中国剩余定理与扩展</title>
      <link href="/2018/10/23/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2018/10/23/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/中国剩余定理/title1.jpg" alt="title1"></p><a id="more"></a><p>​    学习中国剩余定理之前必须学会求解逆元： <a href="http://www.ivan-zcy.top/2018/10/22/关于逆元/">跳转</a></p><p>一.中国剩余定理：</p><p>​    记得小时候听过一个故事，就是韩信想知道自己有多少士兵，然后就先让士兵排成x列，余出来a个人，后来又让士兵排成y列，余出来b个人，后来又让士兵排成z列，余出来c个人，最后韩信直接算出了自己的士兵数。。Orz～</p><p>​    呃呃呃，感觉有点像小学的时候做过的奥数题。。。    </p><p>​    假使x，y，z分别为3，5，7，a，b，c分别为2，3，2，那么我们问最小士兵数是多少？</p><p>​    注意一点！！！x,y,z必须满足两两互质！！！</p><p>​    根据逆元的性质，我们可以知道：</p><p>​    3✖️5✖️mod_reverse(15, 7) ≡ 1 （mod 7） （1）</p><p>​    3✖️7✖️mod_reverse(21, 5) ≡ 1 （mod 5)      (2)</p><p>​    5✖️7✖️mod_reverse(35, 3) ≡ 1 （mod 3）    (3)</p><p>​    把(1)乘2，(2)乘3，(3)乘2，得：</p><p>​    2✖️3✖️5✖️mod_reverse(15, 7) ≡ 2 （mod 7） （4）</p><p>​    3✖️3✖️7✖️mod_reverse(21, 5) ≡ 3 （mod 5)      (5)</p><p>​    2✖️5✖️7✖️mod_reverse(35, 3) ≡ 2 （mod 3）    (6)</p><p>​    我们设：</p><p>​    a = 2✖️3✖️5✖️mod_reverse(15, 7)</p><p>​    b = 3✖️3✖️7✖️mod_reverse(21, 5)</p><p>​    c = 2✖️5✖️7✖️mod_reverse(35, 3)</p><p>​    因此我们可以得到：</p><p>​    (a + b + c) % 3 = a % 3 + b % 3 + c % 3 = 0 + 0 + 2 = 2;</p><p>​    (a + b + c) % 5 = a % 5 + b % 5 + c % 5 = 0 + 3 + 0 = 3;</p><p>​    (a + b + c) % 7 = a % 7 + b % 7 + c % 7 = 2 + 0 + 0 = 2;</p><p>​    所以说，士兵数为a + b + c就满足该条件</p><p>​    代码实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//省略扩展欧几里得求逆元的函数</span><br><span class="line">ll china (ll n, ll *a, ll *m) &#123;//m[i]代表3，5，7等除数，a[i]代表2，3，2等余数</span><br><span class="line">    ll M = 1;//M代表所有除数的乘积</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        M *= m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        ll w = M / m[i];</span><br><span class="line">        ret = (ret + a[i] * w * mod_reverse(w, m[i])) % M;</span><br><span class="line">        //若上面的式子爆longlong，可利用快速乘来求解</span><br><span class="line">    &#125;</span><br><span class="line">    return (ret + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>二.中国剩余定理扩展：</p><p>​    前边注意中已经标注了，中国剩余定理的前提是x，y，z（也就是说除数）必须两两互质。如果不互质我们又该怎么办呢？</p><p>​    我们假设x ≡ a1 (mod n1)</p><p>​            x ≡ a2 (mod n2)</p><p>​    合并两式，得：n1k1 = n2k2 + a2 - a1</p><p>​    两边同除gcd(n1, n2)，得：</p><p>​    n1k1 / gcd(n1, n2) = n2k2 / gcd(n1, n2) + (a2 - a1) / gcd(n1, n2)</p><p>​    由于n1 / gcd(n1, n2) 与n2 / gcd(n1, n2)互质，因此：</p><p>​    n1k1 / gcd(n1, n2) ≡  (a2 - a1) / gcd(n1, n2)    （mod n2 / gcd(n1, n2)）</p><p>​    同除n1 / gcd (n1, n2)，得：k1 ≡ mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2) （mod n2 / gcd(n1, n2)）</p><p>​    k1 = mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2) + n2 / gcd(n1, n2)✖️y</p><p>​    把k1代入x = n1k1 + a1，得：</p><p>​    x =     mod_reverse(n1 / gcd(n1, n2), n2 / gcd(n1, n2))✖️ (a2 - a1) / gcd(n1, n2)✖️n1 + n1n2 / gcd(n1, n2)✖️y</p><p>​    呃呃呃，解x就求出来了…</p><p>​    这是两个式子的联立，那么多个呢？</p><p>​    对于多个，我们先求出两个数的解x，把x带入到a2中，并把n2替换为lcm(n1, n2)，然后继续求2，3的解，直到递推到n结束。最后n - 1和 n的解x即为答案。</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn=1e5+5;</span><br><span class="line">int n;</span><br><span class="line">ll m[maxn],a[maxn];//m[i]为除数，a[i]为余数</span><br><span class="line"></span><br><span class="line">//求gcd</span><br><span class="line">ll gcd (ll a, ll b) &#123;</span><br><span class="line">    return a % b == 0? b: gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展欧几里得算法</span><br><span class="line">ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 0) return -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = extend_gcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求a关于n的逆元</span><br><span class="line">ll mod_reverse (ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = extend_gcd(a, n, x, y);</span><br><span class="line">    if (d == 1) return (x % n + n) % n;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中国剩余定理扩展</span><br><span class="line">ll work()&#123;</span><br><span class="line">    int flag = 0;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        ll n1 = m[i - 1], n2 = m[i];</span><br><span class="line">        ll a1 = a[i - 1], a2 = a[i];</span><br><span class="line">        ll d = gcd(n1, n2);</span><br><span class="line">        if ((a2 - a1) % d != 0) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        m[i] = m[i - 1] / d * m[i];</span><br><span class="line">        ll x = (mod_reverse(n1 / d, n2 / d) * (a2 - a1) / d) % (n2 / d) * n1 + a1;</span><br><span class="line">        x = (x % m[i] + m[i]) % m[i];</span><br><span class="line">        a[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag) return -1;</span><br><span class="line">    return a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    大概就是这样～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论八)容斥原理与抽屉原理</title>
      <link href="/2018/10/23/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/23/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/容斥原理与抽屉原理/title1.jpg" alt="title1"></p><a id="more"></a><p>一.先讲一下抽屉原理，其实高中的时候我们都学过，它可扩展为3个：</p><p>​    1.把n + 1个物体放到n个抽屉，至少有一个抽屉里物件不少于2</p><p>​    2.把mn + 1个物体放到n个抽屉，至少有一个抽屉里物件不少于m+1</p><p>​    3.把无穷多个物体放到n个抽屉，至少有一个抽屉里有无穷多</p><p>它又衍生出来第二抽屉原理，即：</p><p>​    把nm - 1个物体放到n个抽屉，必有一个抽屉中至多有m - 1个物体</p><p>定理就这么简单，但是想用好属实挺难～</p><p>​    例如给你一个数组a和一个数m，问数组中能否选出几个数相加的和能被m整除？</p><p>​    这个题咋一看和抽屉原理也没啥必然联系啊，那就再仔细瞅瞅。。</p><p>​    联系抽屉原理，我们可以知道，当n &gt; m时，必然能选出几个数的和被m整除。</p><p>​    为什么？因为n个数求余m会产生n个余数，至少有两个相同的余数。</p><p>​    n个m以内的余数一定能组成m的倍数</p><p>​    这样，我们只需要判断 n &lt;= m时的情况即可</p><p>二. 容斥原理</p><p>​    容斥原理原理是为避免重复计算的一种想法，很简单，同抽屉原理一样，难在活学活用～</p><p>​    简单说一下容斥原理，例如下图，我们知道三个圆各自的面积，问三个圆一共占有的面积是多少？这时候为了避免重复运算，就需要用到容斥原理了：</p><p>​    <img src="/2018/10/23/容斥原理与抽屉原理/1.png" alt="1"></p><p>在此感谢百度百科提供的图片资源～～～</p><p>也就是说，3个圆占有的面积是三个圆的面积和 - 红色部分 + G部分</p><p>嗯嗯，原理就是这些，还是实战一下吧：</p><p>​    1.例如从m种颜色挑选k种给n盆花染色，要求相邻花颜色不同，问方案数？</p><p>​    从m种颜色挑选k种共有C(m, k)种方案数，而k种颜色给n盆花染色且相邻花颜色不同，这时候我们就可以利用容斥原理了。</p><p>​    种类数应该是：可用k种颜色保证相邻花色不同的方案数 - 可用k - 1种颜色种颜色保证相邻花色不同的方案数+ 可用k - 1种颜色种颜色保证相邻花色不同的方案数…(-1)^(k - 1)✖️可用1种颜色种颜色保证相邻花色不同的方案数</p><p>​    只需要把种类数✖️C(m, k)即为答案</p><p>​    这样就可以简化思考的复杂度了～</p><p>​    2.求区间(a, b)中与n互质的数的个数，例如求区间(a, b)中与12互质的个数</p><p>​    我们可以先筛选出12的全部素因子2, 3，我们只需要求(a, b)的个数 - 素因子2对(a, b)的贡献 - 素因子3对(a, b)的贡献 + 因子(2✖️3)对(a, b)的贡献，即是最终答案。​</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教BM模版(推规律)</title>
      <link href="/2018/10/23/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E7%89%88-%E6%8E%A8%E8%A7%84%E5%BE%8B/"/>
      <url>/2018/10/23/%E6%9D%9C%E6%95%99BM%E6%A8%A1%E7%89%88-%E6%8E%A8%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/杜教BM模版-推规律/title.jpg" alt="title"></p><a id="more"></a><p>​    无论是矩阵快速幂求第n项，还是给出输出前几项求规律的第n项。。。几乎就没有它做不到的～至于原理。。。呃呃呃，会用就完了！！！</p><p>​    下面是找到的能用的BM模版：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</span><br><span class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><br><span class="line">#define pb push_back</span><br><span class="line">#define mp make_pair</span><br><span class="line">#define all(x) (x).begin(),(x).end()</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">#define SZ(x) ((int)(x).size())</span><br><span class="line">typedef vector&lt;int&gt; VI;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const ll mod=1000000007;</span><br><span class="line">ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;</span><br><span class="line">// head</span><br><span class="line"></span><br><span class="line">int _,n;</span><br><span class="line">namespace linear_seq &#123;</span><br><span class="line">    const int N=10010;</span><br><span class="line">    ll res[N],base[N],_c[N],_md[N];</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; Md;</span><br><span class="line">    void mul(ll *a,ll *b,int k) &#123;</span><br><span class="line">        rep(i,0,k+k) _c[i]=0;</span><br><span class="line">        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">        for (int i=k+k-1;i&gt;=k;i--) if (_c[i])</span><br><span class="line">            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;</span><br><span class="line">        rep(i,0,k) a[i]=_c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span><br><span class="line">        //        printf(&quot;%d\n&quot;,SZ(b));</span><br><span class="line">        ll ans=0,pnt=0;</span><br><span class="line">        int k=SZ(a);</span><br><span class="line">        assert(SZ(a)==SZ(b));</span><br><span class="line">        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;</span><br><span class="line">        Md.clear();</span><br><span class="line">        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);</span><br><span class="line">        rep(i,0,k) res[i]=base[i]=0;</span><br><span class="line">        res[0]=1;</span><br><span class="line">        while ((1ll&lt;&lt;pnt)&lt;=n) pnt++;</span><br><span class="line">        for (int p=pnt;p&gt;=0;p--) &#123;</span><br><span class="line">            mul(res,res,k);</span><br><span class="line">            if ((n&gt;&gt;p)&amp;1) &#123;</span><br><span class="line">                for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0;</span><br><span class="line">                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;</span><br><span class="line">        if (ans&lt;0) ans+=mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    VI BM(VI s) &#123;</span><br><span class="line">        VI C(1,1),B(1,1);</span><br><span class="line">        int L=0,m=1,b=1;</span><br><span class="line">        rep(n,0,SZ(s)) &#123;</span><br><span class="line">            ll d=0;</span><br><span class="line">            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;</span><br><span class="line">            if (d==0) ++m;</span><br><span class="line">            else if (2*L&lt;=n) &#123;</span><br><span class="line">                VI T=C;</span><br><span class="line">                ll c=mod-d*powmod(b,mod-2)%mod;</span><br><span class="line">                while (SZ(C)&lt;SZ(B)+m) C.pb(0);</span><br><span class="line">                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                L=n+1-L; B=T; b=d; m=1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ll c=mod-d*powmod(b,mod-2)%mod;</span><br><span class="line">                while (SZ(C)&lt;SZ(B)+m) C.pb(0);</span><br><span class="line">                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return C;</span><br><span class="line">    &#125;</span><br><span class="line">    int gao(VI a,ll n) &#123;</span><br><span class="line">        VI c=BM(a);</span><br><span class="line">        c.erase(c.begin());</span><br><span class="line">        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;</span><br><span class="line">        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (~scanf(&quot;%d&quot;,&amp;n)) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        v.push_back(1);//这儿就可以输入前几项的数，用来推规律</span><br><span class="line">        v.push_back(2);</span><br><span class="line">        v.push_back(4);</span><br><span class="line">        v.push_back(7);</span><br><span class="line">        v.push_back(13);</span><br><span class="line">        v.push_back(24);</span><br><span class="line">        //VI&#123;1,2,4,7,13,24&#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,linear_seq::gao(v,n-1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-23博客搭建进度</title>
      <link href="/2018/10/23/18-10-23%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/23/18-10-23%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/23/18-10-23博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果(10.20更新)</p><p>​    ——新增页面卡通人物效果(10.20更新)</p><p>​    ——微调音乐布局(10.20更新)</p><p>​    ——微调小火箭布局(10.20更新)</p><p>​    ——新增标签数量统计</p><p>​    ——新增博文数量统计</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论七)关于sqrt、pow与log的巧用</title>
      <link href="/2018/10/22/%E5%85%B3%E4%BA%8Esqrt%E4%B8%8Elog%E7%9A%84%E5%B7%A7%E7%94%A8/"/>
      <url>/2018/10/22/%E5%85%B3%E4%BA%8Esqrt%E4%B8%8Elog%E7%9A%84%E5%B7%A7%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/22/关于sqrt与log的巧用/title.jpg" alt="title"></p><a id="more"></a><p>一. sqrt</p><p>​    大家都知道sqrt(x)是求x的平方根，c中自带的math.h库有关于该函数的使用。这里就不多叙述~</p><p>​    关于求sqrt，这里有一个神人约翰-卡马克，大家可以百度搜索一下这个神人的辉煌事迹（求sqrt的神秘数字），附上它的代码%一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float Q_rsqrt( float number )</span><br><span class="line">&#123;</span><br><span class="line">long i;</span><br><span class="line">float x2, y;</span><br><span class="line">const float threehalfs = 1.5F;</span><br><span class="line"></span><br><span class="line">x2 = number * 0.5F;</span><br><span class="line">y = number;</span><br><span class="line">i = * ( long * ) &amp;y; // evil floating point bit level hacking</span><br><span class="line">i = 0x5f3759df - ( i &gt;&gt; 1 ); // what the fuck?</span><br><span class="line">y = * ( float * ) &amp;i;</span><br><span class="line">y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration</span><br><span class="line">// y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed</span><br><span class="line"></span><br><span class="line">#ifndef Q3_VM</span><br><span class="line">#ifdef __linux__</span><br><span class="line">assert( !isnan(y) ); // bk010122 - FPE?</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    它的这段代码求sqrt(number)的倒数，速度比math.h库中的(float)(1.0/sqrt(x))快4倍！！！</p><p>​    注释中的what the fuck? 也表明了我们普通人的心情。。。。</p><p>​    话不多说，%%%%%%%%%%%%%%%%%%%%%%%%%%就完了</p><p>​    </p><p>二.pow</p><p>​    关于pow函数也存在与math.h库中，具体使用也不详细介绍，我们来说一下它的巧用</p><p>​    假如a^b = c，我们已知b和c，如何求a？（其中b &lt;= 200, a &lt;= 1e9, c &lt;=1e100 ）</p><p>​    注意！！c的取值范围是1e100！！！</p><p>​    这时候就有一个巧办法了，虽然double精度不足1e100，但我们只需要知道它的前16位即可，因为当b错一位，c的前16位变化很大。所以虽然double只保留了16位，但计算出的c是唯一的。因此：</p><p>​    pow (c, 1 / n)保留0位小数，即为a</p><p>三.log</p><p>​    关于log的巧妙用法</p><p>​    第一个：例如给出a, b, c, d,如何比较a^b与c^d的大小？</p><p>​    我们只需要求p = b✖️log(a);   q = d✖️log(c)</p><p>​                如果p - q的绝对值 &lt;= 1e-6，则两者相等，</p><p>​                如果 p &lt; q ，则a^b &lt; c^d，</p><p>​                否则a^b &gt; c^d</p><p>​    </p><p>​    第二个：求一个数x有多少位数：</p><p>​        利用(int)log10(x) + 1可以求得x一共多少位</p><p>​    第三个：求一个数x在二进制下有多少位：</p><p>​        利用(int)log2(x) + 1可以求得x在二进制下一共多少位</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论六)关于欧拉(定理、公式、函数、降幂)</title>
      <link href="/2018/10/22/%E5%85%B3%E4%BA%8E%E6%AC%A7%E6%8B%89-%E5%AE%9A%E7%90%86-%E5%85%AC%E5%BC%8F-%E5%87%BD%E6%95%B0/"/>
      <url>/2018/10/22/%E5%85%B3%E4%BA%8E%E6%AC%A7%E6%8B%89-%E5%AE%9A%E7%90%86-%E5%85%AC%E5%BC%8F-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/22/关于欧拉-定理-公式-函数/title.jpg" alt="title"></p><a id="more"></a><p>​    最最开始的时候，我以为欧拉函数，欧拉定理，欧拉公式是一个东西，傻傻分不清。傻笑～</p><p>​    后来知道，这完完全全是三种东西！！要说有啥必然的联系，它们可能都叫欧拉吧～</p><p>​    首先，我们来讲一下三者的定义：</p><p>​    欧拉定理：若n,a为正整数且互质，则a^(Φ(n)) = 1 (mod n)</p><p>​    欧拉公式：e^(i✖️x) = cos(x) + i✖️sin(x)  （例如把x = π带进去，得e^(i✖️π) = -1）</p><p>​    欧拉函数：Φ(n)，用于求1～n中与n互质的个数，若n为质数，那么Φ(n) = n - 1<br>​    欧拉降幂：我们知道当幂特别大的时候可以用快速幂来求，而当幂大到10^1000时快速幂也求不了了。。这时候就需要用到欧拉降幂，它的定理如下（前提是a，p互质）：</p><p>​              a^b ≡ a^(b % Φ(p) + Φ(p)) (mod p)，当x &gt;= p时</p><p>​               a^b ≡ a^(b % Φ(p)) (mod p)，当x &lt; p时</p><p>关于欧拉公式在ACM中我还没有做过相关的题，因此先只讲欧拉函数和欧拉降幂，欧拉定理</p><p>一.关于欧拉定理没什么好说的～</p><p>​    之前我们说过一嘴费马小定理：a ^ (p - 1 ) ≡ 1 (mod p)</p><p>​    又说过当p为素数时Φ(p) = p - 1，因此欧拉定理实际上是费马小定理的推广</p><p>二.关于欧拉函数的求解，我们知道n为质数的情况了，若n为合数呢？</p><p>​    学到了以下四种求法n的欧拉函数：</p><p>​    1.利用容斥原理：</p><p>​        我们先找到n的全部质因子，然后利用容斥原理删掉全部的因子，剩下的就是与n互质的个数</p><p>​        例如30 = 2✖️3✖️5</p><p>​        Φ(30) = 30 - 30 / 2 - 30 / 3 - 30 / 5 + 30 / (2✖️3) + 30 / (2✖️5) + 30 / (3✖️5) - 30 / (2✖️3✖️5)</p><p>​               = 8</p><p>​    2.上面的写法很麻烦，下面有种简便的写法：</p><p>​            30 = 30✖️1 / 2 ✖️2 / 3✖️4 / 5  = 8，这样就能自动容斥啦，时间复杂度是O(sqrt(n))</p><p>​    3.埃筛法：</p><p>​        是不是很耳熟！！！对，求素数有埃筛和线筛，求欧拉函数也有埃筛和线筛～，埃筛的原理就是利用方法2～，时间复杂度是O(n✖️sqrt(n))</p><p>​        </p><p>​        代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getEuler() &#123;</span><br><span class="line">    memset(euler, 0, sizeof(euler));</span><br><span class="line">    euler[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!euler[i]) &#123;</span><br><span class="line">            for (int j = i; j &lt;= N; j += i) &#123;</span><br><span class="line">                if (!euler[j]) &#123;</span><br><span class="line">                    euler[j] = j;//若不存在先初始化</span><br><span class="line">                &#125;</span><br><span class="line">                euler[j] = euler[j] / i * (i - 1);//实质就是方法2 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>​    4.线性筛</p><p>​    线性筛，顾名思义就是线性求解1～n的欧拉函数，需用到一下几个性质：</p><p>​        1.当p为素数时，Φ(p) = p - 1;</p><p>​        2.当p为素数且i % p ==0时，Φ(i✖️p) = Φ(i)✖️p</p><p>​        3.当p为素数且i % p != 0时，Φ(i✖️p) = Φ(i)✖️(p - 1)</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll phi[N + 5];//存储欧拉函数</span><br><span class="line">ll prime[N + 5];//存素数</span><br><span class="line">void Euler() &#123;</span><br><span class="line">    phi[1] = 1;</span><br><span class="line">    memset(phi, 0, sizeof(phi));</span><br><span class="line"> prime[0] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if(!phi[i]) &#123;//若i为素数</span><br><span class="line">            phi[i] = i - 1;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; (ll)i * prime[j] &lt;= N; j++) &#123;</span><br><span class="line">            if (i % prime[j]) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j] - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三.欧拉降幂：</p><p>​        根据 a^b ≡ a^(b % Φ(p) + Φ(p)) (mod p)，当x &gt;= p时</p><p>​               a^b ≡ a^(b % Φ(p)) (mod p)，当x &lt; p时    </p><p>​    我们可以得到以下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Mod(a, b) a &lt; b? a: a % b + b   //重定义取模，按照欧拉定理的条件</span><br><span class="line"></span><br><span class="line">map&lt;ll,ll&gt; mp;//记忆化存储欧拉函数</span><br><span class="line"></span><br><span class="line">//按照欧拉定理的条件进行快速幂</span><br><span class="line">ll qpow(ll x, ll n, ll mod) &#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n &amp; 1) &#123;</span><br><span class="line">            res = Mod(res * x, mod);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        x = Mod(x * x, mod);</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求k的欧拉函数值</span><br><span class="line">ll phi(ll k) &#123;</span><br><span class="line">    ll i;</span><br><span class="line">    ll s = k;</span><br><span class="line">    ll x = k;</span><br><span class="line">    if (mp.count(k))</span><br><span class="line">        return mp[x];                    //记忆化存储</span><br><span class="line">    for(i = 2; i * i &lt;= k; i++) &#123;</span><br><span class="line">        if (k % i == 0)</span><br><span class="line">            s = s / i * (i - 1);//利用方法2</span><br><span class="line">        while(k % i == 0)</span><br><span class="line">            k /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    if(k &gt; 1)</span><br><span class="line">        s = s / k * (k - 1);</span><br><span class="line">    mp[x]=s;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！！当快速幂需要用到之前的递归时，也需要迭代模!!!</p><p>​    例如 a[1]^(a[2]^(a[3]^(a[4]…)))</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL solve(LL l,LL r,LL mod) &#123;</span><br><span class="line">    if (l==r||mod==1) return Mod(a[l], mod);//如果到右端点或者φ值等于1，那么直接返回当前数字</span><br><span class="line">    return qpow(a[l], solve(l+1, r, phi(mod)), mod);//否则指数为[l+1,r]区间的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论五)关于自己理解的逆元</title>
      <link href="/2018/10/22/%E5%85%B3%E4%BA%8E%E9%80%86%E5%85%83/"/>
      <url>/2018/10/22/%E5%85%B3%E4%BA%8E%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/22/关于逆元/title.jpg" alt="title"></p><a id="more"></a><p>学这个之前建议看看之前发的那篇关于快速幂和扩展gcd的博文：<a href="http://www.ivan-zcy.top/2018/10/21/快速幂、快速乘与gcd扩展-杂谈/">跳转</a></p><p>一.引出逆元的用途</p><p>在讲逆元是什么之前，先说一下我们遇到的错误。。</p><p>​    对于特别大的数的连乘，让我们对最终结果取模1e9 + 7，可能在连乘的时候就已经爆longlong了，我们应该怎么做呢？</p><p>​    根据同余定理可知，(a✖️b) % mod = ( (a % mod) ✖️ (b % mod)) % mod，因此，我们可以设longlong型数ans = 1，每次乘以一个较大数的时候，都取模一下1e9+7，避免爆longlong。代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ll mod = 1e9 + 7;</span><br><span class="line">ll ans = 1;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    ans = ans * a[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line">最终ans即为n个数连乘取模1e9 + 7的结果</span><br></pre></td></tr></table></figure><p>​    </p><p>​    若是不只是乘法，中间再夹杂着除法，我们再按照上面的方式ans = ans / a[i] % mod，当我们兴冲冲的上交后，一个冷冰冰的WA在我们脸上胡乱的拍～</p><p>​    这是为啥呢？</p><p>​    因为同余定理中不包含(a / b) % mod = ((a % mod)  / (b % mod)) % mod，记住不包含！！！</p><p>​    那么我们该怎么办呢？好办，我们将除法改成乘不就完了嘛～</p><p>​    除以一个数不就是乘一个数的倒数嘛，一个倒数在取模mod时为多少呢？</p><p>​    这时候逆元就出现了！！</p><p>​    也就是说，a / b % mod相当于a ✖️ b关于mod的逆元 % mod</p><p>​    我们只需要求b关于mod的逆元就可以了～</p><p>二.逆元的求法</p><p>​    至于求逆元的方式有很多，比如利用费马小定理，扩展欧几里得，欧拉定理等等…我比较常用方法是费马小定理和扩展欧几里得</p><p>​    (1)利用费马小定理求逆元：</p><p>​        我们由于费马小定理可知：当p为素数时，有a ^ (p - 1) ≡ 1 (mod p) </p><p>​        两边同时除a，得a^(p - 2) ≡ inv(a) (mod p)    其中inv(a)是a关于p的逆元</p><p>​        因此:  inv(a) = a ^ (p - 2) (mod p)</p><p>​        我们就可以通过使用快速幂求得a ^ (p  - 2)取模p得到 a 关于p的逆元</p><p>​        代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//利用快速幂求a^(p - 2) mod p</span><br><span class="line">ll pow_mod (ll a, ll b, ll p) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans = ans * a % p;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//费马小定理求a关于p的逆元</span><br><span class="line">ll permat (ll a, ll p) &#123;</span><br><span class="line">    return pow_mod (a, p - 2, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)利用扩展欧几里得求逆元</p><p>​    上一篇我们学了gcd的求法，它是根据欧几里得算法的核心 gcd (a, b) = gcd (b, a % b)递归得到的</p><p>​    那么，扩展欧几里得是什么呢？</p><p>​    我们可以利用已知的a，b，一定存在至少一组解x，y，使它们满足贝祖等式：a✖️x + b✖️y = gcd(a, b)</p><p>​    至于这个定理为什么成立，我也没学。。。Orz，我觉得会用就可以了，冷汗😓</p><p>​    根据a✖️x + b✖️y = gcd(a, b)，若a，b互质，那么此时a✖️x + b✖️y = gcd(a, b) = 1</p><p>​    我们对a✖️x + b✖️y = 1同时取余b，会得到a✖️x % b + b✖️y % b = 1 % b</p><p>​     =&gt; a✖️x % b = 1 % b    </p><p>​     =&gt; a✖️x = 1(mod b)        </p><p>​    大家看着是不是似成相识呢？，对！x就是a关于b的逆元</p><p>​    因此，我们就可以通过扩展欧几里得算法求解x即可。</p><p>关于扩展欧几里得算法：</p><p>​    我们设x✖️a + y✖️b = d （d为gcd(a, b));   (1)</p><p>​    那么x1✖️b + y1✖️(a % b) = d;    (2)</p><p>​    也就是说x✖️a + y✖️b = x1✖️b + y1✖️(a % b); （3）</p><p>​    因为a % b = a - (a / b)✖️b;  (4)</p><p>​    我们把(4)带入(3)，得：</p><p>​    x✖️a + y✖️b = x1✖️b + y1✖️(a - (a / b)✖️b)  (5)</p><p>​    化简得：x✖️a + y✖️b =  y1✖️a + (x1 - (a / b)✖️y1)✖️b （6） </p><p>​    因此，我们可得x = y1， y = x1 - (a / b)✖️y1</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//扩展欧几里得</span><br><span class="line">ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp; y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b== 0) return -1;//此时由于a,b无最大公约数，所以出错</span><br><span class="line">    if (b == 0) &#123;//递归终止条件，若b == 0，那么gcd(a,b) == a，a * x + b * y = gcd (a, b) = 1，因此x = 1</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;//返回a用于判断a是否为1，用以确定原a,b是否互质</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = extend_gcd (b, a % b, y, x);//由扩展欧几里得可得</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求逆元 ax = 1 (mod p)</span><br><span class="line">ll mod_reverse (ll a, ll p) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = extend_gcd(a, p, x, y);//把a带入a，p带入b，通过扩展欧几里得求x</span><br><span class="line">    if (d == 1) return (x % p + p) % p;//如果a == 1表明gcd(a,p)为1，也就是a,p互质，因此输出x</span><br><span class="line">    else return -1;//否则a,p不互质，返回-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三.线性求逆元</p><p>​    求素数有线性筛，那么逆元呢？逆元当然不能落后啦，于是线性求逆元出现了Orz～</p><p>​    线性求逆元的公式是：inv(a) = (p - p / a)✖️inv(p % a) % p</p><p>​    证明过程：设x = p % a, y = p / a;</p><p>​    则有x + y✖️a = p</p><p>​    因此(x + y✖️a) % p = 0</p><p>​    x % p = (- y)✖️a % p</p><p>​    x✖️inv(a) % p = (-y) % p</p><p>​    inv(a) = (p - y)✖️inv(x) % p</p><p>​    inv(a) = (p - p / a)✖️inv(p % a) % p</p><p>这样，我们就可以利用之前的逆元求解后面的逆元了，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">    inv[0] = 1;</span><br><span class="line">    inv[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">inv[i] = ((p - p / i) * inv[p % i]) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>四.线性求阶乘逆元</p><p>​    如果我们需要求0!到n!的逆元，对每个元素都求一遍会特别慢<br>​    前面说了，逆元就可一看做是求倒数</p><p>​    那么就有1 / (n+1)! × (n+1)=1/ n!</p><p>​    因此inv[n + 1]✖️(n + 1) = inv[n] (mod p)</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll fact[N + 5];//存储阶乘</span><br><span class="line">ll inv[N + 5];//存储阶乘的逆元</span><br><span class="line">fact[0] = 1;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">    fact[i] = fact[i - 1] * i % p;//线性求阶乘</span><br><span class="line">&#125;</span><br><span class="line">inv[N] = mod_reverse(fact[N], p);//利用前面学的扩展欧几里得求fact[N]关于p的逆元</span><br><span class="line">for (int i = N - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    inv[i] = inv[i + 1] * (i + 1) % mod;   //求线性阶乘逆元</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    以上就是我对逆元的全部理解了，就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论四)快速幂与gcd扩展</title>
      <link href="/2018/10/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E5%BF%AB%E9%80%9F%E4%B9%98%E4%B8%8Egcd%E6%89%A9%E5%B1%95-%E6%9D%82%E8%B0%88/"/>
      <url>/2018/10/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E5%BF%AB%E9%80%9F%E4%B9%98%E4%B8%8Egcd%E6%89%A9%E5%B1%95-%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/快速幂、快速乘与gcd扩展-杂谈/title.jpg" alt="title"></p><a id="more"></a><p>一.关于快速幂:</p><p>​    我们要想求a^b，也就是b个a相乘，我们可以设置ans = 1，然后for循环b次，用ans累成a得到最终答案ans，这样时间复杂度是O(b)</p><p>​    当b大于1e9，我们用上面的办法就不能在1s内求出结果了。</p><p>​    举个栗子2^11,我们仔细观察一下：</p><p>​        ans = 2 ^ 11</p><p>​            = 2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2✖️2</p><p>​            =  4✖️4✖️4✖️4✖️4✖️2</p><p>​            =  16✖️16✖️4✖️2</p><p>​            =  256✖️4✖️2</p><p>​    因此我们可以只求2，4，16，256中2,4,256组合得到2^11，而2,4,16,256可以根据平方递推得到，这样要想求得a ^ b的值时间复杂度只有O(log(b))，可以说是非常快了</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll quick(ll a, ll b) &#123;//求a^b</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans *= a;//只有b为奇数时乘a，例如2^11时ans只累乘2，4，256</span><br><span class="line">        b &gt;&gt;= 1;//相当于b /= 2</span><br><span class="line">        a *= a;//就是上面所说的通过平方和递推，优化运算时间</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二. gcd扩展：</p><p>​    gcd几乎是我们刚入学接触的第一个递归了，大家想必已经熟记于心。</p><p>​    根据gcd(a, b) = gcd (b, a % b) （a &gt; b且 b != 0) 公式，我们只需要知道递归的终止条件，就可以写出这个递归代码。</p><p>​    由于b != 0，所以当a % b == 0时不能继续递归。那么，当a % b == 0时，我们应该返回什么呢？谁才是a,b的最小公约数？</p><p>​    由于a % b == 0，因此a一定是b的倍数，也就说b一定是a的因子，又因为b的最大因子是b，因此a,b的最大公约数一定是b，根据gcd(a, b) = gcd(b, a % b)，我们知道b也是最初始的a,b的最大公约数。</p><p>​    实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll gcd (ll a, ll b) &#123;//前提条件：a,b中不存在0</span><br><span class="line">    return a % b == 0? b: gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    题外话，以前以为该函数的前提条件是a必须大于b。。。其实a&lt;b也可以，因为经过一次递归，就变成了 a = b, b = a，亏我之前还判断a，b的大小。。</p><p>​    好啦，我们说几个gcd的扩展定理：</p><p>​    (1).gcd (ka, kb) = k✖️gcd(a, b)</p><p>​    (2).lcm(ka, kb) = k ✖️lcm(a, b)</p><p>​    (3).lcm(s / a, s / b) = s / gcd(a, b)</p><p>​    </p><p>​    有一些题目可通过这些扩展定理来少走很多弯路～</p><p>​    Over～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论三)素数原理</title>
      <link href="/2018/10/21/%E7%B4%A0%E6%95%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/21/%E7%B4%A0%E6%95%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/素数原理/title.jpg" alt="title"></p><a id="more"></a><p>​    打算写一下自己对ACM中常用到的数论知识，加深巩固和查缺补漏。</p><p>​    在数学中，对于n&gt;1,若n的因子只有1和它本身，那么n就是质数，也称作素数。而在ACM中素数类型的题目是经常会碰到的。</p><p>​    那么我们可以怎么判断素数呢？</p><p>一.对于判断单个n是否为素数，我们可以通过三种情况来判断：</p><p>​    （1）用i遍历2~ n -1，若n % i == 0就代表存在除1和它本身以外的因子，就直接跳出，若执行完就代表没有其它因子，n为素数。时间复杂度为O(n)</p><p>​      (2) 我们可以优化(1)，因为若存在大于sqrt(n)的因子k，那么n / k 的值一定在 2 ~ sqrt(n)中。因此我们只需要用i遍历2 ~ sqrt(n)即可，若n%i == 0就代表存在除1和它本身以外的因子，就直接跳出，若执行完就代表没有其它因子，n为素数，时间复杂度为O(sqrt(n)) 。</p><p>​      (3)    我们继续优化(2)，若 n % 2 != 0，那么从i从3~sqrt(n)，只需要考虑奇数即可。因此时间复杂度为O(sqrt(n) / 2)</p><p>我给出(3)的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool chooes(ll n) &#123;//判断n是否为素数</span><br><span class="line">    if (n % 2 == 0) return false;//若n%2==0，则说明n不是素数</span><br><span class="line">    for (int i = 3; i * i &lt;= n; i += 2) &#123;//从3～sqrt(n)，每次+=2，若存在n % i == 0，则说明n不是素数</span><br><span class="line">        if (n % i == 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;//否则n为素数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二.对于判断2～n每个数是否为素数，我们应该怎么办呢？</p><p>​    我们利用一中最快的(3)方法，时间复杂度为O(n✖️sqrt(n) / 2)，若n为1e5以上，1s之内是筛选不出来的。因此我们只能想别的办法，先来介绍第一种：</p><p>（1）由于是求2～n的每个数，因此我们可以尝试利用之前已经判断过的数来求后面的数是否为素数。我们知道，素数的因子只有1和它本身，那么一个2以上的数的倍数一定不是素数！！又因为合数一定可以由素数累乘得到，所以我们只需要把所有素数的倍数标记为合数，剩余的数一定是质数。</p><p>​    也就是说，对于n = 10，素数2的倍数4，6，8，10一定是合数；</p><p>​                        素数3的倍数6，9一定是合数</p><p>​                        4是合数跳过，素数5的倍数10一定是合数；</p><p>​                        6是合数跳过，得到素数7</p><p>​                        由于8，9，10是合数，因此全部跳过</p><p>​                        我们就得到10以内的素数2，3，5，7</p><p>​    通过这样的办法，我们可以在趋近于线性（实际是nlog(log(n))) 的时间内求出2～n中的每个数是否是素数。</p><p>​    以上的第一种方法，是被埃拉托斯特尼发明的，因此也叫做埃筛法</p><p>​    如果大家觉得还不够快，趋近于线性也不是线性啊！！有没有线性时间就能求出来2～n所有素数的方法呢？</p><p>​    答案是有的，该方法称为线筛。</p><p>（2）我们知道上面的数，对于素数2的倍数4，6，8，10一定是合数；</p><p>​                       对于素数3的倍数6，9一定是合数；</p><p>​    大家有没有发现6此时两次被判定为合数，埃筛之所以不是线性的原因就在于这里。。它可能会造成合数的重复判定。我们怎么样才能每个数只判定一次呢？就是在这个合数的最小素因子时判定该数为合数，其它素因子时不判定，这样就可以保证每个合数只判定一次了。这也就是线性筛的精髓了：</p><p>​    对于2，我们判定为素数，我们检索已经存在的素数2，把2✖️2，也就是4标记为合数；</p><p>​    对于3，我们判定为素数，我们检索已经存在的素数2, 3，把2✖️3，3✖️3，也就是6， 9标记为合数</p><p>​    对于4已标记为合数，我们检索已经存在的素数2，3，把2✖️4，也就是8标记为合数，由于4 % 2 == 0，因此我们直接跳出，不再执行3✖️4也就是12的判定（因为它可以由2✖️6判定，2是12的最小素因子）</p><p>​    对于5，我们判定为素数，我们检索已经存在的素数2，3，5，把2✖️5，3✖️5，5✖️5，也就是10，15，25标记为合数</p><p>​    对于6已标记为合数，    我们检索已经存在的素数2，3，5，把2✖️6，也就是12标记为合数，由于6 % 2 == 0，因此我们直接跳出，不再执行3✖️6也就是18的判定（因为它可以由2✖️9判定，2是18的最小素因子）</p><p>​    ………</p><p>​    就不往下继续写了，通过以上的流程，我们就可以判定2～n中的每个数是否为素数并保证每个数只判定一次（还可以加如果两数相乘大于n直接跳出等限制条件），这样时间复杂度就是O(n)</p><p>我给出(2)方法的实现代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define N 100005</span><br><span class="line"></span><br><span class="line">bool book[N + 5];   //book[i]判断i是否为素数</span><br><span class="line">int prime[N + 5];   //prime数组存储2～N全部素数，若MLE可改小该数组长度</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    memset(book, 0, sizeof(book));</span><br><span class="line">    prime[0] = 0;       //代表2～N当前有多少个素数</span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;             //如果是素数</span><br><span class="line">            prime[++prime[0]] = i;      //存入该素数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;= prime[0] &amp;&amp; (ll)prime[j] * i &lt;= N; j++) &#123;  //遍历之前存储的素数</span><br><span class="line">            book[prime[j] * i] = 1;     //素数的i倍一定不是素数</span><br><span class="line">            if (i % prime[j] == 0) break;    //保证每个合数只判断一次的精髓</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上就是素数判定和素数筛的一些理论与模版。在ACM中关于素数的题目很活，变形也很多，大家有兴趣可以看一下我博客中的数论标签的题目，里面有很多基于素数筛框架的变形题目～</p><p>​    附上博客地址：<a href="http://www.ivan-zcy.top">跳转</a></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA8512线段树维护线性基</title>
      <link href="/2018/10/21/UVA8512%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2018/10/21/UVA8512%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/UVA8512线段树维护线性基/title.jpg" alt="title"></p><a id="more"></a><p>​    题目需要用到线性基，之前写过线性基的原理和模版，想看的同学点右边 -&gt; <a href="http://www.ivan-zcy.top/2018/10/19/浅谈线性基/">走你</a></p><p>题意：</p><p>Consider an array A with n elements . Each of its element is A[i] (1≤i≤n) . Then gives two integers Q, K, and Q queries follow . Each query , give you L, R, you can get Z by the following rules.</p><p>To get Z , at first you need to choose some elements from A[L] to A[R] ,we call them A[i1],A[i2]…A[it] , Then you can get number Z=K or (A[i1] xor A[i2] … xor A[it]) .</p><p>Please calculate the maximum Z for each query .</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Several test cases .</p><p>First line an integer T (1≤T≤10). Indicates the number of test cases.Then TT test cases follows . Each test case begins with three integer N, Q, K (1≤N≤10000, 1≤Q≤100000, 0≤K≤100000). The next line has N integers indicate A[1] to A[N] (0≤A[i]≤108). Then Q lines , each line two integer L, R (1≤L≤R≤N) .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each query , print the answer in a single line.</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 3 0</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>​    翻译成汉语就是，给你一个T代表T组样例，每组样例有n, q, k，表示一个数组有n个数，有q次询问。下一行给出n个数分别是数组中每个数的值。接下来q行每行两个数l,r，问数组a[l] ～a[r]中选几个数的异或和|k的值最大 </p><p>问最大值是多少？</p><p>思路：</p><p>​    由于异或和|k值最大，这里有个小技巧。就是对数组中的每个数进行a[i] = a[i] &amp; (~k)，这样新的数组中最大的异或和|k就是最大值，因此我们只需要求新数组l～r的最大异或和</p><p>​    由于n的数据范围是1e4，q的数据范围是1e5，如果每查询一次重新求一次线性基数组，肯定会超时。因此我们可以利用线段树来维护l～r之间的线性基数组。</p><p>​    再加上各种剪枝，快速读写。用了不到600msA掉</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define N 10005</span><br><span class="line">#define lson rt&lt;&lt;1</span><br><span class="line">#define rson rt&lt;&lt;1|1</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">namespace IO &#123;</span><br><span class="line">    const d MX = 1e7;         //1e7 占用内存 11000kb</span><br><span class="line">    char buf[MX];</span><br><span class="line">    d c, sz;</span><br><span class="line">    </span><br><span class="line">    void begin() &#123;            //该方法用于main方法开头位置，可一次性读完全部输入</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);  //一次性全部读入</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inline bool read(int &amp;t) &#123;        //用于从buf中读入每个数</span><br><span class="line">        while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;))</span><br><span class="line">            c++;</span><br><span class="line">        if (c &gt;= sz) return false;            //若读完整个缓冲块则退出</span><br><span class="line">        bool flag = 0; if(buf[c] == &apos;-&apos;) &#123;</span><br><span class="line">            flag = 1;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++)</span><br><span class="line">            t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        if(flag) t = -t;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inline void write(int t) &#123;</span><br><span class="line">        if (t &gt; 9) write(t / 10);</span><br><span class="line">        putchar(t % 10 + &apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//全局变量</span><br><span class="line">d k;</span><br><span class="line"></span><br><span class="line">//树节点（可存储范围内值的最高位maxn和线性基数组c）</span><br><span class="line">struct node &#123;</span><br><span class="line">    d maxn;</span><br><span class="line">    d c[35];</span><br><span class="line">    void init() &#123;</span><br><span class="line">        mem(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addx(d x) &#123;</span><br><span class="line">        Forr(i, 30, 0) &#123;</span><br><span class="line">            if(x &gt;&gt; i &amp; 1) &#123;</span><br><span class="line">                maxn = i;</span><br><span class="line">                c[i] = x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    d ansmax() &#123;</span><br><span class="line">        d t = 0;</span><br><span class="line">        Forr(i, maxn, 0) &#123;</span><br><span class="line">            if ((t ^ c[i]) &gt; t) &#123;</span><br><span class="line">                t ^= c[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node merge(node A) &#123;</span><br><span class="line">        node t;</span><br><span class="line">        t.init();</span><br><span class="line">        Forr(i, maxn, 0) &#123;</span><br><span class="line">            t.c[i] = c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Forr(i, A.maxn, 0) &#123;</span><br><span class="line">            if (A.c[i]) &#123;</span><br><span class="line">                d x = A.c[i];</span><br><span class="line">                Forr(j, i, 0) &#123;</span><br><span class="line">                    if (x &gt;&gt; j &amp; 1) &#123;</span><br><span class="line">                        if (!t.c[j]) &#123;</span><br><span class="line">                            t.c[j] = x;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        x ^= t.c[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (x == 0) break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.maxn = max(maxn, A.maxn);</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;shu[N &lt;&lt; 2];</span><br><span class="line"></span><br><span class="line">//建树</span><br><span class="line">void Build (d rt, d l, d r) &#123;</span><br><span class="line">    if (l == r) &#123;</span><br><span class="line">        d t;</span><br><span class="line">        IO::read(t);</span><br><span class="line">        t = t &amp; (~k);</span><br><span class="line">        shu[rt].init();</span><br><span class="line">        shu[rt].addx(t);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    d mid = (l + r) &gt;&gt; 1;</span><br><span class="line">    if (l &lt;= mid) Build(lson, l, mid);</span><br><span class="line">    if (mid &lt; r) Build(rson, mid + 1, r);</span><br><span class="line">    shu[rt] = shu[lson].merge(shu[rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">node request (d rt, d l, d r, d L, d R) &#123;</span><br><span class="line">    node t;</span><br><span class="line">    t.init();</span><br><span class="line">    if (l &lt;= L &amp;&amp; r &gt;= R) &#123;</span><br><span class="line">        return shu[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    d mid = (L + R) &gt;&gt; 1;</span><br><span class="line">    if (l &lt;= mid &amp;&amp; r &gt; mid) return request(lson, l, r, L, mid).merge(request(rson, l, r, mid + 1, R));</span><br><span class="line">    else if(l &lt;= mid) return request(lson, l, r, L, mid);</span><br><span class="line">    else if(r &gt;= mid) return request(rson, l, r, mid + 1, R);</span><br><span class="line">    else return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    IO::begin();</span><br><span class="line">    d T, n, q, l, r;</span><br><span class="line">    IO::read(T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        IO::read(n);</span><br><span class="line">        IO::read(q);</span><br><span class="line">        IO::read(k);</span><br><span class="line">        Build(1, 1, n);</span><br><span class="line">        For(i, 1, q) &#123;</span><br><span class="line">            IO::read(l);</span><br><span class="line">            IO::read(r);</span><br><span class="line">            node t = request(1, l, r, 1, n);</span><br><span class="line">            d ans = (t.ansmax() | k);</span><br><span class="line">            IO::write(ans);</span><br><span class="line">            putchar(&apos;\n&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢!</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快到难以想象的快速读模版</title>
      <link href="/2018/10/21/%E5%BF%AB%E5%88%B0%E9%9A%BE%E4%BB%A5%E6%83%B3%E8%B1%A1%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AF%BB%E6%A8%A1%E7%89%88/"/>
      <url>/2018/10/21/%E5%BF%AB%E5%88%B0%E9%9A%BE%E4%BB%A5%E6%83%B3%E8%B1%A1%E7%9A%84%E5%BF%AB%E9%80%9F%E8%AF%BB%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/21/快到难以想象的快速读模版/z1.jpg" alt="z1"></p><a id="more"></a><p>​    没错，比上一个快速读写模版 <a href="http://www.ivan-zcy.top/2018/10/18/ACM快速读写模版/">跳转</a> 还要快，这个模版是利用fread方法实现一次性读完（速度快，缺点也明显，特别耗费内存！！）</p><p>​    具体模版如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace IO &#123;</span><br><span class="line">    const int MX = 4e7; //1e7 占用内存 11000kb</span><br><span class="line">    char buf[MX];</span><br><span class="line">    int c, sz;</span><br><span class="line">    </span><br><span class="line">    void begin() &#123;//该方法用于main方法开头位置，可一次性读完全部输入</span><br><span class="line">        c = 0;</span><br><span class="line">        sz = fread(buf, 1, MX, stdin);  //一次性全部读入</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inline bool read(int &amp;t) &#123;//用于从buf中读入每个数</span><br><span class="line">        while (c &lt; sz &amp;&amp; buf[c] != &apos;-&apos; &amp;&amp; (buf[c] &lt; &apos;0&apos; || buf[c] &gt; &apos;9&apos;)) c++;</span><br><span class="line">        if (c &gt;= sz) return false;//若读完整个缓冲块则退出</span><br><span class="line">        bool flag = 0; if(buf[c] == &apos;-&apos;) &#123;</span><br><span class="line">        flag = 1;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(t = 0; c &lt; sz &amp;&amp; &apos;0&apos; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &apos;9&apos;; c++) </span><br><span class="line">        t = t * 10 + buf[c] - &apos;0&apos;;</span><br><span class="line">        if(flag) t = -t;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    具体用法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[105];</span><br><span class="line">int main() &#123;</span><br><span class="line">    IO::begin();//一次性读完全部输入</span><br><span class="line">    int T, n;</span><br><span class="line">    IO::read(T);//从buf中读入到T</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">    IO::read(n);    //从buf中读入到n</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            IO::read(a[i]);//从buf中读入到a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意！！！只有当运行ctrl + z时才代表IO::begin()结束（在windows下，Linux下为ctrl + d），程序正式执行～</p><p>​    就酱紫～</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-20博客搭建进度</title>
      <link href="/2018/10/20/18-10-20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/20/18-10-20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/18-10-20博客搭建进度/z.jpg" alt="z"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器(10.05更新)</p><p>​    ——新增主页博文出场特效(10.05更新)</p><p>​    ——新增鼠标点击爱心效果</p><p>​    ——新增页面卡通人物效果</p><p>​    ——微调音乐布局</p><p>​    ——微调小火箭布局</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5971二分图染色</title>
      <link href="/2018/10/20/HDU5971/"/>
      <url>/2018/10/20/HDU5971/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5971/title8.jpg" alt="title8"></p><a id="more"></a><p>题意：</p><p>Nowadays, at least one wrestling match is held every year in our country. There are a lot of people in the game is “good player”, the rest is “bad player”. Now, Xiao Ming is referee of the wrestling match and he has a list of the matches in his hand. At the same time, he knows some people are good players,some are bad players. He believes that every game is a battle between the good and the bad player. Now he wants to know whether all the people can be divided into “good player” and “bad player”. </p><p>Input</p><p>Input contains multiple sets of data.For each set of data,there are four numbers in the first line:N (1 ≤ N≤ 1000)、M(1 ≤M ≤ 10000)、X,Y(X+Y≤N ),in order to show the number of players(numbered 1toN ),the number of matches,the number of known “good players” and the number of known “bad players”.In the next M lines,Each line has two numbersa, b(a≠b) ,said there is a game between a and b .The next line has X different numbers.Each number is known as a “good player” number.The last line contains Y different numbers.Each number represents a known “bad player” number.Data guarantees there will not be a player number is a good player and also a bad player.</p><p>Output</p><p>If all the people can be divided into “good players” and “bad players”, output “YES”, otherwise output “NO”.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 0 0</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">5 4 1 0</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给出n个人，m场比赛，已知x个人为好的运动员，y个人为差的运动员，每场比赛两个人必有一个好一个差，问好的和差的是否会前后冲突？如果不冲突是否每个运动员都可以归类？</p><p>思路：</p><p>​    听队友说正解是二分图染色，自己不会图论，就用BFS做了一手，只用62ms成功A掉</p><p>​    初始化book数组为0，把x个好运动员的book[i]初始化为1，y个差运动员的book[i]初始化为-1，并把这x+y个运动员加入到队列中。对队列中的每个运动员进行检查，和该运动员有关的（也就是与他有比赛的）运动员book[i]为0，那么就设置成和他之相反并把有关的运动员加入到队列中。如果和他book[i]相同，那么代表前后矛盾，直接标记为失败并跳出循环。</p><p>​    这是对与X+Y以及与之有关的运动员进行判定，如果没有失败的话，则对所有参与比赛的人进行检索，若存在参加比赛的人book[i]为0，这时候要注意，这个运动员和之前的运动员不存在任何关联！！！所以可以把他设置为book[i]为1并加入到优先队列，再次进行BFS进行检索查看是否有矛盾</p><p>​    若上面两个步骤都没有矛盾，则从头遍历所有运动员，是否有未归类的运动员，若没有则输出YES，否则都是NO。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d book[1005];</span><br><span class="line">vector&lt;d&gt;zcy[1005];</span><br><span class="line">queue&lt;d&gt;line;</span><br><span class="line">d n, m, x, y;</span><br><span class="line">d a[10005], b[10005];</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    d p;</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        zcy[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!line.empty()) &#123;</span><br><span class="line">        line.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, m) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);</span><br><span class="line">        zcy[a[i]].push_back(b[i]);</span><br><span class="line">        zcy[b[i]].push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, x) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">        book[p] = 1;</span><br><span class="line">        line.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, y) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;p);</span><br><span class="line">        book[p] = -1;</span><br><span class="line">        line.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BFS检索与已经入队的运动员有关的运动员是否前后冲突</span><br><span class="line">d work() &#123;</span><br><span class="line">    d flag = 0;</span><br><span class="line">    while (!line.empty()) &#123;</span><br><span class="line">        d t = line.front();</span><br><span class="line">        line.pop();</span><br><span class="line">        d pan = book[t];</span><br><span class="line">        for (d i = 0; i &lt; zcy[t].size(); i++)&#123;</span><br><span class="line">            if(book[zcy[t][i]] == 0) &#123;</span><br><span class="line">                book[zcy[t][i]] = -pan;</span><br><span class="line">                line.push(zcy[t][i]);</span><br><span class="line">            &#125; else if(book[zcy[t][i]] == pan)&#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    while (scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;x, &amp;y) == 4) &#123;</span><br><span class="line">        init();</span><br><span class="line">        d flag = work();</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 1, m) &#123;</span><br><span class="line">            if(!book[a[i]]) &#123;</span><br><span class="line">                book[a[i]] = 1;</span><br><span class="line">                line.push(a[i]);</span><br><span class="line">                flag = work();</span><br><span class="line">                if(flag) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后检索是否存在没有归类的运动员</span><br><span class="line">        For(i, 1, n) &#123;</span><br><span class="line">            if(!book[i]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;YES\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 5976思维</title>
      <link href="/2018/10/20/HDU-5976/"/>
      <url>/2018/10/20/HDU-5976/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU-5976/title7.jpg" alt="title7"></p><a id="more"></a><p>题意：</p><p>​    In a highly developed alien society, the habitats are almost infinite dimensional space.<br>In the history of this planet,there is an old puzzle.<br>​    You have a line segment with x units’ length representing one dimension.The line segment can be split into a number of small line segments: a1,a2, … (x= a1+a2+…) assigned to different dimensions. And then, the multidimensional space has been established. Now there are two requirements for this space:<br>​    1．Two different small line segments cannot be equal ( ai≠aj when i≠j).<br>​    2．Make this multidimensional space size s as large as possible (s= a1∗a2*…).Note that it allows to keep one dimension.That’s to say, the number of ai can be only one.<br>​    Now can you solve this question and find the maximum size of the space?(For the final number is too large,your answer will be modulo 10^9+7)</p><p>Input</p><p>​    The first line is an integer T,meaning the number of test cases.<br>​    Then T lines follow. Each line contains one integer x.<br>​    1≤T≤10^6, 1≤x≤10^9</p><p>Output</p><p>​    Maximum s you can get modulo 10^9+7. Note that we wants to be greatest product before modulo 10^9+7.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p> 翻译成汉语就是给出一个数T代表T组样例，然后每组样例给出一个x，然后将x拆分成任意多个各不相同的数a1,a2a1,a2, … 满足(x= a1+a2a1+a2+…) ，怎样拆分才能使得这些数的乘积最大，输出最大值并取模1e9+7</p><p>思路：</p><p>​    我们先特判a为1的情况，输出1</p><p>​    对于a&gt;1的情况：</p><p>​    由于拆分出的数各不相同，因此我们可以求sum[i]数组代表2 + 3 + .. + i（i &gt;= 2），ans[i]代表2✖️3✖️…✖️i (i &gt;= 2，注意累成需取模1e9+7否则爆longlong)。至于为什么不含1，因此任何数满足n &gt; (n - 1)✖️1，所以拆成1不划算。</p><p>​    我们利用二分找到第一个大于等于a的sum[i]，此时需要分类讨论：</p><p>​    若sum[i] == a，则直接输出ans[i]即为答案</p><p>​    若sum[i] - a == 1，则去掉2和i（也就是用ans[i]分别乘2和i关于1e9+7的逆元），再乘（i + 1）并取模1e9+7即为答案</p><p>​    若sum[i] - a &gt; 1，我们设sum[i] - a为k，k一定小于等于i，我们直接去掉k即可（也就是ans[i]乘k关于1e9+7的逆元）并取模1e9+7即为答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 45000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d sum[N + 5];</span><br><span class="line">ll ans[N + 5];</span><br><span class="line">const ll mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">//预处理sum与ans数组</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(sum);</span><br><span class="line">    ans[1] = 1;</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        sum[i] += sum[i - 1] + i;</span><br><span class="line">        ans[i] = ans[i - 1] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//扩展欧几里得</span><br><span class="line">ll exten(ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if(a == 0 &amp;&amp; b == 0) return -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = exten(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求逆元</span><br><span class="line">ll mod_reverse(ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll t = exten(a, n, x, y);</span><br><span class="line">    if (t == 1) return (x % n + n) % n;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二分查找第一个大于等于val的sum[i]下角标</span><br><span class="line">d erfen(d val) &#123;</span><br><span class="line">    d l = 2, r = N, mid;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; 1;</span><br><span class="line">        if(sum[mid] &gt;= val) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    d T, a;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        if (a == 1) &#123;//特判当a为1时</span><br><span class="line">            printf(&quot;1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        d inx = erfen(a);</span><br><span class="line">        d t = sum[inx] - a;</span><br><span class="line">        if (t == 0) &#123;//分三种情况讨论</span><br><span class="line">            printf(&quot;%lld\n&quot;, ans[inx]);</span><br><span class="line">        &#125; else if (t == 1) &#123;</span><br><span class="line">            d k = inx + 1;</span><br><span class="line">            ll res = ans[inx] * mod_reverse(2, mod) % mod * mod_reverse(inx, mod) % mod * k % mod;</span><br><span class="line">            printf(&quot;%lld\n&quot;, res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ll res = ans[inx] * mod_reverse(t, mod) % mod;</span><br><span class="line">            printf(&quot;%lld\n&quot;, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5974方程化简</title>
      <link href="/2018/10/20/HDU5974/"/>
      <url>/2018/10/20/HDU5974/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5974/title5.jpg" alt="title5"></p><a id="more"></a><p>题意：</p><p>Given two positive integers a and b,find suitable X and Y to meet the conditions:<br>​                                                        X+Y=a<br>​                                              Least Common Multiple (X, Y) =b</p><p>Input</p><p>Input includes multiple sets of test data.Each test data occupies one line,including two positive integers a(1≤a≤2*10^4),b(1≤b≤10^9),and their meanings are shown in the description.Contains most of the 12W test cases.</p><p>Output</p><p>For each set of input data,output a line of two integers,representing X, Y.If you cannot find such X and Y,output one line of “No Solution”(without quotation).</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 8</span><br><span class="line">798 10780</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No Solution</span><br><span class="line">308 490</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，就是给出两个数a，b (a &lt;= 2e4, b &lt;= 1e9)，问是否存在x,y，使得x + y = a, x和y的最小公倍数为b？一共有12万组样例！！</p><p>思路：    </p><p>​    由于有12W组样例，只要每组样例超过1e3几乎就凉了,因此这个题肯定不能暴力。于是我想到了第一种方法：</p><p>​    方法一：先利用素数筛把sqrt(1e9)以内的所有素数筛出来，然后求出b的所有种素因子和每种素因子的个数。</p><p>然后dfs每种素因子（每种素因子可以取0～a[i]个），再加上各种剪枝。。。982ms飘过～～</p><p><img src="/2018/10/20/HDU5974/1.png" alt="1"></p><p>​    </p><p>​    方法一代码耗时982ms实在是太吓人了，万一现场赛评测机一个不高兴给你慢个20ms你就嗝屁了，然后看到网上正解，一拍脑瓜子。哎，智商压制啊～</p><p>​    方法二：我们设x和y的最大公约数为c，那么x = i ✖️ c，y = j ✖️ c。</p><p>​    由于c是x，y的最大公约数，所以i，j一定互质（要是两者不互质存在公约数的话，x，y的最大公约就为c✖️i和j的公约数，而不是c了，因此i，j一定互质）</p><p>​    那么： </p><p>​        a = x + y = (i ✖️ c) + （j✖️c）= （i + j) ✖️ c</p><p>​        b = lcm(x, y) = x ✖️ y / gcd(x, y) = x ✖️ y / c = （i ✖️ c ✖️ j ✖️ c)  / c = i ✖️j✖️c</p><p>​    由于i,j互质，那么（i + j）和 （i * j）也一定互质。我们可以用反证法证明：</p><p>​    若（i + j）,（i✖️j)不互质存在一个素因子t：那么在i✖️j中，t只能是 i的素因子 或 j的素因子(因为i,j互质，不存在公共素因子)；又因为i和j必须都存在素因子t才能使得(i + j)存在素因子t(相当于同余定理，若a % t == 0， 则b % t == 0才能使得（a + b）% t == 0)，因此和i 存在素因子t 或 j存在素因子t相矛盾，所以(i + j)和(i * j)互质</p><p>​    因此gcd(a, b) = c = gcd (x, y)</p><p>​    因此化简得：</p><p>​    x + y = a      (一)</p><p>​    x✖️y = b ✖️ gcd(x, y) = b ✖️gcd(a, b)    （二）</p><p>​    a，b已知，因此就相当于解二元一次方程，把方程（一）带入（二）得：</p><p>​    x✖️(a - x) = b ✖️gcd(a, b) </p><p>=&gt;   x^2 - a✖️x + b✖️gcd(a,b) = 0</p><p>=&gt;    x = (a + sqrt(a^2 - 4✖️b✖️gcd(a,b))) / 2</p><p>​    就可以求出x，y了。这样代码简短，而且耗时只有124ms：</p><p><img src="/2018/10/20/HDU5974/2.png" alt="2"></p><p>​    Orz～</p><p>代码：</p><p>​    方法一：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 32000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line"></span><br><span class="line">bool book[N + 5];</span><br><span class="line">int prime[N + 5];</span><br><span class="line">ll ans[105];</span><br><span class="line">ll ansnum[105];</span><br><span class="line">ll a, b;</span><br><span class="line">bool flag;</span><br><span class="line"></span><br><span class="line">//预处理素数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(prime);</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime[0]) &#123;</span><br><span class="line">            ll t = prime[j] * i;</span><br><span class="line">            if (t &gt; N) break;</span><br><span class="line">            book[t] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求最大公约数</span><br><span class="line">ll gcd (ll y, ll x) &#123;</span><br><span class="line">    ll c = y % x;</span><br><span class="line">    return c == 0? x: gcd(x, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//枚举不同素数组成的因子可能</span><br><span class="line">void dfs(ll now, ll n, ll val) &#123;</span><br><span class="line">    if (flag) return;</span><br><span class="line">    if (val &gt; a / 2) return;</span><br><span class="line">    if(now == n + 1) &#123;</span><br><span class="line">        if(val * (a - val) / gcd((a - val), val) == b) &#123;</span><br><span class="line">            printf(&quot;%lld %lld\n&quot;, val, a - val);</span><br><span class="line">            flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    dfs(now + 1, n, val);</span><br><span class="line">    For(i, 1, ansnum[now]) &#123;</span><br><span class="line">        res *= ans[now];</span><br><span class="line">        dfs(now + 1, n, val * res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    while (scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) == 2) &#123;</span><br><span class="line">        mem(ansnum);</span><br><span class="line">        ll tot = 0, bb = b;</span><br><span class="line">        flag = 0;</span><br><span class="line">        For(i, 1, prime[0]) &#123;</span><br><span class="line">            if(bb % prime[i] == 0) &#123;</span><br><span class="line">                ans[++tot] = prime[i];</span><br><span class="line">                while(bb % prime[i] == 0) &#123;</span><br><span class="line">                    ansnum[tot]++;</span><br><span class="line">                    bb /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (bb == 1) break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(bb != 1) &#123;</span><br><span class="line">            ans[++tot] = bb;</span><br><span class="line">            ansnum[tot] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, tot, 1);</span><br><span class="line">        if(!flag) &#123;</span><br><span class="line">            printf(&quot;No Solution\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    方法二：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll gcd (ll y, ll x) &#123;</span><br><span class="line">    ll c = y % x;</span><br><span class="line">    return c == 0? x: gcd(x, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    while (scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) == 2) &#123;</span><br><span class="line">        ll c = gcd(max(a, b), min(a, b));</span><br><span class="line">        double x = (sqrt(a * a - 4 * b * c) + a) / 2;</span><br><span class="line">        if (x == (ll)x) &#123;</span><br><span class="line">            ll t = (ll)x;</span><br><span class="line">            printf(&quot;%lld %lld\n&quot;, min(t, a - t), max(t, a - t));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;No Solution\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5978水题</title>
      <link href="/2018/10/20/HDU5978/"/>
      <url>/2018/10/20/HDU5978/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5978/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><p>A box contains black balls and a single red ball. Alice and Bob draw balls from this box without replacement, alternating after each draws until the red ball is drawn. The game is won by the player who happens to draw the single red ball. Bob is a gentleman and offers Alice the choice of whether she wants to start or not. Alice has a hunch that she might be better off if she starts; after all, she might succeed in the first draw. On the other hand, if her first draw yields a black ball, then Bob’s chances to draw the red ball in his first draw are increased, because then one black ball is already removed from the box. How should Alice decide in order to maximize her probability of winning? Help Alice with decision. </p><p>Input</p><p>Multiple test cases (number of test cases≤50), process till end of input.<br>For each case, a positive integer k (1≤k≤10^5) is given on a single line. </p><p>Output</p><p>For each case, output:<br>1, if the player who starts drawing has an advantage<br>2, if the player who starts drawing has a disadvantage<br>0, if Alice’s and Bob’s chances are equal, no matter who starts drawing<br>on a single line. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思是一个箱子中有n个蓝球，1个红球。爱丽丝先抓，鲍勃后抓，直到抓到红球的人获胜为止。问谁赢的概率大。0代表概率一样，1代表爱丽丝赢的概率大，2代表鲍勃赢的概率大</p><p>思路：</p><p>​    当n为1的时候，爱丽丝赢的概率是1 / 2；当n为2的时候，爱丽丝赢的概率是1 / 3 + 2 / 3 ✖️ 1 / 2 =  2 / 3；当n为3的时候，爱丽丝赢的概率是1 / 4 + 3 / 4 ✖️ 2 / 3 ✖️1 / 2 = 1 / 2；当n为4的时候，爱丽丝赢的概率是1 / 5 + 4 / 5 ✖️ 3 / 4 ✖️1 / 3  +  4 / 5 ✖️ 3 / 4 ✖️ 2 / 3 ✖️ 1 / 2 =  3 / 5；</p><p>​    因此我们发现，当n为偶数的时候，爱丽丝赢的概率大，输出1。当n为奇数时，两者赢的概率相同，输出0。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int a;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;a) == 1) &#123;</span><br><span class="line">        if(a &amp; 1) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;1\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5980水题</title>
      <link href="/2018/10/20/HDU5980/"/>
      <url>/2018/10/20/HDU5980/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5980/title3.jpg" alt="title3"></p><a id="more"></a><p>题意：</p><p>As is known to all,the ASCII of character ‘a’ is 97. Now,find out how many character ‘a’ in a group of given numbers. Please note that the numbers here are given by 32 bits’ integers in the computer.That means,1digit represents 4 characters(one character is represented by 8 bits’ binary digits). </p><p>Input</p><p>The input contains a set of test data.The first number is one positive integer N (1≤N≤100),and then N positive integersai (1≤ aiai≤2^32 - 1) follow</p><p>Output</p><p>Output one line,including an integer representing the number of ‘a’ in the group of given numbers.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">97 24929 100</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，意思是int类型的数在二进制下有32位，问你一个数组中的数，8位8位的看，问存在多少个97</p><p>思路：</p><p>​    我们把数组中的每个数累除256直到0，每次累除都取余256看是否存在97，存在就++即可</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        unsigned int a;</span><br><span class="line">        int sum =0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(&quot;%u&quot;, &amp;a);</span><br><span class="line">            while(a) &#123;</span><br><span class="line">                if (a % 256 == 97) sum ++;</span><br><span class="line">                a /= 256;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU5979水题</title>
      <link href="/2018/10/20/HDU5979/"/>
      <url>/2018/10/20/HDU5979/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/20/HDU5979/title2.jpg" alt="title2"></p><a id="more"></a><p>题意：</p><p>We have a special convex that all points have the same distance to origin point.<br>As you know we can get N segments after linking the origin point and the points on the convex. We can also get N angles between each pair of the neighbor segments.<br>Now give you the data about the angle, please calculate the area of the convex </p><p>Input</p><p>There are multiple test cases.<br>The first line contains two integer N and D indicating the number of the points and their distance to origin. (3 &lt;= N &lt;= 10, 1 &lt;= D &lt;= 10)<br>The next lines contain N integers indicating the angles. The sum of the N numbers is always 360. </p><p>Output</p><p>For each test case output one float numbers indicating the area of the convex. The printed values should have 3 digits after the decimal point. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">90 90 90 90</span><br><span class="line">6 1</span><br><span class="line">60 60 60 60 60 60</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.000</span><br><span class="line">2.598</span><br></pre></td></tr></table></figure><p>​    2016ICPC大连站的签到题，翻译成汉语，意思是给出n，k，代表凸n边形，每个顶点距离原点的距离为k。然后下一行给出n个角度a[i]，角度之和等于360度。代表从上一个顶点与下一个顶点之间的夹角是a[i]度。问这个凸n边形的面积是多少？</p><p>思路：</p><p>​    由于已知角度和两个顶点距离原点的距离，所以我们可以根据三角形面积公式s = 1 / 2 * sin(夹角度数)分别求出每个三角形的面积。n个三角形的面积求和就是凸n变形的面积。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#define pi acos(-1.0)</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define N 100</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d n;</span><br><span class="line">    double t, a;</span><br><span class="line">    while (scanf(&quot;%d%lf&quot;, &amp;n, &amp;t) == 2) &#123;</span><br><span class="line">        double s = 0;</span><br><span class="line">        For(i, 0, n - 1) &#123;</span><br><span class="line">            scanf(&quot;%lf&quot;, &amp;a);</span><br><span class="line">            s += sin(pi * a / 180) * t * t / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.3f\n&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论二)浅谈线性基</title>
      <link href="/2018/10/19/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2018/10/19/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/19/浅谈线性基/titile1.jpg" alt="titile1"></p><a id="more"></a><p>​    前两天作了一套题，有一道线性基的模版题没出，觉得有必要学一手线性基了..</p><p>一.线性基是什么？</p><p>​    线性基其实就是一个集合。假设一个普通的集合为A，它的线性基集合B是A的一个子集。B中所有子集的异或和组成的集合等价于A中所有子集的亦或和组成的集合（除0外）。</p><p>二.线性基有什么性质：</p><p>​    1.若一个数x能被线性基集合中某个子集的异或和得到，该子集唯一</p><p>​    2.线性基集合中任意一个子集的异或和不为0</p><p>​    3.线性基集合中每个元素的最高位互不相同</p><p>​    4.若线性基集合是满的（也就是说最高位是1～n位的数都存在），那么它的异或集合是【1, 2^n - 1】</p><p>三.关于线性基的代码实现：</p><p>​    我们用p数组存储线性基的元素</p><p>​    （1）关于线性基中元素的插入</p><p>​    我们要插入一个数x，需要从高到低枚举所有位，若x&amp;当前位 != 0，若当前位不存在线性基元素，则将x当作线性基的当前位元素，否则x异或当前位元素，直到x为0或将x添加到线性基中</p><p>​    代码如下 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addx (ll x) &#123;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;//long long型的最大值为2^63 - 1，因此是0～62</span><br><span class="line">        if (x &gt;&gt; i &amp; 1) &#123;</span><br><span class="line">            if (!p[i]) &#123;</span><br><span class="line">                p[i] = x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            x ^= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (2)关于求最大异或和：</p><p>​    初始化res = 0，从高到低遍历位数，若res ^ p[i]大于res就更新res，最后res即为线性基所能得到的最大异或和</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getmax() &#123;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (res &lt; (res ^ p[i])) res ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (3)关于求异或t后的最大异或和：</p><p>​    同上一样，只需要初始化res = t即可。</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getmaxt() &#123;</span><br><span class="line">    ll res = t;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (res &lt; (res ^ p[i])) res ^= p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (4)关于求最小异或和：</p><p>​    最小值就是线性基中位数由低到高第一个存在的p[i]</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll getmin () &#123;</span><br><span class="line">    for (ll i = 0; i &lt;= 62; i++) &#123;</span><br><span class="line">        if (p[i]) return p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (5)关于求异或集合中的第k小值</p><p>​    需要把线性基集合中的元素改为除了最高位为1，其余位为0的形式。也就是说，若j&lt;i且p[i]中第j位是1，就p[i] ^ p[j]</p><p>​    我们对k进行二进制拆分，若第i位为1，就异或p[i]，最终得到的答案就是第k小的异或值</p><p>​    代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int tot = -1;</span><br><span class="line">void build () &#123;</span><br><span class="line">    for (ll i = 62; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (ll j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (p[i] &gt;&gt; j &amp; 1) p[i] ^= p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (ll i = 0; i &lt;= 62; i++) &#123;</span><br><span class="line">        if (p[i]) g[++tot] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll query (ll k) &#123;</span><br><span class="line">//若原数组中存在元素0，则此时需要k--</span><br><span class="line">    if (k &gt;= (1LL * tot)) return -1;</span><br><span class="line">    ll res = 0;</span><br><span class="line">    for (ll i = tot; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (k &gt;&gt; i &amp; 1) res ^= g[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四. 线性基能求解什么问题？</p><p>​    (1). 给出一个数组，问一个数能否由数组中的元素异或得到</p><p>​    (2).给出一个数组，问数组中全部子集异或和组成的集合中，第k小的数是多少</p><p>​    (3).给出一个数组和一个数t，问数组全部子集的异或和（可重复）按从小到大排序，第一个等于t的下角标是多少？</p><p>​    (4).给出一个可重集合和k，等概率选一个子集A，得到A的异或和x，问x^k的数学期望值是多少？</p><p>​    (5).给出一个连通无向图（n个点m条边，每个边有一个权值）,问从起点走到终点异或和最小的值是多少？</p><p>​    以上就是总结的线性基的基础，遇到异或问题，可以首先考虑能否使用线性基，就酱～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1636区间dp</title>
      <link href="/2018/10/19/hihoCoder-1636/"/>
      <url>/2018/10/19/hihoCoder-1636/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/19/hihoCoder-1636/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>In Chinese mythology, Pangu is the first living being and the creator of the sky and the earth. He woke up from an egg and split the egg into two parts: the sky and the earth.</p><p>At the beginning, there was no mountain on the earth, only stones all over the land.</p><p>There were N piles of stones, numbered from 1 to N. Pangu wanted to merge all of them into one pile to build a great mountain. If the sum of stones of some piles was S, Pangu would need S seconds to pile them into one pile, and there would be S stones in the new pile. </p><p>Unfortunately, every time Pangu could only merge successive piles into one pile. And the number of piles he merged shouldn’t be less than L or greater than R.</p><p>Pangu wanted to finish this as soon as possible. </p><p>Can you help him? If there was no solution, you should answer ‘0’.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>There are multiple test cases.</p><p>The first line of each case contains three integers N,L,R as above mentioned (2&lt;=N&lt;=100,2&lt;=L&lt;=R&lt;=N).</p><p>The second line of each case contains N integers a1,a2 …aN (1&lt;= ai  &lt;=1000,i= 1…N ), indicating the number of stones of  pile 1, pile 2 …pile N.</p><p>The number of test cases is less than 110 and there are at most 5 test cases in which N &gt;= 50.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, you should output the minimum time(in seconds) Pangu had to take . If it was impossible for Pangu to do his job, you should output  0.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 2</span><br><span class="line">1 2 3</span><br><span class="line">3 2 3</span><br><span class="line">1 2 3</span><br><span class="line">4 3 3</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">6</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思就是给你三个数n，l，r，代表有n堆石子，之后一行有n个数，代表每堆石子的个数。每次只能把连续的l～r堆石子合并为1堆，若能最终把n堆石子合并为1堆，问最小花费是多少？不能合并为1堆则输出0。（l～r堆石子合并为1堆的花费是这些堆的石子数总和）</p><p>思路：</p><p>​    这是一道区间dp题，做的时候一直在研究如何限制合并的堆数为l～r，想破头皮想出来区间DP嵌套dfs的做法，结果超时了。。。最后从网上看了题解，发现自己想问题想复杂了。我们设sum【i】为前i堆石子的石子数和，dp【i】【j】【k】代表区间i～j的石子堆合并成k堆所需要的最小花费，初始化为INF，然后对于dp【i】【j】【i - j + 1】初始化为0，对于dp【i】【i + len - 1】【1】初始化为sum【i + len - 1】 - sum【i - 1】。</p><p>​    对于推导式，当k！=1时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j][k] = min(dp[i][j][k],dp[i][p][k - 1] + dp[p + 1][j][1]);//其中p属于【i，j)</span><br></pre></td></tr></table></figure><p>​    我们在k！=1时其实不需要限制l～r的合并，因为此时没有合并操作，只是i～p有k - 1堆石子，（p + 1） ～</p><p>r有1堆石子，那么i～j有k堆石子，取最小的即可。至于为什么是k - 1 和 1项加，因为遍历全部的p，就包含i～j的所有合并可能且不重复了。因此我们只需要考虑当k == 1时的合并问题</p><p>​    </p><p>​    对于推导式，当k == 1时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j][1] = min(dp[i][j][1], dp[i][p][len - 1] + dp[p + 1][j][1] + sum[j] - sum[i - 1]); //其中p属于【i，j), len属于【l，r】</span><br></pre></td></tr></table></figure><p>​    </p><p>​    因此，就可以用区间dp来求解，将酱～</p><p>代码；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define N 100</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d a[N + 5];                     //每堆石子数</span><br><span class="line">ll sum[N + 5];                  //前缀和</span><br><span class="line">ll dp[N + 5][N + 5][N + 5];     //dp[i][j][k]代表区间i～j能合并成k堆的最小花费</span><br><span class="line">d n, l, r;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">void init () &#123;</span><br><span class="line">    mem(sum);</span><br><span class="line">    memset(dp, INF, sizeof(dp));</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        sum[i] = a[i] + sum[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        For(j, i, n) &#123;</span><br><span class="line">            dp[i][j][j - i + 1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, l, r) &#123;</span><br><span class="line">        For(p, 1, n + 1 - i) &#123;</span><br><span class="line">            dp[p][p + i - 1][1] = sum[p + i - 1] - sum[p - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work () &#123;</span><br><span class="line">    For(len, 2, n) &#123;</span><br><span class="line">        For(i, 1, n - len + 1) &#123;</span><br><span class="line">            For(q, l, r) &#123;</span><br><span class="line">                For(p, i, i + len - 2) &#123;</span><br><span class="line">                    dp[i][i + len - 1][1] = min(dp[i][i + len - 1][1], dp[i][p][q - 1] + dp[p + 1][i + len - 1][1] + sum[i + len - 1] - sum[i - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            For(k, 2, len - 1) &#123;</span><br><span class="line">                For(p, i, i + len - 2) &#123;</span><br><span class="line">                    dp[i][i + len - 1][k] = min(dp[i][i + len - 1][k], dp[i][p][k - 1] + dp[p + 1][i + len - 1][1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;r) == 3) &#123;</span><br><span class="line">        init();</span><br><span class="line">        work();</span><br><span class="line">        if ((d)dp[1][n][1] == INF) &#123;</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%lld\n&quot;, dp[1][n][1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM快速读写模版</title>
      <link href="/2018/10/18/ACM%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%A8%A1%E7%89%88/"/>
      <url>/2018/10/18/ACM%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/18/ACM快速读写模版/title.jpg" alt="title"></p><a id="more"></a><p>​    有必要整一个快速读写的模版了，万一就差几十ms给TLE了就嗝屁了～</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">//快速读</span><br><span class="line">inline int read() &#123;</span><br><span class="line">    int num=0, w=0;</span><br><span class="line">    char ch=0;</span><br><span class="line">    while (!isdigit(ch)) &#123;</span><br><span class="line">        w|=ch==&apos;-&apos;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while (isdigit(ch)) &#123;</span><br><span class="line">        num = (num&lt;&lt;3) + (num&lt;&lt;1) + (ch^48);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return w? -num: num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速写</span><br><span class="line">inline void write(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&lt;0) &#123;</span><br><span class="line">        putchar(&apos;-&apos;);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x&gt;9) write(x / 10);</span><br><span class="line">    putchar(x % 10 + &apos;0&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t = read();     //读入到t中</span><br><span class="line">    write(t);       //输出t</span><br><span class="line">    putchar(&apos;\n&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVALive 8521组合数+dp</title>
      <link href="/2018/10/18/UVALive-8521/"/>
      <url>/2018/10/18/UVALive-8521/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/18/UVALive-8521/title6.jpg" alt="title6"></p><a id="more"></a><p>题意：</p><p><strong>problem description</strong></p><p>5 friends play LOL together . Every one should BAN one character and PICK one character . The enemy should BAN 5 characters and PICK 5 characters . All these 20 heroes must be different .</p><p>Every one can BAN any heroes by his personal washes . But he can only PICK heroes which he has bought .</p><p>Suppose the enemy can PICK or BAN any heroes. How many different ways are there satisfying the conditions?</p><p>For example , a valid way is :</p><p>Player 1 : picks hero 1, bans hero 2</p><p>Player 2 : picks hero 3, bans hero 4</p><p>Player 3 : picks hero 5, bans hero 6</p><p>Player 4 : picks hero 7, bans hero 8</p><p>Player 5 : picks hero 9, bans hero 10</p><p>Enemies pick heroes 11,12,13,14,15 , ban heroes 16,17,18,19,20 .</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains multiple test cases.(No more than 20)</p><p>In each test case . there’s 5 strings S[1]∼S[5] ,respectively whose lengths are 100 , For the i-th person if he has bought the j-th hero, the j-th character of S[i] is ‘1’, or ‘0’ if not. The total number of heroes is exactly 100 .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case , print the answer mod 1000000007 in a single line .</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0110011100011001001100011110001110001110001010010111111110101010010011010000110100011001001111101011</span><br><span class="line">1000111101111110110100001101001101010001111001001011110001111110101000011101000001011100001001011010</span><br><span class="line">0100101100011110011100110110011100111100010010011001111110101111111000000110001110000110001100001110</span><br><span class="line">1110010101010001000110100011101010001010000110001111111110101010000000001111001110110101110000010011</span><br><span class="line">1000010011111110001101100000101001110100011000111010011111110110111010011111010110101111011111011011</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">515649254</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思是LOL一共有100个英雄，十个人（每队5人）选英雄，每人可以选一个扳一个，问十个人有多少种不同的选扳方案（对答案取余1e9+7）。对面英雄全有，输入5个01串表示我方五个人分别拥有的英雄（1有0无）</p><p>注意点：1.每个人只能选自己拥有的英雄，任意两个人不能选或者扳同一个英雄。同一队伍的1，2，3，4，5召唤师选英雄1，2，3，4，5和选英雄5，4，3，2，1是不同的方案，而1，2，3，4，5召唤师扳英雄1，2，3，4，5和5，4，3，2，1是相同的方案</p><p>思路：</p><p>​    因为我们要求的是全部的方案数，所以我们不用管中间的过程（过程太复杂没法模拟），整体地看待总方案数为：我方选择的英雄方案数✖️敌人选择的英雄方案数✖️我方扳的英雄方案数✖️敌人扳的英雄方案数。</p><p>​    我们无论怎么选取5个英雄，那么敌人只能从剩下的95个中选5个，所以方案数是A（95，5），而我方扳的英雄方案数是C（90， 5），敌人扳的英雄方案数是C（85，5）。至于谁先谁后无所谓，因为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A(95,5) * C(90,5) * C(85,5) = C(95,5) * C(90,5) * A(85,5) = C(95,5) * A(85,5) * C(90,5)</span><br></pre></td></tr></table></figure><p>​    由于敌人选择的英雄方案数✖️我方扳的英雄方案数✖️敌人扳的英雄方案数的值是固定的，我们可以预处理出来，得到g，</p><p>​    因此我们只需要每次利用dp求解我方选择的英雄方案数，再乘g就能得到答案</p><p>​    关于dp求解我方选择的英雄方案数，我们可以设dp【i】【j】代表前j个英雄已经选了i个英雄的方案数，然后遍历每个成员，里层遍历每个英雄。为了避免重复，我们保证每个成员选的英雄都比上一个成员选的英雄下角标大（这样会导致方案数不全，因此我们需在最外层对成员下标进行全排列）</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[8][150];</span><br><span class="line">d t[8][150];</span><br><span class="line">ll dp[8][150];</span><br><span class="line"></span><br><span class="line">//扩展欧几里得</span><br><span class="line">ll extend(ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b==0) r -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        r a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g = extend(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    r g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求逆元</span><br><span class="line">ll mod_re(ll a, ll n) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll g = extend(a, n, x, y);</span><br><span class="line">    if(g == 1) r (x % n + n) % n;</span><br><span class="line">    r -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求A(95，5) * C(90, 5) * C(85, 5)的值</span><br><span class="line">ll init() &#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    For(i, 81, 95) &#123;</span><br><span class="line">        res = res * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 2, 5) &#123;</span><br><span class="line">        ll g = mod_re(i, mod);</span><br><span class="line">        res = res * g % mod * g % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求我方选择英雄的总类数</span><br><span class="line">ll work() &#123;</span><br><span class="line">    ll ans =0;</span><br><span class="line">    d inx[5] = &#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line">    do &#123;</span><br><span class="line">        mem(dp);</span><br><span class="line">        For(j, 0, 99) &#123;</span><br><span class="line">            dp[0][j] = dp[0][j - 1];</span><br><span class="line">            if(s[inx[0]][j] == &apos;1&apos;) &#123;</span><br><span class="line">                dp[0][j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 1, 4) &#123;</span><br><span class="line">            For(j, 0, 99) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - 1];</span><br><span class="line">                if(s[inx[i]][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + dp[4][99]) % mod;</span><br><span class="line">    &#125;while (next_permutation(inx, inx + 5));</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll g = init();</span><br><span class="line">    while (scanf(&quot;%s&quot;, s[0]) == 1) &#123;</span><br><span class="line">        For(i, 1, 4) &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = work();</span><br><span class="line">        printf(&quot;%lld\n&quot;, g * ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用命令（转）</title>
      <link href="/2018/10/18/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/18/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/18/Vim常用命令/title3.jpg" alt="title3"></p><a id="more"></a><p>作者：Bonnie-帮你<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/daocaoren1543169565/article/details/53114347" target="_blank" rel="noopener">https://blog.csdn.net/daocaoren1543169565/article/details/53114347</a> </p><p>感觉总结的特别好，万分感谢！！转了～</p><p>（一）初级个性化配置你的vim</p><p>1、vim是什么？</p><p>vim是Vi IMproved，是编辑器Vi的一个加强版，一个极其强大并符合IT工程师（程序员、运维）习惯的编辑器。如果你是一名职业的SE，那么一定在寻找一款出色的能够自由定制、满足灵活编辑功能的编辑器。那么答案，就是vim或者Emacs。而这一套连续的博文，就为您介绍vim编辑器。至于另一款强大的编辑器Emacs，我们会在今后的一个系列博文中看到。</p><p>2、配置文件在哪？</p><p>Windows系统的配置文件是vim安装目录下的vimrc文件。</p><p>Linux系统，RHEL和CentOS的配置文件是/etc/vimrc，Debian和Ubuntu的配置文件是/usr/share/vim/vimrc。</p><p>Mac OS X的配置文件是/usr/share/vim/vimrc。</p><p>3、vimRC中的RC是什么意思？</p><p>为什么把这么个没有意义的问题也列出来？原因很简单，就是我在接触vim之初第二个想问的问题就是这个（第一个就是上面的“1”）。一般在运行某个软件、环境或工具之初，要初始执行的一些命令，称为Run Commands，即RC。根据Wikipedia.org的记载，RC缩写的用法源自MIT的相容分时操作系统（Compatible Time-Sharing System，CTSS）[参考1]。所以以后如果你看到了SystemRC或者ScreenRC，也就知其缘由了。</p><p>4、三种基本模式</p><p>在《大家来学vim》中提到vim有6+5种模式，但除了细分程度不同外，实际上常用的只有3种模式：Normal Mode、Insert Mode和Command-line Mode。</p><p>从Normal Mode进入Insert Mode，可以按i、I、a、A、o、O、r、R即可。其中i和I表示插入（Insert），r和R表示替换（replace）。</p><p>从Insert Mode进入Normal Mode，只需要按ESC键即可。</p><p>从Normal Mode进入Command-line Mode，可以按“:”、“/”、“?”。其中“:”表示输入vim命令，“/”表示后面输入要向下搜索的字符串，“?”表示后面输入要向上搜索字符串。</p><p>从Command-line Mode进入Normal Mode，只需要按ESC键即可了。</p><p>你可以把Normal Mode理解为常态，进入其他任何一种模式，需要某种特殊方式，而从其他特殊模式回到Normal Mode，就按ESC键即可。</p><p>5、vim中那些最最常用的配置</p><p>当你尝试去Google一些其他人的vimrc配置时，你一定会找到一篇叫做《The ultimate vim configuration》的文章，不过它的作者，Amix后来在他的博客上提到[参考2]，这份在google搜索vimrc会排在前十的vim配置文件，如今已经过时了，所以他提供了一些更新信息。</p><p>（1）颜色设置</p><pre><code>syntax on       &quot;开启代码高亮syntax off      &quot;关闭代码高亮syntax enable   &quot;开启代码高亮</code></pre><p>（2）搜索设置</p><pre><code>set hlsearch    &quot;开启搜索高亮set nohlsearch  &quot;关闭搜索高亮set incsearch   &quot;输入搜索字符串的同时进行搜索set ignorecase  &quot;搜索时忽略大小写</code></pre><p>（3）用户界面</p><pre><code>set showmode        &quot;开启模式显示set ruler           &quot;开启光标位置提示set number      &quot;显示行号set nonu            &quot;不显示行号set cursorline      &quot;强调光标所在行set cmdheight=1 &quot;命令部分高度为1</code></pre><p>（4）编辑辅助配置</p><pre><code>set autoindent      &quot;自动缩进set noautoindent    &quot;不自动缩进set smartindent     &quot;智能缩进set autoread        &quot;当文件在外部被改变时，vim自动更新载入set showmatch       &quot;显示匹配的括号</code></pre><p>参考：</p><pre><code>Run Commands，http://en.wikipedia.org/wiki/Run_commandsThe Ultimate vim Configuration(vimRC)，http://amix.dk/blog/post/19486</code></pre><p>（二）常用的状态切换按键</p><p>1、Normal Mode -&gt; Insert Mode</p><p>i 小写字母i，在光标位置插入<br>a 小写字母a，在光标的下一个位置插入<br>I 大写字母I，在光标所在行的第一个非空格处插入<br>A 大写字母A，在光标所在行的最后一个字符处插入<br>o 小写字母o，在光标所在行的下一行处插入新行<br>O 大写字母O，在光标所在行的上一行处插入新航<br>r 小写字母r，替换光标所在处的字符一次<br>R 大写字母R，持续替换光标所在处的字符，直到按下ESC</p><p>2、Normal Mode -&gt; Command-line Mode</p><p>:w 保存文件<br>:w! 强制保存文件（前提是用户有修改文件访问权限的权限）<br>:q 退出缓冲区<br>:q! 强制退出缓冲区而不保存<br>:wq 保存文件并退出缓冲区<br>:wq! 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限）</p><p>:w 另存为名为filename文件<br>:n1,n2 w 将n1行到n2行的数据另存为名为filename文件<br>:x 如果文件有更改，则保存后退出。否则直接退出。</p><p>3、Insert Mode -&gt; Normal Mode</p><p>按下ESC键</p><p>4、Command-line -&gt; Normal Mode</p><p>按下ESC键</p><p>（三）常用光标移动按键</p><p>1、光标字符操作</p><pre><code>j 向下k 向上h 向左l 向右$ 光标移动到行尾（End），注意要按Shift键0 光标移动到行首（Home）^ 光标移动到行首第一个非空白字符（Home），注意要按Shift键</code></pre><p>2、光标词操作</p><pre><code>w 光标移动到后一词的词首W 光标移动到后一词的词首且忽略标点符号e 光标移动到后一词的词尾E 光标移动到后一词的词尾且忽略标点符号b 光标移动到前一词的词首B 光标移动到前一词的词首且忽略标点符号</code></pre><p>3、光标句操作</p><pre><code>) 光标移动到后一句的句首( 光标移动到前一句的句首% 配合“(”和“)”使用，寻找相匹配的另一半</code></pre><p>4、光标行操作</p><pre><code>G 光标移动到文档的最后一行的第一个非空白字符nG 光标移动到文档的第n行，相当于”:n”gg 光标移动到文档的第1行的第一个非空白字符，相当于”1G”，也相当于”:1″光标向下移动N行</code></pre><p>5、光标段操作</p><pre><code>} 光标移动到下一段的段首{ 光标移动到上一段的段首% 配合“(”和“)”使用，寻找相匹配的另一半</code></pre><p>6、光标页操作</p><pre><code>Ctrl+f 向下翻页（Pagedown）Ctrl+b 向上翻页（Pageup）Ctrl+d 向下翻半页Ctrl+u 向上翻半页H 光标移动到目前显示页的第一行M 光标移动到目前显示页的中间行L 光标移动到目前显示页的最后一行</code></pre><p>7、光标自由操作</p><pre><code>Ctrl+o 回到光标的上一位置</code></pre><p>（四）常用编辑操作按键</p><p>1、删除操作（delete）</p><pre><code>dd 删除光标所在行ndd 删除从光标所在行开始，向下的n行d1G 删除从光标所在行开始，到第一行的所有行dG 删除从光标所在行开始，到最后一行的所有行d$ 删除从光标所在位置，到行尾的所有字符d0 删除从光标所在位置，到行首的所有字符</code></pre><p>2、复制操作（yank）</p><pre><code>yy 复制光标所在行nyy 复制从光标所在行开始，向下的n行y1G 复制从光标所在行开始，到第一行的所有行yG 复制从光标所在行开始，到最后一行的所有行y$ 复制从光标所在位置，到行尾的所有字符y0 复制从光标所在位置，到行首的所有字符</code></pre><p>3、粘贴操作（paste）</p><pre><code>p 小写字母p，粘贴剪贴板中的数据，从光标所在行的下一行开始P 大写字母P，粘贴剪贴板中的数据，从光标所在行的上一行开始</code></pre><p>4、撤销与重做操作（undo，redo）</p><pre><code>u （Undo）撤销上一个操作Ctrl+r （Redo）重做上一个操作</code></pre><p>5、重复操作</p><pre><code>. 重复上一操作</code></pre><p>6、替换操作（replace）</p><pre><code>r 替换光标所在处字符R 进入替换模式，直至按ESC退出cc 替换光标所在行cw 替换光标所在的英文单词~ 转换大小写</code></pre><p>7、排版操作</p><pre><code>:le 光标所在行左对齐:ri 光标所在行右对齐:ce 光标所在行居中</code></pre><p>（五）常用多缓冲区操作按键</p><p>1、多文件编辑模式</p><pre><code>argument list模式，就是在打开vim编辑器时，携带多个文件路径参数。buffer list模式，就是在进入vim编辑器后，打开多个缓冲区进行编辑。</code></pre><p>2、单一缓冲区打开多个文件</p><pre><code>:files 显示目前打开了哪些文件:n 切换到下一个缓冲区内容:N 切换到上一个缓冲区内容:2n 切换到下下个缓冲区内容:bn 下一个缓冲区内容（buffer next）:bp 上一个缓冲区内容（buffer previous）</code></pre><p>3、多个缓冲区打开多个文件</p><pre><code>:sp [filename] 打开一个新的缓冲区，如果有filename则内容为该文件，否则为当前文件Ctrl+w n 新建一个缓冲区Ctrl+w q 退出光标所在的缓冲区Ctrl+w j 光标移动到下一缓冲区Ctrl+w k 光标移动到上一缓冲区Ctrl+w l 光标移动到右一缓冲区Ctrl+w h 光标移动到左一缓冲区Ctrl+w v 左右切割窗口新建缓冲区Ctrl+w s 上下切割窗口新建缓冲区Ctrl+w o 使光标所在缓冲区最大化，其他缓冲区隐藏</code></pre><p>（六）常用搜索与书签操作快捷键</p><ol><li>搜索字符串</li></ol><p>/string 向下搜索字符串“string”?string 向上搜索字符串“string”</p><ol start="2"><li>重复上次搜索</li></ol><p>n 根据上次搜索条件找到下一个匹配的字符串N 根据上次搜索条件找到上一个匹配的字符串</p><ol start="3"><li>搜索单词</li></ol><ul><li>向下搜索光标所在处的单词（完全匹配）# 向上搜索光标所在处的单词（完全匹配）g* 向下搜索光标所在处的单词（部分匹配）g# 向上搜索光标所在处的单词（部分匹配）</li></ul><ol start="4"><li>标记书签（mark）</li></ol><p>ma a为小写字母，为光标所在处设定文档书签amA A为大写字母，为光标所在处设定全局书签A</p><ol start="5"><li>使用书签（mark）</li></ol><p><code>a 到文档书签a处，Tab键上方&#39;a 到文档书签a所在行行首处，Enter键左边</code>A 到全局书签A处，Tab键上方’A 到全局书签A所在行行首处，Enter键左边`n 如果n=0，缓冲区将打开上一次的文档，且光标在上次编辑最后的位置，1-9以此类推’n 如果n=0，缓冲区将打开上一次的文档，且光标在上次编辑最后的位置所在行的行首，1-9以此类推</p><ol start="6"><li>查看书签列表</li></ol><p>:marks 查看当前所有书签</p><p>（7）关于加密</p><p>1、加密你的文本文件</p><p>当你用vim打开或新建一个文件时，如果加上-x参数，即：</p><p>vim -x filename</p><p>那么vim会提示你：</p><p>Enter entryption key:</p><p>当你输入了密码后，vim会提示你重复输入以确认：</p><p>Enter same key again:</p><p>你在设置密码的时候，是以*来显示的，非明文。当下次有人（包括你自己）打开该文件的时候，vim就会提示：</p><p>Need encryption key for “main.cpp”<br>Enter encryption key:</p><p>这时你只要输入你之前所设置的密码就可以了。如果你输入的密码是错误的，vim并不会提示你密码错误，而是显示一堆无意义的垃圾代码。</p><p>2、解除加密与重设密码</p><p>打开你已经加密的文件，然后输入：</p><p>:set key=</p><p>这样，你的密码就被设置为空了，今后进入就不再需要输入密码了。而如果你向重设密码的话，你可以输入：</p><p>:X</p><p>注意是个大写字母X。这时vim会提示你，只要反复输入两次新的密码就可以了：</p><p>Enter entryption key: <strong>*</strong><br>Enter sanme key again: <strong>*</strong></p><p>3、加密引起的问题</p><p>vim的加密功能，可以说是问题一大堆。比如：</p><p>（1）如果密码输入错误，vim不会拒绝访问者编辑文件。在这种显示乱码的情况下编辑文件并保存，整个文件就会变得混乱不堪，无法辨识。今后即使使用正确的密码打开文件，也看不到正确的文档了。</p><p>（2）如果对一个需要编译的源代码文件进行了加密，则无法通过编译器的语法检查。</p><p>（3）交换文件是无法加密的。这样引起什么问题？问题就是如果其他用户想办法读取到了你的交换文件，就可以绕过解密环节，你的加密也就无意义了。解决的办法就是，不使用交换文件。方法有三个，一是修改你的vimrc文件（vim配置文件）：</p><p>set noswapfile</p><p>二是在用vim打开文件之初就输入命令：</p><p>vim -x -n filename</p><p>（注意-x是加密参数，与我们所说的swap没有关系，不要搞混）</p><p>三是在进入vim编辑该文件后，输入：</p><p>:setlocal noswapfile</p><p>不过不使用交换文件的坏处就是，你可能会面临数据丢失而无法找回的悲剧。所以又想用加密，又想不丢失文件的朋友们，就勤按“:w”吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1632模拟</title>
      <link href="/2018/10/17/hihoCoder-1632/"/>
      <url>/2018/10/17/hihoCoder-1632/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/17/hihoCoder-1632/title4.jpg" alt="title4"></p><a id="more"></a><p>题意：</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>The Yongzheng Emperor (13 December 1678 – 8 October 1735), was the fifth emperor of the Qing dynasty of China. He was a very hard-working ruler. He cracked down on corruption and his reign was known for being despotic, efficient, and vigorous.</p><p>Yongzheng couldn’t tolerate people saying bad words about Qing or him. So he started a movement called “words prison”. “Words prison” means literary inquisition. In the famous Zhuang Tinglong Case, more than 70 people were executed in three years because of the publication of an unauthorized history of the Ming dynasty.</p><p>In short, people under Yongzheng’s reign should be very careful if they wanted to write something. So some poets wrote poems in a very odd way that only people in their friends circle could read. This kind of poems were called secret poems.</p><p>A secret poem is a N×N matrix of characters which looks like random and meaning nothing. But if you read the characters in a certain order, you will understand it. The order is shown in figure 1 below:</p><p><img src="/2018/10/17/hihoCoder-1632/1.jpg" alt="1"></p><p>​            figure 1                                                                               figure 2</p><p>Following the order indicated by arrows, you can get “THISISAVERYGOODPOEMITHINK”, and that can mean something.</p><p>But after some time, poets found out that some Yongzheng’s secret agent called “Mr. blood dripping” could read this kind of poems too. That was dangerous. So they introduced a new order of writing poems as shown in figure 2. And they wanted to convert the old poems written in old order as figure1 into the ones in new order. Please help them.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>There are no more than 10 test cases.</p><p>For each test case:</p><p>The first line is an integer N( 1 &lt;= N &lt;= 100), indicating that a poem is a N×N matrix which consist of capital letters.</p><p>Then N lines follow, each line is an N letters string. These N lines represent a poem in old order.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, convert the poem in old order into a poem in new order.</p><p>样例输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">THSAD </span><br><span class="line">IIVOP </span><br><span class="line">SEOOH </span><br><span class="line">RGETI </span><br><span class="line">YMINK</span><br><span class="line">2</span><br><span class="line">AB</span><br><span class="line">CD</span><br><span class="line">4</span><br><span class="line">ABCD</span><br><span class="line">EFGH</span><br><span class="line">IJKL</span><br><span class="line">MNOP</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THISI</span><br><span class="line">POEMS</span><br><span class="line">DNKIA</span><br><span class="line">OIHTV</span><br><span class="line">OGYRE</span><br><span class="line">AB</span><br><span class="line">DC</span><br><span class="line">ABEI</span><br><span class="line">KHLF</span><br><span class="line">NPOC</span><br><span class="line">MJGD</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概是将一串字符按图一的规律排列，让你输出将这串字符按图二的规律排列并输出。</p><p>思路：</p><p>​    没啥别的，暴力大模拟就完了。。。不过暴力一定要优雅和简练！！比如我哈哈哈～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, star, endd) for(d i = star; i &gt;= endd; i--)</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s1[105][105], s2[105][105], s3[105][105];</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d n;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) == 1) &#123;</span><br><span class="line">        mem(s2);</span><br><span class="line">        mem(s3);</span><br><span class="line">        For(i, 0, n - 1) &#123;</span><br><span class="line">            scanf(&quot;%s&quot;, s1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int tot = 0;</span><br><span class="line">        For(i, 0, 2 * n - 2) &#123;</span><br><span class="line">            if (i &amp; 1) &#123;</span><br><span class="line">                For(j, 0, i) &#123;</span><br><span class="line">                    if (i - j &gt; n - 1 || j &gt; n - 1) continue;</span><br><span class="line">                    s2[tot / n][tot % n] = s1[j][i - j];</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Forr(j, i, 0) &#123;</span><br><span class="line">                    if (i - j &gt; n - 1 || j &gt; n - 1) continue;</span><br><span class="line">                    s2[tot / n][tot % n] = s1[j][i - j];</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = 0;</span><br><span class="line">        for (int i = n; i &gt;= 1; i -= 2) &#123;</span><br><span class="line">            for (int j = (n - i) / 2; j &lt;= n - 2 - (n - i) / 2; j++) &#123;</span><br><span class="line">                s3[(n - i) / 2][j] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = (n - i) / 2; j &lt;= n - 2 - (n - i) / 2; j++) &#123;</span><br><span class="line">                s3[j][n - 1 - (n - i) / 2] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = n - 1 - (n - i) / 2; j &gt;= (n - i) / 2 + 1; j--) &#123;</span><br><span class="line">                s3[n - 1 - (n - i) / 2][j] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = n - 1 - (n - i) / 2; j &gt;= (n - i) / 2 + 1; j--) &#123;</span><br><span class="line">                s3[j][(n - i) / 2] = s2[tot / n][tot % n];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n &amp; 1) &#123;</span><br><span class="line">            s3[n / 2][n / 2] = s2[n - 1][n - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        For(i, 0, n - 1) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, s3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 大模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1631模拟</title>
      <link href="/2018/10/17/hihoCoder-1631/"/>
      <url>/2018/10/17/hihoCoder-1631/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/17/hihoCoder-1631/title7.jpg" alt="title7"></p><a id="more"></a><p>题意：</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>There are many homeless cats in PKU campus. They are all happy because the students in the cat club of PKU take good care of them. Li lei is one of the members of the cat club. He loves those cats very much. Last week, he won a scholarship and he wanted to share his pleasure with cats. So he bought some really tasty fish to feed them, and watched them eating with great pleasure. At the same time, he found an interesting question:</p><p>There are m fish and n cats, and it takes ci minutes for the ith cat to eat out one fish. A cat starts to eat another fish (if it can get one) immediately after it has finished one fish. A cat never shares its fish with other cats. When there are not enough fish left, the cat which eats quicker has higher priority to get a fish than the cat which eats slower. All cats start eating at the same time. Li Lei wanted to know, after x minutes, how many fish would be left.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>There are no more than 20 test cases.</p><p>For each test case:</p><p>The first line contains 3 integers: above mentioned m, n and x (0 &lt; m &lt;= 5000, 1 &lt;= n &lt;= 100, 0 &lt;= x &lt;= 1000).</p><p>The second line contains n integers c1,c2 … cn,  ci means that it takes the ith cat ci minutes to eat out a fish ( 1&lt;= ci &lt;= 2000).</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, print 2 integers p and q, meaning that there are p complete fish(whole fish) and q incomplete fish left after x minutes.</p><p>样例输入</p><p>2 1 1</p><p>1</p><p>8 3 5</p><p>1 3 4</p><p>4 5 1</p><p>5 4 3 2 1</p><p>样例输出</p><p>1 0</p><p>0 1</p><p>0 3</p><p>​    翻译成汉语就是给m条鱼，n只猫，每只猫吃鱼的速度为c[i]。问x秒后有多少条鱼没被吃，多少条鱼没吃完？（同一秒吃的快的猫先拿鱼吃）</p><p>思路：</p><p>​    用两个数m代表剩余鱼数，mm代表n-完全吃光的鱼数，两数都初始化为n。先把猫吃鱼的速度排个序，开一个book数组记录一下每个猫的状态（0时代表需要拿一个鱼，1时代表正在吃鱼），我们初始化为0。然后遍历x秒，每秒从快-&gt;慢的猫进行遍历。若状态为0则m–，并把状态更改为1。若时间正好时该鱼速度的倍数，那么mm–，然后把状态更新为0。最后注意当m为0的时候跳出，再注意一下特判就可以啦。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d a[105];</span><br><span class="line">d book[105];</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d m, n, x;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;x) == 3) &#123;</span><br><span class="line">        d mm = m;</span><br><span class="line">        mem(book);</span><br><span class="line">        For(i, 1, n) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + 1, a + n + 1);</span><br><span class="line">        For(i, 1, x) &#123;</span><br><span class="line">            d flag = 0;</span><br><span class="line">            For(j, 1, n) &#123;</span><br><span class="line">                if (!book[j]) &#123;</span><br><span class="line">                    book[j] = 1;</span><br><span class="line">                    m--;</span><br><span class="line">                    if(m == 0) &#123;</span><br><span class="line">                        if(i % a[j] == 0) &#123;//需要特判m为0的时候是否i%a[j] == 0</span><br><span class="line">                            mm --;</span><br><span class="line">                            book[j] = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i % a[j] == 0) &#123;</span><br><span class="line">                    mm --;</span><br><span class="line">                    book[j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;, m, mm - m);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6237思维</title>
      <link href="/2018/10/17/HDU6237/"/>
      <url>/2018/10/17/HDU6237/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/17/HDU6237/title1.jpg" alt="title1"></p><a id="more"></a><p>​    这是2017年ccpc哈尔滨站的一道数论题，很荣幸在我们学校举办，题目另辟蹊径，很好的一道素数题。</p><p>题意：</p><p>Problem Description</p><p>After he has learned how to play Nim game, Bob begins to try another stone game which seems much easier.</p><p>The game goes like this: one player starts the game with N piles of stones. There is ai stones on the ith pile. On one turn, the player can move exactly one stone from one pile to another pile. After one turn, if there exits a number x(x&gt;1) such that for each pile bi is the multiple of x where bi is the number of stone of the this pile now), the game will stop. Now you need to help Bob to calculate the minimum turns he need to stop this boring game. You can regard that 0 is the multiple of any positive number.</p><p>Input</p><p>The first line is the number of test cases. For each test case, the first line contains one positive number N(1≤N≤100000), indicating the number of piles of stones.</p><p>The second line contains N positive number, the ith number ai(1≤ai≤100000) indicating the number of stones of the ith pile.</p><p>The sum of N of all test cases is not exceed 5∗105.</p><p>Output</p><p>For each test case, output a integer donating the answer as described above. If there exist a satisfied number x initially, you just need to output 0. It’s guaranteed that there exists at least one solution. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2</span><br><span class="line">5 7</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    翻译成汉语，大概意思就是给你一个T代表有T组样例，然后每组样例第一行给出一个n代表有n堆石子，然后分别输入每堆石子的石子数。只能从一堆石子中取一个石子移动到另一堆，问至少移动几次能使得每一堆的石子数的公共gcd &gt; 1（若此时已经gcd&gt;1了就输出0，一堆石子允许全部移光）</p><p>​    </p><p>思路：</p><p>​    我们求出所有堆石子的总和sum，然后筛选出它的全部素因子。也就是说，要想让每堆石子的公共gcd大于1，至少其中一个素因子是全部石子堆的因子。因此我们需要遍历每个素因子，分别求出每堆石子数变成该素因子的倍数所需的最小步数，取个最小值就是答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d T, n;</span><br><span class="line">d a[N + 5];</span><br><span class="line">d b[N + 5];</span><br><span class="line">ll prime[105];</span><br><span class="line">bool book[N + 5];</span><br><span class="line">ll prime1[N + 5];</span><br><span class="line"></span><br><span class="line">//筛1e5以内素数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    prime1[0] = 0;</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime1[++prime1[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime1[0]) &#123;</span><br><span class="line">            ll t = prime1[j] * i;</span><br><span class="line">            if (t &gt; N) break;</span><br><span class="line">            book[t] = 1;</span><br><span class="line">            if (i % prime1[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//筛选出t的全部素因子</span><br><span class="line">void su(ll t) &#123;</span><br><span class="line">    prime[0] = 0;</span><br><span class="line">    for (d i = 1; i &lt;= prime1[0]; i ++) &#123;</span><br><span class="line">        if (t % prime1[i] == 0) &#123;</span><br><span class="line">            prime[++prime[0]] = prime1[i];</span><br><span class="line">            while (t % prime1[i] == 0) &#123;</span><br><span class="line">                t /= prime1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (t == 1) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (t != 1) &#123;</span><br><span class="line">        prime[++prime[0]] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从大到小排列</span><br><span class="line">bool cmp (d A, d B) &#123;</span><br><span class="line">    r A &gt; B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求每堆素因子为t的倍数时的最小移动次数</span><br><span class="line">ll Num(ll t) &#123;</span><br><span class="line">    ll sum = 0, ans = 0;</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        b[i] = a[i] % t;</span><br><span class="line">        sum += b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + 1, b + n + 1, cmp);</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        if (b[i] == 0) break;</span><br><span class="line">        ans += t - b[i];</span><br><span class="line">        sum -= t;</span><br><span class="line">        if (sum == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历全部素因子，取最小次数</span><br><span class="line">ll work() &#123;</span><br><span class="line">    ll minn = 99999999999;</span><br><span class="line">    For(i, 1, prime[0]) &#123;</span><br><span class="line">        minn = min(minn, Num(prime[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    r minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        ll sum = 0;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        For(i, 1, n) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        su(sum);</span><br><span class="line">        ll ans = work();</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces-1047C思维</title>
      <link href="/2018/10/16/CodeForces-1047C/"/>
      <url>/2018/10/16/CodeForces-1047C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/16/CodeForces-1047C/title5.jpg" alt="title5"></p><a id="more"></a><p>题意：</p><p>​    Mr. F has nn positive integers, a1,a2,…,an.</p><p>​    He thinks the greatest common divisor of these integers is too small. So he wants to enlarge it by removing some of the integers.</p><p>​    But this problem is too simple for him, so he does not want to do it by himself. If you help him, he will give you some scores in reward.</p><p>​    Your task is to calculate the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.</p><p>Input:</p><p>​    The first line contains an integer nn (2≤n≤3⋅10^5) — the number of integers Mr. F has.</p><p>​    The second line contains nn integers, a1,a2,…,an (1≤ai≤1.5⋅10^7).</p><p>Output:</p><p>​    Print an integer — the minimum number of integers you need to remove so that the greatest common divisor of the remaining integers is bigger than that of all integers.</p><p>​    You should not remove all of the integers.</p><p>​    If there is no solution, print «-1» (without quotes).</p><p>Examples</p><p>Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 4</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6 9 15 30</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>Note</p><p>In the first example, the greatest common divisor is 1 in the beginning. You can remove 1 so that the greatest common divisor is enlarged to 2. The answer is 1.</p><p>In the second example, the greatest common divisor is 3 in the beginning. You can remove 6 and 9 so that the greatest common divisor is enlarged to 15. There is no solution which removes only one integer. So the answer is 2.</p><p>In the third example, there is no solution to enlarge the greatest common divisor. So the answer is −1.</p><p>​    翻译成汉语就是给你n个数，你会得到这n个数的公共gcd，问最少删除几个数，使得删除后的公共gcd比原来的大，如果有输出最少删除数，没有输出-1</p><p>思路：</p><p>​    我们知道，一个数val可以写成p1^a1 ✖️p2^a2✖️ …✖️pn^an的形式，若每个数中都存在pk1，pk2，且pk1在每个数中最少存在t1次，pk2在每个数中最少存在t2次，那么这n个数的公共gcd为pk1^t1✖️pk2^t2</p><p>​    因此，我们想要提高公共gcd的大小，有以下两种办法：</p><p>​    1.对于每个数都存在的素因子，我们去除它最小的幂次方数，如2, 4, 12，它们中都存在素因子2，2中存在1个素因子2，4中存在2个素因子2，12中存在2个素因子2，因此我们只要去掉最小的幂次方的次数，也就是1个素因子2的2，就可以使得gcd变大</p><p>​    2.对于不是每个数都存在的素因子，我们只要去掉存在改素因子的数，就可以使得gcd变大</p><p>​    对于以上两种情况，我们记录一个最小值即可，若最后需要去除n个或者没办法去除，那么就输出-1</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define N 15000000</span><br><span class="line">#define NN 1000000</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d book[N + 5];      //book[i]存i的最小素因子在prime中的下角标</span><br><span class="line">d prime[NN + 5];    //存全部素数</span><br><span class="line">d num[NN + 5];      //存该素数在几个数中出现(若个数等于n取答案与numminx[i]的最小值 小于n取答案与n-num[i]的最小值）</span><br><span class="line">d minx[NN + 5];     //该素数在n个数中若出现，存在其中一个数中出现的次数的最小值</span><br><span class="line">d numminx[NN + 5];  //该素数在n个数中若出现且是最小值的个数</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(num);</span><br><span class="line">    memset(minx, 0x3f3f3f3f, sizeof(minx));</span><br><span class="line">    mem(numminx);</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            book[i] = prime[0];</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime[0]) &#123;</span><br><span class="line">            if (prime[j] * i &gt; N) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            book[i * prime[j]] = j;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work(d a) &#123;</span><br><span class="line">    while(a != 1) &#123;</span><br><span class="line">        d aa = a;</span><br><span class="line">        d t = prime[book[a]], inx = 0;</span><br><span class="line">        num[book[a]]++;</span><br><span class="line">        while (a % t == 0) &#123;</span><br><span class="line">            inx ++;</span><br><span class="line">            a /= t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (inx &lt; minx[book[aa]]) &#123;</span><br><span class="line">            minx[book[aa]] = inx;</span><br><span class="line">            numminx[book[aa]] = 1;</span><br><span class="line">        &#125; else if (inx == minx[book[aa]]) &#123;</span><br><span class="line">            numminx[book[aa]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    d n, a;</span><br><span class="line">    d minn = 0x3f3f3f3f;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    For(i, 1, n) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        work(a);</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 1, prime[0]) &#123;</span><br><span class="line">        if(!num[i]) continue;</span><br><span class="line">        if (num[i] == n) &#123;</span><br><span class="line">            minn = min(numminx[i], minn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = min(n - num[i], minn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (minn == 0x3f3f3f3f || minn == 0 || minn == n) printf(&quot;-1\n&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;, minn);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-048快速乘</title>
      <link href="/2018/10/16/Project-Euler-048/"/>
      <url>/2018/10/16/Project-Euler-048/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/16/Project-Euler-048/title.jpg" alt="title"></p><a id="more"></a><h3 id="048题："><a href="#048题：" class="headerlink" title="048题："></a>048题：</h3><p>题意：</p><p>​    十项的自幂级数求和为 1^1 + 2^2 + 3^3 + … + 10^10 = 10405071317。</p><p>​    求如下一千项的自幂级数求和的最后10位数字：1^1 + 2^2 + 3^3 + … + 1000^1000</p><p>思路：</p><p>​    设mod为1e10，根据同余定理，我们可以利用快速幂求i^i关于mod的模。但是有一个问题，就是快速幂中存在两数先相乘再取余mod的过程，可能两数在相乘时就爆long long了。因此，我们可以通过一个小技巧来防治爆long long。</p><p>​    对于a * b % mod，我们设k为1e5，那么一定存在a = ik + j，b = pk + q （其中i = a / k，j = a % k，p = b / k，q = b % k）</p><p>​    把a和b带入原式，得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a * b % mod = (ik + j) * (pk + q) % mod</span><br><span class="line">= (ipk^2 + iqk + jpk + jq) % mod</span><br></pre></td></tr></table></figure><p>​    由于ipk^2,iqk,jpk,jq都在longlong范围内，因此解决了爆longlong问题</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define t (ll)1e5</span><br><span class="line">#define mod (ll)1e10</span><br><span class="line">#define For(i, star, endd) for(d i = star; i &lt;= endd; i++)</span><br><span class="line"></span><br><span class="line">//乘法防爆longlong</span><br><span class="line">ll mul (ll a, ll b) &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    ll i = a / t;</span><br><span class="line">    ll j = a % t;</span><br><span class="line">    ll p = b / t;</span><br><span class="line">    ll q = b % t;</span><br><span class="line">    ans = (i * p % mod * t % mod *t % mod + i * q % mod * t % mod + j * p % mod * t % mod + j * q % mod) % mod;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速幂</span><br><span class="line">ll quick(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) ans = mul(ans, a);</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//循环球i^i</span><br><span class="line">ll work() &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    For(i, 1, 1000) &#123;</span><br><span class="line">        ans = (ans + quick(i, i)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main()</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = work();</span><br><span class="line">    printf(&quot;%&quot; PRId64 &quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：<strong>9110846700</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6228求边的左右节点数</title>
      <link href="/2018/10/15/HDU6228/"/>
      <url>/2018/10/15/HDU6228/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/15/HDU6228/title.jpg" alt="title"></p><a id="more"></a><p>题意：</p><p>Problem Description</p><p>Consider a un-rooted tree T which is not the biological significance of tree or plant, but a tree as an undirected graph in graph theory with n nodes, labelled from 1 to n. If you cannot understand the concept of a tree here, please omit this problem.<br>Now we decide to colour its nodes with k distinct colours, labelled from 1 to k. Then for each colour i = 1, 2, · · · , k, define Ei as the minimum subset of edges connecting all nodes coloured by i. If there is no node of the tree coloured by a specified colour i, Ei will be empty.<br>Try to decide a colour scheme to maximize the size of E1 ∩ E2 · · · ∩ Ek, and output its size.</p><p>Input</p><p>The first line of input contains an integer T (1 ≤ T ≤ 1000), indicating the total number of test cases.<br>For each case, the first line contains two positive integers n which is the size of the tree and k (k ≤ 500) which is the number of colours. Each of the following n - 1 lines contains two integers x and y describing an edge between them. We are sure that the given graph is a tree.<br>The summation of n in input is smaller than or equal to 200000.</p><p>Output</p><p>For each test case, output the maximum size of E1 ∩ E1 … ∩ Ek.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">6 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">6 2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    翻译成汉语大概意思就是有一颗树，在树上的点涂色，每个点涂一种颜色，一共可以涂k种颜色，然后你需要把每种颜色的点按最短路径用该种颜色连起来，问涂k次的边最多有几条？</p><p>​    第一行输入的是T代表有T组样例，每组样例第一行为n，k，分别代表树上有n个节点，可用k种颜色给节点涂色。之后n-1行a,b代表节点a到节点b之间有一条边</p><p>思路：</p><p>​    我们可以把树转化为图，对于每个边进行dfs（利用记忆化搜索），分别求出该边左边和右边的节点数，只要都大于等于k就可以累加，累加和就是答案。时间复杂度，大概也就O(n)吧，因为记忆化搜索dfs多也多不多少。。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    d left, right;</span><br><span class="line">&#125;bian[200005];</span><br><span class="line">d num[200005][2];         //num[i][0]存储第i个边左边的节点数，num[i][1]存储第i个边右边的节点数</span><br><span class="line">vector&lt;int&gt;zcy[200005];     //zcy[i]存储以i点为端点的边的编号,zcy[i].size()即为边的个数</span><br><span class="line"></span><br><span class="line">//利用dfs+记忆化搜索求编号为now的边的chooes（0为左，1为右）的节点数</span><br><span class="line">int dfs(int now, int chooes) &#123;</span><br><span class="line">    if(num[now][chooes]) return num[now][chooes];       //记忆化搜索</span><br><span class="line">    int ans = 1, t;</span><br><span class="line">    if (chooes == 0) &#123;</span><br><span class="line">        t = bian[now].left;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t = bian[now].right;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; zcy[t].size(); i++) &#123;</span><br><span class="line">        int next = zcy[t][i];</span><br><span class="line">        if (bian[next].left == bian[now].left &amp;&amp; bian[next].right == bian[now].right) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bian[next].left == t) &#123;</span><br><span class="line">            if (num[next][1]) &#123;          //记忆化搜索</span><br><span class="line">                ans += num[next][1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans += dfs(next, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (num[next][0]) &#123;          //记忆化搜索</span><br><span class="line">                ans += num[next][0];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans += dfs(next, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num[now][chooes] = ans;              //记录中间状态</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, k;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">        memset(num, 0, sizeof(num));</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;bian[i].left, &amp;bian[i].right);</span><br><span class="line">            zcy[bian[i].left].push_back(i);</span><br><span class="line">            zcy[bian[i].right].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(i, 0);    //每个边两个dfs，分别求左边和右边（由于有记忆化搜索，所以可以不用右边=节点数-左边）</span><br><span class="line">            dfs(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (num[i][0] &gt;= k &amp;&amp; num[i][1] &gt;= k) ans++;        //此时满足条件</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-021线性求约数和</title>
      <link href="/2018/10/15/Project-Euler-021/"/>
      <url>/2018/10/15/Project-Euler-021/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/15/Project-Euler-021/title3.jpg" alt="title3"></p><a id="more"></a><h3 id="021题："><a href="#021题：" class="headerlink" title="021题："></a>021题：</h3><p>题意：</p><p>​    记d(n)为n的所有真因数（小于n且整除n的正整数）之和<br>​    如果d(a) = b且d(b) = a，且a ≠ b，那么a和b构成一个亲和数对，a和b被称为亲和数</p><p>​    例如，220的真因数包括1、2、4、5、10、11、20、22、44、55和100，因此d(220) = 284；而284的真因数包括1、2、4、71和142，因此d(284) = 220</p><p>​    求所有小于10000的亲和数的和</p><p>思路：</p><p>​    在数论中我们称d(n)这样的函数为约数和函数。具体有以下几个性质：</p><p>​    1.约数和函数为积性函数，因此满足任意两个互质的数a，b，都有d(a✖️b) = d(a) ✖️d(b)</p><p>​    2.若b = a ✖️ a中的最小素因子p1 ，也就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = p1^a1 * p2^a2 * ... * pn^an</span><br><span class="line">b = p1 * p1^a1 * p2^a2 * ... * pn^an</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(b) = d(a) * (1 - p1^(a1 + 2)) / (1 - p1^(a1 + 1))</span><br></pre></td></tr></table></figure><p>​    </p><p>​    3.对于素数来说，它的约数只有1和它本身，所以：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(n) = n + 1;    //当n为素数</span><br></pre></td></tr></table></figure><p>​    </p><p>​    4.对于求解一般的约数和函数，我们有一个约数和定理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(n)=(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak)</span><br><span class="line">//n = p1^a1 * p2^a2 *...* pk^ak且p都为素数</span><br></pre></td></tr></table></figure><p>​    通过等比数列求和公式化简一下，为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d(n)=Π (1 - pi^(ai + 1)) / (1 - pi)</span><br><span class="line">//pi为它的素因子，ai为该种素因子的个数</span><br></pre></td></tr></table></figure><p>​    我们就可以根据n的素因子种类pi和每种的个数ai来求约数和了。关于pi和ai我们可以利用之前的线性筛求因子个数框架来求取 抛个链接：<a href="http://www.ivan-zcy.top/2018/10/12/Project-Euler-012/">走你</a> </p><p>​    </p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define N (d)1e4</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)</span><br><span class="line">#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)</span><br><span class="line">#define printfl(a) printf(&quot;%lld\n&quot;, a)</span><br><span class="line">#define printfd(a) printf(&quot;%d\n&quot;, a)</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line"></span><br><span class="line">ll prime[N + 5];     //存全部的素数</span><br><span class="line">ll dd[N + 5];        //用来存约数和</span><br><span class="line">ll book[N + 5];     //book[i]用来存储i的最小素因子幂次方值，如book[24] = 8</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(dd);</span><br><span class="line">    mem(book);</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        if(!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            dd[i] = i + 1;              //素数的约数只有1和它本身</span><br><span class="line">            book[i] = i;                //素数的最小素因子幂次方值等于它本身</span><br><span class="line">        &#125;</span><br><span class="line">        For(j, 1, prime[0]) &#123;</span><br><span class="line">            ll t = prime[j] * i;</span><br><span class="line">            if (t &gt; N) break;</span><br><span class="line">            if (i % prime[j] == 0) &#123;        //当为性质2的时候</span><br><span class="line">                book[t] = book[i] * prime[j];</span><br><span class="line">                dd[t] = dd[i] * (book[i] * prime[j] * prime[j] - 1) / (book[i] * prime[j] - 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;                        //当为性质1的时候</span><br><span class="line">                dd[t] = dd[prime[j]] * dd[i];</span><br><span class="line">                book[t] = prime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    For(i, 2, N) &#123;</span><br><span class="line">        dd[i] -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    For(i, 0, N) &#123;</span><br><span class="line">        if (dd[i] != i &amp;&amp; dd[i] &lt;= N &amp;&amp; i == dd[dd[i]]) &#123;</span><br><span class="line">            ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printfl(ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果是：<strong>31626</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6265狄利克雷卷积</title>
      <link href="/2018/10/14/HDU6265%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"/>
      <url>/2018/10/14/HDU6265%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/14/HDU6265狄利克雷卷积/title4.jpg" alt="title4"></p><a id="more"></a><p>下面就做一道欧拉函数|积性函数|狄利克雷卷积的题吧，相关原理在上一篇博文：<a href="http://www.ivan-zcy.top/2018/10/14/积性函数与狄利克雷卷积/">点我跳转</a> </p><p>题意：</p><p><img src="/2018/10/14/HDU6265狄利克雷卷积/1.png" alt="1"></p><p>​    翻译成汉语，大概意思就是首先输入一个数T代表有T组样例，每组样例第一行m代表有m对&lt;p,q&gt;（其中p为素数，每对中的p各不相同），计算得到全部pi^qi的乘积n，最后求一下∑d|n φ(d) × n / d的值取模998244353</p><p>思路：</p><p>​    由于p和q数据范围是1e8，我们没办法求出全部p^q的乘积n（爆long long），只能想办法化简公式和通过中间过程来得到答案，又因为给出的∑d|n φ(d) × n / d包含求和，我们遍历辣么大的数的求和铁定超时，所以还应该想办法把公式化简成O(1)的，也就是把求和给去掉</p><p>​    我们接着按照上面的需求想问题：</p><p>​    令函数f(n) = n，令h(n) = ∑d|n φ(d) × n / d，是不是发现了点什么！！！对，h(n）是φ(n)与f(n)的狄利克雷卷积。由于φ(n)是欧拉函数，所以它是积性函数，f(n) = n是单位函数，所以它是完全积性函数，那么h(n)一定也是积性函数，它满足a,b互质，则h(a <em> b) = h(a) </em> h(b)的性质</p><p>​    又因为每对中的p都是不同的素数！！！因此每对pi^qi之间都是互质的，所以,我们就可以解决爆long long 问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h(n) = h(p1^q1 * p2^q2 * ... * pm^qm) = ∏ h(pi ^ qi)  //i为从1～m</span><br></pre></td></tr></table></figure><p>​    这样我们从求h(n)变成了求m个h(pi^qi)的乘积了</p><p>​    此时pi^qi也会爆long long，我们先别管继续往下走</p><p>​    这时候∑d|n φ(d) × n / d就变成了求∑d|p^q φ(d) × p^q / d .我们需要通过化简∑d|p^q φ(d) × p^q / d为O(1)来解决超时问题，怎么化简呢？手写了一份化简过程：</p><p><img src="/2018/10/14/HDU6265狄利克雷卷积/2.jpg" alt="2"></p><p> 我们就可以把h(p^q) = ∑d|p^q φ(d) × p^q / d 化简为h(p^q) = p^q + q <em> p^(q - 1) </em> (p - 1)</p><p>这样我们就可以通过h(n) =  ∏ h(pi ^ qi)来求h(n)了（通过不断的取余998244353来防治爆longlong）</p><p>​    Over～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mod 998244353</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)</span><br><span class="line">#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)</span><br><span class="line">#define printfl(a) printf(&quot;%lld\n&quot;, a)</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line"></span><br><span class="line">//快速幂</span><br><span class="line">ll quick(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) &#123;</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    d T, m;</span><br><span class="line">    ll p, q;</span><br><span class="line">    scanfd(T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        ll ans = 1;</span><br><span class="line">        scanfd(m);</span><br><span class="line">        For (i, 1, m) &#123;</span><br><span class="line">            ll res = 0;</span><br><span class="line">            scanfl(p);</span><br><span class="line">            scanfl(q);</span><br><span class="line">            res = quick(p, q - 1) * q % mod * (p - 1) % mod;</span><br><span class="line">            res = (res + quick(p, q)) % mod;</span><br><span class="line">            ans = ans * res % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        printfl(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(数论一)积性函数与狄利克雷卷积</title>
      <link href="/2018/10/14/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"/>
      <url>/2018/10/14/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/14/积性函数与狄利克雷卷积/title1.jpg" alt="title1"></p><a id="more"></a><p>​    今天做的一道题就是有关积性函数与狄利克雷卷积的，很懵逼。觉得有必要学一手了</p><h4 id="一-积性函数是什么呢？"><a href="#一-积性函数是什么呢？" class="headerlink" title="一.  积性函数是什么呢？"></a>一.  积性函数是什么呢？</h4><p>​    对于函数f，对于任意的a,b互质，都有:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(a * b) = f(a) * f(b)</span><br></pre></td></tr></table></figure><p>​    这样的函数f就称为积性函数，若a,b不互质也满足上述条件的话，那么函数f又可称为完全积性函数</p><p>​    </p><p>它又有什么性质呢？</p><p>1.若n = p1^q1✖️p2^q2✖️ …✖️pn^qn，那么对于积性函数f，有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) = f(p1^q1) * f(p2^q2) * ... * f(pn^qn)</span><br></pre></td></tr></table></figure><p>2.若积性函数f满足f(p^n) = f^n(p)，那么f也是完全积性函数</p><h4 id="二-那么，狄利克雷卷积是什么呢？"><a href="#二-那么，狄利克雷卷积是什么呢？" class="headerlink" title="二.  那么，狄利克雷卷积是什么呢？"></a>二.  那么，狄利克雷卷积是什么呢？</h4><p>​    对于任意函数f,g，令h = f * g,都有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h(n) = ∑d|n f(d)⋅g(n / d)  //d为能被n整除的数</span><br></pre></td></tr></table></figure><p>​    此时这个h就可以称为f和g的狄利克雷卷积</p><p>它有什么性质呢？</p><p>​    1.狄利克雷卷积满足交换律，结合律，加法分配律：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f * g = g * f</span><br><span class="line">f * g * h = f * (g * h)</span><br><span class="line">f * (g + h) = f * g + f *h</span><br></pre></td></tr></table></figure><p>​    2.积性函数卷个积性函数的狄利克雷卷积仍旧是积性函数</p><p>​    </p><h3 id="三-常见的积性函数和狄利克雷卷积有哪些？"><a href="#三-常见的积性函数和狄利克雷卷积有哪些？" class="headerlink" title="三.  常见的积性函数和狄利克雷卷积有哪些？"></a>三.  常见的积性函数和狄利克雷卷积有哪些？</h3><p>我们先说一下常见的积性函数：</p><p>  1.id^k(n) = n^k：幂函数，属于完全积性函数</p><p>  2.I(n) = 1:  恒等函数，属于完全积性函数，相当于id^0(n)</p><p>  3.id(n) = n： 单位函数，属于完全积性函数，相当于id^1(n)</p><p>  4.e(n) = [n = 1]：代表单位元函数，它卷上任意的函数都得原函数，即：    </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e * f = f</span><br></pre></td></tr></table></figure><p>  5.φ(n)：欧拉函数，表示小于等于 n 且与 n 互质的数的个数</p><p>  6.μ(n)：莫比乌斯函数，在狄利克雷卷积中与恒等函数互为逆元：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">μ * I = e</span><br></pre></td></tr></table></figure><p>​    关于莫比乌斯函数公式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">μ(n) = 1;//当n为1时</span><br><span class="line">μ(n) = (-1)^k//当n由k个不同质数相乘得到时</span><br><span class="line">μ(n) = 0;//其余情况</span><br></pre></td></tr></table></figure><p>  7.σ(n)：约数和函数，表示n的全部约数和</p><p>  8.τ(n)：约数个数函数，表示n的全部约数个数</p><p>  9.σk(n)=∑d|n d^k ：因数函数，表示n全部约数的k次方和</p><p>再来说一下常用的狄利克雷卷积：</p><ol><li>I ∗ μ = e （即莫比乌斯函数与恒等函数互为逆元）</li><li>μ∗id = φ  (即莫比乌斯函数卷上单位函数为欧拉函数)</li><li>I ∗ id = σ（即恒等函数卷个单位函数为约数和函数）</li><li>I ∗ I = τ  （即恒等函数卷个恒等函数为约数个数函数）</li><li>I * φ = id (即恒等函数卷个欧拉函数为单位函数)</li></ol><p>可以由狄利克雷卷积证明很多结论，比如：</p><p>1.n = ∑d|n  φ(d) ，也就是n等于全部 φ(d)的和（φ(d)为d的欧拉函数）</p><p>2.σ(n) = ∑d|n  τ(d) ∗ φ(n / d)，也就是欧拉函数卷个约数个数函数为约数和函数</p><p>3.二项式反演：<img src="/2018/10/14/积性函数与狄利克雷卷积/1.png" alt="1"></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6267推规律+线性阶乘逆元</title>
      <link href="/2018/10/14/HDU6267/"/>
      <url>/2018/10/14/HDU6267/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/14/HDU6267/title.jpg" alt="title"></p><a id="more"></a><p>去年杭州站没做上来的一道数学题，今天补了～</p><p>题意：</p><p>​    Hakase provides Nano with a problem. There is a rooted tree with values on nodes. For each query, you are asked to calculate the sum of the values in the subtree. However, Nano is a rookie so she decides to guess the answer. She has known how the data generator works: it identifies the nodes with labels from 0 to n − 1 and then visits them one by one. For each i (1 ≤ i ≤ n), the generator selects a node whose label is smaller than i to be its father. The pseudocode is like this: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i = 1 to n - 1:</span><br><span class="line">    father[i] = random(0, i - 1);</span><br></pre></td></tr></table></figure><p>​    where random(a, b) randomly generates a uniformly distributed random integer in range [a, b]. </p><p>​    Knowing n and the value of the i-th node ai, Nano decides to randomly choose a subtree and sum up all of the values in the subtree as the answer. Now Hakase wants to know what the expectation of the answer is. Can you help her? </p><p>Input </p><p>​    The first line contains an integer T (1 ≤ T ≤ 10) representing the number of test cases.<br> For each test case, the first line contains an integer n (1 ≤ n ≤ 100000), the number of the nodes in the rooted tree.<br>​    The second line contains n integers a0, a1, …, an−1 (1 ≤ ai ≤ 100000) represent the values of nodes. </p><p>Output </p><p>​    It can be proven that the answer equals to an irreducible fraction p/q. For each test case, print p ∗ q−1 mod 998244353 in one line. q−1 is the inverse of q under module number 998244353. </p><p>Example </p><p><img src="/2018/10/14/HDU6267/1.png" alt="1"></p><p>Explanation </p><p>​    The shape of the tree in the first test case is unique. The father of node 1 is 0. It is possible to choose node 0 or 1 with equal possibility. The sum of the subtree with 0 as the root is 2 while the sum of the subtree with 1 as the root is 1. So the expectation is (2 + 1)/2 = 3/2. The output is 3 ∗ 2−1 mod 998244353 = 499122178. </p><p>​    There are two possible shapes in the second test case, node 1’s father destines to be 0, but node 2’s father might be node 0 or node 1. Both conditions are equally possible. </p><p>​    If node 2’s father is node 0, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 2. The sum of the subtree with node 2 as the root is 3. </p><p>​    If node 2’s father is node 1, we randomly choose a node. The sum of the subtree with node 0 as the root is 6. The sum of the subtree with node 1 as the root is 5. The sum of the subtree with node 2 as the root is 3. </p><p>​    So the expectation is (6+2+3+6+5+3)/6 = 25/6. The output is 25∗6−1 mod 998244353 = 166374063. </p><p>​    这么一大串英文，翻译成汉语大概也就是说让你输入一个T，代表有T组样例。每组样例第一行输入一个n，代表一个树有n个节点，然后循环输入每个节点的权值。它组成树的方式是：k号节点等概率的选择0～k-1中任意一个节点当它的父节点。然后随意选一个节点，问以它为根节点组成的子树的权值和的数学期望是多少？</p><p>思路：</p><p>​    n个节点，每个节点等概率的选择0～k-1中任意一个节点当它的父节点。那么这n个节点组成树的可能性为（n - 1）!个。例如4个节点可能组成以下6种树：</p><p><img src="/2018/10/14/HDU6267/2.png" alt="2"></p><p>​    又因为任选一个节点当根节点，所以共有n * （n - 1），也就是n!种子树</p><p>​    因此我们可以通过求（每个节点在全部子树的贡献和）/ n！来求数学期望值。</p><p>​    我们可以看到，0号节点在全部子树的贡献是6次（每种树只有选取0号节点当根节点才包含0号节点），也就是3!</p><p>​     1号节点在全部子树的贡献是12次（每种树只有选取0号节点或者1号节点才包含1号节点），也就是3! + 3! / 1</p><p>​     2号节点在全部子树的贡献是15次（有3种树选0，1，2号节点当根节点包含2号节点，有3种树选0，2号节点当根节点才包含2号节点）,也就是3! + 3! / 1 + 3! / 2</p><p>​     3号节点在全部子树的贡献是17次（有1种树选0，1，2，3号节点当根节点包含3号节点，有2种树选0，1，3号节点当根节点包含3号节点，有1种树选0，2，3号节点当根节点包含3号节点，有2种树选0，3号节点当根节点包含3号节点),也就是3! + 3! / 1 + 3! / 2 + 3! / 3</p><p>​    我们发现第k号节点的贡献为：(n - 1)! + (n - 1) ! / 1 + …. + (n - 1) / k</p><p>​    所以我们设i号节点的贡献为pi，权值为qi，那么每个节点在全部子树的贡献和为∑pi*qi （i从0到n-1），再除以n！即为数学期望。因为需要取余998244353且包含除法，因此需要用到求逆元。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define N 100000</span><br><span class="line">#define mod 998244353</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define scanfd(a) scanf(&quot;%d&quot;, &amp;a)</span><br><span class="line">#define scanfl(a) scanf(&quot;%lld&quot;, &amp;a)</span><br><span class="line">#define printfl(a) printf(&quot;%lld\n&quot;, a)</span><br><span class="line">#define For(i, star, endd) for (d i = star; i &lt;= endd; i++)</span><br><span class="line">#define Forr(i, endd, star) for (d i = endd; i &gt;= star; i--)</span><br><span class="line"></span><br><span class="line">ll q[N + 5];        //存储每个节点的权值</span><br><span class="line">ll fact[N + 5];       //存储阶乘</span><br><span class="line">ll inv[N + 5];      //存储阶乘的逆元</span><br><span class="line">ll inv1[N + 5];     //存储线性逆元</span><br><span class="line">ll num[N + 5];      //存储节点的贡献值</span><br><span class="line"></span><br><span class="line">//扩展欧几里得算法</span><br><span class="line">ll extend_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123;</span><br><span class="line">    if (a == 0 &amp;&amp; b == 0) r -1;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        r a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t = extend_gcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    r t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求a关于mod的逆元</span><br><span class="line">ll mod_reverse (ll a) &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll t = extend_gcd(a, mod, x, y);</span><br><span class="line">    if (t == 1) r (x % mod + mod) % mod;</span><br><span class="line">    r -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//预处理1～100000阶乘及逆元，处理线性逆元</span><br><span class="line">void init() &#123;</span><br><span class="line">    fact[0] = fact[1] = 1;</span><br><span class="line">    inv1[0] = inv1[1] = 1;</span><br><span class="line">    For (i, 2, N) &#123;</span><br><span class="line">        fact[i] = fact[i - 1] * i % mod;</span><br><span class="line">        inv1[i] = (mod - mod / i) * inv1[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N] = mod_reverse(fact[N]);</span><br><span class="line">    Forr (i, N - 1, 0) &#123;</span><br><span class="line">        inv[i] = inv[i + 1] * (i + 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//处理权值和</span><br><span class="line">ll work(d n) &#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    num[0] = fact[n - 1];</span><br><span class="line">    ans = (ans + num[0] * q[0]) % mod;</span><br><span class="line">    For(i, 1, n - 1) &#123;</span><br><span class="line">        num[i] = (num[i - 1] + fact[n - 1] * inv1[i]) % mod;</span><br><span class="line">        ans = (ans + num[i] * q[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    d T, n;</span><br><span class="line">    scanfd(T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        scanfd(n);</span><br><span class="line">        For (i, 0, n - 1) &#123;</span><br><span class="line">            scanfl(q[i]);</span><br><span class="line">            q[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = work(n) * inv[n] % mod;</span><br><span class="line">        printfl(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-019菜勒公式</title>
      <link href="/2018/10/13/Project-Euler-019/"/>
      <url>/2018/10/13/Project-Euler-019/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-019/title.jpg" alt="title"></p><a id="more"></a><h3 id="019题："><a href="#019题：" class="headerlink" title="019题："></a>019题：</h3><p>题意：</p><p>​    在二十世纪（1901年1月1日到2000年12月31日）中，有多少个月的1号是星期天？</p><p>思路：</p><p>​    我们需要遍历从1901到2000年的每一月，判断是否1号为星期天。</p><p>​    一.先用日历看一下1901年一月1号是星期几，然后根据把星期一到星期天定义为0～6，预处理每个月的天数（注意平年和闰年），然后累加取余7，只要判断是否为6即可，是就累加到结果中</p><p>​    </p><p>​    二.利用蔡勒公式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;</span><br><span class="line">//其中w为星期（0～6分别代表星期一到星期天），y，m，d分别代表年月日</span><br></pre></td></tr></table></figure><p>​    该公式有个注意点，就是当月份为1月或2月时，分别把它当作上一年的13月14月计算。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 1000005</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool chooes(d y, d m, d day) &#123;</span><br><span class="line">    if(m == 1 || m == 2) &#123;</span><br><span class="line">        y --;</span><br><span class="line">        m += 12;</span><br><span class="line">    &#125;</span><br><span class="line">    d w = (day + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7;</span><br><span class="line">    if (w == 6) r 1;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d ans = 0;</span><br><span class="line">    for (d i = 1901; i &lt;= 2000; i++) &#123;</span><br><span class="line">        for (d j = 1; j &lt;= 12; j++) &#123;</span><br><span class="line">            if(chooes(i, j, 1)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案是：<strong>171</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-047线性求质因子种类</title>
      <link href="/2018/10/13/Project-Euler-047/"/>
      <url>/2018/10/13/Project-Euler-047/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-047/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="047题："><a href="#047题：" class="headerlink" title="047题："></a>047题：</h3><p>题意：</p><p>首次出现连续两个数均有两个不同的质因数是在：</p><p>​    14 = 2 × 7<br>​    15 = 3 × 5</p><p>首次出现连续三个数均有三个不同的质因数是在：</p><p>​    644 = 22 × 7 × 23<br>​    645 = 3 × 5 × 43<br>​    646 = 2 × 17 × 19</p><p>首次出现连续四个数均有四个不同的质因数时，其中的第一个数是多少？</p><p>思路：</p><p>​    有一下两个思路：</p><p>​    一.先预处理前1e6个素数，然后从1开始往后遍历每个数，如果满足连续四个数的素因子种类都为4，就返回并输出，时间复杂度为O(n*m)，n为预处理的1e6，m为找到的那个数</p><p>​    二.利用线性筛框架，把标记数组改为记录该数有多少种不同素因子的数组。时间复杂度为O(n + m)</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define N 1000005</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d prime[N];//记录1e6范围内的全部素数</span><br><span class="line">d book[N];//book[i]记录数字i由多少种不同素因子相乘得到</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(book);</span><br><span class="line">    for (d i = 2; i &lt; N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            book[i] = 1;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                book[prime[j] * i] = book[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            book[prime[j] * i] = book[i] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (d i = 2; i &lt; N - 4; i++) &#123;</span><br><span class="line">        if(book[i] == 4 &amp;&amp; book[i + 1] == 4 &amp;&amp; book[i + 2] == 4 &amp;&amp; book[i + 3] == 4) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId32&quot;\n&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>134043</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-029思维</title>
      <link href="/2018/10/13/Project-Euler-029/"/>
      <url>/2018/10/13/Project-Euler-029/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-029/title.jpg" alt="title"></p><a id="more"></a><h3 id="029题："><a href="#029题：" class="headerlink" title="029题："></a>029题：</h3><p>题意：</p><p>考虑所有满足2 ≤ a ≤ 5和2 ≤ b ≤ 5的整数组合生成的幂ab：</p><blockquote><p>22=4, 23=8, 24=16, 25=32<br>32=9, 33=27, 34=81, 35=243<br>42=16, 43=64, 44=256, 45=1024<br>52=25, 53=125, 54=625, 55=3125</p></blockquote><p>如果把这些幂按照大小排列并去重，我们得到以下由15个不同的项组成的序列：</p><p>4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125</p><p>在所有满足2 ≤ a ≤ 100和2 ≤ b ≤ 100的整数组合生成的幂ab排列并去重所得到的序列中，有多少个不同的项？</p><p>思路：</p><p>​    我们肯定没有办法计算类似100^100的值，因此我们只能考虑什么情况下a^b的值等于p^q的值</p><p>​    我们可以发现:  2^6  =  4^3  =  8^2，这种情况下我们只需要计算一个即可</p><p>​    我们把4^3化简得到 (2^2)^3 = 2^6,8^2化简得到(2^3)^2=2^6，所以，4，8，16等数都可以看作是2的平方数的形式</p><p>​    因此我们可以创建一个map&lt;inde, bool&gt;zcy[105]的映射数组， 用i遍历2～100，然后若book[i]不存在（即i不是任何数的幂次方)，就对它的所有幂次方进行遍历，设它的inx次方为t，那么它t^j == (i ^ inx) ^j == (i) ^ (inx <em> j)，利用map[i]【j </em> inx】映射判断是否存在过该数。若不存在就累加。时间复杂度大概1e4，完美的解决了爆longlong的问题</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int, bool&gt;zcy[1005];</span><br><span class="line"></span><br><span class="line">ll ans = 0;</span><br><span class="line">bool book[105];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    for (d i = 2; i &lt;= 100; i++) &#123;//遍历a</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            zcy[i].clear();</span><br><span class="line">            d t = i, inx = 1;</span><br><span class="line">            while (t &lt;= 100) &#123;</span><br><span class="line">                book[t] = 1;</span><br><span class="line">                for (d j = 2; j &lt;= 100; j++) &#123;//遍历j</span><br><span class="line">                    if (!zcy[i][j * inx]) &#123;对于t来说，它等于i^inx,因此它就相当于i^(inx * j)</span><br><span class="line">                        ans ++;</span><br><span class="line">                        zcy[i][j * inx] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                inx ++;</span><br><span class="line">                t *= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>9183</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-024思维</title>
      <link href="/2018/10/13/Project-Euler-024/"/>
      <url>/2018/10/13/Project-Euler-024/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-024/title2.jpg" alt="title2"></p><a id="more"></a><h3 id="024题："><a href="#024题：" class="headerlink" title="024题："></a>024题：</h3><p>题意：</p><p>​    排列指的是将一组物体进行有顺序的放置。例如，3124是数字1、2、3、4的一个排列。如果把所有排列按照数字大小或字母先后进行排序，我们称之为字典序排列。0、1、2的字典序排列是：</p><p>​    012   021   102   120   201   210</p><p>​    数字0、1、2、3、4、5、6、7、8、9的字典序排列中第一百万位的排列是什么？</p><p>思路：</p><p>​    设n = 1e6，这个题可以预处理出1～9位数的组合数分别是sum[1~9]；</p><p>​    然后用i遍历从9～1</p><p>​    如果n % sum[i] != 0，那么最高位数字是剩余数字中第n / sum[i] 个数（从0开始）并取出</p><p>​    如果n % sum[i] == 0，那么最高位数字是剩余数字中第n / sum[i] - 1个数（从0开始）并取出，剩余数字由大到小排序，并跳出i循环</p><p>​    这样只需要一次遍历就可以求出第1000000位的排列是多少</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const ll n = 1e6;</span><br><span class="line">ll sum[15];</span><br><span class="line">bool book[15];</span><br><span class="line"></span><br><span class="line">//预处理</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(sum);</span><br><span class="line">    sum[0] = 1;</span><br><span class="line">    for (d i = 1; i &lt;= 9; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - 1] * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求第m个数是多少</span><br><span class="line">void work (ll m) &#123;</span><br><span class="line">    for (d i = 9; i &gt;= 1; i--) &#123;</span><br><span class="line">        ll t = m / sum[i];</span><br><span class="line">        if (m % sum[i] == 0) &#123;//当m%sum[i]==0时</span><br><span class="line">            d num = 0;</span><br><span class="line">            for (d j = 0; j &lt;= 9; j++) &#123;</span><br><span class="line">                if (!book[j]) &#123;</span><br><span class="line">                    if (num == t - 1) &#123;</span><br><span class="line">                        printf(&quot;%&quot; PRId32, j);</span><br><span class="line">                        book[j] = 1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (d j = 9; j &gt;= 0; j--) &#123;</span><br><span class="line">                if(!book[j]) &#123;</span><br><span class="line">                    printf(&quot;%&quot; PRId32, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">            r;</span><br><span class="line">        &#125;</span><br><span class="line">        //当m % sum[i] != 0时</span><br><span class="line">        d num = 0;</span><br><span class="line">        for (d j = 0; j &lt;= 9; j++) &#123;</span><br><span class="line">            if (!book[j]) &#123;</span><br><span class="line">                if (num == t) &#123;</span><br><span class="line">                    printf(&quot;%&quot; PRId32, j);</span><br><span class="line">                    book[j] = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m %= sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //最后别忘已经固定的个位数</span><br><span class="line">    for (d i = 0; i &lt;= 9; i ++) &#123;</span><br><span class="line">        if (!book[i])  &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId32&quot;\n&quot;, i);</span><br><span class="line">            r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    work (n);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>2783915460</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-015组合数</title>
      <link href="/2018/10/13/Project-Euler-015/"/>
      <url>/2018/10/13/Project-Euler-015/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/Project-Euler-015/title.jpg" alt="title"></p><a id="more"></a><h3 id="015题："><a href="#015题：" class="headerlink" title="015题："></a>015题：</h3><p>题意：</p><p>从一个2×2方阵的左上角出发，只允许向右或向下移动，则恰好有6条通往右下角的路径。</p><p><img src="/2018/10/13/Project-Euler-015/p015.gif" alt="p015"></p><p>对于20×20方阵来说，这样的路径有多少条？</p><p>思路：</p><p>​    有两个解题思路：</p><p>​    一.利用DP求解，我们可以设二维数组<code>dp【i】【j】</code>代表到达第i行第j列的方案数，初始化<code>dp【0】【0】= 1</code>利用dp推导式<code>dp【i】【j】=dp【i-1】【j】+dp【i】【j-1】</code>就可求出<code>dp【20】【20】</code>了。这样复杂度式O(n^2)</p><p>​    </p><p>​    二.我们可以利用组合数求解，由于它只能向右或者向下，那么想要到达第i行第j列，就必须往下走i步，往右走j步，有且只能走i+j步。所以我们就可以转化为有i+j个盒子，红球有i个，蓝球有j个，问不同的颜色组成方案。也就是(i + j)! /(i! * j!)的值，时间复杂度为O(n+m) n为行，m为列.一定要注意爆longlong范围的解决方法。</p><p>代码：</p><p>​    还是只写复杂度最低的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define r return</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//用于求(n + m)! / (n)! * (m)!</span><br><span class="line">ll work (ll n, ll m) &#123;</span><br><span class="line">    ll ans1 = 1, t = 20;</span><br><span class="line">    for (ll i = n + m; i &gt; max(n, m); i--) &#123;</span><br><span class="line">        ans1 *= i;</span><br><span class="line">        while (ans1 % t == 0 &amp;&amp; t &gt;= 2) &#123;//解决爆longlong</span><br><span class="line">            ans1 /= t;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r ans1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    ll ans = work (20, 20);</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为：<strong>137846528820</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C与C++区别（转）</title>
      <link href="/2018/10/13/C%E4%B8%8EC-%E5%8C%BA%E5%88%AB-%E8%BD%AC/"/>
      <url>/2018/10/13/C%E4%B8%8EC-%E5%8C%BA%E5%88%AB-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/C与C-区别-转/title.jpg" alt="title"></p><a id="more"></a><p>原文地址：<a href="https://www.itcodemonkey.com/article/9905.html" target="_blank" rel="noopener">点我跳转</a></p><p><img src="/2018/10/13/C与C-区别-转/1.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针详解（转）</title>
      <link href="/2018/10/13/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E2%80%94%E8%BD%AC/"/>
      <url>/2018/10/13/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E2%80%94%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/13/C语言指针详解—转/title3.jpg" alt="title3"></p><a id="more"></a><p>看到讲得特别好，果断转了，原文地址：<a href="https://www.itcodemonkey.com/article/9898.html" target="_blank" rel="noopener">点我跳转</a></p><p><img src="/2018/10/13/C语言指针详解—转/1.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-012积性函数性质</title>
      <link href="/2018/10/12/Project-Euler-012/"/>
      <url>/2018/10/12/Project-Euler-012/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/12/Project-Euler-012/title2.jpg" alt="title2"></p><a id="more"></a><h3 id="012题："><a href="#012题：" class="headerlink" title="012题："></a>012题：</h3><p>题意：</p><p>​    三角形数数列是通过逐个加上自然数来生成的。例如，第7个三角形数是 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28。三角形数数列的前十项分别是：</p><p>​    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>​    让我们列举出前七个三角形数的所有约数：</p><p>​    1: 1<br>     3: 1,3<br>​    6: 1,2,3,6<br>​    10: 1,2,5,10<br>​    15: 1,3,5,15<br>​    21: 1,3,7,21<br>​    28: 1,2,4,7,14,28</p><p>​    我们可以看出，28是第一个拥有超过5个约数的三角形数。</p><p>​    第一个拥有超过500个约数的三角形数是多少？</p><p>思路：</p><p>​    任何一个数都可以写成一个或多个素数的乘积，我们设为n = p1^n1 <em> p2 ^ n2 </em>…..</p><p>​    因此，一个数的因子个数，等同于(n1 + 1) <em> (n2 + 1) </em>….</p><p>​    为什么呢？我们可以想一下，对于素因子p1，我们有n1 + 1种选择，分别是：不选，选一个，选两个…直到选n1个，同理p2有n2+1种选择，所以种类数就是(n1 + 1) <em> (n2 + 1) </em>….</p><p>​    因此，我们只需要计算一个数有多少种素因子，每种素因子的个数，就可以通过算式直接求得一个数的因子数，求法有两种：</p><p>​    ——一种是预处理全部素数，然后每次遍历整除直到该数为1，时间复杂度是O(n)，其中n为满足条件的数 </p><p>​    ——另一种方式是创建记忆化数组数组，存储每个数的最小素因子。再利用：如果a,b互质，那么num(a ✖️ b) = num (a) ✖️ num(b)  ,又因为三角形数都是n / 2 ✖️ (n - 1)或n / 2 ✖️ (n + 1)（n &gt;= 2且n为偶数），所以我们只预处理sqrt（n）项即可（注：num(a)代表数字a的因子数），时间复杂度为O(sqrt(n))</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 40000</span><br><span class="line"></span><br><span class="line">d book[N + 5];      //存储每个数的最小素因子</span><br><span class="line">d prime[N + 5];     //存储2～40000全部素数</span><br><span class="line">d number[N + 5];//存储前40000数的因子数</span><br><span class="line"></span><br><span class="line">//利用线性筛框架初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(prime);</span><br><span class="line">    for (d i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">            book[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt;= N; j++) &#123;</span><br><span class="line">            book[prime[j] * i] = prime[j];</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于求S(n)</span><br><span class="line">ll mul (ll n) &#123;</span><br><span class="line">    r (n + 1) * n / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//求n的因子数</span><br><span class="line">d num(ll n) &#123;</span><br><span class="line">    if (n == 1) r 1;</span><br><span class="line">    d res = 1;</span><br><span class="line">    d t = book[n];</span><br><span class="line">    while(n % t == 0) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        n /= t;</span><br><span class="line">    &#125;</span><br><span class="line">    r res * num(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用当a，b互质，num(a * b) = num(a) * num(b)求a*b的因子数</span><br><span class="line">void work () &#123;</span><br><span class="line">    for (ll i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        number[i] = num(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (ll i = 2; i &lt;= N; i += 2) &#123;</span><br><span class="line">        d p1 = number[i / 2] * number[i - 1];</span><br><span class="line">        d p2 = number[i / 2] * number[i + 1];</span><br><span class="line">        if (p1 &gt; 500) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId64&quot;\n&quot;, i / 2 * (i - 1));</span><br><span class="line">            r;</span><br><span class="line">        &#125; else if(p2 &gt; 500) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId64&quot;\n&quot;, i / 2 * (i + 1));</span><br><span class="line">            r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<strong>76576500</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-009素勾股数</title>
      <link href="/2018/10/12/Project-Euler-009/"/>
      <url>/2018/10/12/Project-Euler-009/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/12/Project-Euler-009/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="009题："><a href="#009题：" class="headerlink" title="009题："></a>009题：</h3><p>题意：</p><p>​    毕达哥拉斯三元组是三个自然数a &lt; b &lt; c组成的集合，并满足</p><p>​    a2 + b2 = c2</p><p>​    例如，32 + 42 = 9 + 16 = 25 = 52。</p><p>​    有且只有一个毕达哥拉斯三元组满足 a + b + c = 1000。求这个三元组的乘积abc</p><p>​    相同类型的还有039题，有时间大家可以做一下！</p><p>思路：</p><p>​    暂时想到了二个：</p><p>​    一.两层嵌套for循环分别从1～1000遍历a和b，只要满足a + b &lt; 1000 &amp;&amp; a^2 + b ^ 2 == （1000 - a - b）^2即可，时间复杂度大概1e6</p><p>​    二.利用素勾股数公式：满足gcd(n, m) == 1的互质数，存在a = 2 <em> n </em> m; b = m^2 - n^2; c = m^2 + n ^2，这是只需要遍历n和m（取值范围都是1～32），只要满足a+b+c == 1000即可，时间复杂度大概是1e3</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//求gcd</span><br><span class="line">d gcd(d a, d b) &#123;</span><br><span class="line">    r b == 0?a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work() &#123;</span><br><span class="line">    for (d i = 1; i &lt;= 32; i++) &#123;</span><br><span class="line">        for (d j = i + 1; j &lt;= 32 &amp;&amp; i * i + j * j &lt; 1000; j++) &#123;</span><br><span class="line">            if (gcd(j, i) == 1) &#123;</span><br><span class="line">                d a = 2 * i * j;</span><br><span class="line">                d b = j * j - i * i;</span><br><span class="line">                d c = j * j + i * i;</span><br><span class="line">                d sum = a + b + c;</span><br><span class="line">                if (1000 % sum == 0) &#123;</span><br><span class="line">                    d t = 1000 / sum;</span><br><span class="line">                    printf(&quot;%&quot; PRId64&quot;\n&quot;, (ll)t * t * t * a * b * c);</span><br><span class="line">                    r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    work();</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    答案是：<strong>31875000</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-045思维</title>
      <link href="/2018/10/12/Project-Euler-045/"/>
      <url>/2018/10/12/Project-Euler-045/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/12/Project-Euler-045/title.jpg" alt="title"></p><a id="more"></a><h3 id="045题："><a href="#045题：" class="headerlink" title="045题："></a>045题：</h3><p>题意：</p><p>​    三角形数、五边形数和六角形数分别由以下公式给出：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>三角形数</td><td>Tn=n(n+1)/2</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>五边形数</td><td>Pn=n(3n−1)/2</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>六边形数</td><td>Hn=n(2n−1)</td><td>1, 6, 15, 28, 45, …</td></tr></tbody></table><p>​    可以验证，T285 = P165 = H143 = 40755。</p><p>​    找出下一个同时是三角形数、五边形数和六角形数的数</p><p>思路：</p><p>​    由于六边形增长速度最快，所以我们优先根据公式遍历六边形数。然后我们看一下三角形数，把n = 2k - 1带入公式，得到Tk = k(2k - 1)，所以，每下角标为2n - 1的三角形数都是六边形数，也就是说是六边形数，一定也是三角形数</p><p>​    因此我们只需要判断六边形数是否为五边形数即可，找到第一个就返回</p><p>​    有以下三个想法判断是否为五边形数：</p><p>​        1.先预处理出前10000个五边形数(应该不会超过这些)，然后利用map<long long,="" bool="">zcy映射一下这些五边形数，然后从144开始遍历六边形数，只要zcy[六边形数]存在就直接输出，时间复杂度O(m + n)，其中m为预处理的五边形数的个数 </long></p><p>​        2.外层for循环从144开始遍历六边形数，然后利用二分五边形数下角标查找是否存在对应的五边形数，若存在则返回并输出，时间复杂度O(n * logn)</p><p>​        3.for循环从144开始遍历六边形数，设得到的数设为t，我们求n(3n−1)/2 = t 的正整数解，也就是n = (1 + sqrt(1 + 24t)) / 6，若n为正整数则该数也为五边形数，时间复杂度O(n)</p><p>代码：</p><p>​    老规矩上时间复杂度最低的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define f double</span><br><span class="line">#define r return</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//六边形公式</span><br><span class="line">ll g(ll a) &#123;</span><br><span class="line">    r a * (2 * a - 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断该六边形数g(a)是否为五边形数</span><br><span class="line">bool chooes(ll a) &#123;</span><br><span class="line">    ll t = g(a);</span><br><span class="line">    f inx = (sqrt(24 * t + 1) + 1 ) / 6;</span><br><span class="line">    if (inx == (ll)inx) return true;</span><br><span class="line">    r false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main () &#123;</span><br><span class="line">    for (ll i = 144; ; i++) &#123;</span><br><span class="line">        if (chooes(i)) &#123;</span><br><span class="line">            printf(&quot;%&quot; PRId64&quot;\n&quot;, g(i));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案为：<strong>1533776805</strong></p><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-044剪枝</title>
      <link href="/2018/10/11/Project-Euler-044/"/>
      <url>/2018/10/11/Project-Euler-044/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/11/Project-Euler-044/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="044题："><a href="#044题：" class="headerlink" title="044题："></a>044题：</h3><p>题意：</p><p>​    五边形数由公式Pn=n(3n−1)/2生成。前十个五边形数是：</p><p>​    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …</p><p>​    可以看出P4 + P7 = 22 + 70 = 92 = P8。然而，它们的差70 − 22 = 48并不是五边形数。</p><p>​    在所有和差均为五边形数的五边形数对Pj和Pk中，找出使D = |Pk − Pj|最小的一对；此时D的值是多少？</p><p>思路：</p><p>​    我们假设a[j] - a[i] = a[t]; a[j] + a[i] = a[k];</p><p>​    想了很久，只能想到极度剪枝的O(n^2)做法，大概三四秒出的答案。</p><p>​    我们可以先预处理出前3000个数，然后用map映射一下。然后从小到大遍历a[t]，内层嵌套遍历a[i],只要有一个满足“a[i] + a[t]存在且2 * a[i] + a[t]存在”，就直接返回a[t]。因为以后再出现的就一定大于等于当前a[t]，可以减少时间浪费。</p><p>​    然后我们进一步剪枝，对于内层for循环遍历a[i]，当i &gt; t时只要a[t] + a[i] &lt; a[i + 1]，那么当i大于当前i值时一定会有a[t] + a[i] &lt; a[i + 1],所以可以直接break跳出</p><p>​    层层剪枝 + map映射之后，速度还是很慢，有些忧伤。。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 3000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;ll, bool&gt;zcy;</span><br><span class="line">ll a[N + 5];</span><br><span class="line"></span><br><span class="line">//预处理前3000个数，并map一下</span><br><span class="line">void init() &#123;</span><br><span class="line">    zcy.clear();</span><br><span class="line">    for (ll i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        a[i] = i * (3 * i - 1) / 2;</span><br><span class="line">        zcy[a[i]] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll work() &#123;</span><br><span class="line">    for (d i = 1; i &lt; N; i++) &#123;         //外层遍历|a[k] − a[j]|，只要出现第一个，那一定就是最小，直接返回</span><br><span class="line">        for (d j = 1; j &lt; N; j++) &#123;</span><br><span class="line">            if (j &gt; i &amp;&amp; a[i] + a[j] &lt; a[j + 1]) break; //当j &gt; i时只要a[i] + a[j] &lt; a[j + 1]，那么a[i]+a[j + 1]一定小于a[j + 2],所以可以直接break跳出</span><br><span class="line">            if (zcy[a[i] + a[j]] &amp;&amp; zcy[2 * a[j] + a[i]]) &#123;</span><br><span class="line">                return a[i];                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ll ans = work();</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案是：<strong>5482660</strong></p><p>​    也就是当a[2167] - a[1020] = a[1912];   a[2167] + a[1020] = a[2395];时</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（四）</title>
      <link href="/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/"/>
      <url>/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/11/操作系统与系统编程-4/title.jpg" alt="title"></p><a id="more"></a><h3 id="系统调用的常用方法："><a href="#系统调用的常用方法：" class="headerlink" title="系统调用的常用方法："></a>系统调用的常用方法：</h3><p>一.系统调用方法用来运行不同的程序，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execve(const char* filename, char* const argv[], char* const envp[]);</span><br></pre></td></tr></table></figure><p>​        该方法以<code>argv</code>为参运行<code>filename</code>指向的可执行程序，并将<code>envp</code>存储的“变量=数值”对作为环境变量代入这个程序。<code>argv</code>的第一个参数必须与<code>filename</code>一致，真正的参数从第二个开始。</p><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h4><p>​    该方法会让<code>filename</code>的程序覆盖进程中正在运行的程序，因此该方法后的代码无法被执行（除非该方法运行失败）</p><p>二.在 Linux 系统中，比起系统调用更常使用以exec开头的六个函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execl(const char* path, const char* arg, ...);</span><br><span class="line">int execlp(const char* file, const char* arg, ...);</span><br><span class="line">int execle(const char* path, const char* arg,</span><br><span class="line">           ..., char* const envp[]);</span><br><span class="line">int execv(const char* path, char* const argv[]);</span><br><span class="line">int execvp(const char* file, char* const argv[]);</span><br><span class="line">int execvpe(const char* file, char* const argv[],</span><br><span class="line">            char* const envp[]);</span><br><span class="line">例如：</span><br><span class="line">execl(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, (char *)NULL);</span><br><span class="line">execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, (char *)NULL);</span><br><span class="line">char* const args[] = &#123;&quot;ls&quot;, &quot;al&quot;, &quot;(char *)NULL&quot;&#125;;</span><br><span class="line">execv(&quot;ls&quot;, args);</span><br><span class="line">execvp(&quot;ls&quot;, args);</span><br></pre></td></tr></table></figure><p>​    它们都具有系统调用功能，可将这些函数表示为：“exec + l/v + p/e/pe”，这六个函数主要有两处不同：</p><p>​    第一处不同（l/v）——“l<em>”类函数将所有参数作为一整个字符串代入，而“v</em>”类函数将参数分别放入一个字符串数组中，将数组作参代入函数运行</p><p>​    第二处不同（p/e/pe）——包含 p的函数可以模仿计算机中壳功能，在“file”中不含“/”时使用环境变量 PATH 中的目录来寻找可执行文件，包含 e的函数可以像<code>execve</code>一样将“变量=数值”对作为环境变量代入程序</p><p>三.用法</p><p>​    使用系统调用函数一般先调用fork()产生新进程，然后再新进程中用<code>exec()</code>类函数运行新程序。</p><p>​    可能大家有疑问，调用fork()会复制了全部父进程地址空间又弃置，会造成浪费。</p><p>​    其实， Linux 系统采用了 copy_on_write 技术，只有在某一数据被修改时那个数据才会被实际复制到子进程的地址空间。所以在<code>fork()</code>之后直接运行<code>exec()</code>时，父进程的地址空间不会被复制过来。</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int pid = fork();</span><br><span class="line">    if (pid==0)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        int pid2 = fork();</span><br><span class="line">        if (pid2 == 0)&#123;</span><br><span class="line">            char** argv = (char**) malloc(3*sizeof(char*));</span><br><span class="line">            argv[0] = &quot;echo&quot;;</span><br><span class="line">            argv[1] = &quot;Hello!&quot;;</span><br><span class="line">            argv[2] = NULL;</span><br><span class="line">            int pid3 = fork();</span><br><span class="line">            count++;</span><br><span class="line">            if (pid3 == 0)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                execvp(&quot;echo&quot;, argv);</span><br><span class="line">                printf(&quot;Count %d,&quot;,count);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                free(argv);</span><br><span class="line">                wait(NULL);</span><br><span class="line">                printf(&quot;%d,&quot;,count);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">            printf(&quot;%d,&quot;,count);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wait(NULL);</span><br><span class="line">        printf(&quot;%d.&quot;,count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后输出为：hello!</p><p>​                2,1,0.</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-038思维</title>
      <link href="/2018/10/11/Project-Euler-038/"/>
      <url>/2018/10/11/Project-Euler-038/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/11/Project-Euler-038/title2.jpg" alt="title2"></p><a id="more"></a><p>题意：</p><p>将192分别与1、2、3相乘：</p><blockquote><p>192 × 1 = 192<br>192 × 2 = 384<br>192 × 3 = 576</p></blockquote><p>连接这些乘积，我们得到一个1至9全数字的数192384576。我们称192384576为192和(1,2,3)的连接乘积。</p><p>同样地，将9分别与1、2、3、4、5相乘，得到1至9全数字的数918273645，即是9和(1,2,3,4,5)的连接乘积。</p><p>对于n &gt; 1，所有某个整数和(1,2, … ,n)的连接乘积所构成的数中，最大的1至9全数字的数是多少？</p><p>思路：</p><p>​    首先，我们需要需要想到的是确定范围。所求是对于n&gt;1来说，所以乘数最大是4位数（因为5位数的话，乘数✖️1得到一个5位数，乘数✖️2 最小是5位数，5+5大于9）</p><p>​    我们继续缩小范围：</p><p>​        当乘数是1位数的话，被乘数最多乘到9才能满足乘积是9位数</p><p>​        当乘数是2位数的话，被乘数最多乘到4才能满足乘积是9位数</p><p>​        当乘数是3位数的话，被乘数最多乘到3才能满足乘积是9位数</p><p>​        当乘数是4位数的话，被乘数最多乘到2才能满足乘积是9位数</p><p>​    因此我们只需要判断这样的数的乘积链接是否为全数字即可。对于链接，我们可以通过以下算式进行链接乘积：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res = res * (int)(pow(10, (int)log10(乘积))) + 乘积;   //res即链接后的9位数</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 10000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d book[10];         //用于标记</span><br><span class="line">d maxx = 0;         //存储最终结果</span><br><span class="line"></span><br><span class="line">//用于判断数字t，最长乘到n的链接数是否为全数字，如果是返回该全数字，不是返回0</span><br><span class="line">d chooes (d t, d n) &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    d res = 0;</span><br><span class="line">    d chang = 0;</span><br><span class="line">    for (d i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        d val = t * i;</span><br><span class="line">        d len = (int)log10(val) + 1;</span><br><span class="line">        d vall = val;</span><br><span class="line">        chang += len;</span><br><span class="line">        while (vall) &#123;</span><br><span class="line">            if (vall % 10 == 0 || book[vall % 10]) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            book[vall % 10] = 1;</span><br><span class="line">            vall /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * (int)(pow(10, len)) + val;</span><br><span class="line">        if (chang == 9) return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于遍历1，2，3，4位数</span><br><span class="line">void work(d len, d n) &#123;</span><br><span class="line">    d low = (int)pow (10, len - 1);</span><br><span class="line">    d high = (int)pow (10, len);</span><br><span class="line">    for (d i = low; i &lt; high; i++) &#123;</span><br><span class="line">        d val = chooes(i, n);</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            maxx = max(maxx, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    d p[4] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    d q[4] = &#123;9, 4, 3, 2&#125;;</span><br><span class="line">    for (d i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        work(p[i], q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, maxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：<strong>932718654</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（三）</title>
      <link href="/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89/"/>
      <url>/2018/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>​                       <img src="/2018/10/11/操作系统与系统编程-三/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="（三）进程常用方法："><a href="#（三）进程常用方法：" class="headerlink" title="（三）进程常用方法："></a>（三）进程常用方法：</h3><p>可通过fork()创建进程，fork()函数格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure><p>​    fork()函数无参数，直接创建一个新进程，新进程为调用fork()的进程的子进程，返回一个进程标识ID(用于区分父进程与子进程，父进程中返回的标识ID是新创建的子进程ID，而子进程中返回的ID为0)</p><p>可通过exit()结束进程，exit()函数格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure><p>​    参数status为进程结束时的状态，当调用该函数结束子进程时，status会作为父进程中wait()函数的第一个参</p><p>wait()函数格式为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t wait(int* stat_loc);</span><br></pre></td></tr></table></figure><p>​    stat_loc为等待的子进程结束状态值的指针（由子进程exit(int status)中的参数status提供，成功为0否则对应错误数字) ，当然，我们设为<code>NULL</code>，函数仍可正常运行。</p><p>​    <code>wait()</code>返回值是返回结束的子进程标识 ID；</p><p>​    <code>wait()</code>使父进程的状态变为等待态，直到父进程中任意一个子进程成功退出并返回结束状态值，父进程才可进入就绪态；</p><p>​    如果在<code>wait()</code>被调用时已经有可用的结束状态值，那么<code>wait()</code>会立即返回</p><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a>注意！！</h4><p>​    （1）如果在等待过程中出现错误（如已经没有可等待的子进程），<code>wait()</code>将返回-1</p><p>​      （2）父进程不能直接等待子进程的子进程</p><p>wait函数作用：</p><p>​    1使子进程某些指令在执行父进程前完成</p><p>​    2 使用wait()让父进程等待所有子进程结束后结束，避免僵尸进程的出现</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int pid = fork();</span><br><span class="line">    if (pid != 0) &#123;</span><br><span class="line">        int status;</span><br><span class="line">        int result = wait (&amp;status);</span><br><span class="line">        if (result == -1 || status != 0) &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, &quot;额，没收到儿子的回信&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, &quot;我是父亲&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int second_pid = fork();</span><br><span class="line">        if (second_pid != 0) &#123;</span><br><span class="line">            int new_status;</span><br><span class="line">            int new_result = wait (&amp;new_status);</span><br><span class="line">            if (new_result == -1 || new_status != 0) &#123;</span><br><span class="line">                printf(&quot;%s\n&quot;, &quot;额，没收到孙子的回信&quot;);</span><br><span class="line">                exit (-1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot;%s\n&quot;, &quot;我是儿子&quot;);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf(&quot;%s\n&quot;, &quot;我是孙子&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>waitpid()函数格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t waitpid (pid_t pid, int* stat_loc, int options);</span><br></pre></td></tr></table></figure><p>​    waitpid()可指定一个标识ID来等待指定进程（当pid &gt; 0时等待标识ID为pid的子进程，当pid == -1时等待任意子进程，当pid == 0时等待进程组标识ID与父进程相同的子进程，当pid &lt; -1时，等待任意进程组标识ID为pid绝对值的进程）</p><p>​    options代表特殊选项（目前Linux只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可用”|”运算符连接使用，当options为0时代表没有特殊选项）</p><p>​    关于特殊选项：</p><p>​    ——WNOHANG ：若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待，若结束，则返回该子进程的ID</p><p>​    ——WUNTRACED 若子进程进入暂停状态则马上返回，此时子进程的结束状态不予理会</p><p>​    所以，当pid = -1，options = 0时，waitpid()等价于wait()</p><p>​    说了以上四个有关进程的函数，它可以用在哪呢？</p><p>​    多进程的应用有很多，比如在网络编程中，每当服务器接收到一个请求，主进程就会用fork()产生一个新进程去处理那个请求，而父进程继续等待其它请求。大家可以自己去探索发现～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-035线性筛</title>
      <link href="/2018/10/10/Project-Euler-035/"/>
      <url>/2018/10/10/Project-Euler-035/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/Project-Euler-035/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="035题："><a href="#035题：" class="headerlink" title="035题："></a>035题：</h3><p>题意：</p><p>​    197被称为圆周素数，因为将它逐位旋转所得到的数：197，719和971都是素数。</p><p>​    小于100的圆周素数有十三个：2、3、5、7、11、13、17、31、37、71、73、79和97。</p><p>​    小于一百万的圆周素数有多少个？</p><p>类似的题还有037题，有空大家可以做一下～    </p><p>思路：</p><p>​    如果1～1000000所有数都逐位旋转复杂度太高，所以应该用线性筛筛选出全部的素数。</p><p>​    对于怎么逐位旋转，我们可以依据以下三点：</p><p>​        1.通过(int)log10(n) + 1来求n的位数</p><p>​        2.利用 n = n / 10 + (n % 10) * pow(10, (int)log10(n)) 来得到逐位旋转的值</p><p>​        3.利用线性筛使用的bool数组来判断逐位旋转的值是否位素数</p><p>​    看到这题网上有些人写了两百多行代码并且时间复杂度还高，觉得利用上述三点就可以缩短代码长度并提高运行效率～</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define d int32_t</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a));</span><br><span class="line">#define N 1000000</span><br><span class="line"></span><br><span class="line">d ans;            //存储满足条件的个数</span><br><span class="line">d prime[N + 5];   //筛选出100万内的全部素数，其中prime[0]为这些素数的个数</span><br><span class="line">bool book[N + 5]; //book[i]代表i是否为素数（0是，1不是）</span><br><span class="line"></span><br><span class="line">//初始化和预处理100万内的全部素数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(prime);</span><br><span class="line">    mem(book);</span><br><span class="line">    ans = 0;</span><br><span class="line">    for (d i = 2; i &lt; N; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (d j = 1; j &lt;= prime[0] &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            book[prime[j] * i] = 1;</span><br><span class="line">            if (i % prime[j] == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断素数t是否满足条件</span><br><span class="line">bool chooes (d t) &#123;</span><br><span class="line">    d len = (int)log10(t);</span><br><span class="line">    d maxx = (int)pow(10, len);</span><br><span class="line">    for (d i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (t % 10 == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        t = t / 10 + (t % 10) * maxx;</span><br><span class="line">        if (book[t]) return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历全部素数</span><br><span class="line">void work() &#123;</span><br><span class="line">    for (d i = 1; i &lt;= prime[0]; i++) &#123;</span><br><span class="line">        d t = prime[i];</span><br><span class="line">        if (chooes (t)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案是 <strong>55</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-032思维</title>
      <link href="/2018/10/10/Project-Euler-32/"/>
      <url>/2018/10/10/Project-Euler-32/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/Project-Euler-32/title3.jpg" alt="title3"></p><a id="more"></a><h3 id="032题："><a href="#032题：" class="headerlink" title="032题："></a>032题：</h3><p>题意：</p><p><strong>全数字的乘积</strong></p><p>​    如果一个n位数包含了1至n的所有数字恰好一次，我们称它为全数字的；例如，五位数15234就是1至5全数字的。</p><p>​    7254是一个特殊的乘积，因为在等式39 × 186 = 7254中，被乘数、乘数和乘积恰好是1至9全数字的。</p><p>​    找出所有被乘数、乘数和乘积恰好是1至9全数字的乘法等式，并求出这些等式中乘积的和。</p><p>​    注意：有些乘积可能从多个乘法等式中得到，但在求和的时候只计算一次</p><p>思路：</p><p>​    和之前一样，不讲暴力。我们想要满足被乘数、乘数和乘积恰好是1至9全数字的，必须保证乘数位数+被乘数位数+乘积位数 = 9</p><p>​    我们知道，乘积位数 = 乘数位数 + 被乘数位数  -  0或1；我们可进一步去重，保证乘数位数 &lt;= 被乘数位数</p><p>​    因此我们发现要想存在1～9全数字乘法等式，只有两种情况：</p><p>​        1.乘数是1位数，被乘数是4位数，乘积是4位数</p><p>​        2.乘数是2位数，被乘数是3位数，乘积是4位数</p><p>​    我们进一步优化，可用dfs+标记找出所有的位值不同的2位数，3位数,4位数,然后用筛选过的2位数乘3位数，看是否满足全数字；再用1位数乘4位数，看是否满足全数字。满足的乘积用map处理一下，第一次出现的累加到结果中</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#define mem(a) memset(a, 0, sizeof(a))</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d num[5][3500];   //num[i][j]表示预处理i位数每位不相同的数，其中num[i][0]代表i位这样的数的个数</span><br><span class="line">d book [15];      //标记数组</span><br><span class="line">d ans = 0;        //总结果</span><br><span class="line">map &lt;d, d&gt;zcy;    //用于映射满足条件的乘积</span><br><span class="line"></span><br><span class="line">void dfs(d n, d inx, d val) &#123;      //n代表位数，inx代表当前位, val代表数字的值</span><br><span class="line">    if (inx == n) &#123;</span><br><span class="line">        num[n][++num[n][0]] = val;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 1; i &lt;= 9; i++) &#123;</span><br><span class="line">        if (!book[i]) &#123;</span><br><span class="line">            book[i] = 1;</span><br><span class="line">            dfs(n, inx + 1, val * 10 + i);</span><br><span class="line">            book[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">//预处理函数</span><br><span class="line">void init() &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    mem(num);</span><br><span class="line">    zcy.clear();</span><br><span class="line">    num[1][0] = 8;</span><br><span class="line">    //预处理1,2,3,4位数每位不相同的数</span><br><span class="line">    for (d i = 2; i &lt;= 9; i++) &#123;</span><br><span class="line">        num[1][i - 1] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 2; i &lt; 5; i ++) &#123;</span><br><span class="line">        mem(book);</span><br><span class="line">        dfs (i, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于判断单个数字</span><br><span class="line">bool chooes1(d x, d *sum) &#123;</span><br><span class="line">    while (x) &#123;</span><br><span class="line">        if (book[x % 10] || (x % 10 == 0)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        *sum += 1;</span><br><span class="line">        book [x % 10] = 1;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于判断乘法算式是否为全数字</span><br><span class="line">void chooes(d x, d y, d z) &#123;</span><br><span class="line">    mem(book);</span><br><span class="line">    d sum = 0;</span><br><span class="line">    bool flag1 = chooes1(x, &amp;sum);</span><br><span class="line">    bool flag2 = chooes1(y, &amp;sum);</span><br><span class="line">    bool flag3 = chooes1(z, &amp;sum);</span><br><span class="line">    if (flag1 &amp;&amp; flag2 &amp;&amp; flag3 &amp;&amp; sum == 9) &#123;</span><br><span class="line">        if (!zcy[z]) &#123;</span><br><span class="line">            ans += z;</span><br><span class="line">            zcy[z] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work() &#123;</span><br><span class="line">    for (d i = 1; i &lt;= num[1][0]; i++) &#123;        //处理1位数*4位数</span><br><span class="line">        d x = num[1][i];</span><br><span class="line">        for (d j = 1; j &lt;= num[4][0]; j++) &#123;</span><br><span class="line">            d y = num[4][j];</span><br><span class="line">            d z = x * y;</span><br><span class="line">            chooes(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 1; i &lt;= num[2][0]; i++) &#123;        //处理2位数*3位数</span><br><span class="line">        d x = num[2][i];</span><br><span class="line">        for (d j = 1; j &lt;= num[3][0]; j++) &#123;</span><br><span class="line">            d y = num[3][j];</span><br><span class="line">            d z = x * y;</span><br><span class="line">            chooes(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后结果是<strong>45228</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（二）</title>
      <link href="/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C/"/>
      <url>/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/操作系统与系统编程-二/title.jpg" alt="title"></p><a id="more"></a><h3 id="（二）进程与线程"><a href="#（二）进程与线程" class="headerlink" title="（二）进程与线程"></a>（二）进程与线程</h3><p>1.关于进程：</p><p>​    ——进程在用户方面，包含了程序的运行状态和这个程序所用的抽象内存及存储数据。</p><p>​    ——进程在操作系统方面：包括：</p><p>​    (1)一个进程的运行状态(通过在进程中存储”状态寄存器、指令计数器、栈指针、通用寄存器“等代表进程目前运行状态的值实现)</p><p>​    (2)从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址及其存储的数据（通过分页存储、分段存储等方法来实现映射）</p><p>​    我们可以将进程笼统看成是一个或多个线程与一个地址空间的结合体</p><p>​    </p><p>2.关于进程的地址空间：</p><p>​    一个进程的全部内存地址和存储的数据，称为这个进程的地址空间</p><p>3.关于线程：</p><p>​    由于多核计算机程序可并发，因此一个进程可能同时包含多个不同的运行状态。为更好区分进程在一个处理器上的运行状态和进程本身的运行状态，于是引入“线程”这一概念。</p><p>​    </p><p>4.​进程控制块和线程控制块：</p><p>​    每个线程拥有一个线程控制块，用来存储“状态寄存器、指令计数器、栈指针、通用寄存器”等数值（也就是在该线程下的进程运行状态），同一进程的所有线程都共享同一个地址空间</p><p>​    进程控制块中包含实现地址转换信息和进程运行状态的线程信息，以及系统在调度进程时需要的信息（比如进程号、进程所处状态、进程优先级等）</p><h4 id="​-注意！！"><a href="#​-注意！！" class="headerlink" title="​    注意！！"></a>​    注意！！</h4><p>​    进程控制块只需存储从抽象内存地址获得实际物理地址的方法，而不会将整个地址空间中地址及其数据都存储</p><p>​    由于进程控制块中的信息是用户进程无权修改的，因此进程控制块存储在内核空间中</p><p>5.三态模型和五态模型</p><p>​    进程三态模型包括运行态（正在执行），就绪态（准备就绪，排入就绪队列等待执行），等待态（等待某一事件发生后才会变为就绪态）</p><p>​    五态模型还包括新建态（被创建尚未加入就绪队列的状态。内核建一个进程需要给它分配资源等，在这个过程中进程就处于新建态）和终止态（终止态对应进程结束但尚未被系统收回的状态，此时系统仍可以获得该进程结束时的信息）</p><p>​    新建态可避免一个新进程在未获得全部资源前就开始运行，终止态可避免一个进程运行完毕后即被系统收回而导致无法获取其信息（因为无法获取该进程信息而导致某一进程停滞不前，产生“僵尸进程”）</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与系统编程（一）</title>
      <link href="/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
      <url>/2018/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/操作系统与系统编程-一/title.jpg" alt="title"></p><a id="more"></a><p>​    对于操作系统和系统编程，自己学的迷迷糊糊懵懵懂懂，希望能够通过写博客梳理一下脉络，加深一下自己的理解～</p><h3 id="（一）操作系统的一些理解与概念"><a href="#（一）操作系统的一些理解与概念" class="headerlink" title="（一）操作系统的一些理解与概念"></a>（一）操作系统的一些理解与概念</h3><p>1.一般程序猿也不会参与系统编程，那么还有学习操作系统和系统编程的必要吗？                       </p><p>​    答案是肯定，因为理解操作系统可以更好地服务于编程，比如更深入的理解多线程等</p><p>2.操作系统的理解：</p><p>​    操作系统是应用程序和硬件间的抽象层，方便软件利用硬件资源，也可以避免软件直接与物理资源接触（防止恶意程序）</p><p>​    操作系统的抽象包括很多层面，包括文件和文件系统，基于进程的抽象等</p><p>3.操作系统的作用：</p><p>​    ——提供公共服务：如读写文件等（无需用户理解实现原理）</p><p>​    ——协调进程交互：操作系统负责给每个进程分配处理器时间、内存等。进程间同步和通信、进程切换过程中处理器和高速缓存器状态的变化等都属于操作系统的协调范围</p><p>​    ——管理与控制资源：将有限物理资源合理分配给不同的进程，提高资源利用率</p><p>​    以上称为操作系统内核，计算机启动时第一个运行的进程就是内核，所有用户进程都基于内核运行，所有资源管控、进程交互协调都由内核完成。也就是说处理器每隔一段时间就中断正在执行的用户进程，切回内核，让它重新分配物理资源，然后决定下一个运行的用户进程。</p><p>4.关于进程的理解：</p><p>​    我们知道，程序在处理器上运行是不连续的，因为硬件资源有限，不可能为所有程序提供全部处理器时间，同样计算机有限的内存迫使一个程序的部分内存留在磁盘上，只有部分数据存在系统内存中。所以系统处理程序的过程是非常复杂的</p><p>​    如果程序猿在编写程序的过程中需要考虑那么多，估计会累死吧。。所以，就有了“进程”这样一个概念。</p><p>​    我们把占用全部内存和处理器时间的程序（理想状态）抽象为“进程”。“进程”大大方便了多个程序同时在系统中运行（因为程序猿不需考虑在内存中所占大小和位置，也不需考虑上下文切换（从一个进程切换到另一个进程）时的复杂过程，只需考虑自己的程序在理想状态下的运行情况）</p><p>​    而且，每个进程都在抽象的内存空间中进行读写，不直接接触其它进程的内存，从而保护进程不受到其它恶意进程的侵害</p><p>5.关于内核与用户进程的理解：</p><p>​    内核和用户进程都是进程！内核就相当于一个指挥官，而用户进程就相当于小兵，指挥官决定小兵的资源分配以及小兵间的协调配合。</p><p>​    内核与用户进程使用不同的存储空间，防止用户进程获得内核信息（内核所在存储空间称为系统空间 用户进程所用空间称为用户空间）</p><p>6.用户进程到内核的方式</p><p>​    ——系统调用 （关于系统调用，会在8中的（1）里有详细描述）</p><p>​    ——中断（又称外中断或异步中断）包括时钟中断（即一个进程执行一段时间后，时钟发出中断信号使计算机进入内核态）、设备 I/O 中断。</p><p>​    ——异常（又称内中断或同步中断）可能源于程序的非法操作（如除数为0、超长度读取数组等）、硬件故障等，通过内核中对应的异常处理程序处理</p><p>7.关于双模式操作：</p><p>​    我们用两种不同模式来区分用户进程与内核的不同权限，这种区分被称为双模式操作</p><p>​    两种模式由处理器中一个位来区分，当处理器执行只允许内核态执行的操作时，它会通过位判断是否处于内核态，如果不是，处理器就会触发异常并终止该进程</p><p>8.一些疑问和答案：</p><p>（1）诸如文件读写啦，进程间通信啦，都是内核专属的权利，用户进程是没有权限的，那么平时用的软件是怎么实现该操作的呢？</p><p>​    操作系统提供了给用户进程的服务(即系统调用)，它可以使用户进程在固定位置进入系统空间并使用系统提供的服务，这样就可以解决文件读写之类的问题啦</p><p>​    所有系统调用的地址存放在系统调用表里（存储的是系统自带的系统调用的地址！！）</p><h3 id="​注意！！！"><a href="#​注意！！！" class="headerlink" title="​注意！！！"></a>​注意！！！</h3><p>​    编程中新建一个数组是用户进程使用自己已分配的一段内存，并不需要进入内核态！！！</p><p>​    而从磁盘中读取文件，写入文件，处理异常等操作都需进入内核态！！</p><p>（2）如果同时有多个中断发生时，处理器将怎么处理？</p><p>​    处理器会先处理优先级高的中断。如果在处理一个中断过程中出现另一个优先级更高的中断信号，那么处理器可能切换处理新的中断信号，这时会出现多重中断。</p><p>​    为避免中断耗费过多时间，在处理中断信号时会屏蔽某一优先等级的中断信号或某个单独的中断信号</p><p>​    </p><p>（3）怎么控制用户进程获取系统调用？</p><p>​    所有中断服务程序的地址按顺序存储在中断向量表中。向量表控制用户进程进入系统的地址，保护内核不被篡改。处理器可以利用中断向量表转入中断服务程序</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-031动态规划</title>
      <link href="/2018/10/10/Project-Euler-031/"/>
      <url>/2018/10/10/Project-Euler-031/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/10/Project-Euler-031/title.jpg" alt="title"></p><a id="more"></a><h3 id="031题："><a href="#031题：" class="headerlink" title="031题："></a>031题：</h3><p>题意：</p><p>​    英国的货币单位包括英镑£和便士p，在流通中的硬币一共有八种：</p><blockquote><p>1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), £2 (200p)</p></blockquote><p>​    以下是组成£2的其中一种可行方式：</p><blockquote><p>1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p</p></blockquote><p>不限定使用的硬币数目，组成£2有多少种不同的方式？</p><p>思路：</p><p>​    题目很简单～有一个坑点。</p><p>​    起初的DP推导式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0] = 1;//dp[i]代表当有i元时的组合方案数</span><br><span class="line">for (d i = 1; i &lt;= 200; i++) &#123;</span><br><span class="line">    for (d j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">        d t = i - money[j];</span><br><span class="line">        if (t &gt;= 0) &#123;</span><br><span class="line">            dp[i] += dp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码会造成重复，比如当i为5的时候，dp[4] = 5，它把1+1+1+1，2+1+1，1+2+1，1+1+2，2+2分别当成了一种。</p><p>​    我们知道，2+1+1，1+2+1，1+1+2它们三个应该算作一种，应当怎样避免这种重复呢？</p><p>​    我们可以通过创建二维数组dp【i】【j】（代表共有i元钱，其中最大的钱为money[j]的方案数）来解决（确定好最大的钱，以后添加的钱只能大于等于最大的钱，就可以避免重复问题，比如上面i为4时，只会出现1+1+1+1，1+1+2，2+2三种情况）。最后累加dp【200】【0】～dp【200】【7】,即是正确答案</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line"></span><br><span class="line">d dp[205][10]; //dp[i][j]代表共有i元钱，其中最大的钱为money[j]的方案数</span><br><span class="line">d money[8] = &#123;1, 2, 5, 10, 20, 50, 100, 200&#125;;//存储钱的种类</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    d ans = 0;//存储总方案数</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (d i = 1; i &lt;= 200; i++) &#123;</span><br><span class="line">        for (d j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">            d t = i - money[j];</span><br><span class="line">            if (t &gt;= 0) &#123;</span><br><span class="line">                for (d p = 0; p &lt;= j; p++) &#123;//避免重复计算精髓</span><br><span class="line">                    dp[i][j] += dp[t][p];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (d i = 0; i &lt; 8; i ++) &#123;</span><br><span class="line">        ans += dp[200][i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId32&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为：<strong>73682</strong>   Over～</p><p>—————————分割线————————</p><p>​    呃呃呃，上面二维DP数组可以简化为一维，就是完全背包了。。今天脑子不好使了～</p><p>​    推导式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0] = 1;//dp[i]代表当有i元时的组合方案数</span><br><span class="line">for (d j = 0; j &lt; 8; j++) &#123;</span><br><span class="line">for (d i = 1; i &lt;= 200; i++) &#123;</span><br><span class="line">        d t = i - money[j];</span><br><span class="line">        if (t &gt;= 0) &#123;</span><br><span class="line">            dp[i] += dp[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    没错。。就是将两个for循环的位置调换一下，就可解决重复问题，因为遍历钱的种类数在外层，就使得后面钱种类一定大于等于前面</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-014记忆化搜索</title>
      <link href="/2018/10/09/Project-Euler-014/"/>
      <url>/2018/10/09/Project-Euler-014/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/09/Project-Euler-014/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="014题："><a href="#014题：" class="headerlink" title="014题："></a>014题：</h3><p>​    今天做了将近10道Project Euler上的题，要么和之前写的题型类似，要么简单，吐血～</p><p>​    14题虽然简单些，但是胜在之前没说过，就一并讲一下吧。。。</p><p>题意：</p><p>​    在正整数集上定义如下的迭代序列：</p><p>​    n → n/2 （若n为偶数）<br>​    n → 3n + 1 （若n为奇数）</p><p>​    从13开始应用上述规则，我们可以生成如下的序列：</p><p>​    13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p><p>​    可以看出这个序列（从13开始到1结束）共有10项。尽管还没有被证明，但我们普遍认为，从任何数开始最终都能迭代至1（“考拉兹猜想”）。</p><p>​    从小于一百万的哪个数开始，能够生成最长的序列呢？</p><p>​    <strong>注：</strong> 序列开始生成后允许其中的项超过一百万</p><p>思路：</p><p>​    如果采用暴力的话，从1到1000000分别枚举，每个数再模拟一下它变成1的过程。时间复杂度估计会大到爆炸吧～</p><p>​    接下来我就想能不能逆推，推出最长的那个数。但是题上说允许迭代的过程中存在大于1000000的数，那么逆推暂时没有想到终止条件是什么。Orz～</p><p>​    好吧。。这题我只想到一种思路能在1s内算出来，就是采用记忆化搜索！由于每个数它的用dp[]数组来记录每个数的迭代步数(初始化dp[1] = 0)。</p><p>​    例如：3的迭代过程是：3-&gt;10-&gt;5-&gt;16-&gt;8-&gt;4-&gt;2-&gt;1</p><p>​    此时dp[2] = 1;dp[4] = 2; dp[8] = 3; dp[16] = 4; dp[5] = 5; dp[10] = 6;dp[3] = 7;</p><p>​     我们再看4的迭代时，直接可由dp[4] = 2得到步数为2；</p><p>​    以此类推，看5的迭代时，可由dp[5] = 5得到步数为5;</p><p>​    看6的迭代时，6-&gt;3，可由dp[3] + 1得到dp[6] = 7；</p><p>​    这样就省略了很多很多的中间过程，优化了效率，典型的用空间换取时间。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define N 1000000</span><br><span class="line"></span><br><span class="line">d dp[N + 5];        //记忆化数组</span><br><span class="line">d maxx = 0;         //记录最大步数</span><br><span class="line"></span><br><span class="line">d dfs (ll n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &lt;= N &amp;&amp; dp[n] != 0) &#123;         //该步就相当于剪枝</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &amp; 1) &#123;</span><br><span class="line">        d t = 1 + dfs(n * 3 + 1);</span><br><span class="line">        if (n &lt;= N) &#123;</span><br><span class="line">            dp[n] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        d t = 1 + dfs(n / 2);</span><br><span class="line">        if (n &lt;= N) &#123;</span><br><span class="line">            dp[n] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d main() &#123;</span><br><span class="line">    ll ans;</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (ll i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        d res = dfs(i);</span><br><span class="line">        if (maxx &lt; res) &#123;</span><br><span class="line">            maxx = res;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后答案为：<strong>837799</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-005短除法</title>
      <link href="/2018/10/09/Project-Euler-005/"/>
      <url>/2018/10/09/Project-Euler-005/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/09/Project-Euler-005/title.jpg" alt="title"></p><a id="more"></a><h3 id="005题："><a href="#005题：" class="headerlink" title="005题："></a>005题：</h3><p>题意：</p><p>​    2520是最小的能够被1到10整除的数。</p><p>​    最小的能够被1到20整除的正数是多少？</p><p>思路：</p><p>​    我们能够想到，既然是12的倍数，那么也一定会是1，2，3，4，6的倍数；既然是14的倍数，也一定会是7的倍数；既然是15的倍数，也一定是5的倍数；既然是16的倍数，也一定是8的倍数；既然是18的倍数，也一定是9的倍数；既然是20的倍数，那一定也是10的倍数</p><p>​    所以，我们只需要考虑11～20的最小公倍数即可</p><p>​    思路一：​    利用辗转相除法求11和12的最大公因子，进而通过<code>11*12/gcd(11,12)</code> 来求它们的最小公倍数，然后求最小公倍数和13的最小公倍数并更新最小公倍数，循环上述过程直到20</p><p>​    思路二：我们知道，两个数的最小公倍数，相比它俩相乘，缩小了它俩的公共因数倍。</p><p>​    类比到多个数，比如： 2，3， 6， 12，16：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 = 2； 3 = 3； 6 = 3*2； 12 = 3 * 2* 2；16 = 2 * 2 * 2 * 2；</span><br></pre></td></tr></table></figure><p>​    我们发现：</p><p>​    公因子2在2中存在1次，在6中存在1次，在12中存在2次，在16中存在4次</p><p>​    公因子3在3中存在1次，在6中存在1次，在12中存在1次</p><p>​    那么它们的最小公倍数，就是<code>pow（2，4）* pow（3，1）= 48</code></p><p>​    也就是说，每个因子找这些数中它出现的最大次数，其它数都是重复的，可以去掉，然后累乘每个因子的最大次数幂即为最小公倍数。</p><p>​    除了运算速度快之外，还可以避免辗转相除法取余1e9+7导致错误的尴尬（只有累乘不会出错，但是中途取余求gcd会造成错误）</p><p>​    兴冲冲的发现了这个规律后，结果一百度发现已经存在这个定理了，叫短除法。。哎，优队算法就这样没了。。。</p><p>代码：</p><p>​    和之前一样，暴力求法不写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">d a[10];</span><br><span class="line">ll ans = 1;         //最终结果</span><br><span class="line">ll prime[8] = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125;;  //20以内的质数</span><br><span class="line"></span><br><span class="line">//用于存储11～20</span><br><span class="line">void init() &#123;</span><br><span class="line">    for (d i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        a[i] = 11 + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速幂函数</span><br><span class="line">ll quick (ll a, d b) &#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1) res *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//短除法</span><br><span class="line">void short_division() &#123;</span><br><span class="line">    for (d i = 0; i &lt; 8; i ++) &#123;</span><br><span class="line">        d maxx = 0;                 //对于11～20，能够循环整除prime[i]的最大次数</span><br><span class="line">        for (d j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            d inx = 0;              //记录当前数能循环整除prime[i]的最大次数</span><br><span class="line">            while (a[j] % prime[i] == 0) &#123;</span><br><span class="line">                a[j] /= prime[i];</span><br><span class="line">                inx ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxx = max(maxx, inx);</span><br><span class="line">        &#125;</span><br><span class="line">        ans *= quick(prime[i], maxx);   //结果乘质因子的最大循环整除次数次幂</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);    //最后结果为11～20，也就是1～20的最小公倍数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    short_division();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：<strong>232792560</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-030思维</title>
      <link href="/2018/10/09/Project-Euler-030/"/>
      <url>/2018/10/09/Project-Euler-030/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/09/Project-Euler-030/title.jpg" alt="title"></p><a id="more"></a><p>跳题是因为有些题简单没有写的必要，或者难度大需要在后面写，循序渐进～</p><h3 id="030题："><a href="#030题：" class="headerlink" title="030题："></a>030题：</h3><p>该题与Project Euler-034和Project Euler-036类似，有时间的童鞋可以看一下那两道题</p><p>题意：</p><p>有三个数可以写成它们各位数字的四次幂之和：</p><blockquote><p>1634 = 1^4 + 6^4 + 3^4 + 4^4<br>8208 = 8^4 + 2^4 + 0^4 + 8^4<br>9474 = 9^4 + 4^4 + 7^4 + 4^4</p></blockquote><p>由于1 = 1^4不是一个和，所以这里并没有把它包括进去。</p><p>这些数的和是1634 + 8208 + 9474 = 19316。</p><p>找出所有可以写成它们各位数字的五次幂之和的数，并求这些数的和。</p><p>思路：</p><p>​    遇到这个题，我们首先需要确定它的上界是什么，不然暴力枚举都不知道终止条件。</p><p>​    对于每一位来说，9^5最大，因此我们通过每位都是9的数来确定它的上界。我们设上限为n</p><p>​    当n为二位数时，最大累计和为六位数;  当n为三位数时，最大累计和为六位数;  当n为四位数时，最大累计和为六位数;  当n为五位数时，最大累计和为六位数;  当n为六位数时，最大累计和为六位数; 当n为七位数时，最大累计和为六位数。</p><p>​    从上边就可以看出，当一个数为7位数及更大，它的最大累计和都不足该数的位数，说明n的上限为6位数。</p><p>​    因此，我有以下两个思路：</p><p>​    思路一：求出6个9^5的和为354294，然后遍历2～354294之间的数，只要满足条件就累加求和，时间复杂度为1e6</p><p>​    思路二：分别求出0～9的五次方（快速幂），然后遍历位数（从2～6），多少位就相当于取多少个数（利用dfs剪枝），只需判断这些数的五次方和是否为与位数相同且等同与这几个数，相同就累加，时间复杂度大概1e5（就相当于有10种球，每种球无限个，同时取2个，3个，4个，5个，6个的方案数，经计算只有7997种）</p><p>代码：</p><p>​    老规矩，暴力代码不写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int num[10];</span><br><span class="line">int ans;</span><br><span class="line">int book1[10], book2[10];</span><br><span class="line">int sss = 0;</span><br><span class="line">//快速幂函数</span><br><span class="line">int quick (int a, int b) &#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while (b) &#123;</span><br><span class="line">        if (b &amp; 1)  res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//预处理0～9的五次方</span><br><span class="line">void init () &#123;</span><br><span class="line">    memset (num, 0, sizeof(num));</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        num[i] = quick (i, 5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//dfs剪枝求当为n位数的不同数字组合</span><br><span class="line">void dfs(int now, int inx, int n, int val) &#123;</span><br><span class="line">    if (inx == n) &#123;</span><br><span class="line">        sss ++;       //计算枚举的个数</span><br><span class="line">        memset (book2, 0, sizeof(book2));</span><br><span class="line">        int vall = val, flag = 0;</span><br><span class="line">        while (vall) &#123;</span><br><span class="line">            book2[vall % 10] ++;</span><br><span class="line">            vall /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">            if (book1[i] != book2[i]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            ans +=val;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //剪枝精髓</span><br><span class="line">    for (int i = now; i &lt; 10; i++) &#123;</span><br><span class="line">        book1[i] ++;</span><br><span class="line">        dfs (i, inx + 1, n, val + num[i]);</span><br><span class="line">        book1[i] --;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main () &#123;</span><br><span class="line">    init();</span><br><span class="line">    ans = 0;</span><br><span class="line">    for (int i = 2; i &lt;= 6; i ++) &#123;</span><br><span class="line">        memset(book1, 0, sizeof(book1));</span><br><span class="line">        dfs(0, 0, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    //printf(&quot;%d\n&quot;, sss);  //真正枚举的个数，只有7997</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出答案为: <strong>443839</strong></p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-003思维+线性筛</title>
      <link href="/2018/10/08/Project-Euler-003/"/>
      <url>/2018/10/08/Project-Euler-003/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/08/Project-Euler-003/title.jpg" alt="title"></p><a id="more"></a><h3 id="003题："><a href="#003题：" class="headerlink" title="003题："></a>003题：</h3><p>题意：</p><p>​    13195的所有质因数为5、7、13和29。</p><p>​    600851475143最大的质因数是多少？</p><p>思路：</p><p>​    600851475143大概是6e11，如果纯暴力找它的每个因子，然后再判断每个因子是不是质数，时间复杂度大约是1e22，家用电脑估计一个小时也跑不完吧～</p><p>​    有些人继续优化，说可以用线性筛求[2,600851475143]范围内的质数，然后找最大满足是600851475143因子的质数。这样时间复杂度是1e11，家里电脑依然跑不完～而且线性筛需要开两个1e11的数组分别用来判断是否为质数和存质数，我们无法开这么大的数组。</p><p>​    这时候，我们就需要明白一点，600851475143的临界值是多少？嗯，这个数的临界值为（int）(sqrt(600851475143))，为什么呢？</p><p>​    仔细想一下，如果最大质因子小于等于(int)(sqrt(600851475143))，那么我们只需要线性筛前(int)(sqrt(600851475143))就可以找出它的最大质因子。</p><p>​    如果最大质因子大于(int)(sqrt(600851475143))，那么600851475143中不可能同时存在两个大于(int)(sqrt(600851475143))的质因子（如果存在，两个质因子相乘就大于600851475143啦），所以我们可以通过除以(int)(sqrt(600851475143))以内所有600851475143的质因子，最后剩下的数，就是大于(int)(sqrt(600851475143))的质因子。</p><p>​    而(int)(sqrt(600851475143))为<strong>775146</strong>,用线性筛求775146范围内的质数时间复杂度只有1e6左右，家用电脑一秒钟以内肯定能求出来～</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#define ll int64_t</span><br><span class="line">#define d int32_t</span><br><span class="line">#define len 775150</span><br><span class="line">ll n = 600851475143;</span><br><span class="line">//prime[]用于存素数</span><br><span class="line">d prime[len];</span><br><span class="line">//choose[i]用于判断i是否为素数,0是，1不是</span><br><span class="line">bool choose[len];</span><br><span class="line"></span><br><span class="line">ll init() &#123;</span><br><span class="line">    ll maxx = 0; //用来存储最大的质因子</span><br><span class="line">    prime[0] = 0; //用来记录质数个数</span><br><span class="line">    memset (choose, 0, sizeof(choose));</span><br><span class="line">    for (d i = 2; i &lt; len; i ++) &#123;</span><br><span class="line">        if (!choose[i]) &#123;</span><br><span class="line">        //如果i是素数就添加到prime中</span><br><span class="line">            prime [++prime[0]] = i;</span><br><span class="line">            //如果i是不断缩小的n的因子，则n循环累除i</span><br><span class="line">            if(n % i == 0) &#123;</span><br><span class="line">                while (n % i == 0) &#123;</span><br><span class="line">                    n /= i;</span><br><span class="line">                &#125;</span><br><span class="line">                //更新质因子的最大值</span><br><span class="line">                maxx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //线性筛的性质</span><br><span class="line">      for (d j = 1; j &lt;= prime[0] &amp;&amp; i * prime[j] &lt; len; j++) &#123;     </span><br><span class="line">            choose[i * prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果此时n不为1，说明最大质因子大于(int)sqrt(600851475143)</span><br><span class="line">    if (n != 1) &#123;</span><br><span class="line">        maxx = n; //那么更新最大质因子</span><br><span class="line">    &#125;</span><br><span class="line">    return maxx;//最后返回值即为结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll ans = init();</span><br><span class="line">    printf(&quot;%&quot; PRId64&quot;\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后输出答案为<strong>6857</strong> ，Over～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-002矩阵快速幂+二分</title>
      <link href="/2018/10/08/Project-Euler-002/"/>
      <url>/2018/10/08/Project-Euler-002/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/08/Project-Euler-002/title.jpg" alt="title"></p><a id="more"></a><h3 id="002题："><a href="#002题：" class="headerlink" title="002题："></a>002题：</h3><p>题意：</p><p>​    斐波那契数列中每一项都是前两项的和。由1和2开始生成的斐波那契数列前10项为：</p><p>​    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>​    考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和</p><p>思路：</p><p>​    本题也想到了两个思路：</p><p>​    思路一：由于斐波那契数列增长速度非常快，所以不超过四百万的斐波那契数顶多有100个，极限了。因此我们可以通过while(Fib[i] &lt;= 4e6) 循环查找出为偶数的项并累加求和</p><p>​    思路二（有点脱了裤子放屁的感觉～）：我们通过斐波那契数列的性质可知，对于该斐波那契数列：</p><p>​    1 2 3 5 8 13 21 34…..</p><p>​    有以下两个有用的性质：</p><p>​    1.  S(n) = Fib[n + 2] - 2     </p><p>​        //S(n)代表斐波那契数列前n项和 ，Fib[i]代表下标为i的斐波那契数</p><p>​    2.  对于前下角标为3的倍数 + 2个斐波那契数，项数为偶数的和等于项数为奇数的和 + 1</p><p>​    </p><p>​    因此我们可以通过二分法套矩阵快速幂来求取4e6以内的最大斐波那契数，并返回该数在斐波那契数中的下角标n，然后用矩阵快速幂求Fib[n + 2]，求的n + 2的下角标为3的倍数 + 2，所以偶数项的和为（Fib[n+2] - 1） / 2;</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">int N = 2;</span><br><span class="line">//用于矩阵相乘</span><br><span class="line">void multi(ll *a, ll *b) &#123;</span><br><span class="line">    ll c[N][N];</span><br><span class="line">    memset(c, 0, sizeof(c));</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            for (int k = 0; k &lt; N; k++) &#123;</span><br><span class="line">                c[i][j] += *(a + i * N + k) * *(b + k * N + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            *(a + i * N + j) = c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//矩阵快速幂</span><br><span class="line">void quick(ll *a, ll n) &#123;</span><br><span class="line">    ll ans[N][N];</span><br><span class="line">    memset(ans, 0, sizeof(ans));</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        ans[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        if (n &amp; 1) &#123;</span><br><span class="line">            multi(ans[0], a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">        multi(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            *(a + i * N + j) = ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//二分法找4e6以内最大斐波那契数，并返回该下角标</span><br><span class="line">int erfen(int l, int r, ll val) &#123;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">        ll root[N][N], a[N][N];</span><br><span class="line">        memset(root, 0, sizeof(root));</span><br><span class="line">        memset(a, 0, sizeof(a));</span><br><span class="line">        root[1][0] = 1;</span><br><span class="line">        a[0][1] = 1; a[1][0] = 1; a[1][1] = 1;</span><br><span class="line">        quick(a[0], mid);</span><br><span class="line">        multi(a[0], root[0]);</span><br><span class="line">        ll res = a[1][0];</span><br><span class="line">        if(res &lt;= val) &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//感觉不会超过100个啦，就二分的下标1到100</span><br><span class="line">    int res = erfen(1, 100, 4000000);</span><br><span class="line">    ll root[N][N], a[N][N], sum;</span><br><span class="line">    memset(root, 0, sizeof(root));</span><br><span class="line">    memset(a, 0, sizeof(a));</span><br><span class="line">    root[1][0] = 1;</span><br><span class="line">    a[0][1] = 1; a[1][0] = 1; a[1][1] = 1;</span><br><span class="line">    if (res % 3 == 2) &#123;</span><br><span class="line">        quick(a[0], res + 2);</span><br><span class="line">        multi(a[0], root[0]);</span><br><span class="line">        sum = (a[1][0] - 1 )/ 2;</span><br><span class="line">    &#125;else if(res % 3 == 1) &#123;</span><br><span class="line">        //由于满足res % 3 == 2 就不再考虑</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //由于满足res % 3 == 2 就不再考虑</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后求出结果为：<strong>4613732</strong></p><p>​    第二个想法虽好，但由于最后发现下角标的值才40多！！可能二分+矩阵快速幂比纯暴力还慢。。。就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Euler-001容斥原理</title>
      <link href="/2018/10/08/Project-Euler-001/"/>
      <url>/2018/10/08/Project-Euler-001/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/08/Project-Euler-001/title.jpg" alt="title"></p><a id="more"></a><p>欧拉计划里面都是一些数学题，可以通过编程来解决它，只需要输入最后的结果即可。从简单到难，一点一点做，加油！</p><h3 id="001题："><a href="#001题：" class="headerlink" title="001题："></a>001题：</h3><p>题意：</p><p>​    如果我们列出10以内所有3或5的倍数，我们将得到3、5、6和9，这些数的和是23。</p><p>​    求1000以内（不包括1000）所有3或5的倍数的和</p><p>思路：</p><p>​    有两个：1.用暴力的方法遍历从1～999，只要是3或5的倍数就累加</p><p>​            2.利用容斥原理，用3的倍数的和 + 5的倍数的和 - 15的倍数的和</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">    int num3 = 999 / 3;//求出1000以内3的倍数的个数</span><br><span class="line">    int num5 = 999 / 5;//求出1000以内5的倍数的个数</span><br><span class="line">    int num15 = 999 / 15;//求出1000以内15的倍数的个数</span><br><span class="line">    //求出1000以内3的倍数的数的累加和</span><br><span class="line">    int ans3 = (1 + num3) * num3 / 2 * 3;</span><br><span class="line">    //求出1000以内5的倍数的数的累加和</span><br><span class="line">    int ans5 = (1 + num5) * num5 / 2 * 5;</span><br><span class="line">    //求出1000以内15的倍数的数的累加和</span><br><span class="line">    int ans15 = (1 + num15) * num15 / 2 * 15;</span><br><span class="line">    //通过容斥原理求得结果为233168</span><br><span class="line">    printf (&quot;%d\n&quot;, ans3 + ans5 - ans15);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Over～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十七)</title>
      <link href="/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%B8%83/"/>
      <url>/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/07/C语言查缺补漏-十七/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十七：指针空间补充与堆内存保存函数中的值"><a href="#忽略点十七：指针空间补充与堆内存保存函数中的值" class="headerlink" title="忽略点十七：指针空间补充与堆内存保存函数中的值"></a>忽略点十七：指针空间补充与堆内存保存函数中的值</h3><p>​    关于之前讲解就不再重复，点➡️ <a href="http://www.ivan-zcy.top/2018/10/02/C语言查缺补漏-6/">点我</a> 跳转</p><h4 id="补充1"><a href="#补充1" class="headerlink" title="补充1:"></a>补充1:</h4><p>​    除了之前讲的malloc和calloc外，还有一个特别重要的函数——realloc()，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* realloc (void* ptr, size_t size);</span><br></pre></td></tr></table></figure><p>​    realloc可以将已分配的堆内存扩充到size的大小，并返回扩充后的内存起始地址（注意！当第一个参数所指向的内存空间不够扩大到size时，realloc将会重新分配一段足够大的内存空间，将旧内存空间中的内容拷贝到新地址并释放旧内存空间）</p><h4 id="补充2"><a href="#补充2" class="headerlink" title="补充2:"></a>补充2:</h4><p>​    易错点：对于下面代码，会输出什么？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* test = &quot;test&quot;;</span><br><span class="line">test[0] = &apos;j&apos;;</span><br><span class="line">printf(&quot;%s\n&quot;, test);</span><br></pre></td></tr></table></figure><p>​    既不是”test”，也不是”jest”，也不是”j”， 由于”test”存在内存的常量区，因此不能修改</p><h4 id="补充3"><a href="#补充3" class="headerlink" title="补充3:"></a>补充3:</h4><p>​    由于函数执行完毕后会释放掉函数所占用的栈内存，所以在函数中定义的东西就会随栈内存的释放而消失。那么，我们怎么样才能保存函数中一些有用的信息呢？</p><p>​    我暂时就想到以下3种方法，欢迎大佬们补充：</p><p>​    ——利用返回值：</p><p>​    我们可以利用返回值把函数中的某一个值传入到main函数中，如果有多个值，我们也可以专门定义一个结构体，把多个值放到结构体中，返回该结构体（如果你们不嫌麻烦的话）例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    int age;</span><br><span class="line">    char address[15];</span><br><span class="line">&#125;;</span><br><span class="line">node fun() &#123;</span><br><span class="line">    node t;</span><br><span class="line">    int age = 12;</span><br><span class="line">    char name[10] = &quot;Ivan&quot;;</span><br><span class="line">    char address[15] = &quot;Shan Dong&quot;;</span><br><span class="line">    t.age = age;</span><br><span class="line">    strcpy(t.name, name);</span><br><span class="line">    strcat(t.address, address);</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    node k = fun();</span><br><span class="line">    printf(&quot;%s\n&quot;, k.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ——利用静态变量</p><p>​    我们可以在函数中声明该变量为静态变量，这样变量就不会随着函数的结束而消失，而是直到整个程序结束后才会释放。但是声明静态变量有个局限性，就是该变量的作用域！！在函数内定义的静态变量，它虽然不会随着函数的消失而消失，但它只能作用于函数中！！例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">    static int a = 0;</span><br><span class="line">    a ++;</span><br><span class="line">    printf(&quot;%d\n&quot;, a);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    fun();//此时a输出1</span><br><span class="line">    fun();//此时a输出2 表明上次fun函数释放后a的值保存了下来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ——创建堆内存存储并返回指向堆内存空间的指针</p><p>​    感觉这是最好的解决办法了，专门声明一块堆内存空间，然后把函数中想保存的东西存到里面，然后返回指向该内存空间的指针。这样就不会随函数的消失而消失，而且无论什么情况下都可通过指针去调用。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* fun() &#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    int *p = (int *)malloc(5 * sizeof(int));</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        p[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int *k = fun();</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, k[i]);//输出为1 2 3 4 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ​        </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十六)</title>
      <link href="/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E5%85%AD/"/>
      <url>/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/07/C语言查缺补漏-十六/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十六：EOF-NULL-0的区别"><a href="#忽略点十六：EOF-NULL-0的区别" class="headerlink" title="忽略点十六：EOF NULL  \0的区别"></a>忽略点十六：EOF NULL  \0的区别</h3><h4 id="——关于EOF："><a href="#——关于EOF：" class="headerlink" title="——关于EOF："></a>——关于EOF：</h4><p>​    在C语言中，关于EOF的宏定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define EOF -1</span><br></pre></td></tr></table></figure><p>​    也就是说，EOF其实就是-1，由于ASCII代码值的范围是从0～255，不会存在-1的情况，因此可以用EOF作为文件(必须是文本文件)结束标志或输入结束标志！！例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (scanf (&quot;%d&quot;, &amp;a) != EOF) &#123;&#125;</span><br></pre></td></tr></table></figure><p>​    EOF结束在windows对应按键是CTRL+Z，在linux对应按键是CTRL+D    </p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="——关于NULL："><a href="#——关于NULL：" class="headerlink" title="——关于NULL："></a>——关于NULL：</h4><p>​    在C语言中，关于NULL的宏定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#undef NULL</span><br><span class="line">#if defined(__cplusplus)//如果存在__cplusplus这个宏定义</span><br><span class="line">#define NULL 0//NULL代表0</span><br><span class="line">#else//否则</span><br><span class="line">#define NULL ((void *)0)//NULL代表((void *)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    由于__cplusplus宏定义只存在于C++中，所以在C语言里，NULL代表的是值为0的void型指针，称为空地址；</p><p>​    空地址真的是空吗？我们通过下面代码来输出一下NULL指针的地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p=NULL;</span><br><span class="line">printf(&quot;%p\n&quot;,p);//输出结果为0x00000000</span><br></pre></td></tr></table></figure><p>​    也就是说，NULL是用来代表指针为空的，但NULL也有地址，它并不是真正意义的空！！！它的作用是用来防止出现野指针的。从下面代码中就可以看出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p;</span><br><span class="line">if(p == NULL) &#123;</span><br><span class="line">    printf(&quot;Ok\n&quot;);//不会执行，表明野指针并不为空</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%p\n&quot;, p);//输出为一个随机地址</span><br></pre></td></tr></table></figure><p>​    </p><p>​    我们可以使用NULL作为空指针常量使用，例如：<code>int<em> p = NULL;</em></code>也可以直接使用0作为空指针常量，例如：<code>int p = 0;</code> </p><p>​    所以NULL常常用于指代对象或指针为空。例如用在链表中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node* p = root;</span><br><span class="line">while (p -&gt; next != NULL) &#123;</span><br><span class="line">//前提条件是最后一个节点的next成员已经赋值为NULL，不然野指针并不为NULL</span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="——关于-0"><a href="#——关于-0" class="headerlink" title="——关于\0:"></a>——关于\0:</h4><p>​    ‘\0’是一个ASCII控制字符(转义字符)，它代表空字符，作为字符串结尾字符～</p><p>​    比如用在某个字符串的遍历中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char s[15] = &quot;hello ACM&quot;;</span><br><span class="line">int i = 0;</span><br><span class="line">while (s[i] != &apos;\0&apos;) &#123;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    至于为什么拿出这三个来讲，是因为有时在while()里面对字符串，文本文件，指针之类的操作，!= 后加什么有时候迷糊～</p><p>​    就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十五)</title>
      <link href="/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%BA%94/"/>
      <url>/2018/10/07/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E5%8D%81%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/07/C语言查缺补漏-十五/titile.jpg" alt="titile"></p><a id="more"></a><h3 id="忽略点十五：strtok-的使用"><a href="#忽略点十五：strtok-的使用" class="headerlink" title="忽略点十五：strtok()的使用"></a>忽略点十五：strtok()的使用</h3><p>​    在ACM中，常常使用字符串函数诸如：strlen求字符串长度，strcpy字符串复制，strcmp字符串比较，strcat字符串追加等等，但忽略了一个特别重要的函数——strtok()</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* strtok(char* str, const char* delimiters);</span><br></pre></td></tr></table></figure><p>​        它用于将字符串<code>str</code>用分隔符<code>delimiters</code>分为更短的字符串。<code>delimiters</code>是含多个字符的字符串，其中每个字符都是一个独立的分隔符。如<code>\n\t</code>中<code>\n</code>和<code>\t</code>都是分隔符。</p><p>​    需要注意！！<code>strtok</code>函数会改变源字符串<code>str</code>，返回值指向第一个由非分隔符字符的指针的分割片段；之后每次调用，都要把<code>NULL</code>作为第一个参数，如果调用成功就会返回下一个分割片段，如果已经到达<code>str</code>的末尾则会返回<code>NULL</code></p><p>​    具体使用如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char s[55] = &quot;hello,My name is Ivan,I&apos;m fifteen years|old&quot;;</span><br><span class="line">char s1[5] = &quot;, |&quot;;</span><br><span class="line">char *p = strtok(s, s1);  //利用s1中分隔符将s分隔开</span><br><span class="line">printf(&quot;%s\n&quot;, s);//输出hello</span><br><span class="line">printf(&quot;%ld\n&quot;, strlen(s));//输出5，代表s只剩分隔符分隔后的第一块</span><br><span class="line">while (p != NULL) &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, p);</span><br><span class="line">    //循环输出每一块</span><br><span class="line">    //分别为hello,My,name,is,Ivan,I&apos;m,fifteen,years,old</span><br><span class="line">    p = strtok(NULL, s1);//循环的使用方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS High问题及解决方法(转载)</title>
      <link href="/2018/10/06/MacOS-High%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2018/10/06/MacOS-High%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/MacOS-High问题及解决方法-转载/title.jpg" alt="title"></p><a id="more"></a><h2 id="原文地址：https-blog-csdn-net-jackymvc-article-details-78256120"><a href="#原文地址：https-blog-csdn-net-jackymvc-article-details-78256120" class="headerlink" title="原文地址：https://blog.csdn.net/jackymvc/article/details/78256120"></a>原文地址：<a href="https://blog.csdn.net/jackymvc/article/details/78256120" target="_blank" rel="noopener">https://blog.csdn.net/jackymvc/article/details/78256120</a></h2><p><div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                                            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"><br>                        <div class="htmledit_views"><br>OSX的High Sierra正式版出来半个月有余，听着什么自媒体、科技媒体吹这系统多么牛B，手贱点了升级，好在升级过程中没有遇到各种坑还挺顺利的，但是我没有感觉多么好用的同时，却给我带来不大不小的麻烦。且听我一一道来……</div></div></p><p>10.13版本加强了权限的限制，尤其是对/usr/local目录，默认开通 SIP （System Intergrity Protection），它禁止了软件以root身份在Mac上运行，不管你是在终端中如何运行</p><p>MyMBP:~ Jacky$ sudo chown -R $(whoami) /usr/local ，返回给你的就是 chown: Operation not permitted，哪怕你是用root的身份。</p><p>有些软件在运行过程中需要对/usr/local下的文件读写，比如你更新ruby，起因是我要通过homebrew来安装zookeeper</p><p>brew install zookeeper</p><p>运行后下载了zookeeper，但是安装过程中，报了一个ruby的错误（原谅我没有截图），大意是ruby 2.3.0已经不被High Sierra支持了，看样子是要更新ruby</p><p>顺序做了一些操作，都没有起什么作用</p><p>rvm -v发现是1.19.3版本最新的已经到1.29.3了</p><p>ruby -v版本是2.3.0，最新已经到2.4.2了</p><p>rvm install 2.4.2也是由于权限问题安装不了</p><p>看来只有关掉SIP了</p><p>1.重启Mac，按住Command + R键直到Apple Logo出现，进入Recovery Mode模式（我感觉我是按了好半天）</p><p>2.点击工具里的Terminal（终端）</p><p>3.输入csrutil disable，之后回车</p><p>4.重启Mac</p><p>5.重启完成后，终端中输入sudo chflags norestricted /usr/local &amp;&amp; sudo chown -R $(whoami):admin /usr/local</p><p>成功执行，没有报操作不允许了</p><p>（如果想重新开启安全设置，则重复1、2步骤，输入csrutil enable就可以了）</p><p>更新rvm工具：curl -L get.rvm.io | bash -s stable</p><p>rvm install 2.4.2（这次可以正确安装ruby了，别问我为什么是2.4.2版本）</p><p>然后就是安装zookeeper</p><p>brew install zookeeper（这次也正确安装了）</p><p>后来又重启过一次，发现我的mysql不能开机启动了</p><p>在系统偏好设置最下方找到MySQL的图标，打开后发现mysql已经停止，且有一行警告：the /usr/local/mysql/data directory is not owned by the ‘mysql’ or ‘_mysql’ user</p><p>这个好办：sudo chown -R mysql /usr/local/mysql/data</p><p>然后就可以启动mysql了</p><p>自从长乔帮主走后，苹果办事越来越不上心了，哪怕是自己的OSX系统，伤心……估计还会有不少童鞋遇到我类似的情况，不妨一试</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十四)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-14/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-14/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-14/title1.jpg" alt="title1"></p><a id="more"></a><h3 id="忽略点十四：gdb的使用"><a href="#忽略点十四：gdb的使用" class="headerlink" title="忽略点十四：gdb的使用"></a>忽略点十四：gdb的使用</h3><p>​    在Linux系统下如果想要调试一个项目，我们应该怎么做？</p><p>​    有些童鞋可能会说：IDE呀！</p><p>​    没毛病老哥～非常标准的答案。除此之外，我们还可以使用gdb，为什么使用gdb，它有什么优势呢？它可以在终端下使用，它短小精悍，功能强大～</p><p>​    嗯嗯嗯，我就是这样说服自己的～</p><p>​    要注意！！使用gdb前，我们在编译项目文件时需加<code>-g</code>作为一个编译参数(否则你将看不见函数名、变量名，而只能看到运行时的内存地址)，再通过gdb运行可执行文件，例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o program -g main.c</span><br><span class="line">gdb ./program</span><br></pre></td></tr></table></figure><p>​    执行完上述命令，会看到关于 gdb 的说明和如下所示的调试命令行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>​    </p><p>​    关于gdb的基本使用：</p><p>​        ——输入<code>l</code>（list 首字母)gdb 会列出10行代码，<code>l</code>后可加参数代表从第参数行开始列出（例如希望列出第 2 到11行时，我们可以写<code>l 2</code>）</p><p>​    ——输入<code>b</code>（breakpoint首字母），表示设置程序运行的断点，程序运行到断点处就会暂停运行。<code>b</code>后既可以加函数名作参数，使程序在调用某函数时暂停；也可以加行号作为参数，使程序在运行至某一行时暂停。</p><p>​    ——输入<code>d</code>（Delete breakpoint简写），对应b命令，用于删除断点</p><p>​    ——输入<code>i b</code> ：(info breakpoints简写), 用于查看断点信息</p><p>​    ——输入<code>r</code>（run 首字母），程序会开始运行，并在第一个断点处暂停</p><p>​    ——输入<code>q</code>  (quit首字母)，退出GDB调试环境</p><p>​    ——输入<code>help [cmd]</code> , 如果制定了cmd命令，则显示该命令说明 否则显示全部</p><p>​    ——直接回车：重复上一步命令</p><p>​    ——输入<code>p 表达式</code>（print 的首字母） 表示在当前断点处运行该表达式并查看它的值。例如<code>p ++age[0]</code>表示我们希望让<code>age[0]</code>自增并查看自增后的值（表达式会对之后程序运行造成影响）</p><p>​    ——输入<code>finish</code> ：结束函数</p><p>   ——输入<code>s</code> (step首字母) 程序会执行下一行代码，如果此行代码中有函数调用，则进入该函数</p><p>​    ——输入<code>n</code>（next 的首字母）程序会执行下一行代码，如果此行代码中有函数调用一并执行</p><p>​    ——输入<code>c</code>（continue 的首字母）程序会继续执行到下一个断点处并暂停（如果没有断点就会执行直到结束）</p><p>​    以上就是gdb的简单用法，具体用法请参考官方文档～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十三)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-13/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-13/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-13/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十三：文件操作"><a href="#忽略点十三：文件操作" class="headerlink" title="忽略点十三：文件操作"></a>忽略点十三：文件操作</h3><p>​    我们要想对文件进行读取或写入，需要有一个能够访问到该文件的文件指针（FILE类型）,这样我们就能通过文件指针对文件进行操作啦！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE *fp;//声明文件指针</span><br><span class="line">fp = fopen(文件路径, 访问模式);//指向文件，第一个参数为字符串</span><br></pre></td></tr></table></figure><p>​    关于访问模式：    ——只读：“r”   </p><p>​                    ——只写（覆盖）： “w” </p><p>​                    —— 文件末尾追加： “a”    </p><p>​                    ——可读可写： “r+”或“w+”</p><p>​                    ——二进制文件：“b”</p><p>​                    ——文本文件：“t”</p><p>​    //访问模式可以叠加，例如”rb”代表读取二进制文件</p><p>​    之后我们就可以对文件进行操作啦（如fgetc()函数（读取）和fputc()函数（写入））</p><p>​    ——关于读取：文件指针指向文件后，通过<code>fgetc(fp);</code>获得当前指针之后位置的一个字符，每获得一个字符指针就会自动向后移动一个字符（如果到达文件尾部则会返回<code>EOF</code>）</p><p>​        ——关于写入：通过<code>fputc(‘字符’, fp);</code>方式将字符写入到与<code>fp</code>关联的文件中</p><p>​    文件指针不再使用后需断开关联，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fclose(fp);//若不加此句，程序正常结束后系统会自动为打开的文件调用fclose</span><br></pre></td></tr></table></figure><p>​    举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//省略代码</span><br><span class="line">FILE *p1 = fopen(&quot;路径1&quot;, &quot;r&quot;);</span><br><span class="line">FILE *p2 = fopen(&quot;路径2&quot;, &quot;w&quot;);</span><br><span class="line">char c;</span><br><span class="line">while ((c = fgetc(p1)) != EOF) &#123;//把一个文件内容复制到另一个文件</span><br><span class="line">    fputc(c, p2);</span><br><span class="line">&#125;</span><br><span class="line">fclose(p1);</span><br><span class="line">fclose(p2);</span><br></pre></td></tr></table></figure><h4 id="注意！！！！"><a href="#注意！！！！" class="headerlink" title="注意！！！！"></a>注意！！！！</h4><p>​        在给文件指针命名时，不能使用 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 这三个名字，因为这三个名字是系统内置用于标准输入、标准输出、标准错误的文件指针名</p><p>​    我们可通过 <code>fgetc(stdin);</code> 获得来自标准输入的字符</p><p>​        通过 <code>fputc(ch, stdout);</code> 将 <code>ch</code> 字符输出到标准输出</p><p>​        通过 <code>fputc(ch, stderr);</code> 将 <code>ch</code> 字符输出到标准错误</p><p>​    </p><p>​    除<code>fgetc</code>和<code>fputc</code>外，我们还可以使用<code>fscanf</code>和<code>fprintf</code>函数</p><p>​    我们可以使用fscanf通过文件指针读取：</p><p>​    也可以使用fprintf通过文件指针写出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fscanf(p1, &quot;%c&quot;, &amp;a);//通过文件指针p1获取字符并存储到a中</span><br><span class="line">fprintf(p2, &quot;%c&quot;, a);//通过文件指针p2将字符a写入文件中</span><br></pre></td></tr></table></figure><p>​    这两个函数是不是感觉有点眼熟？对！大家熟悉的<code>scanf</code>和<code>printf</code> 和它们长得很像，那它们之间有关系吗？</p><p>​        答案是有的。<code>scanf</code>可以看作是 <code>fscanf</code>的特例</p><p>​                         <code>printf</code>可以看作是<code>fprintf</code> 的特例</p><p>​    至于为什么，看下面的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fscanf(stdin, &quot;%c&quot;, &amp;a);//等价于下一行</span><br><span class="line">scanf(&quot;%c&quot;, &amp;a);</span><br><span class="line"></span><br><span class="line">fprintf(stdout, &quot;%c&quot;, a);//等价于下一行</span><br><span class="line">printf(&quot;%c&quot;, a);</span><br></pre></td></tr></table></figure><p>​    嗯嗯，上面也说啦，stdin和stdout的实质也是文件指针，分别代表从控制台获取，输出到控制台。</p><p>​    当然啦，stdin和stdout也可以通过fclose关掉，大家可以试一下关掉后还能进行scanf和printf嘛～ 赶紧跑路hahaha</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十二)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-12/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-12/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-12/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十二：main函数参数"><a href="#忽略点十二：main函数参数" class="headerlink" title="忽略点十二：main函数参数"></a>忽略点十二：main函数参数</h3><p>​    大家都知道，main函数的完整格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这两个参数有什么用呢？</p><p>​    <code>main</code>函数第一个参数是整数型，代表命令行参数的个数（系统依据用户输入的参数个数自动生成，非手动输入），第二个参是<code>char *argv[]</code>，也就是char型指针数组，用于储存用户从命令行中传进来的参</p><p>​    例如：在命令行中输入<code>./main hello world</code></p><p>​    此时，<code>argc</code>为 <code>3</code>，<code>argv[0]</code>为<code>./main</code>，<code>argv[1]</code>为<code>hello</code>，<code>argv[2]</code>为<code>world</code></p><p>​    命令行参数默认是由空格分隔，但如果某个参数中含空格我们应该怎么办</p><p>这时我们在输入含空格的参数时要用引号将整个参数包裹起来，例如：</p><p>​    执行<code>./main “hello world” is my greet</code></p><p>​    此时，<code>argc</code>为 <code>5</code>，<code>argv[0]</code>为<code>./main</code>，<code>argv[1]</code>为<code>hello world</code>，<code>argv[2]</code>为<code>is</code>，<code>argv[3]</code>为<code>my</code>，<code>argv[4]</code>为<code>greet</code></p><h5 id="易错点！！！！"><a href="#易错点！！！！" class="headerlink" title="易错点！！！！"></a>易错点！！！！</h5><h5 id="int-main-int-arc-char-argv-中argc取的不是main函数的参数个数！！！"><a href="#int-main-int-arc-char-argv-中argc取的不是main函数的参数个数！！！" class="headerlink" title="int main(int arc, char **argv)中argc取的不是main函数的参数个数！！！"></a>int main(int arc, char **argv)中argc取的不是main函数的参数个数！！！</h5><p>​    main函数个数固定是2！！argc取的是命令行中键入的参数个数！！而不是main函数的参数个数</p><p>​    关于参数的使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;//**argv等价于*argv[]</span><br><span class="line">    for (int i = 0; i &lt; argc; i ++) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    main函数的参数也挺有用的，比如你可以设置进入一个软件的两种模式</p><p>​    比如当<code>strcmp(argv[1], “master”) == 0</code>时，进入该软件的管理员模式，其余情况或者无参时进入用户模式等等。</p><p>​    除了上述，main函数参还有很多黑科技！！！等待大家去发现，哈哈哈～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十一)</title>
      <link href="/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-11/"/>
      <url>/2018/10/06/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-11/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/06/C语言查缺补漏-11/title.jpg" alt="title"></p><a id="more"></a><p>[TOC]</p><h2 id="忽略点十一：make命令与Makefile文件"><a href="#忽略点十一：make命令与Makefile文件" class="headerlink" title="忽略点十一：make命令与Makefile文件"></a>忽略点十一：make命令与Makefile文件</h2><p>​    对于C/C++项目，在编译时我们需要把每个模块的代码都生成为目标文件，然后再将目标文件联编生成一个可执行文件。</p><p>​    编译要输入这么多命令，每次修改一点内容就要重新编译整个工程，是不是特别恶心！！！</p><p>​     这时候，上帝就出现了——<code>make</code>命令，它可以读取当前路径下的<code>Makefile</code>文件，并根据<code>Makefile</code>中的规则描述把源文件生成为可执行的程序文件</p><p>​    注意，Makefile文件无后缀名！！</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>​    <code>Makefile</code>文件中包含了一系列形式如下的规则（makefile三要素：目标、依赖、规则命令）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标: 依赖1 依赖2 ...</span><br><span class="line">命令</span><br></pre></td></tr></table></figure><p>​    注意！！！每条规则的命令前，必须有一个制表符’\t‘    </p><p>​    为了提高效率，命令只有在需求发生变化后才会真正执行</p><h3 id="存在多条规则"><a href="#存在多条规则" class="headerlink" title="存在多条规则"></a>存在多条规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main: a.o m.o</span><br><span class="line">    gcc -o main a.o m.o</span><br><span class="line">m.o: m.c</span><br><span class="line">    gcc -c -o m.o m.c</span><br><span class="line">a.o: a.c</span><br><span class="line">    gcc -c -o a.o a.c</span><br></pre></td></tr></table></figure><p>​      我们想生成哪一个，就可以在<code>make</code>命令后加上需要生成的目标名称,例如：<code>make a.o</code></p><p>​    注意!！在我们执行<code>make main</code>时，<code>make</code>命令发现<code>a.o</code>和<code>m.o</code>不存在，就会自动生成它们（没有<code>a.o</code>和<code>m.o</code>的规则也能生成）</p><p>​    为什么没有a.o和m.o规则也能生成呢？因为makefile文件默认生成.o文件格式为：\$(CC)  \$(CFLAGS)  -c  -o 名.o  名.c         </p><p>​    而CC默认值为cc，CFLAGS默认值为空（可通过修改CC和CFLAGS来修改对应的编译环境与参数（如-std -Wall等等））</p><p>​    执行makefile文件中的第一条规则可以在命令行中简写成make，例如上边代码中执行<code>make</code>相当于执行<code>make main</code></p><h3 id="删除与伪目标"><a href="#删除与伪目标" class="headerlink" title="删除与伪目标"></a>删除与伪目标</h3><p>​    可以利用makefile规则添加删除功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -f a.o m.o main//rm命令表示删除，-f表示强制</span><br></pre></td></tr></table></figure><p>​    以上规则有一个Bug——就是当已经存在clean文件，rm命令就不执行了（而且执行一次<code>make clean</code> 就会产生clean文件，该命令最多只能执行一次）</p><p>​    这时我们可以通过 <code>.PHONY</code> 来声明clean为伪目标来解决上述问题（系统不会检查伪目标是否存在，且不会通过规则生成该目标文件）上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    rm -f array.o main.o main</span><br></pre></td></tr></table></figure><h3 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bojfiles = main.o a.o b.o//变量的定义</span><br><span class="line"></span><br><span class="line">main: $(objfiles)//变量的使用</span><br></pre></td></tr></table></figure><p>makefile常用匹配符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$@//目标</span><br><span class="line">$^//全部依赖</span><br><span class="line">$&lt;//第一个依赖</span><br><span class="line">$?//第一个变化的依赖</span><br></pre></td></tr></table></figure><h3 id="makefile常用函数"><a href="#makefile常用函数" class="headerlink" title="makefile常用函数"></a>makefile常用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//wildcard用于文件匹配</span><br><span class="line">srcfiles = $(wildcard *.c)</span><br><span class="line"></span><br><span class="line">//patsubst用于内容替换</span><br><span class="line">objfiles = $(patsubst %.c,%.o,$(srcfiles))//将srcfiles的所有.c替换为.o</span><br></pre></td></tr></table></figure><h3 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 执行时不想输出此条命令，在规则命令前加@</span><br><span class="line">2. 如果当前命令执行错误还想继续往下执行，在规则命令前加-</span><br><span class="line">3. 如果想要运行具体的makefile文件，用make -f 文件名</span><br></pre></td></tr></table></figure><p>抛出一个较为完整的<code>Makefile</code> 栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 井号开头的行是一个注释</span><br><span class="line"># 设置 C 语言的编译器</span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"># -g 增加调试信息</span><br><span class="line"># -Wall 打开大部分警告信息</span><br><span class="line">CFLAGS = -g -Wall</span><br><span class="line"></span><br><span class="line"># 设置变量</span><br><span class="line">MAINOBJS = main.o array.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">main: $(MAINOBJS)</span><br><span class="line">    $(CC) $(CFLAGS) -o main $(MAINOBJS)</span><br><span class="line">    #定义的变量可通过$(变量名)使用</span><br><span class="line"></span><br><span class="line">array.o: array.c array.h</span><br><span class="line">    $(CC) $(CFLAGS) -c -o array.o array.c</span><br><span class="line"></span><br><span class="line">main.o: main.c array.h</span><br><span class="line">    $(CC) $(CFLAGS) -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f $(MAINOBJS) main</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-05博客搭建进度</title>
      <link href="/2018/10/05/18-10-05%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/05/18-10-05%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>​                                            <img src="/2018/10/05/18-10-05博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接(10.03更新)</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载 10.03更新)</p><p>​    ——提供博文百度搜索功能(需审核 10.03更新)</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名(10.03更新)</p><p>​    ——代码托管从github转到coding，优化网速(10.03更新)</p><p>​    ——修正主页博文标签跳转错误(10.03更新)</p><p>​    ——新增弹出式音乐播放器</p><p>​    ——新增主页博文出场特效</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让hexo博文被百度收录</title>
      <link href="/2018/10/04/%E5%A6%82%E4%BD%95%E8%AE%A9hexo%E5%8D%9A%E6%96%87%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/"/>
      <url>/2018/10/04/%E5%A6%82%E4%BD%95%E8%AE%A9hexo%E5%8D%9A%E6%96%87%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/04/如何让hexo博文被百度收录/title.jpg" alt="title"></p><a id="more"></a><p>​    建了博客，大家可能会发现，必须得进了博客主页后才能查看博文，没有办法通过百度搜索博文的方式，进入主页中对应的博文。</p><p>​    这样会导致很少人发现你的博文（除了真爱哈哈哈），这怎么能行呢！！！所以，我们需要让百度收录自己的博客，具体步骤如下：</p><h3 id="——Step1-让百度收录你的域名"><a href="#——Step1-让百度收录你的域名" class="headerlink" title="——Step1:让百度收录你的域名"></a>——Step1:让百度收录你的域名</h3><p>​    很简单，就是百度搜索自己的域名，如果搜索不到，会出现“很抱歉！没有找到xxxx相关的网页”，这时候底下会出现 “提交网址”给我们 的超链接，我们点进去</p><h3 id="——Step2-验证网站的所有权"><a href="#——Step2-验证网站的所有权" class="headerlink" title="——Step2:验证网站的所有权"></a>——Step2:验证网站的所有权</h3><p>​    登录<a href="https://ziyuan.baidu.com" target="_blank" rel="noopener">百度站长</a>平台 , 在站点管理中点击添加网站，然后输入你的域名地址（加前缀www）</p><p>​    在选择完网站的类型后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证,html标签验证和cname解析验证，使用哪一种方式都可以。具体流程在官方会有提示，就不再重复了</p><h3 id="——Step3-生成网站地图"><a href="#——Step3-生成网站地图" class="headerlink" title="——Step3:生成网站地图"></a>——Step3:生成网站地图</h3><p>​    我们先安装sitemap插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save12</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>​    再修改博客路径下的配置文件（非主题）中的url站点地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: #在这儿填写你的博客域名</span><br><span class="line">root: /</span><br><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>​    执行完之后就会在博客路径下生成sitemap.xml文件和baidusitemap.xml文件，可以通过<a href="http://此处填你的域名/baidusitemap.xml" target="_blank" rel="noopener">http://此处填你的域名/baidusitemap.xml</a>,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件 </p><h3 id="——Step4-向百度提交链接"><a href="#——Step4-向百度提交链接" class="headerlink" title="——Step4:向百度提交链接"></a>——Step4:向百度提交链接</h3><p>​    找到百度站长平台-&gt;网站支持-&gt;数据引入-&gt;链接提交，我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap</p><p>​    大家可以任选一种方式进行提交，具体流程官方会有提示和帮助，就不一一列举了。</p><p>​    然后，我们的博客就被百度收录啦，可以通过文章名百度一下就能找到对应的文章。（当然啦，这个需要一定的时间收录，以百度的速度，大概需要个半月吧 Orz～）</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(十)</title>
      <link href="/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-10/"/>
      <url>/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-10/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/04/C语言查缺补漏-10/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点十：-ifndef与-endif"><a href="#忽略点十：-ifndef与-endif" class="headerlink" title="忽略点十：#ifndef与#endif"></a>忽略点十：#ifndef与#endif</h3><p>​    印象中两者在C/C++项目创建头文件时自动添加，一直没有深究它的意义，决定跟大家讲一下它的用法，顺便也是对自己的查缺补漏</p><p>​    要将他们，首先要说一下项目，对于C语言项目来说，多文件中的每个文件的特殊全局变量，类型定义，函数可能需要在多个文件中被使用，这时可将这些全局变量，类型定义，函数声明单独写成一个头文件</p><p>​    这些头文件一般采用  源文件名.h  命名，在需要用到该头文件的文件中采用#include “源文件名.h” 引用（注意不是尖括号&lt;&gt;，而是””）,不仅源文件可以引用头文件，头文件也可以引用头文件。</p><p>​    这时候，会出现一种情况：源文件1.c中引用2.h和3.h头文件，而2.h头文件中也引用了3.h头文件。    这时3.h头文件被引用了两次，有可能会造成函数，变量的重复声明！！！</p><p>​    为了避免这一种情况的出现，我们可以在3.h中定义一个宏：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define 宏名</span><br></pre></td></tr></table></figure><p>​    只要这个宏定义过，就跳过整个3.h的整个内容</p><p>​    如何实现这一点呢？</p><p>​    对，就是利用#ifndef 宏名和#endif，格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef 宏名//判断是否声明过该宏名，如果声明过，直接跳到#endif</span><br><span class="line">#define 宏名//如果没有声明过，声明该宏名</span><br><span class="line">//.h文件内容</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>​    这样又会造成一个问题，若2.h的验证宏名为p（即#ifndef后声明的宏名），3.h的验证宏名也为p，那么先引用2.h，后引用3.h，会造成3.h引用不上。也就是说，必须得保证每个头文件的#ifndef后的宏名都不一样！！！</p><p>​    因此，此类宏名有一个固定格式，即：工程名 _ 路径名_ 文件名_ H_ </p><p>​    这样就能避免重名的风险</p><p>​    以上就是#ifndef和#endif的全部，Over！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(九)</title>
      <link href="/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-9/"/>
      <url>/2018/10/04/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/04/C语言查缺补漏-9/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点九：共用体与枚举类型"><a href="#忽略点九：共用体与枚举类型" class="headerlink" title="忽略点九：共用体与枚举类型"></a>忽略点九：共用体与枚举类型</h3><p>​    共用体？What？它是什么，上了两年大学的我有点懵逼。共用体已然成了我C语言的盲区。</p><p>​    存在必然有它的意义，所以恶补了一下有关共用体的知识。</p><p>​    在我的理解里，共用体和上一篇博文所介绍的结构体，都是用来存储不同数据类型的“容器”。</p><p>​    那么他们两个的区别呢？从上上篇查缺补漏系列博文中 <a href="http://www.ivan-zcy.top/2018/10/03/C语言查缺补漏-7/">跳转至查缺补漏（七）</a>，我们知道结构体不同类型类型成员按照内存对齐规则，“排队”占用内存，而共用体，则是所有类型成员共用同一块内存（也就是说他们的起始位置都是从0开始）。</p><p>​    既然所占用内存都是从0开始，那么共用体有两个特征：</p><h3 id="——成员不会同时出现使用"><a href="#——成员不会同时出现使用" class="headerlink" title="——成员不会同时出现使用"></a>——成员不会同时出现使用</h3><p>后面出现的成员会覆盖掉之前成员的内容(也会相互影响)，因为两者的内存地址都是从0开始的，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union A &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">//省略代码</span><br><span class="line">A p1;</span><br><span class="line">p1.a = 1; p1.b = 2;</span><br><span class="line">printf(&quot;%d %d\n&quot;, p1.a, p1.b);//结果p1.a，p1.b输出都为2</span><br><span class="line">p1.a++;</span><br><span class="line">printf(&quot;%d %d\n&quot;, p1.a, p2.b);//结果p1.a, p1.b都输出为3</span><br></pre></td></tr></table></figure><h3 id="——收尾："><a href="#——收尾：" class="headerlink" title="——收尾："></a>——收尾：</h3><p> 共用体所占内存的总大小，必须是它内部最大成员所占内存大小的整数倍(像数组，结构体等成员在计算时按其成员的最大成员所占内存算)，不是要补齐</p><p>给大家上份代码理解一手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union A &#123;</span><br><span class="line">    int a;//所占内存地址为0~3</span><br><span class="line">    int b;//所占内存地址为0～3</span><br><span class="line">    char s[10]; //所占内存为0～9</span><br><span class="line">&#125;;//共用体A总共所占内存地址为0～11</span><br><span class="line"></span><br><span class="line">union B &#123;</span><br><span class="line">    double t;//所占内存地址为0～7</span><br><span class="line">    A a;//所占内存地址为0～11</span><br><span class="line">    int b[3];//所占内存内存地址0～11</span><br><span class="line">&#125;;//共用体B总共所占内存地址为0～15</span><br></pre></td></tr></table></figure><p>在共用体A中：</p><p>​    int类型a为4字节，所以占用0～3位置</p><p>​    int类型a为4字节，所以占用0～3位置</p><p>​    char型数组s中最大成员单个char为1字节，而数组长度为10，所以占用0～9位置</p><p>​    在共用体A中，最大成员为int型的4字节，所用占用内存大小为4的倍数，由于最大占用空间为10，所以共用体至少占用内存位置为0～11</p><p>在共用体B中：</p><p>​    double类型t为8字节，所以占用0～7位置</p><p>​    A类型a中最大成员为int类型为4字节，A类型总的内存占用为12字节，所以占用0～11位置</p><p>​    int型数组b中最大成员单个int为4字节，而数组长度为3，所以占用0～11位置</p><p>​    在共用体B中，最大成员为double型的8字节，所用占用内存大小为8的倍数，由于最大占用空间为12，所以共用体至少占用内存位置为0～15</p><p>​    </p><p>由于共用体特别节省内存，所以大家不能学我，它在C语言中是不容忽略的！！！（比如用于存储IPV4，IPV6地址，可用共用体来存储）</p><p>​    枚举类型大学期间使用次数仅仅比共用体好上那么一丢丢，举个枚举类型的栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum week &#123;</span><br><span class="line">    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday//注意，最后没有分号！！！！！</span><br><span class="line">&#125;;</span><br><span class="line">//省略代码</span><br><span class="line">week now = Sunday;</span><br></pre></td></tr></table></figure><p>关于枚举类型只要记住两点就可以：</p><h5 id="——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）"><a href="#——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）" class="headerlink" title="——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）"></a>——枚举类型只能由整数成员组成，每个成员对应一个整数编号（默认从0开始）</h5><p>​    例如上边代码，默认Sunday的值为0，Monday的值为1，一直到Saturday的值为6</p><h5 id="——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此-1"><a href="#——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此-1" class="headerlink" title="——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此+1"></a>——枚举类型的值可相同，未显性赋值的成员将从它前一个显性编号的成员以此+1</h5><p>​    例如以下代码中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum week &#123;</span><br><span class="line">    Sunday = 1, Monday, Tuesday, Wednesday = 0, Thursday, Friday, Saturday//注意，最后没有分号！！！！！</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    上边代码中，Sunday为1，Monday为2，Tuesday为3，Wednesday为0，Thursday为1，Friday为2， Saturday为3</p><p>​    好啦，共用体和枚举类型查缺补漏完毕！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-10-03博客搭建进度</title>
      <link href="/2018/10/03/18-10-03%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/10/03/18-10-03%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/03/18-10-03博客搭建进度/title.jpg" alt="title"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找(感谢帮忙拍版的鹏飞 09.29更新)</p><p>​    ——新增返回顶部的小火箭 (09.29更新）</p><p>​    ——优化布局(09.29更新)</p><p>​    ——新增巨巨们的友情链接(09.29更新)</p><p>​    ——主页新增邮箱与QQ跳转链接</p><p>​    ——引入“畅言”评论平台(位于留言界面，需等待3秒加载)</p><p>​    ——提供博文百度搜索功能（需审核）</p><p>​    ——关联<a href="http://www.ivan-zcy.com" target="_blank" rel="noopener">www.ivan-zcy.com</a>  与  <a href="http://www.ivan-zcy.top">www.ivan-zcy.top</a>  域名</p><p>​    ——代码托管从github转到coding，优化网速</p><p>​    ——修正主页博文标签跳转错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(八)</title>
      <link href="/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-8/"/>
      <url>/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/03/C语言查缺补漏-8/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点八：typedef的使用"><a href="#忽略点八：typedef的使用" class="headerlink" title="忽略点八：typedef的使用"></a>忽略点八：typedef的使用</h3><p>至于typedef，说起来实在是太丢人了！！这两年一直以为这个关键字是结构体的专属关键字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef 结构体类型 &#123;</span><br><span class="line">    //省略代码</span><br><span class="line">&#125; 类型别名</span><br><span class="line"></span><br><span class="line">类型别名 变量名//定义</span><br></pre></td></tr></table></figure><p>​    最近才发现，它不仅可以给结构体起别名，还可以给各种各样的类型起各种各样的别名，用法实在是太活了！</p><p>​    ——比如基本数据类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedefint size;</span><br><span class="line">size a;//等价于int a;</span><br></pre></td></tr></table></figure><p>​    ——比如数组：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int T[105];</span><br><span class="line">T a;//等价于 int a[105];</span><br></pre></td></tr></table></figure><p>​    </p><p>​    ——比如指针：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef char* ps;</span><br><span class="line">ps p1, p2;//等价于 char *p1, *p2;</span><br></pre></td></tr></table></figure><p>​    说到这儿，有一个代码大家需要注意：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* p1, p2;</span><br></pre></td></tr></table></figure><p>​    这里面的p1和p2分别是什么类型？</p><p>​    可能和大家想的不太一样（反正到时我是掉坑里了，尴尬），p1是char型指针，p2是char型。</p><p>​    ——用来定义与平台无关的东西：</p><p>​    比如定义一个叫Max_Double的浮点类型:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef long double Max_Double; //在一般平台的定义</span><br><span class="line">typedef double Max_Double;//在不支持long double平台的定义</span><br><span class="line">typedef float Max_Double;  //在不支持double平台的定义</span><br></pre></td></tr></table></figure><p>​    这样在跨平台时，只需要改一下Max_Double定义即可，比如之前博文写的通用long long写法 <a href="http://www.ivan-zcy.top/2018/09/30/C语言查缺补漏-3/">点这儿走你</a> 添加的&lt;inttype.h&gt;头文件就是采用了该方法。</p><p>​    要记住！！！typedef是定义了一种类型的新别名，不是简单的字符串替换！！比如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int* T;</span><br><span class="line">int mystrcmp(const T);</span><br></pre></td></tr></table></figure><p>​    const T等同于什么？我当初不假思索地以为是const int<em> 。然后现实给了我狠狠的打嘴巴子，它实际上相当于int</em> const。<strong>原因在于const给予了整个指针本身以常量性，也就是形成了常量指针int* const</strong> (简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。)</p><p>​    说到const int<em> 和 int</em> const等几个的区别：</p><p>​    ——const int  *a; 表示a是一个指针，可以任意指向int型常量或变量</p><p>​    ——int const    <em>a： 同const int </em>a</p><p>​    ——int * const a; 表示a是一个指针常量，初始化时必须固定指向一个int变量，之后就不能再指向别的地方了</p><p>​    </p><p>​    除此之外，typedef不能影响对象的存储特性！！！例如以下代码会出错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef static int T;   //无法与之前的&apos;typedef&apos;声明说明符结合使用</span><br></pre></td></tr></table></figure><p>​    最后再总结一句：typedef作用是为类型起别名，但不同于#define的简单替换！而且不同于#define替换时不作正确性检查，typedef是在编译时处理的。</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(七)</title>
      <link href="/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-7/"/>
      <url>/2018/10/03/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/03/C语言查缺补漏-7/titile.jpg" alt="titile"></p><a id="more"></a><h3 id="忽略点七-结构体内存对齐原则"><a href="#忽略点七-结构体内存对齐原则" class="headerlink" title="忽略点七:结构体内存对齐原则"></a>忽略点七:结构体内存对齐原则</h3><p>​    直到前几个星期做了一道选择题才知道，结构体元素的声明顺序可能影响结构体使用时所需的内存大小！！！</p><p>​    一查才知道，在C语言中结构体有内存对齐原则，这个原则可以总结为两点：</p><h5 id="——数据成员对齐规则："><a href="#——数据成员对齐规则：" class="headerlink" title="——数据成员对齐规则："></a>——数据成员对齐规则：</h5><p>​        结构体或联合体的数据成员，第一个数据成员放在offset为0的地方，以后每个成员存储的起始位置为该成员大小（当该成员为基本类型时）或者该成员的最大子成员大小(当该成员为数组，结构体等时)的整数倍位置</p><h5 id="——收尾："><a href="#——收尾：" class="headerlink" title="——收尾："></a>——收尾：</h5><p>​        结构体所占内存的总大小，必须是它内部最大成员所占内存大小的整数倍(像数组，结构体等成员在计算时按其成员的最大成员所占内存算)，不是要补齐</p><p>​    </p><p>​    对于以上的文字，大家可能会不理解，给大家上份代码理解一手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bb &#123;</span><br><span class="line">    int id;     //所占内存位置为0～3</span><br><span class="line">    double weight;//所占内存位置为8～15</span><br><span class="line">    char s[10];//所占位置为16~25</span><br><span class="line">&#125;;//整个结构体bb所占内存位置为 0~31</span><br><span class="line"></span><br><span class="line">struct aa &#123;</span><br><span class="line">    char name[2]; //所占内存位置为0～1</span><br><span class="line">    bbb;//所占内存位置为8~39;</span><br><span class="line">    int age;//所占内存位置为40~43;</span><br><span class="line">&#125;;//整个结构体aa所占内存位置0~47</span><br></pre></td></tr></table></figure><p>在结构体bb中：</p><p>​    int类型id为4字节，所以占用0～3位置</p><p>​    double类型weight为8字节，它的起始位置必须是8的整数倍，所以它的起始位置为8，占用位置为8～15</p><p>​    char型数组s中最大成员单个char是1字节，所以char数组的起始位置必须是1的整数倍，所以它的起始位置为16，而数组长度为10，总占用字节为10，所以占用位置为16～25</p><p>​    在结构体bb中，最大成员为double型的weight（有同学会说char s[10]最大，为什么不是char s[10]？因为char s的最大成员所占内存为1，s按照1进行比较），所以结构体bb总占用内存必须为8的整数倍，所以结构体bb的总内存地址为0～31</p><p>在结构体aa中：</p><p>​    char型数组name数组长度为2，单个char占1字节，数组总共占两字节，所以占用位置为0～1</p><p>​    bb型结构体b中最大成员为double型的weight，所以bb类型的起始位置必须是8的整数倍，也就是8，而结构体bb总占用内存是32，所以占用b位置为8～39</p><p>​    int型age为4字节，所以起始位置必须是4的整数倍，也就是40,所以它占用的位置是40～43</p><p>​    在结构体aa中，最大成员是结构体b（它的最大成员weight占用内存为8），所以结构体aa总占用内存必须是8的整数倍，所以结构体aa的总内存地址为0～47</p><p>​    </p><p>而这样：</p><p>​    讲到这儿，我们会有一个疑问，C语言为什么要有对齐原则呢？多浪费空间呀！大家可能知道桶排这种算法，以空间换时间。对齐原则也不例外，以耗费空间为代价，来加快寻址速度。</p><p>​    至于原理：如果一个结构的最大成员字长为w，那么系统会假设在这种体系结构上字长为w的数据使用最频繁，优先提高对w位数据操作。所有的数据访问都以w位对齐，这样需要传输的地址位减少，寻址自然就可以加快。</p><p>​    那么我们可以自己设定对齐规则吗？在规定的范围内是可以的，例如：</p><p>​    在文件开头加 #pragma pack(1)            //不对齐</p><p>​                #pragma pack(2)            //支持1,2对齐 </p><p>​                #pragma pack(4)            //支持1,2,4对齐</p><p>​                #pragma pack(8)            //支持1,2,4,8对齐（默认）</p><p>​    也就是说pack是多少，结构体中的成员它的初始位置最多是多少的倍数</p><p>​    </p><p>​    嗯嗯，就酱紫~</p><p>​    <a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>​    如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p><p>​                </p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(六)</title>
      <link href="/2018/10/02/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-6/"/>
      <url>/2018/10/02/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/02/C语言查缺补漏-6/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点六-内存空间，指针的指针"><a href="#忽略点六-内存空间，指针的指针" class="headerlink" title="忽略点六:内存空间，指针的指针"></a>忽略点六:内存空间，指针的指针</h3><p>​    介绍内存前，我们首先要知道一个由C/C++编译的程序占用的内存分为哪几个部分：</p><p>​    ——栈内存：C语言程序在编译时会被分配到内存的一片有限的连续区域，这部分内存会用于存储局部变量（函数中声明的变量），这部分连续区域被成为栈内存，由编译器自动分配和释放</p><p>​    ——堆内存：一般由程序员分配和释放，若程序员没有释放，则可能在程序结束时由操作系统回收（并不一定）。注意它与数据结构中的堆是两种东西！！</p><p>​    ——全局区(静态区，static)：程序的全局变量和静态变量都存放在这里， 初始化存放在一块区域，未初始化的放在相邻的另一块区域（BSS），程序结束后由系统释放。注意！它既不是栈内存，也不是堆内存！</p><p>​    ——文字常量区：也叫字面量池区。常量字符串就是放在这里，又系统释放。</p><p>​    ——程序代码区：存放函数体的区域</p><p>​    以下代码大家理解一手：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1;     //全局初始化区</span><br><span class="line">int b;   //全局未初始化区</span><br><span class="line">int main() &#123;</span><br><span class="line">    char s[] = &quot;abc&quot;;     //栈区</span><br><span class="line">    char *p = &quot;abc&quot;;      //“abc”在文字常量区（“abc”不是变量，也不是指针变量），p在栈区</span><br><span class="line">    static c = 0;    //全局初始化区</span><br><span class="line">    char *q = (char *) malloc (sizeof(char)); //q为栈区，申请的内容为堆区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    关于栈内存与堆内存：</p><p>​        ——栈内存：内存大小由系统预先设定，且是一块连续的内存空间，如果超出范围就是造成栈溢出，由于是系统分配的，所以速度较快，但程序猿无法控制。</p><p>​        ——堆内存：内存大小由程序猿手动申请，不一定连续，无内存范围限制（当然啦，肯定不能超过系统的有效内存），由于是程序猿分配的，一般速度较慢，但是用起来方便。（当然，如果使用不当的话，会造成严重的内存泄漏！！！而栈内存由于编译器自动回收内存，所以不会出现泄漏问题）</p><p>​    我们由上边知道了堆内存是需要程序猿申请和释放的。那么通过什么方法申请呢？用什么头文件呢？</p><p>​    ——关于头文件，sodlib.h头文件与malloc.h都有封装的相关申请与释放堆内存的函数，所以两个选择任意一个即可</p><p>​    ——关于方法，申请有两个函数</p><h5 id="一个是malloc函数，它的格式为："><a href="#一个是malloc函数，它的格式为：" class="headerlink" title="一个是malloc函数，它的格式为："></a>一个是malloc函数，它的格式为：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p = (int *) malloc (n * sizeof (int));</span><br></pre></td></tr></table></figure><p>​    sizeof (int)表示n个整形变量所需内存空间大小</p><p>​    malloc (sizeof (int))表示申请该大小的内存空间，返回值为void型的指针</p><p>​    (int *)表示强制转换成int类型的指针</p><h5 id="另一个是calloc函数，它个格式为："><a href="#另一个是calloc函数，它个格式为：" class="headerlink" title="另一个是calloc函数，它个格式为："></a>另一个是calloc函数，它个格式为：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p = (int *) calloc (n, sizeof(int));</span><br></pre></td></tr></table></figure><p>​    该代码意义同malloc一致，至于两者的区别，malloc申请后不初始化，而calloc申请后全部初始化为0</p><p>​    ——释放有一个函数free，它的用法如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free(p);//将p所指向的堆内存空间释放回系统</span><br><span class="line">p = NULL;//为避免错误使用p指针碰触已释放的内存，应设置为 p = NULL</span><br></pre></td></tr></table></figure><p>​    以上就是内存空间的申请和释放，可能会有童鞋说还有new,delete，这些属于C++中的内容，等到C++查缺补漏时再总结～</p><p>​    前一篇博文探究了指针作参的情况，这篇博文来研究一下指针的指针</p><p>​    废话不多说，上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">int **q = &amp;p;</span><br></pre></td></tr></table></figure><p>​    在上面代码中：</p><p>​    对于第一行来说：a是int类型变量</p><p>​    对于第二行来说：p为变量a的地址(&amp;a)，而*p为a的值</p><p>​    对于第三行来说，q为指针变量p的地址，也就是&amp;p，而*q为p的值，也就是a的地址(&amp;a)</p><p>​    因此：*q = p = &amp;a           q = &amp;p</p><p>​    就是酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo加快访问速度</title>
      <link href="/2018/10/02/hexo%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/"/>
      <url>/2018/10/02/hexo%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/02/hexo加快访问速度/title.jpg" alt="title"></p><a id="more"></a><p>​    hexo+github访问速度超慢！！！这两天算是领悟到了它的龟速暴击。。。原因只有一个，托管网站的github是外网，访问外网慢是必然的。</p><p>​    有很多人博客采用hexo+github+coding方式，至于coding是什么？大家可以理解为中国版的github，如果把代码既托管到coding上，又托管到github上，让大陆的用户访问的是由coding托管的网站，歪果仁访问的是由github托管的网站，这样访问速度就能上去了。</p><p>​    hexo与github的步骤不再重复，全在之前的博客里 <a href="http://www.ivan-zcy.top/2018/09/30/Blog搭建流程-Mac系统完结帖/">点这里跳转</a> </p><p>​    完成上面步骤，我们接着往下走：</p><p>​    Step1:此时我们需要创建一个coding账号，然后添加一个项目，项目名为你的coding账号名，例如我的账号名是ivan-zcy，所以我新建的项目为ivan-zcy，注意要在初始化项目那一项打勾</p><p>​    <img src="/2018/10/02/hexo加快访问速度/1.png" alt="1"></p><p>​    </p><p>​    Step2:进入项目 -&gt; 设置 -&gt; 部署公匙 -&gt;新建部署公匙，给项目添加公匙SSH，ssh公匙获取方法和github一样，在之前博客 <a href="http://www.ivan-zcy.top/2018/09/30/Blog搭建流程-Mac系统完结帖/">点这里跳转</a>  第四步有详细的介绍。公匙名称可以不填，但是授予推送权限选项必须打勾，这样你才有写权限</p><p>​    Step3: 在你的域名管理平台中（比如阿里云，腾讯云之类的），域名 -&gt;管理-&gt; 解析域名，增加一条CNAME信息，记录值为 youruser.coding.me（youruser为你的coding用户名）例如我的：</p><p><img src="/2018/10/02/hexo加快访问速度/2.png" alt="2"></p><p>​    </p><p>Step4:等到第三步的解析生效（最长十分钟），在coding中，项目 -&gt; 代码 -&gt; Pages服务中，一键部署Pages。在Pages的设置里，自定义自己的域名并绑定（域名前加www.前缀）</p><p>Step5:在本地博客路径下，修改_config.yml下的deploy，改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">      github:</span><br><span class="line">        git@github.com:yourname/yourname.github.io.git,master</span><br><span class="line">      coding: </span><br><span class="line">        git@git.coding.net:yourname/yourname.git,master</span><br></pre></td></tr></table></figure><p>格式一定要正确！！！不然会报错！！！</p><p>Step6:</p><p>​    在本地博客路径下，执行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>Ok!这样本地博客就能同时同步到github和coding上了，访问你的域名会解析到coding平台上，速度比github快很多</p><p>最后！！！关于万恶的coding广告，每次跳转你的域名都会弹出coding的广告，有两个解决办法：</p><p>​    1.充钱即王道，198元包年。。。</p><p>​    2.在博客首页加入它的推广链接（只需要将以下代码加入到首页html任意位置即可），然后向官方申请去除广告（建议平民采用这种方法，大概一天审批时间，审批方法：主页头像 -&gt; 切换旧版 -&gt; 项目 -&gt; 代码 -&gt; Pages中）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>​    </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个特别搞笑的故事哈哈</title>
      <link href="/2018/10/02/%E4%B8%80%E4%B8%AA%E7%89%B9%E5%88%AB%E6%90%9E%E7%AC%91%E7%9A%84%E6%95%85%E4%BA%8B%E5%93%88%E5%93%88/"/>
      <url>/2018/10/02/%E4%B8%80%E4%B8%AA%E7%89%B9%E5%88%AB%E6%90%9E%E7%AC%91%E7%9A%84%E6%95%85%E4%BA%8B%E5%93%88%E5%93%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/02/一个特别搞笑的故事哈哈/title.jpg" alt="title"></p><a id="more"></a><h3 id="分享一个特别长的程序猿的故事："><a href="#分享一个特别长的程序猿的故事：" class="headerlink" title="分享一个特别长的程序猿的故事："></a>分享一个特别长的程序猿的故事：</h3><p><img src="/2018/10/02/一个特别搞笑的故事哈哈/1.jpeg" alt="1"></p><p><img src="/2018/10/02/一个特别搞笑的故事哈哈/2.jpeg" alt="2"></p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(五)</title>
      <link href="/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-5/"/>
      <url>/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/01/C语言查缺补漏-5/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点五-指针作参"><a href="#忽略点五-指针作参" class="headerlink" title="忽略点五:指针作参"></a>忽略点五:指针作参</h3><p>​    平时比赛很少用到指针（链表，动态数组都有对应的STL，字典树也可以用数组模拟），业精于勤荒于嬉，C语言的指针就这样被我遗忘了。。</p><p>​    之前博文说过，C语言的优势之一就是在于能够直接访问物理地址，C语言的一大特色就是指针！！所以，学C语言舍弃指针是非常不明智的选择，终归是要还以前忽略的债。。苦笑～</p><p>​    关于指针，自己忽略的部分有很多，这一篇主要讲一下关于指针作参的用法：</p><h4 id="——对于函数来说："><a href="#——对于函数来说：" class="headerlink" title="——对于函数来说："></a>——对于函数来说：</h4><p>​    它不像变量那样可以进行值传递，我们在将函数作参进行传递时，需要传递它的地址，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int g (int (*f)(int), int a) &#123;//定义</span><br><span class="line">    return f(a);</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">g(函数名, int型变量); //调用</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="——对于一维数组来说："><a href="#——对于一维数组来说：" class="headerlink" title="——对于一维数组来说："></a>——对于一维数组来说：</h4><p>​    它的格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f (int *p) &#123;//定义</span><br><span class="line">    //省略代码</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[5];</span><br><span class="line">f (a);//调用</span><br></pre></td></tr></table></figure><p>​    关于这个a，我对它的理解是数组的初始位置，它等价于&amp;a[0]。因为我们在声明指针指向a数组时，是通过 int *p = a来实现的。</p><h4 id="注意点！！！！"><a href="#注意点！！！！" class="headerlink" title="注意点！！！！"></a>注意点！！！！</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f (int a[5]) &#123;//定义</span><br><span class="line">    //省略代码</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[5];</span><br><span class="line">f (a);//调用</span><br></pre></td></tr></table></figure><p>​    对于 void f(int a[5])，参数int a[5]就真的是数组吗？</p><p>​    答案是否定的，这里如果真的把数组作为函数参数的话，需要分配临时的栈区执行拷贝等操作，会特别麻烦。所以编译器对代码进行了优化，把数组退化成了指针。从调用传入的是a（指针）就可以看出。</p><h4 id="——对于二维数组来说："><a href="#——对于二维数组来说：" class="headerlink" title="——对于二维数组来说："></a>——对于二维数组来说：</h4><p>它的格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f (int *p) &#123;//定义</span><br><span class="line">    //省略代码</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[5][5];</span><br><span class="line">f (a[0]);//调用 由一维数组可知，a[0]等价于&amp;a[0][0]，也等价于*a</span><br></pre></td></tr></table></figure><p>​    a[0]等同于二维数组的首地址，也是二维数组下标为0行的首地址，同理a[1]为下标为1行的首地址，以此类推。</p><p>​    下面的问题没想明白，欢迎大佬来为我解惑。</p><p>​    我的认识（不一定正确）：那么二维数组的a是什么呢？从上边我们可以知道，a[0], a[1]等等都是地址信息，把他们整体来看，就是一个一维的指针数组。那么a为这个一维指针数组的首地址，而*a就是a[0]的值，也就是二维数组的首地址，从下面代码中也可以证实我的观点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f(int *p) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[2][2] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">f(*a);</span><br></pre></td></tr></table></figure><p>​    最后结果输出 1，2，3，4，说明了*a 等价于a[0]，也就是二维数组的首地址</p><p>​    按上面的逻辑，<em>a等价于a[0]，那么a就是存储a[0]指针地址的地址，所以a的值应该与a[0]不相同，也就是与 </em>a不相同，所以以下代码会报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f(int *p) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">int a[2][2] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">f(a);</span><br></pre></td></tr></table></figure><p>可我通过以下代码输出发现，a的值等于 a[0]</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[2][2] = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">printf(&quot;%p\n&quot;, a);</span><br><span class="line">printf(&quot;%p\n&quot;, *a);</span><br></pre></td></tr></table></figure><p>输出为：</p><p><img src="/2018/10/01/C语言查缺补漏-5/515E7E54-C1C3-4E2B-A854-93D2AAD5748D.png" alt="515E7E54-C1C3-4E2B-A854-93D2AAD5748D"></p><p>很迷茫。。。希望有大佬能为我解惑～</p><h4 id="——对于结构体来说："><a href="#——对于结构体来说：" class="headerlink" title="——对于结构体来说："></a>——对于结构体来说：</h4><p>​    结构体指针和变量指针作参类似，但它的指针可通过 -&gt;符指向它的成员，举个栗子(截取遍历链表代码的一部分)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    node *next;</span><br><span class="line">&#125;</span><br><span class="line">void f(node *root) &#123;</span><br><span class="line">    while (root -&gt; next != NULL) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, root -&gt; val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//省略代码</span><br><span class="line">node root = &#123;a, NULL&#125;;</span><br><span class="line">f(&amp;root);</span><br></pre></td></tr></table></figure><p>​    root -&gt; val等价于 (*root).val</p><p>​    只要捋清楚每个变量所代表的意义，指针作参就不会那么迷糊了，就酱紫～</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(四)</title>
      <link href="/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-4/"/>
      <url>/2018/10/01/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/10/01/C语言查缺补漏-4/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点四-宏定义的使用与-、-用法"><a href="#忽略点四-宏定义的使用与-、-用法" class="headerlink" title="忽略点四:宏定义的使用与#、##用法"></a>忽略点四:宏定义的使用与#、##用法</h3><p>​    初学C语言时常常忽略宏定义的使用，因为觉得声明局部变量，全局变量，静态变量就够用了，所以忽略了宏定义的使用</p><p>​    上述想法完全是错误的，因为宏定义在系统编译时就将其全部替换，定义的变量不会在运行时候分配内存。所以它有无可替代的优点：效率特别高！！！不占用内存空间！！！</p><p>​    宏定义不仅可以定义变量，使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。</p><p>​    如果不使用宏定义，在发生函数调用时，需要保留调用函数的现场，以便子函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，当函数调用次数特别多的时候，这些时间的消耗是不可忽略的。</p><p>​    而使用宏定义就不会出现这个问题，因为它在预处理阶段即进行了宏展开，在执行时不需要转换。</p><p>宏定义有无参宏定义和带参数宏定义两种</p><h5 id="1-无参宏定义的一般形式为"><a href="#1-无参宏定义的一般形式为" class="headerlink" title="1.无参宏定义的一般形式为:"></a>1.无参宏定义的一般形式为:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define 宏名 字符序列    //宏名与字符序列之间用空格符分隔，用于替代后面的字符序列</span><br></pre></td></tr></table></figure><p>​    </p><p>​    ——每个宏定义都在源程序中单独占一行，换行符是宏定义的结束标志。如果一个宏定义一行不够时可采用续行的方法。续行是在按回车前先输入符号”/“</p><p>​    <strong>注意！！回车要紧接在符号”/“后，中间不能插入其它符号</strong></p><p>​    ——宏定义的有效范围称为辖域，辖域从定义开始到源文件末尾。可用预处理命令#undef终止宏定义名的辖域</p><p>​    ——宏名可被重复定义，重定义后会覆盖之前的字符序列</p><p>一般无参宏定义用于定义常量，比如定义数组长度（数组长度不能由变量定义，除了宏定义外，还可以使用const 关键字定义）</p><h5 id="2-带参宏定义的一般形式为"><a href="#2-带参宏定义的一般形式为" class="headerlink" title="2.带参宏定义的一般形式为:"></a>2.带参宏定义的一般形式为:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define 宏名(参数表) 字符序列  //参数间用逗号分隔，字符序列中应包含参数表中的参数</span><br></pre></td></tr></table></figure><p>​    <strong>注意！！宏名与左圆括号之间不允许有空白符</strong></p><h4 id="以下是易错点！！！！！！！！！！！！！"><a href="#以下是易错点！！！！！！！！！！！！！" class="headerlink" title="以下是易错点！！！！！！！！！！！！！"></a>以下是易错点！！！！！！！！！！！！！</h4><p>​    易错点一：大家要深入理解宏替换的“替换”两个字！例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define F(x) x * x</span><br></pre></td></tr></table></figure><p>​    如果a = 1, b = 2，那么F(a + b)为多少？</p><p>​    很多同学会认为是9，但是答案是5。</p><p>​    原因是替换！只是简单的替换！！！</p><p>​    F(x) = x <em> x = 1 + 2 </em> 1 + 2 = 5</p><p>​    就是酱紫。。所以代码需要改成#define F(x) (x) * (x) 才会输出9</p><p>​    在宏定义中，我们使用#把宏参数变为一个字符串</p><p>​    用##把两个宏参数连在一起（这里说的是在预处理是对源文件的操作）<br>​    例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define S(s)   #s </span><br><span class="line">#define F(a,b) int(a##e##b)</span><br></pre></td></tr></table></figure><p>​    </p><p>​    易错点二：</p><p>​    对于以下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define a 1e5</span><br><span class="line">const int b = 1e5;</span><br></pre></td></tr></table></figure><p>​    输出a和b的值，分别是多少呢？</p><p>​    a:   -272632256</p><p>​    b: 100000</p><p>​    所以，要想宏定义科学计数法，需：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define a int(1e5)</span><br></pre></td></tr></table></figure><p>​    此时a的值为100000</p><h3 id="关于宏中-和-的用法："><a href="#关于宏中-和-的用法：" class="headerlink" title="关于宏中#和##的用法："></a>关于宏中#和##的用法：</h3><p>在字符序列中：</p><p>​    用#可以把宏参数变为一个字符串</p><p>​    用##可以把两个宏参数连接在一起</p><p>例如下面代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define STR(s)     #s </span><br><span class="line">#define CONS(a,b) int(a##e##b)</span><br><span class="line">//...省略其余代码</span><br><span class="line">printf(STR(hello));           // 输出字符串&quot;vck&quot; </span><br><span class="line">printf(&quot;%d/n&quot;, CONS(1,5)); // 输出:100000</span><br></pre></td></tr></table></figure><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(三)</title>
      <link href="/2018/09/30/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-3/"/>
      <url>/2018/09/30/C%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/C语言查缺补漏-3/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点三-空格规范以及通用long-long类型的定义"><a href="#忽略点三-空格规范以及通用long-long类型的定义" class="headerlink" title="忽略点三:空格规范以及通用long long类型的定义"></a>忽略点三:空格规范以及通用long long类型的定义</h3><p>​    大一大二两年时间都没有注意过空格的规范，导致自己写的代码奇丑无比，被队友同学诟病 冷汗！</p><p>​    直到我看到另一份比我更丑的代码后，我才意识到代码的规范有多重要！！</p><h5 id="尤其是空格的合理使用！！！！"><a href="#尤其是空格的合理使用！！！！" class="headerlink" title="尤其是空格的合理使用！！！！"></a>尤其是空格的合理使用！！！！</h5><p>​    为了避免后来难改这种陋习，建议从刚开始学C语言就贯彻空格的使用规范</p><p>​        ——逗号，分号后加空格</p><p>​        ——运算符前后都需要加空格</p><p>​        ——if，switch等关键字与左括号之间加空格</p><p>​        ——函数名与左括号之间加空格</p><p>​        ——左花括号前，右花括号后加空格</p><p>​        —— -&gt;或者.后不能加空格！！</p><p>​    为了避免同学同事幽怨的目光，请妥善使用空格哈哈哈！！！</p><p>​    在ACM竞赛中，官方会提前告诉我们对于long long类型，我们是用%lld输出(Linux系统)，还是用%I64d输出(Windows系统) </p><p>​    不过，我们有一种兼容的写法（这个特别重要！因为这种写法兼容性好，真需要代码移植的时候就不需要挨个手动改了)</p><h5 id="注意，需要加inttypes-h头文件！！！"><a href="#注意，需要加inttypes-h头文件！！！" class="headerlink" title="注意，需要加inttypes.h头文件！！！"></a>注意，需要加inttypes.h头文件！！！</h5><p>​    通用写法: int64_t a;</p><p>​             printf (“%”PRId64”\n”, a);   </p><p>​    其中PRId64为宏替换，在Linux下为lld，在Windows下为I64d</p><p>​    除了int64_t (long long类型)以外,还有int32_t (int类型)，int16_t (short类型), int8_t (char类型)，uint64_t (unsigned long long类型)，uint32_t (unsigned int类型)，uint16_t (unsigned short类型), uint8_t (unsigned char类型)等等，就不一一列举了，大家可以自行百度！ </p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(二)</title>
      <link href="/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-2/"/>
      <url>/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/c语言查缺补漏-2/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点二：使用IED而忽略最基础的命令"><a href="#忽略点二：使用IED而忽略最基础的命令" class="headerlink" title="忽略点二：使用IED而忽略最基础的命令"></a>忽略点二：使用IED而忽略最基础的命令</h3><p>大一开始使用CodeBlocks来写C语言程序，后来用VS，再后来Xcode。最近才发现一个问题，自己竟然不会使用终端编译执行.C文件。这种最基本的东西，很遗憾在这两年学习中被我无情的忽略了。</p><p>​    第一步： cd到.c文件所在目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 路径地址</span><br></pre></td></tr></table></figure><p>​    第二步：编译源文件并生成可执行代码文件，举个例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc main.c//编译main.c文件，生成可执行文件(默认名a.out)</span><br><span class="line">$ gcc -o program main.c  //main.c为源文件，program为生成的可执行文件</span><br></pre></td></tr></table></figure><p>关于默认生成的a.out，它是临时性的可执行文件。如果同一路径下多个c语言源文件采用了默认编译，a.out中输出的内容为最后一个C语言源文件所执行的结果（也就是说之前源文件编译生成的a.out被覆盖掉了)</p><p>这时候就体现了 gcc -o 的-o的作用 它可以指定生成输出文件</p><p>以下到第三步之前是附加内容（除此之外</p><p>选项 -E 可以将test.c预处理输出（其中-E的功能是预处理test.c并输出到终端，不生成文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -E test.c -o test.i</span><br><span class="line">$ gcc -E test.c &gt; test.i        //其中&gt;为重定向符</span><br></pre></td></tr></table></figure><p>选项 -S 可以将test.c汇编成test.s文件（也就是从源文件-&gt;汇编代码)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -S  -o test.s test.c </span><br><span class="line">$ gcc -S test.c (简写 效果一样)</span><br><span class="line">$ gcc -S test.c &gt; test.s</span><br></pre></td></tr></table></figure><p>选项 -c 可将test.c编译输出到test.o文件 (编译过程中的中间文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c  -o test.o test.c </span><br><span class="line">$ gcc -c test.c (简写 效果一样)</span><br></pre></td></tr></table></figure><p>除此之外，还有选项 -g 用于增加调试信息，选项 -Wall用于打开大部分警告信息 ，-std=版本号用于选择标准（例如：-std=c99）等等，就不一一列举了，大家可以查相关文档</p><p>其中：    .i文件是进行预编译之后生成的文件，一般是引用头文件的内容和一些宏定义</p><p>​        .s文件是汇编语言源文件,一般是 .c 文件经过汇编器处理后的输出</p><p>​        .o文件程序编译中的目标文件（注意是编译中，不是最终！）里面包含了各个函数的入口标记与描述，程序执行还需要链接(link).链接就是把多个.o文件链成一个可执行文件。）</p><p>​    </p><p>​    第三步：执行可执行文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./program</span><br></pre></td></tr></table></figure><p>以上就是用命令行实现C语言的编译运行的全过程</p><p>对于项目（多文件），我们无法单个的编译运行，这时候我们应该怎么办呢？</p><p>​    第一步: 分别用-c命令编译每个.c文件(包括main函数文件)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c xxx.c</span><br></pre></td></tr></table></figure><p>我们会得到每个xxx.c文件的目标文件xxx.o</p><p>​    第二步:将主程序的目标代码与他们链接在一起</p><p>​    例如下面命令是将项目的所有目标代码xxx.o与main.o链接在一起，并输出了可执行文件program</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc main.o xxx.o xxx.o xxx.o -o program</span><br></pre></td></tr></table></figure><p>这样一个项目多文件代码就可以运行啦！</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言查缺补漏(一)</title>
      <link href="/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-1/"/>
      <url>/2018/09/30/c%E8%AF%AD%E8%A8%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/c语言查缺补漏-1/title.jpg" alt="title"></p><a id="more"></a><h3 id="忽略点一：C语言能够干什么？它的优势在哪？"><a href="#忽略点一：C语言能够干什么？它的优势在哪？" class="headerlink" title="忽略点一：C语言能够干什么？它的优势在哪？"></a>忽略点一：C语言能够干什么？它的优势在哪？</h3><p>首先，这是我们在学C语言前就应该了解的。总觉得大学的课程缺少一个体系，学完了之后，不知道能用它来做什么，或者说不知道用它处理什么东西好。</p><p>这是我刚开始学C语言时所忽略的地方，现在回头想想这个东西其实挺重要的。</p><p>C语言的优势是什么？</p><p>​    ——快！快！快！！！！C语言允许直接访问物理地址，可以直接对硬件进行操作。这是高级语言所无法比拟的。所以，越是经常反复使用的代码，越需要用这类语言实现。可能调用一次两次差距不明显，但调用次数多了，两者的运算差距就大了。</p><p>​    ——生成目标代码质量高，程序执行效率高。其本质还是上边所讲的，快！C语言相比汇编语言可读性好，易于调试和移植，而效率只比汇编程序生成的目标代码低10%～20%</p><p>​    ——至于它的可移植性，虽不是最好，但也有较高的可移植性</p><p>我们就要紧紧抓住它的优势，让它的优势最大化，所以我们最好把它用在以下几个方面：</p><p>​    ——C语言可用与操作系统上的编程，比方说自己写个内存管理啦服务器之类的</p><p>​    ——C语言用来设计操作系统，大部分的操作系统内核就是用C语言写的</p><p>​    ——关于网络传输协议的设计与实现，离不开C语言</p><p>​    ——嵌入式系统编程大部分也依赖于C语言</p><p>​    ——很多编译器也是通过C语言实现的</p><p>​    ——现如今C/C++语言也常常用于游戏开发</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用网站汇总(持续更新)</title>
      <link href="/2018/09/30/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2018/09/30/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB%E2%80%94%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/实用网站汇总——持续更新/title.jpg" alt="title"></p><a id="more"></a><p>以下是这几年积攒的全部家底了，哈哈哈！</p><p>在线编程平台:</p><p>​    计蒜客  <a href="https://www.jisuanke.com" target="_blank" rel="noopener">传送门</a>    ——灰常好用</p><p>​    hackerrank <a href="https://www.hackerrank.com" target="_blank" rel="noopener">传送门</a> ——国外学习各类语言的在线编译平台 除网速慢 其它特别棒 白瞎全哥给我推荐了 几乎没用过</p><p>​    在线编译 <a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">传送门</a> ——能在线编译10多种语言</p><p>网上学习平台:</p><p>​    维基百科 <a href="https://www.wikipedia.org" target="_blank" rel="noopener">传送门</a>  —— 涵盖方方面面</p><p>​    stackoverflow <a href="https://stackoverflow.com" target="_blank" rel="noopener">传送门</a> ——与程序相关的IT技术问答网站</p><p>​    海贼科技 <a href="https://www.haizeix.com" target="_blank" rel="noopener">传送门</a> ——信海贼 得永生</p><p>​    哔哩哔哩 <a href="https://www.bilibili.com" target="_blank" rel="noopener">传送门</a> ——里面啥都有 不容反驳！！！</p><p>​    Github <a href="https://github.com" target="_blank" rel="noopener">传送门</a> ——开源大法好</p><p>​    coding <a href="https://coding.net/" target="_blank" rel="noopener">传送门</a>  —— 国语版的Github？</p><p>​    CSDN <a href="https://www.csdn.net" target="_blank" rel="noopener">传送门</a> ——个人感觉CSDN是目前为止对我帮助最大的平台了</p><p>​    博客园 <a href="https://www.cnblogs.com" target="_blank" rel="noopener">传送门</a> —— 如果还有的话，那就是博客园</p><p>​    计蒜客  <a href="https://www.jisuanke.com" target="_blank" rel="noopener">传送门</a>    —— 伴随式学习课程 方便学习</p><p>​    网易云课堂 <a href="https://study.163.com" target="_blank" rel="noopener">传送门</a> —— 感觉国内最好的视频学习平台了</p><p>​    慕课网 <a href="https://coding.imooc.com/?mc_marking=5931f8e07e353edf2b94a098f44a062c&amp;mc_channel=bdqdkj" target="_blank" rel="noopener">传送门</a> ——和计蒜客类似</p><p>​    菜鸟教程 <a href="http://www.runoob.com" target="_blank" rel="noopener">传送门</a> ——各种语言的学习文档</p><p>​    易百教程 <a href="https://www.yiibai.com" target="_blank" rel="noopener">传送门</a> ——和菜鸟教程差不多</p><p>​    简书 <a href="https://www.jianshu.com" target="_blank" rel="noopener">传送门</a> ——里边有很多IT文章 特别赞</p><p>C语言：<br>​    stack overflow <a href="https://stackoverflow.com" target="_blank" rel="noopener">传送门</a>  ——C语言界的“知乎”<br>​    cplusplus <a href="http://www.cplusplus.com" target="_blank" rel="noopener">传送门</a>    ——C语言文档</p><p>ACM：</p><p>​    小白菜OJ <a href="http://caioj.cn" target="_blank" rel="noopener">传送门</a> ——简单基础，带视频讲解</p><p>​    洛谷 <a href="https://www.luogu.org/training/mainpage" target="_blank" rel="noopener">传送门</a> ——灰常好玩</p><p>​    HUD <a href="http://acm.hdu.edu.cn" target="_blank" rel="noopener">传送门</a> ——个人认为国内现在最繁忙的OJ了吧</p><p>​    POJ <a href="http://poj.org" target="_blank" rel="noopener">传送门</a> ——北大OJ</p><p>​    Project Euler <a href="https://projecteuler.net" target="_blank" rel="noopener">传送门</a> ——国外一个纯数学编程题的网站</p><p>​    华中理工VJ <a href="https://vjudge.net" target="_blank" rel="noopener">传送门</a> ——可以很方便的从各大OJ拉题</p><p>​    CodeForce <a href="http://codeforces.com" target="_blank" rel="noopener">传送门</a> ——比赛特别多 不过大多数都在半夜！ 平时不需要翻墙 注册时需要翻墙才能收到验证码</p><p>​    数论 <a href="https://www.cnblogs.com/linyujun/category/784324.html" target="_blank" rel="noopener">传送门</a> ——看过最好的数论博客</p><p>​    大佬 <a href="http://zory.cf" target="_blank" rel="noopener">传送门</a> ——分享一个经常看的大佬博客</p><p>机器学习类:</p><p>​    吴恩达课程+笔记 <a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">传送门</a>  ——黄海广博士翻译</p><p>数学类：</p><p>​    OEIS <a href="http://oeis.org" target="_blank" rel="noopener">传送门</a> ——国外的在线整数数列查询网站 啥也不说了 OEIS大法好</p><p>​    WolframMathWorld <a href="http://mathworld.wolfram.com" target="_blank" rel="noopener">传送门</a> ——国外数学网站</p><p>Linux：</p><p>​    Linux命令大全 <a href="http://man.linuxde.net/sub/目录基本操作" target="_blank" rel="noopener">传送门</a> ——全中文呀</p><p>面试题：</p><p>​    猿圈 <a href="https://st.oxcoder.com" target="_blank" rel="noopener">传送门</a> ——有针对于面试笔试的题库</p><p>​    牛客网 <a href="https://www.nowcoder.com" target="_blank" rel="noopener">传送门</a> ——同猿圈一样​    </p><p>​    </p><p>云服务平台：</p><p>​    DNSPOD <a href="https://www.dnspod.cn/Login?r=/console/dns//ivan-zcy.com" target="_blank" rel="noopener">传送门</a> ——第三方域名解析平台</p><p>​    阿里云 <a href="https://account.aliyun.com" target="_blank" rel="noopener">传送门</a> ——云服务的集成平台</p><p>​    景安 <a href="https://nssp.zzidc.com" target="_blank" rel="noopener">传送门</a> ——为什么是景安？没错，是贫穷！</p><p>​    GoDaddy <a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">传送门</a> ——国外域名商 买完后悔了 现在法律规定必须备案才能使用 要备案必须得转到国内。。</p><p>工具：</p><p>​    在线工具 <a href="https://tool.lu" target="_blank" rel="noopener">传送门</a> ——特别全的在线工具集合</p><p>​    ProcessOn <a href="https://www.processon.com" target="_blank" rel="noopener">传送门</a> ——在线绘图平台</p><p>​    超级简历 <a href="https://www.wondercv.com" target="_blank" rel="noopener">传送门</a> ——在线简历制作</p><p>​    知页 <a href="https://www.zhiyeapp.com/?utm_source=baidu&amp;utm_medium=sem&amp;utm_term=83594555225&amp;utm_content=21611848941&amp;uc_pagenum=1&amp;uc_adposition=cl2" target="_blank" rel="noopener">传送门</a> ——同超级简历一样</p><p>​    印象笔记 <a href="https://www.yinxiang.com/?utm_source=b1&amp;utm_medium=b1&amp;utm_term=aydtn" target="_blank" rel="noopener">传送门</a> ——记事本 可同步移动端</p><p>​    </p><p>前端类:</p><p>​    Iconfont <a href="http://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.3" target="_blank" rel="noopener">传送门</a> ——许许多多美观的图标</p><p>​    Font Awesome <a href="http://fontawesome.dashgame.com" target="_blank" rel="noopener">传送门</a> ——简洁大方的图标字体库</p><p>​    设计导航 <a href="http://hao.shejidaren.com" target="_blank" rel="noopener">传送门</a> ——前端所需的汇总平台</p><p>​    jQuery插件库 <a href="http://www.jq22.com" target="_blank" rel="noopener">传送门</a>    ——里面有好多很棒的特效</p><p>​    W3school <a href="http://www.w3school.com.cn/h.asp" target="_blank" rel="noopener">传送门</a> ——前端语言学习文档</p><p>​    花瓣网 <a href="http://huaban.com" target="_blank" rel="noopener">传送门</a> ——图片素材</p><p>​    模版王 <a href="http://www.mobanwang.com/mb/" target="_blank" rel="noopener">传送门</a> ——有许许多多网站模版 不过坑好多</p><p>​    Layui <a href="https://www.layui.com/doc/element/color.html" target="_blank" rel="noopener">传送门</a> ——关于前端的使用 它的颜色设计感很棒</p><p><a href="http://www.ivan-zcy.top">转载请注明出处！！！</a>  </p><p>如果有写的不对或者不全面的地方 可通过主页的联系方式进行指正，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog搭建流程(Mac系统完结帖)</title>
      <link href="/2018/09/30/Blog%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B-Mac%E7%B3%BB%E7%BB%9F%E5%AE%8C%E7%BB%93%E5%B8%96/"/>
      <url>/2018/09/30/Blog%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B-Mac%E7%B3%BB%E7%BB%9F%E5%AE%8C%E7%BB%93%E5%B8%96/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/30/Blog搭建流程-Mac系统完结帖/title.jpg" alt="title"></p><a id="more"></a><p>讲完这一篇hexo就算暂时性翻过去了 以后专注于算法和C++底层  加油加油！</p><h3 id="Step1-安装Node-js"><a href="#Step1-安装Node-js" class="headerlink" title="Step1 安装Node.js"></a>Step1 安装Node.js</h3><p>可通过以下两种方式在 Mac OS 上安装 node.js：</p><p>方式一： 在<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方下载网站</a>下载 pkg 安装包，直接点击安装即可</p><p>方式二： 使用 brew 命令来安装：</p><ul><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></li></ul><h3 id="Step2-安装Git"><a href="#Step2-安装Git" class="headerlink" title="Step2 安装Git"></a>Step2 安装Git</h3><p>首先查看电脑是否安装Git，终端输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure><p>安装过则会输出下表，然后跳过该步</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WMBdeMacBook-Pro:~ WENBO$ git</span><br><span class="line">usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]</span><br><span class="line">           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">These are common Git commands used in various situations:</span><br><span class="line"></span><br><span class="line">start a working area (see also: git help tutorial)</span><br><span class="line">   clone      Clone a repository into a new directory</span><br><span class="line">   init       Create an empty Git repository or reinitialize an existing one</span><br><span class="line"></span><br><span class="line">work on the current change (see also: git help everyday)</span><br><span class="line">   add        Add file contents to the index</span><br><span class="line">   mv         Move or rename a file, a directory, or a symlink</span><br><span class="line">   reset      Reset current HEAD to the specified state</span><br><span class="line">   rm         Remove files from the working tree and from the index</span><br><span class="line"></span><br><span class="line">examine the history and state (see also: git help revisions)</span><br><span class="line">   bisect     Use binary search to find the commit that introduced a bug</span><br><span class="line">   grep       Print lines matching a pattern</span><br><span class="line">   log        Show commit logs</span><br><span class="line">   show       Show various types of objects</span><br><span class="line">   status     Show the working tree status</span><br><span class="line"></span><br><span class="line">grow, mark and tweak your common history</span><br><span class="line">   branch     List, create, or delete branches</span><br><span class="line">   checkout   Switch branches or restore working tree files</span><br><span class="line">   commit     Record changes to the repository</span><br><span class="line">   diff       Show changes between commits, commit and working tree, etc</span><br><span class="line">   merge      Join two or more development histories together</span><br><span class="line">   rebase     Reapply commits on top of another base tip</span><br><span class="line">   tag        Create, list, delete or verify a tag object signed with GPG</span><br><span class="line"></span><br><span class="line">collaborate (see also: git help workflows)</span><br><span class="line">   fetch      Download objects and refs from another repository</span><br><span class="line">   pull       Fetch from and integrate with another repository or a local branch</span><br><span class="line">   push       Update remote refs along with associated objects</span><br><span class="line"></span><br><span class="line">&apos;git help -a&apos; and &apos;git help -g&apos; list available subcommands and some</span><br><span class="line">concept guides. See &apos;git help &lt;command&gt;&apos; or &apos;git help &lt;concept&gt;&apos;</span><br><span class="line">to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure><p>​    </p><p>​    如果没有显示上面内容，我们可以通过homebrew安装GIt，若未安装homebrew 则通过终端执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>​    随后执行一下命令进行Git的安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><h3 id="Step3-注册Github账号并新建仓库"><a href="#Step3-注册Github账号并新建仓库" class="headerlink" title="Step3 注册Github账号并新建仓库"></a>Step3 注册Github账号并新建仓库</h3><p>​    网站链接：<a href="https://github.com" target="_blank" rel="noopener">Github</a> </p><p>​    注册完账号后需新建一个仓库。注意！！新建的仓库名字必须是username.github.io。例如我username是ivan-zcy，那么仓库名字必须是ivan-zcy.github.io</p><h3 id="Step4-配置SSH-Key（可省略-建议配置）"><a href="#Step4-配置SSH-Key（可省略-建议配置）" class="headerlink" title="Step4 配置SSH Key（可省略 建议配置）"></a>Step4 配置SSH Key（可省略 建议配置）</h3><p>这一步能省略 但是配置后更新博客就不用每次都输入用户名密码了</p><p>步骤：<br>​    1 检查主机是否已存在SSH Key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .ssh</span><br><span class="line">ls -la</span><br></pre></td></tr></table></figure><p>若输出的文件列表中存在id_rsa.pub 或 id_dsa.pub 文件，则直接跳到第三小步</p><p>​    </p><p>​    2 创建SSH Key<br>在终端输入如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>按下回车 会让输入文件名，直接回车会创建默认文件名的文件  然后会提示输入两次密码(可为空)</p><p>​    3 添加SSH Key到Github</p><p>（如果之前在Github中添加过SSH 则跳过该步）</p><p>如果你没有指定文件名（也就是使用默认文件名），那么在.ssh文件夹下会有一个id_rsa.pub文件，打开该文件并复制里面的内容</p><p>登录Github，点击右上角头像右边的三角图标，点击Settings –&gt; SSH and GPG keys –&gt; New SSH key。Title 随便填一个，在Key栏中填入复制的内容，点击Add SSH key，就添加成功了</p><p>​    4 检验SSH Key是否配置成功<br>在终端输入如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果最后出现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>就说明SSH Key配置成功了</p><h3 id="Step5-安装Hexo"><a href="#Step5-安装Hexo" class="headerlink" title="Step5 安装Hexo"></a>Step5 安装Hexo</h3><p>使用npm命令安装Hexo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>接着在任意位置创建一个文件夹，如Blog，cd到该路径下执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>该命令会在目标文件夹内建立网站所需的基础文件</p><p>接着安装安装依赖包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>此时本地博客就搭建好了</p><p>执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>此时可在浏览器中输入<a href="https://link.jianshu.com/?t=http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>进行本地查看（其他人无法访问）</p><p>​    当然 此时可修改本地博客路径下的_config文件对博客进行全局设置，里边设置项挺多就不一一列举啦！自行百度</p><p>​    </p><h3 id="Step6-同步到远程Github仓库"><a href="#Step6-同步到远程Github仓库" class="headerlink" title="Step6 同步到远程Github仓库"></a>Step6 同步到远程Github仓库</h3><p>在本地Blog路径下找到_config.yml，把deploy节点修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>（其中 username为你的Github用户名）</p><p>为了能够使Hexo部署到GitHub上，需安装一个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这时候就可以在浏览器通过输入username.github.io就可以访问你的博客了</p><h3 id="Step7-配置主题"><a href="#Step7-配置主题" class="headerlink" title="Step7 配置主题"></a>Step7 配置主题</h3><p>​    前边写过配置主题的博文 抛出一个传送门：</p><p>​                    <a href="http://www.ivan-zcy.top/2018/09/28/hexo更换主题流程/">滴滴，我是传送门</a></p><p>​    （主题在github上 知乎上 hexo官网上有很多很多 适合自己就好）</p><p>​    </p><h3 id="注意点！！！！"><a href="#注意点！！！！" class="headerlink" title="注意点！！！！"></a>注意点！！！！</h3><p>一些主题的功能需要我们自己预先创建好对应的页面，例如标签tags 关于about等等等等</p><p>此时我们需要在本地Blog路径下</p><p>​    1 添加关于页面（可选）</p><p>使用：<code>hexo new page &quot;about&quot;</code>新建一个 关于我 页面。<br>主题的 <code>_config.yml</code>文件中的 <code>menu</code>中进行匹配</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类</span><br><span class="line">  archives: /archives   //归档</span><br><span class="line">  tags: /tags   //标签</span><br><span class="line">  about: /about   //关于                  （添加此行即可）</span><br></pre></td></tr></table></figure><p>​    也可在本地博客路径 –&gt; source  –&gt; about文件下，通过修改其中的index.md对其页面进行配置</p><p>​    2 添加标签页面（可选）</p><p>使用： <code>hexo new page tags</code>新建一个 标签 页面。<br>主题的 <code>_config.yml</code>文件中的 <code>menu</code>中进行匹配</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  categories: /categories //分类</span><br><span class="line">  archives: /archives   //归档</span><br><span class="line">  tags: /tags   //标签                  （添加此行即可）</span><br><span class="line">  about: /about   //关于</span><br></pre></td></tr></table></figure><p>​    也可在本地博客路径 –&gt; source  –&gt; tags文件下，通过修改其中的index.md对其页面进行配置</p><p>​    </p><p>​    除了上边两个之外还有分类categories，自定义页面等等就不一一列举啦 自行百度吧！</p><h3 id="Step8-发布博文"><a href="#Step8-发布博文" class="headerlink" title="Step8 发布博文"></a>Step8 发布博文</h3><p>​    接着抛链接：</p><p>​            <a href="http://www.ivan-zcy.top/2018/09/28/hexo发表博客常用命令/">滴滴，我也是一个传送门</a></p><h3 id="Step9-绑定个人域名"><a href="#Step9-绑定个人域名" class="headerlink" title="Step9 绑定个人域名"></a>Step9 绑定个人域名</h3><p>​    步骤：</p><p>​    1 购买域名 </p><p>建议从<a href="https://account.aliyun.com/login/login.htm?oauth_callback=http%3A%2F%2Fnetcn.console.aliyun.com%2Fcore%2Fdomain%2Flist%3Fspm%3Da2c1d.8251892.0.0.4f0f52f2SzXZY4" target="_blank" rel="noopener">阿里云平台</a>啦之类的国内大型平台购买（这一步通常需要身份验证之类的 大概需要几天时间吧也记不清楚了 反正挺麻烦挺磨唧的）</p><p>​    2 配置DNS地址 </p><p>进入阿里云控制台 –&gt; 域名 –&gt; 域名列表 找到自己的域名 点击下图红圈圈的“管理”​    </p><p><img src="/2018/09/30/Blog搭建流程-Mac系统完结帖/1.png" alt="1"></p><p>​    </p><p>​    3 进行域名解析 </p><p>找到管理界面下的域名解析 在其中添加3条记录（username是github的用户名）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@          A             192.30.252.153</span><br><span class="line">@          A             192.30.252.154</span><br><span class="line">www      CNAME         username.github.io.</span><br></pre></td></tr></table></figure><p>​    4添加CNAME文件<br>新建一个名为CNAME的文件(无后缀)，内容为你的域名地址。将该文件放到本地博客的source文件夹里面，并更新到Github</p><p>​    这时候你的博客就建完啦！</p><p>​    最后附上主页地址： <a href="http://www.ivan-zcy.top">戳我</a>      </p><p>​    一起造作吧！！！！</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://segmentfault.com/a/1190000008040387" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008040387</a></p><p><a href="https://blog.csdn.net/ganzhilin520/article/details/79047249" target="_blank" rel="noopener">https://blog.csdn.net/ganzhilin520/article/details/79047249</a></p><p><a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">https://www.jianshu.com/p/e5f95eb990ad</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-09-29博客搭建进度</title>
      <link href="/2018/09/29/18-09-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/"/>
      <url>/2018/09/29/18-09-29%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/29/18-09-29博客搭建进度/man.jpg" alt="man"></p><a id="more"></a><p>特点:简约 流畅 死宅</p><h3 id="进度表："><a href="#进度表：" class="headerlink" title="进度表："></a>进度表：</h3><p>​    ——新增标签页，方便查找（感谢帮忙拍版的鹏飞）</p><p>​    ——新增返回顶部的小火箭</p><p>​    ——优化布局</p><p>​    ——新增巨巨们的友情链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo发表博客常用命令</title>
      <link href="/2018/09/28/hexo%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/28/hexo%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/28/hexo发表博客常用命令/man.jpg" alt="man"></p><a id="more"></a><h5 id="以下命令需要在本地Blog路径下执行"><a href="#以下命令需要在本地Blog路径下执行" class="headerlink" title="以下命令需要在本地Blog路径下执行"></a>以下命令需要在本地Blog路径下执行</h5><h3 id="Step1-创建文章"><a href="#Step1-创建文章" class="headerlink" title="Step1 创建文章"></a>Step1 创建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br><span class="line">$ hexo n <span class="string">"My New Post"</span>    //安装hexo-asset-image后可使用</span><br></pre></td></tr></table></figure><h3 id="Step2-编辑文章"><a href="#Step2-编辑文章" class="headerlink" title="Step2 编辑文章"></a>Step2 编辑文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文章头部加</span><br><span class="line">---</span><br><span class="line">title: //此处填写文章名</span><br><span class="line">date: //此处填写发布日期</span><br><span class="line">tags: </span><br><span class="line">  - //此处填写标签名(可多个)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>由于在首页中显示文章内容使用的是 <code>post.content</code> 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个 <code>&lt;!-- more --&gt;</code> 标记。添加了这个标记之后，<code>post.excerpt</code> 将会获取到标记之前的内容</p><p>之后的内容大家可以随意Diy啦</p><p>编辑md文件建议使用Typora软件 特别推荐！！！</p><h4 id="关于文章添加图片："><a href="#关于文章添加图片：" class="headerlink" title="关于文章添加图片："></a>关于文章添加图片：</h4><p>​    1 把本地Blog文件下的配置文件（非主题下）<code>_config.yml</code>里的<code>post_asset_folder:</code>选项设置为<code>true</code></p><p>​    2 在本地Blog路径下执行<code>npm install hexo-asset-image --save</code> （用于下载安装一个可以上传本地图片的插件）</p><p>​    3 运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文  </p><p>​       会发现在/source/_posts<code>文件夹中除了</code>xxxx.md`文件还生成了一个同名文件夹 </p><p>​    4最后在<code>xxxx.md</code>引入图片时，先把图片复制到xxxx文件夹中 然后在xxxx.md中按照markdown的格式引入图片：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx/图片名.jpg)</span><br></pre></td></tr></table></figure><h3 id="Step3-清除缓存-（可省略-建议使用）"><a href="#Step3-清除缓存-（可省略-建议使用）" class="headerlink" title="Step3 清除缓存 （可省略 建议使用）"></a>Step3 清除缓存 （可省略 建议使用）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 db.json 和已生成的静态文件 public  </p><p>当网站显示异常时可以执行这条命令试试</p><h3 id="Step4-生成静态文件"><a href="#Step4-生成静态文件" class="headerlink" title="Step4 生成静态文件"></a>Step4 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g      //简写</span><br></pre></td></tr></table></figure><p>这步骤就相当于程序的编译，如果有错误的话，在终端会有相应的提示信息</p><p>如果没有错误的话 可以继续往下执行</p><h3 id="Step5-启动本地服务器-（可省略）"><a href="#Step5-启动本地服务器-（可省略）" class="headerlink" title="Step5 启动本地服务器 （可省略）"></a>Step5 启动本地服务器 （可省略）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s      //简写</span><br></pre></td></tr></table></figure><p>用于预览主题，默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><h3 id="Step6-部署到远程站点"><a href="#Step6-部署到远程站点" class="headerlink" title="Step6 部署到远程站点"></a>Step6 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d       //简写</span><br></pre></td></tr></table></figure><p>上述步骤结束后 恭喜你 一篇博文完成啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo更换主题流程</title>
      <link href="/2018/09/28/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/09/28/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/09/28/hexo更换主题流程/man.jpg" alt="man"></p><a id="more"></a><h3 id="Step1-下载"><a href="#Step1-下载" class="headerlink" title="Step1: 下载"></a>Step1: 下载</h3><p>​    cd到本地博客路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 你的博客目录路径</span><br></pre></td></tr></table></figure><p>​    </p><p>​    用clone命令将想要的主题下载下来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone 主题链接</span><br></pre></td></tr></table></figure><p>​    注意 需要git到当地Glob文件夹下的theme文件夹内</p><h3 id="Step2-修改配置文件并安装"><a href="#Step2-修改配置文件并安装" class="headerlink" title="Step2: 修改配置文件并安装"></a>Step2: 修改配置文件并安装</h3><p>​    git克隆完成后，打开本地Blog下的“_config.yml”配置文件（非主题文件下）</p><p>​    找到theme配置选项(一般在文件的最后)  将theme选项配置为新下载的主题即可（“：”冒号之后空格不可少 空格后为新下载的主题名）</p><h3 id="Step3-修改主题配置文件"><a href="#Step3-修改主题配置文件" class="headerlink" title="Step3 修改主题配置文件"></a>Step3 修改主题配置文件</h3><p>​    打开主题路径下的“_config.yml”配置文件 按照作者要求进行相关配置</p><h3 id="Step4-调试，发布"><a href="#Step4-调试，发布" class="headerlink" title="Step4:调试，发布"></a>Step4:调试，发布</h3><p>​    在本地Blog路径下 输入调试命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server --debug</span><br></pre></td></tr></table></figure><p>​    </p><p>​    在浏览器中输入localhost:4000查看</p><p><img src="/2018/09/28/hexo更换主题流程/cmm.png" alt="cmm"></p><p>​    </p><p>​    在本地查看无误之后，输入生成和发布命令, 就可将新主题发布到自己的博客网站上了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>​    如出现缓存引起的异常，可在生成命令执行前执行清除缓存命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="Step5-自己DIY"><a href="#Step5-自己DIY" class="headerlink" title="Step5 自己DIY"></a>Step5 自己DIY</h3><p>​    如果主题没有想象中好 忍无可忍无需再忍 那就自己动手修改它的源码吧！（建议事先备份 推荐使用Webstrom）</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First Blog</title>
      <link href="/2018/09/28/First-Blog/"/>
      <url>/2018/09/28/First-Blog/</url>
      
        <content type="html"><![CDATA[<p>​    <img src="/2018/09/28/First-Blog/person.png" alt="person"></p><p>​    <a id="more"></a></p><p>​    距离明年秋招不到一年，有对未来的忐忑，也有期待。</p><p>​    不知道自己未来会怎样，但希望能像阿甘那样，永远不被挫折打倒。</p><p>​    今天搭建了个人博客，希望自己能坚持写下去，从一而终。</p><p>​    加油 坚持！</p><p>​    愿接下来的一年自己能收到满意的答卷！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
